;;;
;;; internal integer functions
;;;
;;;

;;; function theory provides a definition of "first-class" functions.
;;; here, we define first-class versions of the arithmetic functions.

(load fn)
(load elem)
(load setrules)

;;; addition

(zf-function add (k)
    (map (pair!pair i (+ i k))
      ((i) (int))))

(rule in-add (x k)
  (= (in x (add k))
     (and (pair!is-pair x)
	  (in (pair!fst x) (int))
	  (= (pair!snd x) (+ (pair!fst x) k)))))
(USE ADD.DEFINITION (I$0 X) (K K))
(SPLIT (AND (PAIR!IS-PAIR X)
	    (IN (PAIR!FST X) (INT))
	    (= (PAIR!SND X) (+ (PAIR!FST X) K))))
(REWRITE)
(INSTANTIATE (I (PAIR!FST X)))
(SIMPLIFY)

(rule is-function-add (k)
  (= (fn!is-function (add k))
     (true)))
(WITH-ENABLED (FN!IS-FUNCTION REL!IS-RELATION) (REDUCE))

(rule dom-add (k)
  (= (rel!dom (add k))
     (int)))
(WITH-ENABLED (SETRULES!EXTENSIONALITY-SUBGOAL REL!IN-DOM) (REWRITE))

(rule ran-add (k)
  (implies (in k (int))
	   (= (rel!ran (add k)) (int))))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL!IN-RAN) (REWRITE))
(INSTANTIATE (A (- E K)))
(SIMPLIFY)

(rule inverse-add (k)
  (implies (in k (int))
	   (= (rel!inverse (add k))
	      (add (negate k)))))
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)

(rule apply-add (k x)
  (implies (in x (int))
	   (= (fn!apply (add k) x)
	      (+ x k))))
(USE FN!APPLY-DEFINITION (F (ADD K)) (X X))
(REWRITE)

(rule comp-add-add (m n)
  (implies (and (in m (int))
		(in n (int)))
	   (= (rel!comp (add m) (add n))
	      (add (+ m n)))))
(USE FN!FUNCTION-EXTENSIONALITY
     (F (REL!COMP (ADD M) (ADD N)))
     (G (ADD (+ M N))))
(REARRANGE)
(REWRITE)

(rule add-0-is-id ()
  (= (add 0)
     (rel!id (int))))
(WITH-ENABLED (SETRULES!EXTENSIONALITY-SUBGOAL) (REWRITE))

(rule image-add-range (i j k)
  (implies (and (in i (int))
		(in j (int))
		(in k (int)))
	   (= (rel!image (add i) (range j k))
	      (range (+ i j) (+ i k)))))
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)
(PRENEX)
(USE FN!IN-PRE-IMAGE-OF-FUNCTION
     (F (REL!INVERSE (ADD I)))
     (X E)
     (Y (RANGE J K)))
(REARRANGE)
(REWRITE)



(zf-function plus ()			; curried addition function
  (map (pair!pair x (add x))
    ((x) (int))))

(rule in-plus (x)
  (= (in x (plus))
     (and (pair!is-pair x)
	  (in (pair!fst x) (int))
	  (= (pair!snd x) (add (pair!fst x))))))
(USE PLUS.DEFINITION (X$0 X))
(SPLIT (AND (PAIR!IS-PAIR X)
	    (IN (PAIR!FST X) (INT))
	    (= (PAIR!SND X) (ADD (PAIR!FST X)))))
(REWRITE)
(INSTANTIATE (X$0 (PAIR!FST X)))
(SIMPLIFY)

(rule is-function-plus ()
  (= (fn!is-function (plus))
     (true)))
(WITH-ENABLED (FN!IS-FUNCTION REL!IS-RELATION) (REDUCE))

(rule dom-plus ()
  (= (rel!dom (plus))
     (int)))
(WITH-ENABLED (SETRULES!EXTENSIONALITY-SUBGOAL REL!IN-DOM) (REWRITE))

(rule apply-plus (k)
  (implies (in k (int))
	   (= (fn!apply (plus) k)
	      (add k))))
(USE FN!APPLY-DEFINITION (F (PLUS)) (X K))
(REWRITE)

;;; multiplication

(zf-function multiples-of (k)
  (select (n (int))
    (some (x) (and (in x (int)) (= n (* k x))))))

(rule multiples-of-0 ()
  (= (multiples-of 0)
     (unit 0)))
(WITH-ENABLED (SETRULES!EXTENSIONALITY-SUBGOAL) (REWRITE))

(rule multiples-of-1 ()
  (= (multiples-of 1)
     (int)))
(WITH-ENABLED (SETRULES!EXTENSIONALITY-SUBGOAL) (REWRITE))

(rule multiples-of--1 ()
  (= (multiples-of -1)
     (int)))
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)
(INSTANTIATE (X (NEGATE E)))
(SIMPLIFY)

(zf-function multiply-by (k)
    (map (pair!pair i (* i k))
      ((i) (int))))

(rule in-multiply-by (x k)
  (= (in x (multiply-by k))
     (and (pair!is-pair x)
	  (in (pair!fst x) (int))
	  (= (pair!snd x) (* (pair!fst x) k)))))
(USE MULTIPLY-BY.DEFINITION (I$0 X) (K K))
(SPLIT (AND (PAIR!IS-PAIR X)
	    (IN (PAIR!FST X) (INT))
	    (= (PAIR!SND X) (* (PAIR!FST X) K))))
(REWRITE)
(INSTANTIATE (I (PAIR!FST X)))
(SIMPLIFY)

(rule is-function-multiply-by (k)
  (= (fn!is-function (multiply-by k))
     (true)))
(WITH-ENABLED (FN!IS-FUNCTION REL!IS-RELATION) (REDUCE))

(rule dom-multiply-by (k)
  (= (rel!dom (multiply-by k))
     (int)))
(WITH-ENABLED (SETRULES!EXTENSIONALITY-SUBGOAL REL!IN-DOM) (REWRITE))

(rule ran-multiply-by (k)
  (implies (in k (int))
	   (= (rel!ran (multiply-by k)) (multiples-of k))))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL!IN-RAN) (REWRITE))
(PRENEX)
(CASES)
(INSTANTIATE (X$0 A))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (A X))
(SIMPLIFY)
(NEXT)

(rule apply-multiply-by (k x)
  (implies (in x (int))
	   (= (fn!apply (multiply-by k) x)
	      (* x k))))
(USE FN!APPLY-DEFINITION (F (MULTIPLY-BY K)) (X X))
(REWRITE)

(rule comp-multiply-by-multiply-by (m n)
  (implies (and (in m (int))
		(in n (int)))
	   (= (rel!comp (multiply-by m) (multiply-by n))
	      (multiply-by (* m n)))))
(USE FN!FUNCTION-EXTENSIONALITY
     (F (REL!COMP (MULTIPLY-BY M) (MULTIPLY-BY N)))
     (G (MULTIPLY-BY (* M N))))
(USE REL!IMAGE-OF-SUPERSET-OF-DOM (R (REL!INVERSE (MULTIPLY-BY M))) (X (INT)))
(REARRANGE)
(REWRITE)
(REDUCE)

(rule multiply-by-1-is-id ()
  (= (multiply-by 1)
     (rel!id (int))))
(WITH-ENABLED (SETRULES!EXTENSIONALITY-SUBGOAL) (REWRITE))

(rule inverse-multiply-by--1 ()
  (= (rel!inverse (multiply-by -1))
     (multiply-by -1)))
(WITH-ENABLED (SETRULES!EXTENSIONALITY-SUBGOAL) (REWRITE))

(axiom *-monotonic (x y z)
  (implies (and (in x (int))
		(in y (int))
		(in z (int))
		(> x 0))
	   (= (>= (* x y) (* x z))
	      (>= y z))))
(SPLIT (>= (* X (- Y Z)) 0))
(SIMPLIFY)

(rule is-function-inverse-multiply-by (i)
  (implies (and (in i (int))
		(not (= i 0)))
	   (= (fn!is-function (rel!inverse (multiply-by i))) (true))))
(WITH-ENABLED (FN!IS-FUNCTION REL!IS-RELATION) (REDUCE))
(PRENEX)
(USE *-MONOTONIC (X I) (Y B) (Z C))
(USE *-MONOTONIC (X (NEGATE I)) (Y B) (Z C))
(USE *-MONOTONIC (X (NEGATE I)) (Y C) (Z B))
(USE *-MONOTONIC (X I) (Y C) (Z B))
(SIMPLIFY)


(rule image-multiply-positive-range (i j k)
  (implies (and (in i (int))
		(in j (int))
		(in k (int))
		(> i 0))
	   (= (rel!image (multiply-by i) (range j k))
	      (inter (multiples-of i)
		     (range (* i j) (* i k))))))
(APPLY SETRULES!EXTENSIONALITY)
(PRENEX)
(WITH-ENABLED (REL!IN-IMAGE) (REWRITE))
(CASES)
(INSTANTIATE (X Z))
(USE *-MONOTONIC (X I) (Y K) (Z Z))
(USE *-MONOTONIC (X I) (Y Z) (Z J))
(REARRANGE)
(REWRITE)
(NEXT)
(PRENEX)
(INSTANTIATE (Z X))
(USE *-MONOTONIC (X I) (Y K) (Z X))
(USE *-MONOTONIC (X I) (Y X) (Z J))
(REARRANGE)
(SIMPLIFY)
(NEXT)

(rule image-multiply-negative-range (i j k)
  (implies (and (in i (int))
		(in j (int))
		(in k (int))
		(< i 0))
	   (= (rel!image (multiply-by i) (range j k))
	      (inter (multiples-of i)
		     (range (* i k) (* i j))))))
(APPLY SETRULES!EXTENSIONALITY)
(PRENEX)
(WITH-ENABLED (REL!IN-IMAGE) (REWRITE))
(CASES)
(INSTANTIATE (X Z))
(USE *-MONOTONIC (X (NEGATE I)) (Y K) (Z Z))
(USE *-MONOTONIC (X (NEGATE I)) (Y Z) (Z J))
(REARRANGE)
(REWRITE)
(NEXT)
(PRENEX)
(INSTANTIATE (Z X))
(USE *-MONOTONIC (X (NEGATE I)) (Y K) (Z X))
(USE *-MONOTONIC (X (NEGATE I)) (Y X) (Z J))
(REARRANGE)
(SIMPLIFY)
(NEXT)


(zf-function times ()
  (map (pair!pair x (multiply-by x))
    ((x) (int))))

(rule in-times (x)
  (= (in x (times))
     (and (pair!is-pair x)
	  (in (pair!fst x) (int))
	  (= (pair!snd x) (multiply-by (pair!fst x))))))
(USE TIMES.DEFINITION (X$0 X))
(SPLIT (AND (PAIR!IS-PAIR X)
	    (IN (PAIR!FST X) (INT))
	    (= (PAIR!SND X) (MULTIPLY-BY (PAIR!FST X)))))
(REWRITE)
(INSTANTIATE (X$0 (PAIR!FST X)))
(SIMPLIFY)

(rule is-function-times ()
  (= (fn!is-function (times))
     (true)))
(WITH-ENABLED (FN!IS-FUNCTION REL!IS-RELATION) (REDUCE))

(rule dom-times ()
  (= (rel!dom (times))
     (int)))
(WITH-ENABLED (SETRULES!EXTENSIONALITY-SUBGOAL REL!IN-DOM) (REWRITE))

(rule apply-times (k)
  (implies (in k (int))
	   (= (fn!apply (times) k)
	      (multiply-by k))))
(USE FN!APPLY-DEFINITION (F (TIMES)) (X K))
(REWRITE)
