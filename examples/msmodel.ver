(load tuple)

;;; ============ Message types ============

;;; The various message types are disjoint.  We make use of tag-of to
;;; formalize the disjointness.

;(function-stub tag-of (x))
;(function-stub value-of (x))

(disabled (function tag-of (x) () (tuple!p1 x)))

(disabled (function value-of (x) () (tuple!p2 x))) ; only for basic values

;;; ============ Basic Messages ============

;;; Basic messages include nonces, principals, and text.

;;; Nonces.

;(function-stub nonces ())
;(function-stub nonce (n))

(disabled (function nonce (n) () (tuple!2tuple 0 (ord n))))
(zf-function nonces () (map (nonce n) ((n) (int))))

(frule tag-of-nonce (n)
  (implies (in n (nonces))
           (= (tag-of n) 0)))
(WITH-ENABLED (TAG-OF NONCE NONCES)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule nonce-in-nonces (n)
  (in (nonce n) (nonces)))
(WITH-ENABLED (NONCE NONCES)
 (REDUCE))

(axiom nonces-are-constructed (x)
  (implies (in x (nonces))
           (some (n) (= x (nonce n)))))
(WITH-ENABLED (NONCE NONCES)
 (REDUCE))
(INSTANTIATE (N$0 N))
(SIMPLIFY)

(grule value-of-nonce (n)
  (= (value-of (nonce n)) (ord n)))
(WITH-ENABLED (VALUE-OF NONCE) (REDUCE))

(rule nonce-value-of (n)
  (implies (in n (nonces))
           (= (nonce (value-of n)) n)))
(WITH-ENABLED (VALUE-OF NONCE NONCES)
 (REDUCE))
(PRENEX)
(REDUCE)

;;; Principals

;(function-stub principals ())
;(function-stub principal (p))

(disabled
 (function principal (p) () (tuple!2tuple 1 (ord p))))
(zf-function principals () (map (principal p) ((p) (int))))

(frule tag-of-principal (n)
  (implies (in n (principals))
           (= (tag-of n) 1)))
(WITH-ENABLED (TAG-OF PRINCIPAL PRINCIPALS)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule principal-in-principals (p)
  (in (principal p) (principals)))
(WITH-ENABLED (PRINCIPAL PRINCIPALS) (REDUCE))

(axiom principals-are-constructed (x)
  (implies (in x (principals))
           (some (p) (= x (principal p)))))
(WITH-ENABLED (PRINCIPAL PRINCIPALS)
 (REDUCE))
(INSTANTIATE (P$0 P))
(SIMPLIFY)

(grule value-of-principal (p)
  (= (value-of (principal p)) (ord p)))
(WITH-ENABLED (VALUE-OF PRINCIPAL) (REDUCE))

(rule principal-value-of (n)
  (implies (in n (principals))
           (= (principal (value-of n)) n)))
(WITH-ENABLED (VALUE-OF PRINCIPAL PRINCIPALS)
 (REDUCE))
(PRENEX)
(REDUCE)

;;; Text

;(function-stub text-messages ())
;(function-stub text (p))

(disabled
 (function text (t) () (tuple!2tuple 2 (ord t))))

(zf-function text-messages () (map (text t) ((t) (int))))

(frule tag-of-text (t)
  (implies (in t (text-messages))
           (= (tag-of t) 2)))
(WITH-ENABLED (TAG-OF TEXT-MESSAGES TEXT)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule text-in-text-messages (t) (in (text t) (text-messages)))
(WITH-ENABLED (TEXT TEXT-MESSAGES)
 (REDUCE))

(axiom text-messages-are-constructed (x)
  (implies (in x (text-messages))
           (some (t) (= x (text t)))))
(WITH-ENABLED (TEXT TEXT-MESSAGES)
 (REDUCE))
(INSTANTIATE (T$0 T))
(SIMPLIFY)

(grule value-of-text (t)
  (= (value-of (text t)) (ord t)))
(WITH-ENABLED (VALUE-OF TEXT) (REDUCE))



;;; ============ Keys ============

;;; We are assuming that the key to encryption includes the algorithm.

;;; The keys include symmetric and asymmetric keys.

;(function-stub symmetric-keys ())
;(function-stub symkey (k))

(disabled (function symkey (k) () (tuple!2tuple 5 (ord k))))
(zf-function symmetric-keys () (map (symkey k) ((k) (int))))

(frule tag-of-symkey (k)
  (implies (in k (symmetric-keys)) (= (tag-of k) 5)))
(WITH-ENABLED (TAG-OF SYMMETRIC-KEYS SYMKEY)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule symkey-in-symmetric-keys (k)
  (in (symkey k) (symmetric-keys)))
(WITH-ENABLED (SYMKEY SYMMETRIC-KEYS)
 (REDUCE))

(axiom symmetric-keys-are-constructed (x)
  (implies (in x (symmetric-keys))
           (some (k) (= x (symkey k)))))
(WITH-ENABLED (SYMKEY SYMMETRIC-KEYS)
 (REDUCE))
(INSTANTIATE (K$0 K))
(SIMPLIFY)

(grule value-of-symkey (k)
  (= (value-of (symkey k)) (ord k)))
(WITH-ENABLED (VALUE-OF SYMKEY) (REDUCE))

(rule symkey-value-of (n)
  (implies (in n (symmetric-keys))
           (= (symkey (value-of n)) n)))
(WITH-ENABLED (VALUE-OF SYMKEY SYMMETRIC-KEYS)
 (REDUCE))
(PRENEX)
(REDUCE)

;(function-stub public-keys ())
;(function-stub pubkey (k))

(disabled (function pubkey (k) () (tuple!2tuple 6 (ord k))))
(zf-function public-keys () (map (pubkey k) ((k) (int))))

(frule tag-of-pubkey (k)
  (implies (in k (public-keys)) (= (tag-of k) 6)))
(WITH-ENABLED (TAG-OF PUBLIC-KEYS PUBKEY)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule pubkey-in-public-keys (k)
  (in (pubkey k) (public-keys)))
(WITH-ENABLED (PUBKEY PUBLIC-KEYS)
 (REDUCE))

(axiom public-keys-are-constructed (x)
  (implies (in x (public-keys))
           (some (k) (= x (pubkey k)))))
(WITH-ENABLED (PUBKEY PUBLIC-KEYS)
 (REDUCE))
(INSTANTIATE (K$0 K))
(SIMPLIFY)

(grule value-of-pubkey (k)
  (= (value-of (pubkey k)) (ord k)))
(WITH-ENABLED (VALUE-OF PUBKEY) (REDUCE))

(rule pubkey-value-of (n)
  (implies (in n (public-keys))
           (= (pubkey (value-of n)) n)))
(WITH-ENABLED (VALUE-OF PUBKEY PUBLIC-KEYS)
 (REDUCE))
(PRENEX)
(REDUCE)


;(function-stub secret-keys ())
;(function-stub seckey (k))

(disabled
 (function seckey (k) () (tuple!2tuple 7 (ord k))))
(zf-function secret-keys ()
  (map (seckey k) ((k) (int))))

(frule tag-of-seckey (k)
  (implies (in k (secret-keys)) (= (tag-of k) 7)))
(WITH-ENABLED (TAG-OF SECRET-KEYS SECKEY)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule seckey-in-secret-keys (k)
  (in (seckey k) (secret-keys)))
(WITH-ENABLED (SECKEY SECRET-KEYS)
 (REDUCE))

(axiom secret-keys-are-constructed (x)
  (implies (in x (secret-keys))
           (some (k) (= x (seckey k)))))
(WITH-ENABLED (SECKEY SECRET-KEYS)
 (REDUCE))
(INSTANTIATE (K$0 K))
(SIMPLIFY)

(grule value-of-seckey (k) (= (value-of (seckey k)) (ord k)))
(WITH-ENABLED (VALUE-OF SECKEY) (REDUCE))

(rule seckey-value-of (n)
  (implies (in n (secret-keys))
           (= (seckey (value-of n)) n)))
(WITH-ENABLED (VALUE-OF SECKEY SECRET-KEYS)
 (REDUCE))
(PRENEX)
(REDUCE)

(disabled
  (function asymmetric-keys () () (union (public-keys) (secret-keys))))

(frule tag-of-asymmetric-keys (k)
  (implies (in k (asymmetric-keys))
           (and (>= (tag-of k) 6)
                (<= (tag-of k) 7))))
(WITH-ENABLED (ASYMMETRIC-KEYS)
 (REDUCE))

(disabled
 (function keys () () (union (symmetric-keys) (asymmetric-keys))))

(frule public-key-is-asymmetric (k)
  (implies (in k (public-keys))
           (in k (asymmetric-keys))))
(WITH-ENABLED (PUBLIC-KEYS ASYMMETRIC-KEYS)
 (REDUCE))

(frule secret-key-is-asymmetric (k)
  (implies (in k (secret-keys))
           (in k (asymmetric-keys))))
(WITH-ENABLED (SECRET-KEYS ASYMMETRIC-KEYS)
 (REDUCE))

(frule tag-of-keys (k)
  (implies (in k (keys))
           (and (>= (tag-of k) 5)
                (<= (tag-of k) 7))))
(WITH-ENABLED (KEYS)
 (REDUCE))

(disabled
 (function inverse (k) ()
   (if (in k (public-keys))
       (seckey (value-of k))
       (if (in k (secret-keys))
           (pubkey (value-of k))
           k))))

(rule inverse-symmetric (k)
  (implies (in k (symmetric-keys))
           (= (inverse k) k)))
(WITH-ENABLED (INVERSE) (REDUCE))

(rule inverse-pubkey (k)
  (implies (in k (public-keys))
           (= (inverse k) (seckey (value-of k)))))
(WITH-ENABLED (INVERSE) (REDUCE))

(rule inverse-seckey (k)
  (implies (in k (secret-keys))
           (= (inverse k) (pubkey (value-of k)))))
(WITH-ENABLED (INVERSE) (REDUCE))

(grule inverse-asymmetric (k)
  (implies (in k (asymmetric-keys))
           (in (inverse k) (asymmetric-keys))))
(SPLIT (IN K (PUBLIC-KEYS)))
(REWRITE)
(SPLIT (IN K (SECRET-KEYS)))
(REWRITE)
(INVOKE ASYMMETRIC-KEYS)
(REWRITE)

(frule symmetric-key-in-keys (k)
  (implies (in k (symmetric-keys))
           (in k (keys))))
(WITH-ENABLED (KEYS) (REDUCE))

(frule asymmetric-key-in-keys (k)
  (implies (in k (asymmetric-keys))
           (in k (keys))))
(WITH-ENABLED (KEYS) (REDUCE))

(rule inverse-in-keys (k)
  (= (in (inverse k) (keys)) (in k (keys))))
(WITH-ENABLED (INVERSE KEYS)
 (REDUCE))

(grule inverse-in-keys-1 (k)
  (implies (in k (keys))
           (in (inverse k) (keys))))
(WITH-ENABLED (INVERSE KEYS)
 (REDUCE))

(rule inverse-inverse (k)
  (implies (in k (keys))
           (= (inverse (inverse k)) k)))
(WITH-ENABLED (INVERSE)
 (REDUCE))
(CASES)
(USE PUBLIC-KEYS-ARE-CONSTRUCTED (X K))
(REWRITE)
(PRENEX)
(REWRITE)
(NEXT)
(USE SECRET-KEYS-ARE-CONSTRUCTED (X K))
(REWRITE)
(PRENEX)
(REWRITE)
(NEXT)

(grule tag-of-inverse-1 (k)
  (implies (in k (keys))
           (>= (tag-of (inverse k)) 5)))
(WITH-ENABLED (KEYS ASYMMETRIC-KEYS)
 (REDUCE))

(grule tag-of-inverse-2 (k)
  (implies (in k (keys))
           (<= (tag-of (inverse k)) 7)))
(WITH-ENABLED (KEYS ASYMMETRIC-KEYS)
 (REDUCE))

;;; Encryption

;(function-stub encrypt (d k))

(disabled
 (function encrypt (d k) () (tuple!3tuple 10 d k)))

(zf-function encrypts (ds)
  (map (encrypt d k) ((d) ds) ((k) (keys))))

(frule tag-of-encrypt-internal (k ds)
  (implies (in k (encrypts ds)) (= (tag-of k) 10)))
(WITH-ENABLED (TAG-OF ENCRYPTS ENCRYPT)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule tag-of-encrypt (d k) (= (tag-of (encrypt d k)) 10))
(WITH-ENABLED (TAG-OF ENCRYPT) (REDUCE))

(disabled
  (rule encrypt-injective (d1 d2 k1 k2)
    (= (= (encrypt d1 k1) (encrypt d2 k2)) (and (= d1 d2)(= k1 k2)))))
(SPLIT (AND (= D1 D2)(= K1 K2)))
(WITH-ENABLED (ENCRYPT) (REDUCE))

;(rule encrypt-in-encrypts (d k ds)
;  (= (in (encrypt d k) (encrypts ds))
;     (and (in d ds) (in k (keys)))))
;(WITH-ENABLED (ENCRYPTS)
; (REWRITE))

(grule encrypt-in-encrypts (d k ds)
  (implies (and (in d ds)
                (in k (keys)))
           (in (encrypt d k) (encrypts ds))))
(WITH-ENABLED (ENCRYPTS)
 (REWRITE))

;;; (function-stub endt (e))
;;; (function-stub enky (e))

(disabled
 (function endt (e) () (tuple!p2 e)))

(disabled
 (function enky (e) () (tuple!p3 e)))

(grule endt-encrypt (d k)
  (= (endt (encrypt d k)) d))
(WITH-ENABLED (ENDT ENCRYPT) (REDUCE))

(grule enky-encrypt (d k)
  (= (enky (encrypt d k)) k))
(WITH-ENABLED (ENKY ENCRYPT) (REDUCE))

;;; function-stub share-encrypt (d k1 k2)

(disabled
 (function share-encrypt (d k1 k2) () (tuple!4tuple 11 d k1 k2)))

(zf-function share-encrypts (ds)
  (map (share-encrypt d k1 k2) ((d) ds) ((k1 k2) (asymmetric-keys))))

(frule tag-of-share-encrypt-internal (k ds)
  (implies (in k (share-encrypts ds)) (= (tag-of k) 11)))
(WITH-ENABLED (TAG-OF SHARE-ENCRYPTS SHARE-ENCRYPT)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule tag-of-share-encrypt (d k1 k2)
  (= (tag-of (share-encrypt d k1 k2)) 11))
(WITH-ENABLED (TAG-OF SHARE-ENCRYPT) (REDUCE))

(disabled
  (rule share-encrypt-injective (d1 d2 k1 k2 k3 k4)
    (= (= (share-encrypt d1 k1 k2) (share-encrypt d2 k3 k4))
       (and (= d1 d2)(= k1 k3)(= k2 k4)))))
(SPLIT (AND (= D1 D2)(= K1 K3)(= K2 K4)))
(WITH-ENABLED (SHARE-ENCRYPT) (REDUCE))

(grule share-encrypt-in-share-encrypts (d k1 k2 ds)
  (implies (and (in d ds)
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys)))
           (in (share-encrypt d k1 k2) (share-encrypts ds))))
(WITH-ENABLED (SHARE-ENCRYPTS)
 (REWRITE))


;;; (function-stub shendt (e))
;;; (function-stub shenky1 (e))
;;; (function-stub shenky2 (e))

(disabled
 (function shendt (e) () (tuple!p2 e)))

(disabled
 (function shenky1 (e) () (tuple!p3 e)))

(disabled
 (function shenky2 (e) () (tuple!p4 e)))

(grule shendt-share-encrypt (d k1 k2)
  (= (shendt (share-encrypt d k1 k2)) d))
(WITH-ENABLED (SHENDT SHARE-ENCRYPT) (REDUCE))

(grule shenky1-share-encrypt (d k1 k2)
  (= (shenky1 (share-encrypt d k1 k2)) k1))
(WITH-ENABLED (SHENKY1 SHARE-ENCRYPT) (REDUCE))

(grule shenky2-share-encrypt (d k1 k2)
  (= (shenky2 (share-encrypt d k1 k2)) k2))
(WITH-ENABLED (SHENKY2 SHARE-ENCRYPT) (REDUCE))


;;; Aggregation

;(function-stub combine (d1 d2))

(disabled
 (function combine (d1 d2) () (tuple!3tuple 12 d1 d2)))

(zf-function combines (ds)
  (map (combine d1 d2) ((d1 d2) ds)))

(frule tag-of-combine-internal (d ds)
  (implies (in d (combines ds))
           (= (tag-of d) 12)))
(WITH-ENABLED (TAG-OF COMBINES COMBINE)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule tag-of-combine (d1 d2)
  (= (tag-of (combine d1 d2)) 12))
(WITH-ENABLED (TAG-OF COMBINE) (REDUCE))

(disabled
  (rule combine-injective (c1 c2 d1 d2)
    (= (= (combine c1 c2) (combine d1 d2)) (and (= c1 d1)(= c2 d2)))))
(SPLIT (AND (= C1 D1)(= C2 D2)))
(WITH-ENABLED (COMBINE) (REDUCE))

(grule combine-in-combines (d1 d2 ds)
  (implies (and (in d1 ds)
                (in d2 ds))
           (in (combine d1 d2) (combines ds))))
(WITH-ENABLED (COMBINES)
 (REWRITE))


;;; (function-stub cb1 (c))
;;; (function-stub cb2 (c))

(disabled
 (function cb1 (c) () (tuple!p2 c)))

(disabled
 (function cb2 (c) () (tuple!p3 c)))

(grule cb1-combine (d1 d2)
  (= (cb1 (combine d1 d2)) d1))
(WITH-ENABLED (CB1 COMBINE) (REDUCE))

(grule cb2-combine (d1 d2)
  (= (cb2 (combine d1 d2)) d2))
(WITH-ENABLED (CB2 COMBINE) (REDUCE))


;;; Hashing

;(function-stub hash (m))

(disabled
 (function hash (m) () (tuple!2tuple 13 m)))

(zf-function hashes (ms)
  (map (hash m) ((m) ms)))

(frule tag-of-hash-internal (d ds)
  (implies (in d (hashes ds))
           (= (tag-of d) 13)))
(WITH-ENABLED (TAG-OF HASHES HASH)
 (REDUCE))
(PRENEX)
(REDUCE)

(grule tag-of-hash (m) (= (tag-of (hash m)) 13))
(WITH-ENABLED (TAG-OF HASH) (REDUCE))


;;; Assume perfect hashing

(disabled
  (rule hash-injective (m1 m2)
    (= (= (hash m1) (hash m2)) (= m1 m2))))
(SPLIT (= M1 M2))
(WITH-ENABLED (HASH) (REDUCE))

(grule hash-in-hashes (d ds)
  (implies (in d ds)
           (in (hash d) (hashes ds))))
(WITH-ENABLED (HASHES)
 (REWRITE))

(disabled
 (function hsdt (c) () (tuple!p2 c)))

(grule hsdt-hash (m)
  (= (hsdt (hash m)) m))
(WITH-ENABLED (HSDT HASH) (REDUCE))


;;; Now, formalize the set of messages.

(load nat)

(disabled
 (function basic-messages () ()
   (union (nonces)
          (union (principals)
                 (text-messages)))))

(frule tag-of-basic-messages (k)
  (implies (in k (basic-messages))
           (and (>= (tag-of k) 0)
                (<= (tag-of k) 2))))
(WITH-ENABLED (BASIC-MESSAGES)
 (REDUCE))

(frule nonce-in-basic-messages (k)
  (implies (in k (nonces))
           (in k (basic-messages))))
(INVOKE BASIC-MESSAGES)
(REWRITE)

(frule principal-in-basic-messages (k)
  (implies (in k (principals))
           (in k (basic-messages))))
(INVOKE BASIC-MESSAGES)
(REWRITE)

(frule text-in-basic-messages (k)
  (implies (in k (text-messages))
           (in k (basic-messages))))
(INVOKE BASIC-MESSAGES)
(REWRITE)

(disabled
 (function atomic-messages () ()
    (union (keys) (basic-messages))))

(frule tag-of-atomic-messages (k)
  (implies (in k (atomic-messages))
           (and (>= (tag-of k) 0)
                (<= (tag-of k) 7))))
(WITH-ENABLED (ATOMIC-MESSAGES)
 (REDUCE))

(frule key-in-atomic-messages (k)
  (implies (in k (keys))
           (in k (atomic-messages))))
(INVOKE ATOMIC-MESSAGES)
(REWRITE)

(frule basic-message-in-atomic-messages (k)
  (implies (in k (basic-messages))
           (in k (atomic-messages))))
(INVOKE ATOMIC-MESSAGES)
(REWRITE)

(function messages-aux (n) ((measure n))
  (if (>= n 1)
      (union (encrypts (messages-aux (- n 1)))
             (union (share-encrypts (messages-aux (- n 1)))
                    (union (combines (messages-aux (- n 1)))
                           (union (hashes (messages-aux (- n 1)))
                                  (messages-aux (- n 1))))))
      (atomic-messages)))
(REDUCE)

(axiom in-messages-aux-monotonic (m n1 n2)
  (implies (and (>= n1 0)
                (>= n2 n1)
                (in m (messages-aux n1)))
           (in m (messages-aux n2))))
(INDUCT (MESSAGES-AUX N2))
(REDUCE)
(INVOKE (MESSAGES-AUX N1))
(REDUCE)

(zf-function messages-aux-aux ()
  (map (messages-aux n) ((n) (nat!nat))))

(disabled (function messages () () (cup (messages-aux-aux))))


(frule atomic-message-in-messages (m)
  (implies (in m (atomic-messages))
           (in m (messages))))
(INVOKE MESSAGES)
(REDUCE)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(REWRITE)
(INSTANTIATE (N 0))
(CONTRADICT)
(CASES)
(INVOKE MESSAGES-AUX)
(REWRITE)
(NEXT)

(disabled
  (function encrypt-messages () () (encrypts (messages))))

(frule in-encrypt-in-encrypt-messages (m)
  (implies (in m (encrypts (messages)))
           (in m (encrypt-messages))))
(INVOKE ENCRYPT-MESSAGES)
(SIMPLIFY)

(grule encrypt-in-encrypt-messages (m k)
  (implies (and (in m (messages))
                (in k (keys)))
           (in (encrypt m k) (encrypt-messages))))
(REDUCE)

(frule tag-of-encrypt-messages (m)
  (implies (in m (encrypt-messages)) (= (tag-of m) 10)))
(WITH-ENABLED (ENCRYPT-MESSAGES)
 (REDUCE))

(frule encrypt-message-in-messages (m)
  (implies (in m (encrypt-messages))
           (in m (messages))))
(INVOKE ENCRYPT-MESSAGES)
(APPLY ENCRYPTS.DEFINITION)
(INVOKE MESSAGES)
(REDUCE)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 (+ N 1)))
(CONTRADICT)
(CASES)
(REWRITE)
(INVOKE (MESSAGES-AUX (+ 1 N)))
(REWRITE)
(NEXT)

(disabled
  (function share-encrypt-messages () () (share-encrypts (messages))))

(frule in-share-encrypt-in-share-encrypt-messages (m)
  (implies (in m (share-encrypts (messages)))
           (in m (share-encrypt-messages))))
(INVOKE SHARE-ENCRYPT-MESSAGES)
(SIMPLIFY)

(grule share-encrypt-in-share-encrypt-messages (m k1 k2)
  (implies (and (in m (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys)))
           (in (share-encrypt m k1 k2) (share-encrypt-messages))))
(REDUCE)

(frule tag-of-share-encrypt-messages (m)
  (implies (in m (share-encrypt-messages)) (= (tag-of m) 11)))
(WITH-ENABLED (SHARE-ENCRYPT-MESSAGES)
 (REDUCE))

(frule share-encrypt-message-in-messages (m)
  (implies (in m (share-encrypt-messages))
           (in m (messages))))
(INVOKE SHARE-ENCRYPT-MESSAGES)
(APPLY SHARE-ENCRYPTS.DEFINITION)
(INVOKE MESSAGES)
(REDUCE)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 (+ N 1)))
(CONTRADICT)
(CASES)
(REWRITE)
(INVOKE (MESSAGES-AUX (+ 1 N)))
(REWRITE)
(NEXT)


(disabled
  (function combine-messages () () (combines (messages))))

(frule in-combine-in-combine-messages (m)
  (implies (in m (combines (messages)))
           (in m (combine-messages))))
(INVOKE COMBINE-MESSAGES)
(SIMPLIFY)

(grule combine-in-combine-messages (m1 m2)
  (implies (and (in m1 (messages))
                (in m2 (messages)))
           (in (combine m1 m2) (combine-messages))))
(REDUCE)

(frule tag-of-combine-messages (m)
  (implies (in m (combine-messages)) (= (tag-of m) 12)))
(WITH-ENABLED (COMBINE-MESSAGES)
 (REDUCE))

(frule combine-message-in-messages (m)
  (implies (in m (combine-messages))
           (in m (messages))))
(INVOKE COMBINE-MESSAGES)
(APPLY COMBINES.DEFINITION)
(INVOKE MESSAGES)
(REDUCE)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(REWRITE)
(PRENEX)
(INSTANTIATE (N$1 (IF (>= N N$0) (+ N 1) (+ N$0 1))))
(CONTRADICT)
(CASES)
(REWRITE)
(CASES)
(INVOKE (MESSAGES-AUX (+ 1 N)))
(REWRITE)
(APPLY COMBINES.DEFINITION)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(USE IN-MESSAGES-AUX-MONOTONIC (M D2) (N1 N$0) (N2 N))
(REWRITE)
(NEXT)
(INVOKE (MESSAGES-AUX (+ 1 N$0)))
(REWRITE)
(APPLY COMBINES.DEFINITION)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(USE IN-MESSAGES-AUX-MONOTONIC (M D1) (N1 N) (N2 N$0))
(REWRITE)
(NEXT)

(disabled
  (function hash-messages () () (hashes (messages))))

(frule in-hash-in-hash-messages (m)
  (implies (in m (hashes (messages)))
           (in m (hash-messages))))
(INVOKE HASH-MESSAGES)
(SIMPLIFY)

(grule hash-in-hash-messages (m)
  (implies (in m (messages))
           (in (hash m) (hash-messages))))
(REDUCE)

(frule tag-of-hash-messages (m)
  (implies (in m (hash-messages)) (= (tag-of m) 13)))
(WITH-ENABLED (HASH-MESSAGES)
 (REDUCE))

(frule hash-message-in-messages (m)
  (implies (in m (hash-messages))
           (in m (messages))))
(INVOKE HASH-MESSAGES)
(APPLY HASHES.DEFINITION)
(INVOKE MESSAGES)
(REDUCE)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 (+ N 1)))
(CONTRADICT)
(CASES)
(REWRITE)
(INVOKE (MESSAGES-AUX (+ 1 N)))
(REWRITE)
(NEXT)


;;; ============ Knowledge ============

(function known-in-aux (d s n) ((measure n))
  (or (and (in d s) (in d (messages)))
      (if (>= n 1)
          (or (some (d1 k)
                (and (= d (encrypt d1 k))
                     (in d (messages))
                     (in k (keys))
                     (known-in-aux d1 s (- n 1))
                     (known-in-aux k s (- n 1))))
              (some (d1 k1 k2)
                (and (= d (share-encrypt d1 k1 k2))
                     (in d (messages))
                     (in k1 (asymmetric-keys))
                     (in k2 (asymmetric-keys))
                     (known-in-aux d1 s (- n 1))
                     (known-in-aux k1 s (- n 1))
                     (known-in-aux k2 s (- n 1))))
              (some (d1 k1 k2)
                (and (= d (share-encrypt d1 k1 k2))
                     (in d (messages))
                     (in k1 (asymmetric-keys))
                     (in k2 (asymmetric-keys))
                     (known-in-aux d1 s (- n 1))
                     (known-in-aux (inverse k1) s (- n 1))
                     (known-in-aux (inverse k2) s (- n 1))))
              (some (k)
                (and (in d (messages))
                     (in k (keys))
                     (known-in-aux (encrypt d k) s (- n 1))
                     (known-in-aux (inverse k) s (- n 1))))
              (some (k1 k2)
                (and (in d (messages))
                     (in k1 (asymmetric-keys))
                     (in k2 (asymmetric-keys))
                     (known-in-aux (share-encrypt d k1 k2) s (- n 1))
                     (known-in-aux k1 s (- n 1))
                     (known-in-aux k2 s (- n 1))))
              (some (k1 k2)
                (and (in d (messages))
                     (in k1 (asymmetric-keys))
                     (in k2 (asymmetric-keys))
                     (known-in-aux (share-encrypt d k1 k2) s (- n 1))
                     (known-in-aux (inverse k1) s (- n 1))
                     (known-in-aux (inverse k2) s (- n 1))))
              (some (d1 d2)
                (and (= d (combine d1 d2))
                     (in d1 (messages))
                     (in d2 (messages))
                     (known-in-aux d1 s (- n 1))
                     (known-in-aux d2 s (- n 1))))
              (some (d1 d2)
                (and (= d1 (combine d d2))
                     (in d (messages))
                     (in d2 (messages))
                     (known-in-aux d1 s (- n 1))))
              (some (d1 d2)
                (and (= d2 (combine d1 d))
                     (in d1 (messages))
                     (in d (messages))
                     (known-in-aux d2 s (- n 1))))
              (some (d1)
                (and (= d (hash d1))
                     (in d1 (messages))
                     (known-in-aux d1 s (- n 1))))
              (known-in-aux d s (- n 1)))
          (false))))
(REDUCE)

(function known-from-encrypt (d s n) ()
  (some (d1 k)
    (and (= d (encrypt d1 k))
         (in d (messages))
         (in k (keys))
         (known-in-aux d1 s (- n 1))
         (known-in-aux k s (- n 1)))))

(function known-from-share-encrypt (d s n) ()
  (some (d1 k1 k2)
    (and (= d (share-encrypt d1 k1 k2))
         (in d (messages))
         (in k1 (asymmetric-keys))
         (in k2 (asymmetric-keys))
         (known-in-aux d1 s (- n 1))
         (known-in-aux k1 s (- n 1))
         (known-in-aux k2 s (- n 1)))))

(function known-from-share-encrypt-inverse (d s n) ()
  (some (d1 k1 k2)
    (and (= d (share-encrypt d1 k1 k2))
         (in d (messages))
         (in k1 (asymmetric-keys))
         (in k2 (asymmetric-keys))
         (known-in-aux d1 s (- n 1))
         (known-in-aux (inverse k1) s (- n 1))
         (known-in-aux (inverse k2) s (- n 1)))))

(function known-from-decrypt (d s n) ()
  (some (k)
    (and (in d (messages))
         (in k (keys))
         (known-in-aux (encrypt d k) s (- n 1))
         (known-in-aux (inverse k) s (- n 1)))))

(function known-from-share-decrypt (d s n) ()
  (some (k1 k2)
    (and (in d (messages))
         (in k1 (asymmetric-keys))
         (in k2 (asymmetric-keys))
         (known-in-aux (share-encrypt d k1 k2) s (- n 1))
         (known-in-aux k1 s (- n 1))
         (known-in-aux k2 s (- n 1)))))

(function known-from-share-decrypt-inverse (d s n) ()
  (some (k1 k2)
    (and (in d (messages))
         (in k1 (asymmetric-keys))
         (in k2 (asymmetric-keys))
         (known-in-aux (share-encrypt d k1 k2) s (- n 1))
         (known-in-aux (inverse k1) s (- n 1))
         (known-in-aux (inverse k2) s (- n 1)))))

(function known-from-combine (d s n) ()
  (some (d1 d2)
    (and (= d (combine d1 d2))
         (in d1 (messages))
         (in d2 (messages))
         (known-in-aux d1 s (- n 1))
         (known-in-aux d2 s (- n 1)))))

(function known-from-decombine-left (d s n) ()
  (some (d1 d2)
    (and (= d1 (combine d d2))
         (in d (messages))
         (in d2 (messages))
         (known-in-aux d1 s (- n 1)))))

(function known-from-decombine-right (d s n) ()
  (some (d1 d2)
    (and (= d2 (combine d1 d))
         (in d1 (messages))
         (in d (messages))
         (known-in-aux d2 s (- n 1)))))

(function known-from-hash (d s n) ()
  (some (d1)
    (and (= d (hash d1))
         (in d1 (messages))
         (known-in-aux d1 s (- n 1)))))

(function known-from-recursion (d s n) ()
  (known-in-aux d s (- n 1)))

(disabled
  (rule known-in-aux-definition (d s n)
    (= (known-in-aux d s n)
       (or (and (in d s) (in d (messages)))
           (if (>= n 1)
               (or (known-from-encrypt d s n)
                   (known-from-share-encrypt d s n)
                   (known-from-share-encrypt-inverse d s n)
                   (known-from-decrypt d s n)
                   (known-from-share-decrypt d s n)
                   (known-from-share-decrypt-inverse d s n)
                   (known-from-combine d s n)
                   (known-from-decombine-left d s n)
                   (known-from-decombine-right d s n)
                   (known-from-hash d s n)
                   (known-from-recursion d s n))
               (false))))))
(INVOKE KNOWN-IN-AUX)
(INVOKE KNOWN-FROM-ENCRYPT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(INVOKE KNOWN-FROM-DECRYPT)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(INVOKE KNOWN-FROM-COMBINE)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(INVOKE KNOWN-FROM-HASH)
(INVOKE KNOWN-FROM-RECURSION)
(SIMPLIFY)
(SPLIT (IN D (MESSAGES)))
(SIMPLIFY)

;;; (function-stub known-in (d s))

(disabled
 (function known-in (d s) ()
   (some (n) (known-in-aux d s n))))

(frule known-in-aux-in-messages (x s n)
  (implies (known-in-aux x s n)
           (in x (messages))))
(INDUCT (NAT!WEAK-INDUCTION N))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX X S N))
(INVOKE NAT!ZEROP)
(REWRITE)
(CASES)
(WITH-DISABLED (KNOWN-IN-AUX)
 (REDUCE))
(CASES)
(PRENEX)
(SPLIT (= X (COMBINE D1 D2)))
(EQUALITY-SUBSTITUTE)
(SPLIT (IN D2 (MESSAGES)))
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)
(NEXT)
(PRENEX)
(SPLIT (= X (HASH D1)))
(EQUALITY-SUBSTITUTE)
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)
(NEXT)
(WITH-DISABLED (KNOWN-IN-AUX)
 (REDUCE))
(CASES)
(PRENEX)
(REWRITE)
(NEXT)
(CASES)
(PRENEX)
(REWRITE)
(NEXT)
(CASES)
(PRENEX)
(REWRITE)
(NEXT)
(PRENEX)
(REWRITE)
(CASES)
(SPLIT (= X (COMBINE D1 D2)))
(EQUALITY-SUBSTITUTE)
(SPLIT (IN D2 (MESSAGES)))
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)
(NEXT)
(SPLIT (= X (HASH D1$0)))
(EQUALITY-SUBSTITUTE)
(SPLIT (IN D1$0 (MESSAGES)))
(REWRITE)
(NEXT)

(frule known-in-in-messages (x s)
  (implies (known-in x s)
           (in x (messages))))
(INVOKE KNOWN-IN)
(PRENEX)
(REWRITE)

(axiom in-messages-aux-lemma (n d)
  (implies (>= n 0)
           (= (in d (messages-aux n))
              (or (in d (atomic-messages))
                  (and (>= n 1)
                       (or (in d (encrypts (messages-aux (- n 1))))
                           (in d (share-encrypts (messages-aux (- n 1)))) 
                           (in d (combines (messages-aux (- n 1))))
                           (in d (hashes (messages-aux (- n 1))))))))))
(INDUCT)
(REDUCE)
;(REDUCE)
(CASES)
(WITH-ENABLED (ENCRYPTS)
 (REWRITE))
(INSTANTIATE (D$1 D$0))
(SIMPLIFY)
(NEXT)
(CASES)
(WITH-ENABLED (SHARE-ENCRYPTS)
 (REWRITE))
(INSTANTIATE (D$1 D$0))
(SIMPLIFY)
(NEXT)
(CASES)
(WITH-ENABLED (COMBINES)
 (REWRITE))
(INSTANTIATE (D1$0 D1) (D2$0 D2)) ; **** Check instantiate.lisp
(SIMPLIFY)
(NEXT)
(CASES)
(WITH-ENABLED (HASHES)
 (REWRITE))
(INSTANTIATE (M$0 M))
(SIMPLIFY)
(NEXT)
(WITH-ENABLED (HASHES)
 (REWRITE))
(INSTANTIATE (M$0 M))
(SIMPLIFY)
(NEXT)

(axiom in-messages-sublemma (d)
  (= (in d (messages))
     (or (in d (atomic-messages))
         (in d (encrypts (messages)))
         (in d (share-encrypts (messages)))
         (in d (combines (messages)))
         (in d (hashes (messages))))))
(INVOKE MESSAGES)
(WITH-ENABLED (MESSAGES-AUX-AUX)
 (REWRITE))
(INSTANTIATE (N 0))
(REDUCE)
(USE IN-MESSAGES-AUX-LEMMA (D D))
(REARRANGE)
(SIMPLIFY)
(CASES)
(WITH-ENABLED (ENCRYPTS MESSAGES-AUX-AUX)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N$0 (+ N 1)))
(INSTANTIATE (D$1 D$0) (K$0 K))
(REWRITE)
(NEXT)
(CASES)
(WITH-ENABLED (SHARE-ENCRYPTS MESSAGES-AUX-AUX)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N$0 (+ N 1)))
(INSTANTIATE (D$1 D$0) (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(WITH-ENABLED (COMBINES MESSAGES-AUX-AUX)
 (REWRITE))
(PRENEX)
(REARRANGE)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (N$1 (IF (>= N N$0) (+ N 1) (+ N$0 1))))
(INSTANTIATE (N$2 (IF (>= N N$0) (+ N 1) (+ N$0 1))))
(REWRITE)
(CASES)
(USE IN-MESSAGES-AUX-MONOTONIC (N1 N$0) (N2 N) (M D2))
(SIMPLIFY)
(NEXT)
(USE IN-MESSAGES-AUX-MONOTONIC (N1 N) (N2 N$0) (M D1))
(SIMPLIFY)
(NEXT)
(SPLIT (IN D (HASHES (CUP (MESSAGES-AUX-AUX)))))
(SIMPLIFY)
(CASES)
(WITH-ENABLED (HASHES MESSAGES-AUX-AUX)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N$0 (+ N 1)))
(INSTANTIATE (N$1 (+ N 1)))
(REWRITE)
(NEXT)
(SIMPLIFY)
(PRENEX)
(INVOKE (MESSAGES-AUX N))
(WITH-ENABLED (ENCRYPTS SHARE-ENCRYPTS COMBINES HASHES MESSAGES-AUX-AUX)
 (REWRITE))
(INSTANTIATE (N$1 N))
(REARRANGE)
(REWRITE)
(CASES)
(INSTANTIATE (D$3 D$0) (K$1 K) (N$2 (- N 1)))
(REWRITE)
(NEXT)
(CASES)
(INSTANTIATE (D$9 D$5) (K1$3 K1$1) (K2$3 K2$1) (N$8 (- N 1)))
(REWRITE)
(NEXT)
(CASES)
(INSTANTIATE (D1$5 D1$3) (D2$5 D2$3) (N$14 (- N 1)))
(REWRITE)
(NEXT)
(CASES)
(INSTANTIATE (M M$3) (N$0 (- N 1)))
(REWRITE)
(NEXT)
(USE IN-MESSAGES-AUX-MONOTONIC (N1 (- N 1)) (N2 N) (M D))
(SIMPLIFY)
(NEXT)

(axiom in-messages-lemma (d)
  (= (in d (messages))
     (or (in d (atomic-messages))
         (in d (encrypt-messages))
         (in d (share-encrypt-messages))
         (in d (combine-messages))
         (in d (hash-messages)))))
(USE IN-MESSAGES-SUBLEMMA (D D))
(WITH-ENABLED
   (ENCRYPT-MESSAGES SHARE-ENCRYPT-MESSAGES COMBINE-MESSAGES HASH-MESSAGES)
 (REDUCE))

(disabled
 (rule in-messages-definition (d)
   (= (in d (messages))
      (or (in d (atomic-messages))
          (in d (encrypt-messages))
          (in d (share-encrypt-messages))
          (in d (combine-messages))
          (in d (hash-messages))))))
(USE IN-MESSAGES-LEMMA (D D))
(SIMPLIFY)

(axiom known-in-aux-implication (n d s)
  (implies (known-in-aux d s n)
           (or (in d (atomic-messages))
               (in d (encrypt-messages))
               (in d (share-encrypt-messages))
               (in d (combine-messages))
               (in d (hash-messages)))))
(USE IN-MESSAGES-LEMMA (D D))
(SIMPLIFY)

(axiom known-in-aux-monotonic (n1 n2 d s)
  (implies (and (known-in-aux d s n1)
                (>= n1 0)
                (>= n2 n1))
           (known-in-aux d s n2)))
(INDUCT (NAT!WEAK-INDUCTION N2))
(INVOKE NAT!ZEROP)
(REWRITE)
(INVOKE (KNOWN-IN-AUX D S N2))
(SIMPLIFY)

(disabled (rule known-in-definition (c s)
            (= (known-in c s)
               (some (n) (and (>= n 0) (known-in-aux c s n))))))
(INVOKE KNOWN-IN)
(SPLIT (SOME (N) (KNOWN-IN-AUX C S N)))
(REWRITE)
(PRENEX)
(SPLIT (>= N 0))
(SIMPLIFY)
(APPLY KNOWN-IN-AUX-DEFINITION)
(REWRITE)
(INSTANTIATE (N$0 0))
(SIMPLIFY)

(axiom known-in-transitive-lemma (s1 s2 n1)
  (implies
   (>= n1 0)
   (all (c)
     (implies
      (and (known-in-aux c s1 n1)
           (all (c1) (implies (in c1 s1)
                              (some (n2) (and (>= n2 0)
                                              (known-in-aux c1 s2 n2))))))
      (some (n3) (and (>= n3 0) (known-in-aux c s2 n3)))))))
(INDUCT (NAT!WEAK-INDUCTION N1))
(CASES)
(REDUCE)
(PRENEX)
(INSTANTIATE (C1 C))
(REWRITE)
(NEXT)
(INVOKE NAT!ZEROP)
(PRENEX)
(REWRITE)
(SPLIT (IN C (MESSAGES)))
(REWRITE)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S1 N1))
(REWRITE)
(CASES)
(INSTANTIATE (C$0 C))
(INVOKE (KNOWN-IN-AUX C S1 (+ -1 N1)))
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-ENCRYPT)
(PRENEX)
(INSTANTIATE (C$0 D1))
(INSTANTIATE (C$0 K))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(INSTANTIATE (N3$2 (+ N3$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-ENCRYPT)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K$0 K))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D D1) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$2 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-ENCRYPT)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K$0 K))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D K) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(PRENEX)
(INSTANTIATE (C$0 D1))
(INSTANTIATE (C$0 K1))
(INSTANTIATE (C$0 K2))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(SPLIT (>= N3$1 N3$0))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3) (D D1) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D K1) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3$0) (D D1) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D K2) (S S2))
(REWRITE)
(NEXT)
(SPLIT (>= N3$1 N3))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D D1) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3) (D K1) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3$0) (D K1) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D K2) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (C$0 D1))
(INSTANTIATE (C$0 (INVERSE K1)))
(INSTANTIATE (C$0 (INVERSE K2)))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(SPLIT (>= N3$1 N3$0))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3) (D D1) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D (INVERSE K1)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3$0) (D D1) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D (INVERSE K2)) (S S2))
(REWRITE)
(NEXT)
(SPLIT (>= N3$1 N3))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D D1) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3) (D (INVERSE K1)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3$0) (D (INVERSE K1)) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D (INVERSE K2)) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (ENCRYPT C K)))
(INSTANTIATE (C$0 (INVERSE K)))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(INSTANTIATE (N3$2 (+ N3$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-DECRYPT)
(REWRITE)
(INSTANTIATE (K$0 K))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D (ENCRYPT C K)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$2 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-DECRYPT)
(REWRITE)
(INSTANTIATE (K$0 K))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D (INVERSE K)) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C$0 K1))
(INSTANTIATE (C$0 K2))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(SPLIT (>= N3$1 N3$0))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC
     (N1 N3$1) (N2 N3) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D K1) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D K2) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC
     (N1 N3$1) (N2 N3$0) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(REWRITE)
(NEXT)
(SPLIT (>= N3$1 N3))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3) (D K1) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC
     (N1 N3$0) (N2 N3) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3$0) (D K1) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D K2) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C$0 (INVERSE K1)))
(INSTANTIATE (C$0 (INVERSE K2)))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(SPLIT (>= N3$1 N3$0))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC
     (N1 N3$1) (N2 N3) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D (INVERSE K1)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D (INVERSE K2)) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC
     (N1 N3$1) (N2 N3$0) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(REWRITE)
(NEXT)
(SPLIT (>= N3$1 N3))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3) (D (INVERSE K1)) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC
     (N1 N3$0) (N2 N3) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$1) (N2 N3$0) (D (INVERSE K1)) (S S2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D (INVERSE K2)) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-COMBINE)
(PRENEX)
(INSTANTIATE (C$0 D1))
(INSTANTIATE (C$0 D2))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(INSTANTIATE (N3$2 (+ N3$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-COMBINE)
(REWRITE)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D D1) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$2 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3$0 1)))
(INVOKE KNOWN-FROM-COMBINE)
(REWRITE)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D D2) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (C$0 (COMBINE C D2)))
(REWRITE)
(PRENEX)
(INSTANTIATE (N3$1 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(REWRITE)
(PRENEX)
(INSTANTIATE (C$0 (COMBINE D1 C)))
(REWRITE)
(PRENEX)
(INSTANTIATE (N3$1 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-HASH)
(PRENEX)
(INSTANTIATE (C$0 D1))
(REWRITE)
(PRENEX)
(INSTANTIATE (N3$1 (+ N3 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 (+ N3 1)))
(INVOKE KNOWN-FROM-HASH)
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-RECURSION)
(INSTANTIATE (C$0 C))
(REWRITE)
(NEXT)

(axiom known-in-transitive (m s1 s2)
  (implies (and (known-in m s1)
                (all (c) (implies (in c s1) (known-in c s2))))
           (known-in m s2)))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(USE KNOWN-IN-TRANSITIVE-LEMMA (S1 S1) (S2 S2) (N1 N))
(SIMPLIFY)
(INSTANTIATE (C M))
(SIMPLIFY)

(axiom combine-in-messages-consequence (c1 c2)
  (implies (in (combine c1 c2) (messages))
           (and (in c1 (messages)) (in c2 (messages)))))
(USE IN-MESSAGES-LEMMA (D (COMBINE C1 C2)))
(INVOKE COMBINE-MESSAGES)
(WITH-ENABLED (COMBINES COMBINE-INJECTIVE)
 (REWRITE))

(axiom encrypt-in-messages-consequence (c k)
  (implies (in (encrypt c k) (messages))
           (and (in c (messages))
                (in k (keys)))))
(USE IN-MESSAGES-LEMMA (D (ENCRYPT C K)))
(INVOKE ENCRYPT-MESSAGES)
(WITH-ENABLED (ENCRYPTS ENCRYPT-INJECTIVE)
 (REWRITE))

(axiom share-encrypt-in-messages-consequence (c k1 k2)
  (implies (in (share-encrypt c k1 k2) (messages))
           (and (in c (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys)))))
(USE IN-MESSAGES-LEMMA (D (SHARE-ENCRYPT C K1 K2)))
(INVOKE SHARE-ENCRYPT-MESSAGES)
(WITH-ENABLED (SHARE-ENCRYPTS SHARE-ENCRYPT-INJECTIVE)
 (REWRITE))

(grule known-in-bool (m s)
  (= (type-of (known-in m s)) (bool)))
(SIMPLIFY)

(rule known-in-aux-monotonic-rule (n1 n2 d s)
  (implies (and (known-in-aux d s n1)
                (>= n1 0)
                (>= n2 n1))
           (= (known-in-aux d s n2) (true))))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N1) (N2 N2) (D D) (S S))
(SIMPLIFY)

(rule known-in-aux-monotonic-rule-1 (n1 n2 d s)
  (implies (and (not (known-in-aux d s n2))
                (>= n1 0)
                (>= n2 n1))
           (= (known-in-aux d s n1) (false))))
(USE KNOWN-IN-AUX-MONOTONIC (N1 N1) (N2 N2) (D D) (S S))
(SIMPLIFY)

;;; don't export a1 and a2

(rule a1 (c1 c2 s)
  (implies (and (known-in c1 s) (known-in c2 s))
           (= (known-in (combine c1 c2) s) (true))))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(SPLIT (>= N N$0))
(CASES)
(INSTANTIATE (N$1 (+ N 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX (COMBINE C1 C2) S (+ N 1)))
(INVOKE KNOWN-FROM-COMBINE)
(REWRITE)
(NEXT)
(INSTANTIATE (N$2 (+ N$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX (COMBINE C1 C2) S (+ N$0 1)))
(INVOKE KNOWN-FROM-COMBINE)
(REWRITE)
(NEXT)

(axiom a2 (c1 c2 s)
  (implies (known-in (combine c1 c2) s)
           (and (known-in c1 s) (known-in c2 s))))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(CASES)
(USE COMBINE-IN-MESSAGES-CONSEQUENCE (C1 C1) (C2 C2))
(REWRITE)
(INSTANTIATE (N$0 (+ N 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C1 S (+ N 1)))
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(REWRITE)
(NEXT)
(INSTANTIATE (N$1 (+ N 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C2 S (+ N 1)))
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(REWRITE)
(USE COMBINE-IN-MESSAGES-CONSEQUENCE (C1 C1) (C2 C2))
(REWRITE)
(NEXT)

(rule a1a2 (c1 c2 s)
  (= (known-in (combine c1 c2) s)
     (and (known-in c1 s) (known-in c2 s))))
(USE A2 (C1 C1) (C2 C2) (S S))
(SPLIT (KNOWN-IN C2 S))
(SPLIT (KNOWN-IN C1 S))
(REWRITE)

(rule a3 (c k s)
  (implies (and (in k (keys))
                (known-in c s)
                (known-in k s))
           (= (known-in (encrypt c k) s) (true))))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(INSTANTIATE (N$1 (IF (>= N N$0) (+ N 1) (+ N$0 1))))
(REWRITE)
(SPLIT (>= N N$0))
(SIMPLIFY)
(CASES)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX (ENCRYPT C K) S (+ 1 N)))
(INVOKE KNOWN-FROM-ENCRYPT)
(REWRITE)
(NEXT)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX (ENCRYPT C K) S (+ 1 N$0)))
(INVOKE KNOWN-FROM-ENCRYPT)
(REWRITE)
(NEXT)

(rule a3b (c k1 k2 s)
  (implies (and (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (known-in c s)
                (known-in k1 s)
                (known-in k2 s))
           (= (known-in (share-encrypt c k1 k2) s) (true))))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(SPLIT (>= N$0 N))
(CASES)
(SPLIT (>= N$1 N$0))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION
       (KNOWN-IN-AUX (SHARE-ENCRYPT C K1 K2) S (+ N 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION
       (KNOWN-IN-AUX (SHARE-ENCRYPT C K1 K2) S (+ N$0 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(NEXT)
(SPLIT (>= N$1 N))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION
       (KNOWN-IN-AUX (SHARE-ENCRYPT C K1 K2) S (+ N 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N 1)))
(APPLY KNOWN-IN-AUX-DEFINITION
       (KNOWN-IN-AUX (SHARE-ENCRYPT C K1 K2) S (+ N$0 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(NEXT)

(rule a3c (c k1 k2 s)
  (implies (and (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (known-in c s)
                (known-in (inverse k1) s)
                (known-in (inverse k2) s))
           (= (known-in (share-encrypt c k1 k2) s) (true))))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(SPLIT (>= N$0 N))
(CASES)
(SPLIT (>= N$1 N$0))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION
       (KNOWN-IN-AUX (SHARE-ENCRYPT C K1 K2) S (+ N 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION
       (KNOWN-IN-AUX (SHARE-ENCRYPT C K1 K2) S (+ N$0 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(NEXT)
(SPLIT (>= N$1 N))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION
       (KNOWN-IN-AUX (SHARE-ENCRYPT C K1 K2) S (+ N 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N 1)))
(APPLY KNOWN-IN-AUX-DEFINITION
       (KNOWN-IN-AUX (SHARE-ENCRYPT C K1 K2) S (+ N$0 1)))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(NEXT)

(axiom a4 (c k s)
  (implies (and (in k (keys))
                (known-in (encrypt c k) s)
                (known-in (inverse k) s))
           (known-in c s)))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(SPLIT (>= N N$0))
(CASES)
(INSTANTIATE (N$1 (+ N 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N 1)))
(INVOKE KNOWN-FROM-DECRYPT)
(REWRITE)
(USE ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K K))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K$0 K))
(REWRITE)
(NEXT)
(INSTANTIATE (N$2 (+ N$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N$0 1)))
(INVOKE KNOWN-FROM-DECRYPT)
(REWRITE)
(USE ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K K))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K$0 K))
(REWRITE)
(NEXT)

(axiom a4b (c k1 k2 s)
  (implies (and (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (known-in (share-encrypt c k1 k2) s)
                (known-in k1 s)
                (known-in k2 s))
           (known-in c s)))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(SPLIT (>= N$0 N))
(CASES)
(SPLIT (>= N$1 N$0))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N$0 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(SPLIT (>= N$1 N))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N$0 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)

(axiom a4c (c k1 k2 s)
  (implies (and (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (known-in (share-encrypt c k1 k2) s)
                (known-in (inverse k1) s)
                (known-in (inverse k2) s))
           (known-in c s)))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(SPLIT (>= N$0 N))
(CASES)
(SPLIT (>= N$1 N$0))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N$0 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N$0 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(SPLIT (>= N$1 N))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S (+ N$0 1)))
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)

(rule a7 (m s)
  (implies (and (in m (messages))
                (in m s))
           (= (known-in m s) (true))))
(APPLY KNOWN-IN-DEFINITION)
(APPLY KNOWN-IN-AUX-DEFINITION)
(INSTANTIATE (N 0))
(REWRITE)

(rule a12 (c s)
  (implies (known-in c s)
           (= (known-in (hash c) s) (true))))
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(INSTANTIATE (N$0 (+ N 1)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX (HASH C) S (+ N 1)))
(INVOKE KNOWN-FROM-HASH)
(REWRITE)

(function comp-of-aux (d s n) ((measure n))
  (or (and (in d s) (in d (messages)))
      (if (>= n 1)
          (or (some (k)
                (and (in d (messages))
                     (in k (keys))
                     (comp-of-aux (encrypt d k) s (- n 1))
                     (comp-of-aux (inverse k) s (- n 1))))
              (some (k1 k2)
                (and (in d (messages))
                     (in k1 (asymmetric-keys))
                     (in k2 (asymmetric-keys))
                     (comp-of-aux (share-encrypt d k1 k2) s (- n 1))
                     (comp-of-aux k1 s (- n 1))
                     (comp-of-aux k2 s (- n 1))))
              (some (k1 k2)
                (and (in d (messages))
                     (in k1 (asymmetric-keys))
                     (in k2 (asymmetric-keys))
                     (comp-of-aux (share-encrypt d k1 k2) s (- n 1))
                     (comp-of-aux (inverse k1) s (- n 1))
                     (comp-of-aux (inverse k2) s (- n 1))))
              (some (d1 d2)
                (and (= d1 (combine d d2))
                     (in d (messages))
                     (in d2 (messages))
                     (comp-of-aux d1 s (- n 1))))
              (some (d1 d2)
                (and (= d2 (combine d1 d))
                     (in d1 (messages))
                     (in d (messages))
                     (comp-of-aux d2 s (- n 1))))
              (comp-of-aux d s (- n 1)))
          (false))))
(REDUCE)

(function comp-from-decrypt (d s n) ()
  (some (k)
    (and (in d (messages))
         (in k (keys))
         (comp-of-aux (encrypt d k) s (- n 1))
         (comp-of-aux (inverse k) s (- n 1)))))

(function comp-from-share-decrypt (d s n) ()
  (some (k1 k2)
    (and (in d (messages))
         (in k1 (asymmetric-keys))
         (in k2 (asymmetric-keys))
         (comp-of-aux (share-encrypt d k1 k2) s (- n 1))
         (comp-of-aux k1 s (- n 1))
         (comp-of-aux k2 s (- n 1)))))

(function comp-from-share-decrypt-inverse (d s n) ()
  (some (k1 k2)
    (and (in d (messages))
         (in k1 (asymmetric-keys))
         (in k2 (asymmetric-keys))
         (comp-of-aux (share-encrypt d k1 k2) s (- n 1))
         (comp-of-aux (inverse k1) s (- n 1))
         (comp-of-aux (inverse k2) s (- n 1)))))

(function comp-from-decombine-left (d s n) ()
  (some (d1 d2)
    (and (= d1 (combine d d2))
         (in d (messages))
         (in d2 (messages))
         (comp-of-aux d1 s (- n 1)))))

(function comp-from-decombine-right (d s n) ()
  (some (d1 d2)
    (and (= d2 (combine d1 d))
         (in d1 (messages))
         (in d (messages))
         (comp-of-aux d2 s (- n 1)))))

(function comp-from-recursion (d s n) ()
  (comp-of-aux d s (- n 1)))

(disabled
  (rule comp-of-aux-definition (d s n)
    (= (comp-of-aux d s n)
       (or (and (in d s) (in d (messages)))
           (if (>= n 1)
               (or (comp-from-decrypt d s n)
                   (comp-from-share-decrypt d s n)
                   (comp-from-share-decrypt-inverse d s n)
                   (comp-from-decombine-left d s n)
                   (comp-from-decombine-right d s n)
                   (comp-from-recursion d s n))
               (false))))))
(INVOKE COMP-OF-AUX)
(INVOKE COMP-FROM-DECRYPT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INVOKE COMP-FROM-RECURSION)
(SIMPLIFY)

;;; function-stub comp-of (d s))

(disabled
  (function comp-of (d s) ()
    (some (n) (comp-of-aux d s n))))

(frule comp-of-aux-in-messages (x s n)
  (implies (comp-of-aux x s n)
           (in x (messages))))
(INDUCT (NAT!WEAK-INDUCTION N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX X S N))
(INVOKE NAT!ZEROP)
(WITH-DISABLED (COMP-OF-AUX)
 (REDUCE))

(frule comp-of-in-messages (x s)
  (implies (comp-of x s)
           (in x (messages))))
(INVOKE COMP-OF)
(PRENEX)
(REWRITE)

(axiom comp-of-aux-monotonic (n1 n2 d s)
  (implies (and (comp-of-aux d s n1)
                (>= n1 0)
                (>= n2 n1))
           (comp-of-aux d s n2)))
(INDUCT (NAT!WEAK-INDUCTION N2))
(INVOKE NAT!ZEROP)
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX D S N2))
(INVOKE COMP-FROM-RECURSION)
(REWRITE)

(rule comp-of-aux-monotonic-rule (n1 n2 d s)
  (implies (and (comp-of-aux d s n1)
                (>= n1 0)
                (>= n2 n1))
           (= (comp-of-aux d s n2) (true))))
(USE COMP-OF-AUX-MONOTONIC (N1 N1) (N2 N2) (D D) (S S))
(SIMPLIFY)

(rule comp-of-aux-monotonic-rule-1 (n1 n2 d s)
  (implies (and (not (comp-of-aux d s n2))
                (>= n1 0)
                (>= n2 n1))
           (= (comp-of-aux d s n1) (false))))
(USE COMP-OF-AUX-MONOTONIC (N1 N1) (N2 N2) (D D) (S S))
(SIMPLIFY)

(disabled (rule comp-of-definition (c s)
            (= (comp-of c s)
               (some (n) (and (>= n 0) (comp-of-aux c s n))))))
(INVOKE COMP-OF)
(SPLIT (SOME (N) (COMP-OF-AUX C S N)))
(REWRITE)
(PRENEX)
(SPLIT (>= N 0))
(SIMPLIFY)
(APPLY COMP-OF-AUX-DEFINITION)
(REWRITE)
(INSTANTIATE (N$0 0))
(SIMPLIFY)

(grule comp-of-bool (s1 s2)
  (= (type-of (comp-of s1 s2)) (bool)))
(SIMPLIFY)

(axiom comp-of-transitive-lemma (s1 s2 n1)
  (implies
   (>= n1 0)
   (all (c)
     (implies
      (and (comp-of-aux c s1 n1)
           (all (c1) (implies (and (in c1 s1) (in c1 (messages)))
                              (some (n2) (and (>= n2 0)
                                              (comp-of-aux c1 s2 n2))))))
      (some (n3) (and (>= n3 0) (comp-of-aux c s2 n3)))))))
(INDUCT (NAT!WEAK-INDUCTION N1))
(CASES)
(REDUCE)
(PRENEX)
(INSTANTIATE (C1 C))
(REWRITE)
(NEXT)
(INVOKE NAT!ZEROP)
(PRENEX)
(REWRITE)
(SPLIT (IN C (MESSAGES)))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S1 N1))
(REWRITE)
(CASES)
(INSTANTIATE (C$0 C))
(INVOKE (COMP-OF-AUX C S1 (+ -1 N1)))
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (ENCRYPT C K)))
(INSTANTIATE (C$0 (INVERSE K)))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(INSTANTIATE (N3$2 (+ N3$0 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3 1)))
(INVOKE COMP-FROM-DECRYPT)
(REWRITE)
(INSTANTIATE (K$0 K))
(USE COMP-OF-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D (ENCRYPT C K)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$2 (+ N3 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3$0 1)))
(INVOKE COMP-FROM-DECRYPT)
(REWRITE)
(INSTANTIATE (K$0 K))
(USE COMP-OF-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D (INVERSE K)) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C$0 K1))
(INSTANTIATE (C$0 K2))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(SPLIT (>= N3$1 N3$0))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE COMP-OF-AUX-MONOTONIC
     (N1 N3$1) (N2 N3) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D K1) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3$0 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3$0 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D K2) (S S2))
(USE COMP-OF-AUX-MONOTONIC
     (N1 N3$1) (N2 N3$0) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(REWRITE)
(NEXT)
(SPLIT (>= N3$1 N3))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3$1) (N2 N3) (D K1) (S S2))
(USE COMP-OF-AUX-MONOTONIC
     (N1 N3$0) (N2 N3) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3$0 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3$1) (N2 N3$0) (D K1) (S S2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D K2) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C$0 (INVERSE K1)))
(INSTANTIATE (C$0 (INVERSE K2)))
(REWRITE)
(PRENEX)
(SPLIT (>= N3$0 N3))
(CASES)
(SPLIT (>= N3$1 N3$0))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE COMP-OF-AUX-MONOTONIC
     (N1 N3$1) (N2 N3) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3$0) (N2 N3) (D (INVERSE K1)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3$0 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3$0 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D (INVERSE K2)) (S S2))
(USE COMP-OF-AUX-MONOTONIC
     (N1 N3$1) (N2 N3$0) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(REWRITE)
(NEXT)
(SPLIT (>= N3$1 N3))
(CASES)
(INSTANTIATE (N3$3 (+ N3$1 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3$1) (N2 N3) (D (INVERSE K1)) (S S2))
(USE COMP-OF-AUX-MONOTONIC
     (N1 N3$0) (N2 N3) (D (SHARE-ENCRYPT C K1 K2)) (S S2))
(REWRITE)
(NEXT)
(REWRITE)
(INSTANTIATE (N3$3 (+ N3 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3$0 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3$1) (N2 N3$0) (D (INVERSE K1)) (S S2))
(USE COMP-OF-AUX-MONOTONIC (N1 N3) (N2 N3$0) (D (INVERSE K2)) (S S2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (C$0 (COMBINE C D2)))
(REWRITE)
(PRENEX)
(INSTANTIATE (N3$1 (+ N3 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3 1)))
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(PRENEX)
(INSTANTIATE (C$0 (COMBINE D1 C)))
(REWRITE)
(PRENEX)
(INSTANTIATE (N3$1 (+ N3 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 (+ N3 1)))
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C$0 C))
(REWRITE)
(NEXT)

(axiom comp-of-transitive (m s1 s2)
  (implies (and (comp-of m s1)
                (all (c) (implies (and (in c s1) (in c (messages)))
                                  (comp-of c s2))))
           (comp-of m s2)))
(APPLY COMP-OF-DEFINITION)
(PRENEX)
(USE COMP-OF-TRANSITIVE-LEMMA (S1 S1) (S2 S2) (N1 N))
(SIMPLIFY)
(INSTANTIATE (C M))
(SIMPLIFY)

(axiom b1 (c1 c2 s)
  (implies (comp-of (combine c1 c2) s)
           (and (comp-of c1 s) (comp-of c2 s))))
(APPLY COMP-OF-DEFINITION)
(PRENEX)
(CASES)
(INSTANTIATE (N$0 (+ N 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 S (+ N 1)))
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(REWRITE)
(USE COMBINE-IN-MESSAGES-CONSEQUENCE (C1 C1) (C2 C2))
(REWRITE)
(NEXT)
(INSTANTIATE (N$1 (+ N 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C2 S (+ N 1)))
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(USE COMBINE-IN-MESSAGES-CONSEQUENCE (C1 C1) (C2 C2))
(REWRITE)
(NEXT)

(axiom b2 (c k s)
  (implies (and (in k (keys))
                (comp-of (encrypt c k) s)
                (comp-of (inverse k) s))
           (comp-of c s)))
(APPLY COMP-OF-DEFINITION)
(PRENEX)
(SPLIT (>= N N$0))
(CASES)
(INSTANTIATE (N$1 (+ N 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N 1)))
(INVOKE COMP-FROM-DECRYPT)
(REWRITE)
(USE ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K K))
(REWRITE)
(INSTANTIATE (K$0 K))
(REWRITE)
(NEXT)
(INSTANTIATE (N$2 (+ N$0 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N$0 1)))
(INVOKE COMP-FROM-DECRYPT)
(REWRITE)
(USE ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K K))
(REWRITE)
(INSTANTIATE (K$0 K))
(REWRITE)
(NEXT)

(axiom b2b (c k1 k2 s)
  (implies (and (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (comp-of (share-encrypt c k1 k2) s)
                (comp-of k1 s)
                (comp-of k2 s))
           (comp-of c s)))
(APPLY COMP-OF-DEFINITION)
(PRENEX)
(SPLIT (>= N$0 N))
(CASES)
(SPLIT (>= N$1 N$0))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N$0 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N$0 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(SPLIT (>= N$1 N))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N$0 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)

(axiom b2c (c k1 k2 s)
  (implies (and (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (comp-of (share-encrypt c k1 k2) s)
                (comp-of (inverse k1) s)
                (comp-of (inverse k2) s))
           (comp-of c s)))
(APPLY COMP-OF-DEFINITION)
(PRENEX)
(SPLIT (>= N$0 N))
(CASES)
(SPLIT (>= N$1 N$0))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N$0 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N$0 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(SPLIT (>= N$1 N))
(CASES)
(INSTANTIATE (N$2 (+ N$1 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INSTANTIATE (N$3 (+ N 1)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S (+ N$0 1)))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(USE SHARE-ENCRYPT-IN-MESSAGES-CONSEQUENCE (C C) (K1 K1) (K2 K2))
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)

(rule b5 (m s)
  (implies (and (in m (messages))
                (in m s))
           (= (comp-of m s) (true))))
(APPLY COMP-OF-DEFINITION)
(APPLY COMP-OF-AUX-DEFINITION)
(REWRITE)
(INSTANTIATE (N 0))
(REDUCE)

(rule comp-of-aux-0 (c s)
  (= (comp-of-aux c s 0)
     (and (in c s) (in c (messages)))))
(REDUCE)

;;; negation of comp-of

(axiom c1-lemma (c c2 k s n)
  (implies (and (in c (messages))
                (in k (keys))
                (not (comp-of c s))
                (not (comp-of (inverse k) s))
                (not (= c (encrypt c2 k))))
           (and (not (comp-of-aux c (setadd (encrypt c2 k) s) n))
                (not (comp-of-aux (inverse k)
                                  (setadd (encrypt c2 k) s) n))
                (all (c1)
                  (implies
                    (and (in c1 (messages))
                         (not (= c1 (encrypt c2 k))))
                    (= (comp-of-aux c1 (setadd (encrypt c2 k) s) n)
                       (comp-of-aux c1 s n)))))))
(INVOKE COMP-OF)
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(REWRITE)
(CASES)
(CASES)
(INSTANTIATE (N$0 N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S N))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C (SETADD (ENCRYPT C2 K) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(REWRITE)
(INSTANTIATE (C1 (ENCRYPT C K$1)))
(INSTANTIATE (C1 (INVERSE K$0)))
(INSTANTIATE (K$1 K$0))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1$0 K2$0)))
(INSTANTIATE (C1 K1))
(INSTANTIATE (C1 K2))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1$0 K2$0)))
(INSTANTIATE (C1 (INVERSE K1)))
(INSTANTIATE (C1 (INVERSE K2)))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(REWRITE)
(INSTANTIATE (C1 (COMBINE C D2$0)))
(INSTANTIATE (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(INSTANTIATE (C1 (COMBINE D1$0 C)))
(INSTANTIATE (D1$0 D1))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(REWRITE)
(NEXT)
(INSTANTIATE (N$1 N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (INVERSE K) S N))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX (INVERSE K) (SETADD (ENCRYPT C2 K) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(REWRITE)
(INSTANTIATE (C1 (ENCRYPT (INVERSE K) K$1)))
(INSTANTIATE (C1 (INVERSE K$0)))
(INSTANTIATE (K$1 K$0))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (C1 (SHARE-ENCRYPT (INVERSE K) K1$0 K2$0)))
(INSTANTIATE (C1 K1))
(INSTANTIATE (C1 K2))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (C1 (SHARE-ENCRYPT (INVERSE K) K1$0 K2$0)))
(INSTANTIATE (C1 (INVERSE K1)))
(INSTANTIATE (C1 (INVERSE K2)))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(REWRITE)
(INSTANTIATE (C1 (COMBINE (INVERSE K) D2$0)))
(INSTANTIATE (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(INSTANTIATE (C1 (COMBINE D1$0 (INVERSE K))))
(INSTANTIATE (D1$0 D1))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(REWRITE)
(NEXT)
(INSTANTIATE (C1 C1$0))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 (SETADD (ENCRYPT C2 K) S) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 S N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$1 K$0))
(INSTANTIATE (C1$0 (ENCRYPT C1 K$0)))
(INSTANTIATE (C1$0 (INVERSE K$0)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 K1))
(INSTANTIATE (C1$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 (INVERSE K1)))
(INSTANTIATE (C1$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K$0 K$1))
(INSTANTIATE (C1$0 (ENCRYPT C1 K$0)))
(INSTANTIATE (C1$0 (INVERSE K$0)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 K1))
(INSTANTIATE (C1$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 (INVERSE K1)))
(INSTANTIATE (C1$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(SPLIT (IN D2 (MESSAGES)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)
(INSTANTIATE (N$2 0))
(INSTANTIATE (N$1 0))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C (SETADD (ENCRYPT C2 K) S) N))
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX (INVERSE K) (SETADD (ENCRYPT C2 K) S) N))
(REWRITE)
(PRENEX)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 (SETADD (ENCRYPT C2 K) S) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 S N))
(REWRITE)
(NEXT)

(axiom c1-lemma2 (c2 s n)
  (implies (>= n 0)
           (all (c1) (implies (comp-of-aux c1 s n)
                              (comp-of-aux c1 (setadd c2 s) n)))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(REWRITE)
(PRENEX)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 (SETADD C2 S) N))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 S N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$0 K))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(REWRITE)
(NEXT)

(rule c1 (c c2 k s)
  (implies
    (and (in k (keys))
         (not (comp-of (inverse k) s))
         (not (= c (encrypt c2 k))))
    (= (comp-of c (setadd (encrypt c2 k) s))
       (comp-of c s))))
(SPLIT (COMP-OF C S))
(REWRITE)
(CASES)
(APPLY COMP-OF-DEFINITION)
(PRENEX)
(INSTANTIATE (N$1 N))
(USE C1-LEMMA2 (C2 (ENCRYPT C2 K)) (S S) (N N))
(REWRITE)
(NEXT)
(INVOKE (COMP-OF C (SETADD (ENCRYPT C2 K) S)))
(PRENEX)
(USE C1-LEMMA (C C) (C2 C2) (K K) (S S) (N N))
(REWRITE)
(NEXT)

(function prop1 (k1 k2 s) ()
  (and (comp-of k1 s) (comp-of k2 s)))

(function prop2 (k1 k2 s n) ()
  (and (comp-of-aux k1 s n) (comp-of-aux k2 s n)))

(axiom c1b-lemma (c c2 k1 k2 s n)
  (implies (and (in c (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (not (comp-of c s))
                (not (prop1 k1 k2 s))
                (not (prop1 (inverse k1) (inverse k2) s))
                (not (= c (share-encrypt c2 k1 k2))))
           (and (not (comp-of-aux c (setadd (share-encrypt c2 k1 k2) s) n))
                (not (prop2 k1 k2 (setadd (share-encrypt c2 k1 k2) s) n))
                (not (prop2 (inverse k1)
                            (inverse k2)
                            (setadd (share-encrypt c2 k1 k2) s)
                            n))
                (all (c1)
                  (implies
                    (and (in c1 (messages))
                         (not (= c1 (share-encrypt c2 k1 k2))))
                    (= (comp-of-aux c1 (setadd (share-encrypt c2 k1 k2) s) n)
                       (comp-of-aux c1 s n)))))))
(INVOKE COMP-OF)
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(CASES)
(INSTANTIATE (N$0 0))
(REWRITE)
(CASES)
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX C (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(NEXT)
(INVOKE PROP2)
(INVOKE (COMP-OF-AUX K1 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(INVOKE (COMP-OF-AUX K1 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) (- N 1)))
(REWRITE)
(INVOKE PROP1)
(REWRITE)
(INVOKE (COMP-OF K2 S))
(INVOKE (COMP-OF-AUX K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(INSTANTIATE (N$1 0))
(REWRITE)
(INVOKE (COMP-OF K1 S))
(INSTANTIATE (N$1 0))
(REWRITE)
(NEXT)
(INVOKE PROP2)
(REWRITE)
(INVOKE (COMP-OF-AUX (INVERSE K1) (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(INVOKE (COMP-OF-AUX (INVERSE K2) (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(INVOKE (PROP1 (INVERSE K1) (INVERSE K2) S))
(INVOKE COMP-OF)
(REWRITE)
(INSTANTIATE (N$1 0))
(REWRITE)
(INSTANTIATE (N$1 0))
(REWRITE)
(NEXT)
(PRENEX)
(INVOKE COMP-OF-AUX)
(REWRITE)
(NEXT)
(REARRANGE)
(REWRITE)
(CASES)
(INSTANTIATE (N$0 N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S N))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX C (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1 (ENCRYPT C K)))
(INSTANTIATE (C1 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1$0 K2$0)))
(INSTANTIATE (C1 K1$0))
(INSTANTIATE (C1 K2$0))
(INVOKE (PROP2 K1 K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1$0 K2$0)))
(INSTANTIATE (C1 (INVERSE K1$0)))
(INSTANTIATE (C1 (INVERSE K2$0)))
(INVOKE (PROP2 (INVERSE K1)
               (INVERSE K2)
               (SETADD (SHARE-ENCRYPT C2 K1 K2) S)
               (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE C D2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE D1 C)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(REWRITE)
(NEXT)
(INVOKE (PROP2 K1 K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(INVOKE (PROP1 K1 K2 S))
(REWRITE)
(CASES)
(INVOKE (COMP-OF K2 S))
(INSTANTIATE (N$0 N))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX K2 S N))
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1 (ENCRYPT K2 K)))
(INSTANTIATE (C1 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT K2 K1$0 K2$0)))
(INSTANTIATE (C1 K1$0))
(INSTANTIATE (C1 K2$0))
(REWRITE)
(INVOKE (PROP2 K1 K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT K2 K1$0 K2$0)))
(INSTANTIATE (C1 (INVERSE K1$0)))
(INSTANTIATE (C1 (INVERSE K2$0)))
(REWRITE)
(INVOKE (PROP2 (INVERSE K1)
               (INVERSE K2)
               (SETADD (SHARE-ENCRYPT C2 K1 K2) S)
               (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE K2 D2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE D1 K2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-OF)
(INSTANTIATE (N$0 N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX K1 S N))
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX K1 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(CONTRADICT)
(CASES)
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1 (ENCRYPT K1 K)))
(INSTANTIATE (C1 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT K1 K1$0 K2$0)))
(INSTANTIATE (C1 K1$0))
(INSTANTIATE (C1 K2$0))
(REWRITE)
(INVOKE (PROP2 K1 K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT K1 K1$0 K2$0)))
(INSTANTIATE (C1 (INVERSE K1$0)))
(INSTANTIATE (C1 (INVERSE K2$0)))
(REWRITE)
(INVOKE (PROP2 (INVERSE K1)
               (INVERSE K2)
               (SETADD (SHARE-ENCRYPT C2 K1 K2) S)
               (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE K1 D2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE D1 K1)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1 K1))
(REWRITE)
(NEXT)
(INVOKE
  (PROP2 (INVERSE K1) (INVERSE K2) (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(INVOKE (PROP1 (INVERSE K1) (INVERSE K2) S))
(REWRITE)
(CASES)
(INVOKE (COMP-OF (INVERSE K2) S))
(INSTANTIATE (N$0 N))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (INVERSE K2) S N))
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX (INVERSE K2) (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1 (ENCRYPT (INVERSE K2) K)))
(INSTANTIATE (C1 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT (INVERSE K2) K1$0 K2$0)))
(INSTANTIATE (C1 K1$0))
(INSTANTIATE (C1 K2$0))
(REWRITE)
(INVOKE (PROP2 K1 K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT (INVERSE K2) K1$0 K2$0)))
(INSTANTIATE (C1 (INVERSE K1$0)))
(INSTANTIATE (C1 (INVERSE K2$0)))
(REWRITE)
(INVOKE (PROP2 (INVERSE K1)
               (INVERSE K2)
               (SETADD (SHARE-ENCRYPT C2 K1 K2) S)
               (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE (INVERSE K2) D2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE D1 (INVERSE K2))))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1 (INVERSE K2)))
(REWRITE)
(NEXT)
(INVOKE COMP-OF)
(INSTANTIATE (N$0 N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (INVERSE K1) S N))
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX (INVERSE K1) (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(CONTRADICT)
(CASES)
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1 (ENCRYPT (INVERSE K1) K)))
(INSTANTIATE (C1 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT (INVERSE K1) K1$0 K2$0)))
(INSTANTIATE (C1 K1$0))
(INSTANTIATE (C1 K2$0))
(REWRITE)
(INVOKE (PROP2 K1 K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT (INVERSE K1) K1$0 K2$0)))
(INSTANTIATE (C1 (INVERSE K1$0)))
(INSTANTIATE (C1 (INVERSE K2$0)))
(REWRITE)
(INVOKE (PROP2 (INVERSE K1)
               (INVERSE K2)
               (SETADD (SHARE-ENCRYPT C2 K1 K2) S)
               (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE (INVERSE K1) D2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE D1 (INVERSE K1))))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1 (INVERSE K1)))
(REWRITE)
(NEXT)
(INSTANTIATE (C1 C1$0))
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX C1 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 S N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$0 K))
(INSTANTIATE (C1$0 (ENCRYPT C1 K)))
(INSTANTIATE (C1$0 (INVERSE K)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$1 K1$0) (K2$1 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1$0 K2$0)))
(INSTANTIATE (C1$0 K1$0))
(INSTANTIATE (C1$0 K2$0))
(REWRITE)
(INVOKE (PROP2 K1 K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) (+ -1 N)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$1 K1$0) (K2$1 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1$0 K2$0)))
(INSTANTIATE (C1$0 (INVERSE K1$0)))
(INSTANTIATE (C1$0 (INVERSE K2$0)))
(REWRITE)
(INVOKE (PROP2 (INVERSE K1)
               (INVERSE K2)
               (SETADD (SHARE-ENCRYPT C2 K1 K2) S)
               (+ -1 N)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1$0 (ENCRYPT C1 K)))
(INSTANTIATE (C1$0 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1$0 K2$0)))
(INSTANTIATE (C1$0 K1$0))
(INSTANTIATE (C1$0 K2$0))
(REWRITE)
(INVOKE (PROP2 K1 K2 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1$0 K2$0)))
(INSTANTIATE (C1$0 (INVERSE K1$0)))
(INSTANTIATE (C1$0 (INVERSE K2$0)))
(REWRITE)
(INVOKE (PROP2 (INVERSE K1)
               (INVERSE K2)
               (SETADD (SHARE-ENCRYPT C2 K1 K2) S)
               (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(SPLIT (IN D2 (MESSAGES)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)

(rule c1b (c c2 k1 k2 s)
  (implies (and (in c (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (not (= c (share-encrypt c2 k1 k2)))
                (not (and (comp-of k1 s) (comp-of k2 s)))
                (not (and (comp-of (inverse k1) s)
                          (comp-of (inverse k2) s))))
           (= (comp-of c (setadd (share-encrypt c2 k1 k2) s))
              (comp-of c s))))
(SPLIT (COMP-OF C S))
(CASES)
(REWRITE)
(APPLY COMP-OF-DEFINITION)
(PRENEX)
(USE C1-LEMMA2 (C2 (SHARE-ENCRYPT C2 K1 K2)) (S S) (N N))
(REWRITE)
(INSTANTIATE (C1 C))
(REWRITE)
(NEXT)
(SPLIT (COMP-OF C (SETADD (SHARE-ENCRYPT C2 K1 K2) S)))
(SIMPLIFY)
(INVOKE (COMP-OF C (SETADD (SHARE-ENCRYPT C2 K1 K2) S)))
(PRENEX)
(USE C1B-LEMMA (C C) (C2 C2) (K1 K1) (K2 K2) (S S) (N N))
(INVOKE PROP1)
(INVOKE PROP2)
(REARRANGE)
(REWRITE)
(NEXT)

(axiom c1c-lemma (c c2 s n)
  (implies (and (in c (messages))
                (not (comp-of c s))
                (not (= c (hash c2))))
           (and (not (comp-of-aux c (setadd (hash c2) s) n))
                (all (c1)
                  (implies
                    (and (in c1 (messages))
                         (not (= c1 (hash c2))))
                    (= (comp-of-aux c1 (setadd (hash c2) s) n)
                       (comp-of-aux c1 s n)))))))
(INVOKE COMP-OF)
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(CASES)
(INSTANTIATE (N$0 0))
(REWRITE)
(CASES)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C (SETADD (HASH C2) S) N))
(REWRITE)
(NEXT)
(INVOKE (COMP-OF-AUX C1 (SETADD (HASH C2) S) N))
(REWRITE)
(INVOKE (COMP-OF-AUX C1 S N))
(REWRITE)
(NEXT)
(REARRANGE)
(REWRITE)
(CASES)
(INSTANTIATE (N$0 N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S N))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C (SETADD (HASH C2) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1 (ENCRYPT C K)))
(INSTANTIATE (C1 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C1 K1))
(INSTANTIATE (C1 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C1 (INVERSE K1)))
(INSTANTIATE (C1 (INVERSE K2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE C D2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE D1 C)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(REWRITE)
(NEXT)
(INSTANTIATE (C1 C1$0))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 (SETADD (HASH C2) S) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 S N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$0 K))
(INSTANTIATE (C1$0 (ENCRYPT C1 K)))
(INSTANTIATE (C1$0 (INVERSE K)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 K1))
(INSTANTIATE (C1$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 (INVERSE K1)))
(INSTANTIATE (C1$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1$0 (ENCRYPT C1 K)))
(INSTANTIATE (C1$0 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 K1))
(INSTANTIATE (C1$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 (INVERSE K1)))
(INSTANTIATE (C1$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(SPLIT (IN D2 (MESSAGES)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)

(rule c1c (c c2 s)
  (implies (and (in c (messages))
                (not (= c (hash c2))))
           (= (comp-of c (setadd (hash c2) s))
              (comp-of c s))))
(SPLIT (COMP-OF C S))
(CASES)
(REWRITE)
(APPLY COMP-OF-DEFINITION)
(PRENEX)
(USE C1-LEMMA2 (C2 (HASH C2)) (S S) (N N))
(REWRITE)
(INSTANTIATE (C1 C))
(REWRITE)
(NEXT)
(SPLIT (COMP-OF C (SETADD (HASH C2) S)))
(SIMPLIFY)
(INVOKE (COMP-OF C (SETADD (HASH C2) S)))
(PRENEX)
(USE C1C-LEMMA (C C) (C2 C2) (S S) (N N))
(REARRANGE)
(REWRITE)
(NEXT)

(axiom c2-lemma (c c2 k s n)
  (implies (and (in c (messages))
                (in c2 (messages))
                (in k (keys))
                (not (comp-of c (setadd c2 s)))
                (not (= c (encrypt c2 k))))
           (and (not (comp-of-aux c (setadd (encrypt c2 k) s) n))
                (all (c1)
                  (implies
                    (and (in c1 (messages))
                         (not (= c1 (encrypt c2 k)))
                         (comp-of-aux c1 (setadd (encrypt c2 k) s) n))
                    (comp-of-aux c1 (setadd c2 s) n))))))
(INDUCT (NAT!WEAK-INDUCTION N))
(REWRITE)
(INVOKE NAT!ZEROP)
(REWRITE)
(CASES)
(APPLY COMP-OF-DEFINITION)
(INSTANTIATE (N$0 N))
(REWRITE)
(CASES)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C (SETADD C2 S) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C (SETADD (ENCRYPT C2 K) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K$0 K$1))
(INSTANTIATE (C1 (ENCRYPT C K$0)))
(INSTANTIATE (C1 (INVERSE K$0)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C1 K1))
(INSTANTIATE (C1 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C1 (INVERSE K1)))
(INSTANTIATE (C1 (INVERSE K2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE C D2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE D1 C)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1 C))
(REWRITE)
(NEXT)
(INSTANTIATE (C1 C1$0))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 (SETADD (ENCRYPT C2 K) S) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 (SETADD C2 S) N))
(REWRITE)
(CASES)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$1 K$0))
(INSTANTIATE (C1$0 (ENCRYPT C1 K$0)))
(INSTANTIATE (C1$0 (INVERSE K$0)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 K1))
(INSTANTIATE (C1$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 (INVERSE K1)))
(INSTANTIATE (C1$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$1 K$0))
(INSTANTIATE (C1$0 (ENCRYPT C1 K$0)))
(INSTANTIATE (C1$0 (INVERSE K$0)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 K1))
(INSTANTIATE (C1$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 (INVERSE K1)))
(INSTANTIATE (C1$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)
(APPLY COMP-OF-AUX-DEFINITION)
(REWRITE)
(INVOKE COMP-OF)
(INSTANTIATE (N$0 0))
(REWRITE)
(NEXT)

(rule c2 (c c2 k s)
  (implies
    (and (not (comp-of c (setadd c2 s)))
         (in c2 (messages))
         (in k (keys))
         (not (= c (encrypt c2 k))))
    (= (comp-of c (setadd (encrypt c2 k) s))
       (false))))
(APPLY COMP-OF-DEFINITION (COMP-OF C (SETADD (ENCRYPT C2 K) S)))
(PRENEX)
(USE C2-LEMMA (C C) (C2 C2) (K K) (S S) (N N))
(REWRITE)

(axiom c2b-lemma (c c2 k1 k2 s n)
  (implies (and (in c (messages))
                (in c2 (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (not (comp-of c (setadd c2 s)))
                (not (= c (share-encrypt c2 k1 k2))))
           (and (not (comp-of-aux c (setadd (share-encrypt c2 k1 k2) s) n))
                (all (c1)
                  (implies
                    (and (in c1 (messages))
                         (not (= c1 (share-encrypt c2 k1 k2)))
                         (comp-of-aux c1 (setadd (share-encrypt c2 k1 k2) s)
                                      n))
                    (comp-of-aux c1 (setadd c2 s) n))))))
(INDUCT (NAT!WEAK-INDUCTION N))
(REWRITE)
(INVOKE NAT!ZEROP)
(REWRITE)
(CASES)
(APPLY COMP-OF-DEFINITION)
(INSTANTIATE (N$0 N))
(REWRITE)
(CASES)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C (SETADD C2 S) N))
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX C (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1 (ENCRYPT C K)))
(INSTANTIATE (C1 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1$0 K2$0)))
(INSTANTIATE (C1 K1$0))
(INSTANTIATE (C1 K2$0))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$0 K1$1) (K2$0 K2$1))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1$0 K2$0)))
(INSTANTIATE (C1 (INVERSE K1$0)))
(INSTANTIATE (C1 (INVERSE K2$0)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE C D2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1 D1$0) (D2 D2$0))
(INSTANTIATE (C1 (COMBINE D1 C)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1 C))
(REWRITE)
(NEXT)
(INSTANTIATE (C1 C1$0))
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX C1 (SETADD (SHARE-ENCRYPT C2 K1 K2) S) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 (SETADD C2 S) N))
(REWRITE)
(CASES)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$0 K))
(INSTANTIATE (C1$0 (ENCRYPT C1 K)))
(INSTANTIATE (C1$0 (INVERSE K)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$1 K1$0) (K2$1 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1$0 K2$0)))
(INSTANTIATE (C1$0 K1$0))
(INSTANTIATE (C1$0 K2$0))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$1 K1$0) (K2$1 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1$0 K2$0)))
(INSTANTIATE (C1$0 (INVERSE K1$0)))
(INSTANTIATE (C1$0 (INVERSE K2$0)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$0 K))
(INSTANTIATE (C1$0 (ENCRYPT C1 K)))
(INSTANTIATE (C1$0 (INVERSE K)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$1 K1$0) (K2$1 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1$0 K2$0)))
(INSTANTIATE (C1$0 K1$0))
(INSTANTIATE (C1$0 K2$0))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$1 K1$0) (K2$1 K2$0))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1$0 K2$0)))
(INSTANTIATE (C1$0 (INVERSE K1$0)))
(INSTANTIATE (C1$0 (INVERSE K2$0)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1$0 C1))
(REWRITE)
(NEXT)
(APPLY COMP-OF-AUX-DEFINITION)
(REWRITE)
(INVOKE COMP-OF)
(INSTANTIATE (N$0 0))
(REWRITE)
(NEXT)

(rule c2b (c c2 k1 k2 s)
  (implies
    (and (not (comp-of c (setadd c2 s)))
         (in c2 (messages))
         (in k1 (asymmetric-keys))
         (in k2 (asymmetric-keys))
         (not (= c (share-encrypt c2 k1 k2))))
    (= (comp-of c (setadd (share-encrypt c2 k1 k2) s))
       (false))))
(APPLY COMP-OF-DEFINITION (COMP-OF C (SETADD (SHARE-ENCRYPT C2 K1 K2) S)))
(PRENEX)
(USE C2B-LEMMA (C C) (C2 C2) (K1 K1) (K2 K2) (S S) (N N))
(REWRITE)

(axiom c3-lemma (x s n)
  (implies
   (in x (basic-messages))
   (all (c1)
     (implies (and (in c1 (messages))
                   (not (= c1 x)))
              (= (comp-of-aux c1 (setadd x s) n)
                 (comp-of-aux c1 s n))))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(REWRITE)
(CASES)
(INSTANTIATE (C1 C1$0))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 (SETADD X S) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 S N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$0 K))
(INSTANTIATE (C1$0 (ENCRYPT C1 K)))
(INSTANTIATE (C1$0 (INVERSE K)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 K1))
(INSTANTIATE (C1$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 (INVERSE K1)))
(INSTANTIATE (C1$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-RECURSION)
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$0 K))
(INSTANTIATE (C1$0 (ENCRYPT C1 K)))
(INSTANTIATE (C1$0 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 K1))
(INSTANTIATE (C1$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 (INVERSE K1)))
(INSTANTIATE (C1$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE C1 D2)))
(REWRITE)
(SPLIT (IN D2 (MESSAGES)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (C1$0 (COMBINE D1 C1)))
(REWRITE)
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(REWRITE)
(NEXT)
(INVOKE COMP-OF-AUX)
(REWRITE)
(NEXT)

(rule c3 (c x s)
  (implies
    (and (in c (messages))
         (not (= c x))
         (in x (basic-messages)))
    (= (comp-of c (setadd x s))
       (comp-of c s))))
(SPLIT (COMP-OF C S))
(SIMPLIFY)
(INVOKE COMP-OF)
(CASES)
(PRENEX)
(USE C3-LEMMA (X X) (S S) (N N))
(INSTANTIATE (N$0 N))
(INSTANTIATE (C1 C))
(REWRITE)
(NEXT)
(PRENEX)
(USE C3-LEMMA (X X) (S S) (N N))
(INSTANTIATE (C1 C))
(INSTANTIATE (N$0 N))
(SIMPLIFY)
(NEXT)

(axiom c4-lemma (c d1 d2 s n)
  (implies (and (in c (messages))
                (in d1 (messages))
                (in d2 (messages))
                (not (comp-of c (union s (make-set d1 d2))))
                (not (= c (combine d1 d2))))
           (and (not (comp-of-aux c (setadd (combine d1 d2) s) n))
                (all (c1)
                  (implies
                    (and (in c1 (messages))
                         (not (= c1 (combine d1 d2)))
                         (comp-of-aux c1 (setadd (combine d1 d2) s) n))
                    (comp-of-aux c1 (union s (make-set d1 d2)) n))))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(REWRITE)
(CASES)
(CASES)
(INVOKE COMP-OF)
(INSTANTIATE (N$0 N))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX C (UNION S (SETADD D1 (SETADD D2 (NULLSET)))) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C (SETADD (COMBINE D1 D2) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K K$0))
(INSTANTIATE (C1 (ENCRYPT C K)))
(INSTANTIATE (C1 (INVERSE K)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C1 K1))
(INSTANTIATE (C1 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1 K1$0) (K2 K2$0))
(INSTANTIATE (C1 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C1 (INVERSE K1)))
(INSTANTIATE (C1 (INVERSE K2)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1$0 D1$1) (D2$0 D2$1))
(INSTANTIATE (C1 (COMBINE C D2$0)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1$0 D1$1) (D2$0 D2$1))
(INSTANTIATE (C1 (COMBINE D1$0 C)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C1 C))
(REWRITE)
(NEXT)
(INSTANTIATE (C1 C1$0))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION
       (COMP-OF-AUX C1 (UNION S (SETADD D1 (SETADD D2 (NULLSET)))) N))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C1 (SETADD (COMBINE D1 D2) S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$0 K))
(INSTANTIATE (C1$0 (ENCRYPT C1 K)))
(INSTANTIATE (C1$0 (INVERSE K)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 K1))
(INSTANTIATE (C1$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(INSTANTIATE (C1$0 (SHARE-ENCRYPT C1 K1 K2)))
(INSTANTIATE (C1$0 (INVERSE K1)))
(INSTANTIATE (C1$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$1 D1$0) (D2$1 D2$0))
(INSTANTIATE (C1$0 (COMBINE C1 D2$0)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$1 D1$0) (D2$1 D2$0))
(INSTANTIATE (C1$0 (COMBINE D1$0 C1)))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(REWRITE)
(NEXT)
(INVOKE COMP-OF)
(INSTANTIATE (N$0 N))
(INVOKE (COMP-OF-AUX C (UNION S (SETADD D1 (SETADD D2 (NULLSET)))) N))
(REWRITE)
(INVOKE (COMP-OF-AUX C (SETADD (COMBINE D1 D2) S) N))
(REWRITE)
(INVOKE (COMP-OF-AUX C1 (SETADD (COMBINE D1 D2) S) N))
(REWRITE)
(INVOKE (COMP-OF-AUX C1 (UNION S (SETADD D1 (SETADD D2 (NULLSET)))) N))
(REWRITE)
(NEXT)

(rule c4 (c d1 d2 s)
 (implies
  (and
   (in c (messages))
   (in d1 (messages))
   (in d2 (messages))
   (not
    (comp-of c (union s (make-set d1 d2))))
   (not (= c (combine d1 d2))))
  (= (comp-of c (setadd (combine d1 d2) s)) (false))))
(INVOKE (COMP-OF C (SETADD (COMBINE D1 D2) S)))
(PRENEX)
(USE C4-LEMMA (C C) (D1 D1) (D2 D2) (S S) (N N))
(SIMPLIFY)

(axiom comp-of-aux-nullset (n)
  (not (some (x) (comp-of-aux x (nullset) n))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(REWRITE)
(CASES)
(PRENEX)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX X (NULLSET) N))
(WITH-DISABLED (COMP-OF-AUX)
 (REDUCE))
(NEXT)
(PRENEX)
(INVOKE COMP-OF-AUX)
(REWRITE)
(NEXT)

(rule c5 (c) (= (comp-of c (nullset)) (false)))
(INVOKE COMP-OF)
(PRENEX)
(USE COMP-OF-AUX-NULLSET (N N))
(SIMPLIFY)

(disabled
  (function set-of-keys (x) ()
    (subset x (keys))))

(axiom c7-lemma (s n)
  (implies (set-of-keys s)
           (all (c) (= (comp-of-aux c s n) (in c s)))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(CASES)
(WITH-ENABLED (SET-OF-KEYS)
 (REDUCE))
(INSTANTIATE (E C))
(REWRITE)
(NEXT)
(REWRITE)
(PRENEX)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S N))
(REWRITE)
(CASES)
(INVOKE SET-OF-KEYS)
(INVOKE SUBSET)
(INSTANTIATE (E C))
(REWRITE)
(NEXT)
(INVOKE SET-OF-KEYS)
(INVOKE SUBSET)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (ENCRYPT C K)))
(INSTANTIATE (E (ENCRYPT C K)))
(REWRITE)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (E (SHARE-ENCRYPT C K1 K2)))
(REWRITE)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1$0 K2$0)))
(INSTANTIATE (E (SHARE-ENCRYPT C K1$0 K2$0)))
(REWRITE)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (C$0 (COMBINE C D2)))
(INSTANTIATE (E (COMBINE C D2)))
(REWRITE)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (C$0 (COMBINE D1 C)))
(INSTANTIATE (E (COMBINE D1 C)))
(REWRITE)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C$0 C))
(REWRITE)
(NEXT)

(disabled
 (rule c7 (c s)
   (implies (and (not (in c s))
                 (set-of-keys s))
            (= (comp-of c s) (false)))))
(INVOKE COMP-OF)
(PRENEX)
(USE C7-LEMMA (S S) (N N))
(INSTANTIATE (C$0 C))
(SIMPLIFY)

(disabled
  (rule set-of-keys-definition (s)
    (= (set-of-keys s) (subset s (keys)))))
(INVOKE SET-OF-KEYS)
(SIMPLIFY)

(rule c8 (k s)
  (implies (and (in k (keys)) (set-of-keys s))
           (= (set-of-keys (setadd k s)) (true))))
(WITH-ENABLED (SET-OF-KEYS)
 (REDUCE))

(rule c9 ()
  (= (set-of-keys (nullset)) (true)))
(WITH-ENABLED (SET-OF-KEYS)
 (REDUCE))

(axiom d1-lemma (s n)
  (implies (>= n 0)
           (all (c) (implies (comp-of-aux c s n)
                             (known-in-aux c s n)))))
(INDUCT (NAT!WEAK-INDUCTION N))
(CASES)
(REDUCE)
(NEXT)
(INVOKE NAT!ZEROP)
(PRENEX)
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S N))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S N))
(REWRITE)
(CASES)
(WITH-DISABLED (COMP-OF-AUX KNOWN-IN-AUX)
 (REDUCE))
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(INVOKE KNOWN-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (K$0 K))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INVOKE KNOWN-FROM-RECURSION)
(REWRITE)
(NEXT)

(frule d1 (s1 s)
  (implies (not (known-in s1 s)) (not (comp-of s1 s))))
(SPLIT (COMP-OF S1 S))
(SIMPLIFY)
(APPLY COMP-OF-DEFINITION)
(APPLY KNOWN-IN-DEFINITION)
(INSTANTIATE (N$0 N))
(USE D1-LEMMA (S S) (N N))
(SIMPLIFY)


(axiom d2-lemma (s n)
  (and (all (b) (implies (and (in b (atomic-messages))
                              (known-in-aux b s n))
                         (comp-of-aux b s n)))
       (all (m k) (implies (and (in m (messages))
                                (in k (keys))
                                (known-in-aux (encrypt m k) s n))
                           (or (and (known-in-aux m s n)
                                    (known-in-aux k s n))
                               (comp-of-aux (encrypt m k) s n))))
       (all (m k1 k2) (implies (and (in m (messages))
                                    (in k1 (asymmetric-keys))
                                    (in k2 (asymmetric-keys))
                                    (known-in-aux (share-encrypt m k1 k2) s n))
                               (or (and (known-in-aux m s n)
                                        (known-in-aux k1 s n)
                                        (known-in-aux k2 s n))
                                   (and (known-in-aux m s n)
                                        (known-in-aux (inverse k1) s n)
                                        (known-in-aux (inverse k2) s n))
                                   (comp-of-aux (share-encrypt m k1 k2) s n))))
       (all (c1 c2) (implies (and (in c1 (messages))
                                  (in c2 (messages))
                                  (known-in-aux (combine c1 c2) s n))
                             (or (and (known-in-aux c1 s n)
                                      (known-in-aux c2 s n))
                                 (comp-of-aux (combine c1 c2) s n))))))
(INDUCT (NAT!WEAK-INDUCTION N))
(CASES)
(INVOKE NAT!ZEROP)
(APPLY KNOWN-IN-AUX-DEFINITION)
(APPLY COMP-OF-AUX-DEFINITION)
(REWRITE)
(NEXT)
(INVOKE NAT!ZEROP)
(CASES)
(PRENEX)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX B S N))
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE KNOWN-FROM-ENCRYPT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(INVOKE KNOWN-FROM-COMBINE)
(INVOKE KNOWN-FROM-HASH)
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX B S N))
(SPLIT (IN B S))
(CASES)
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(SPLIT (COMP-FROM-RECURSION B S N))
(REWRITE)
(INVOKE COMP-FROM-RECURSION)
(CASES)
(INVOKE KNOWN-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (M B) (K$0 K))
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K$1 K))
(INSTANTIATE (B$0 B))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 B) (K1$0 K1) (K2$0 K2))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$1 K1) (K2$1 K2))
(INSTANTIATE (B$0 B))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$0 B) (K1$0 K1) (K2$0 K2))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$1 K1) (K2$1 K2))
(INSTANTIATE (B$0 B))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (C1 B) (C2 D2))
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (B$0 B))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (C1 D1) (C2 B))
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(INSTANTIATE (B$0 B))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-RECURSION)
(INSTANTIATE (B$0 B))
(REWRITE)
(NEXT)
(PRENEX)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX (ENCRYPT M K) S N))
(REWRITE)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(INVOKE KNOWN-FROM-COMBINE)
(INVOKE KNOWN-FROM-HASH)
(REWRITE)
(SPLIT (KNOWN-FROM-RECURSION (ENCRYPT M K) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-RECURSION)
(INSTANTIATE (M$0 M) (K$0 K))
(REARRANGE)
(REWRITE)
(NEXT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-RECURSION)
(USE D1-LEMMA (S S) (N (- N 1)))
(INSTANTIATE (C (ENCRYPT M K)))
(REWRITE)
(SPLIT (IN (ENCRYPT M K) S))
(CASES)
(INVOKE (COMP-OF-AUX (ENCRYPT M K) S (+ -1 N)))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-ENCRYPT (ENCRYPT M K) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-ENCRYPT)
(PRENEX)
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-DECRYPT (ENCRYPT M K) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (ENCRYPT M K)) (K$1 K$0))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (ENCRYPT M K) S N))
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K$2 K$0))
(INSTANTIATE (K$3 K$0))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-SHARE-DECRYPT (ENCRYPT M K) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (M$1 (ENCRYPT M K)) (K1$0 K1) (K2$0 K2))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (ENCRYPT M K) S N))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$1 K1) (K2$1 K2))
(INSTANTIATE (K1$2 K1) (K2$2 K2))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-SHARE-DECRYPT-INVERSE (ENCRYPT M K) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$1 (ENCRYPT M K)) (K1$0 K1) (K2$0 K2))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (ENCRYPT M K) S N))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$1 (INVERSE K1)) (K2$1 (INVERSE K2)))
(INSTANTIATE (K1$1 K1) (K2$1 K2))
(INSTANTIATE (K1$2 K1) (K2$2 K2))
(INSTANTIATE (B (INVERSE K1)))
(INSTANTIATE (B (INVERSE K2)))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-DECOMBINE-LEFT (ENCRYPT M K) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (C1 (ENCRYPT M K)) (C2 D2))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (ENCRYPT M K) S N))
(INVOKE (COMP-FROM-DECOMBINE-LEFT (ENCRYPT M K) S N))
(REWRITE)
(NEXT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (C1 D1) (C2 (ENCRYPT M K)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (ENCRYPT M K) S N))
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(NEXT)
(PRENEX)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX (SHARE-ENCRYPT M K1 K2) S N))
(REWRITE)
(INVOKE KNOWN-FROM-ENCRYPT)
(INVOKE KNOWN-FROM-COMBINE)
(INVOKE KNOWN-FROM-HASH)
(REWRITE)
(SPLIT (KNOWN-FROM-RECURSION (SHARE-ENCRYPT M K1 K2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-RECURSION)
(INSTANTIATE (M$1 M) (K1$0 K1) (K2$0 K2))
(REARRANGE)
(REWRITE)
(NEXT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-RECURSION)
(USE D1-LEMMA (S S) (N (- N 1)))
(INSTANTIATE (C (SHARE-ENCRYPT M K1 K2)))
(REWRITE)
(SPLIT (IN (SHARE-ENCRYPT M K1 K2) S))
(CASES)
(INVOKE (COMP-OF-AUX (SHARE-ENCRYPT M K1 K2) S (+ -1 N)))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-SHARE-ENCRYPT (SHARE-ENCRYPT M K1 K2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(PRENEX)
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-SHARE-ENCRYPT-INVERSE (SHARE-ENCRYPT M K1 K2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(PRENEX)
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-DECRYPT (SHARE-ENCRYPT M K1 K2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)) (K$0 K))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (SHARE-ENCRYPT M K1 K2) S N))
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K$1 K))
(INSTANTIATE (K$2 K))
(INSTANTIATE (K$3 K))
(INSTANTIATE (K$4 K))
(INSTANTIATE (K$5 K))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-SHARE-DECRYPT (SHARE-ENCRYPT M K1 K2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (M$1 (SHARE-ENCRYPT M K1 K2)) (K1$1 K1$0) (K2$1 K2$0))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (SHARE-ENCRYPT M K1 K2) S N))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$2 K1$0) (K2$2 K2$0))
(INSTANTIATE (K1$3 K1$0) (K2$3 K2$0))
(INSTANTIATE (K1$4 K1$0) (K2$4 K2$0))
(INSTANTIATE (K1$5 K1$0) (K2$5 K2$0))
(INSTANTIATE (K1$6 K1$0) (K2$6 K2$0))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-SHARE-DECRYPT-INVERSE (SHARE-ENCRYPT M K1 K2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$1 (SHARE-ENCRYPT M K1 K2)) (K1$1 K1$0) (K2$1 K2$0))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (SHARE-ENCRYPT M K1 K2) S N))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$2 K1$0) (K2$2 K2$0))
(INSTANTIATE (K1$3 K1$0) (K2$3 K2$0))
(INSTANTIATE (K1$4 K1$0) (K2$4 K2$0))
(INSTANTIATE (K1$5 K1$0) (K2$5 K2$0))
(INSTANTIATE (K1$6 K1$0) (K2$6 K2$0))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-DECOMBINE-LEFT (SHARE-ENCRYPT M K1 K2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (C1 (SHARE-ENCRYPT M K1 K2)) (C2 D2))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (SHARE-ENCRYPT M K1 K2) S N))
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(REWRITE)
(NEXT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (C1 D1) (C2 (SHARE-ENCRYPT M K1 K2)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (SHARE-ENCRYPT M K1 K2) S N))
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(NEXT)
(PRENEX)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX (COMBINE C1 C2) S N))
(REWRITE)
(INVOKE KNOWN-FROM-ENCRYPT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(INVOKE KNOWN-FROM-HASH)
(REWRITE)
(SPLIT (KNOWN-FROM-RECURSION (COMBINE C1 C2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-RECURSION)
(INSTANTIATE (C1$0 C1) (C2$0 C2))
(REARRANGE)
(REWRITE)
(NEXT)
(NEXT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-RECURSION)
(USE D1-LEMMA (S S) (N (- N 1)))
(INSTANTIATE (C (COMBINE C1 C2)))
(REWRITE)
(SPLIT (IN (COMBINE C1 C2) S))
(CASES)
(INVOKE (COMP-OF-AUX (COMBINE C1 C2) S (+ -1 N)))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-DECRYPT (COMBINE C1 C2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (COMBINE C1 C2)) (K$0 K))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (COMBINE C1 C2) S N))
(INVOKE COMP-FROM-DECRYPT)
(INSTANTIATE (K$1 K))
(INSTANTIATE (K$2 K))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-SHARE-DECRYPT (COMBINE C1 C2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (COMBINE C1 C2)) (K1$0 K1) (K2$0 K2))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (COMBINE C1 C2) S N))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$1 K1) (K2$1 K2))
(INSTANTIATE (K1$2 K1) (K2$2 K2))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-SHARE-DECRYPT-INVERSE (COMBINE C1 C2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)) (K1$0 K1) (K2$0 K2))
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (COMBINE C1 C2) S N))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$1 K1) (K2$1 K2))
(INSTANTIATE (K1$2 K1) (K2$2 K2))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-DECOMBINE-LEFT (COMBINE C1 C2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (C1$0 (COMBINE C1 C2)) (C2$0 D2))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (COMBINE C1 C2) S N))
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(REWRITE)
(NEXT)
(SPLIT (KNOWN-FROM-DECOMBINE-RIGHT (COMBINE C1 C2) S N))
(CASES)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (C1$0 D1) (C2$0 (COMBINE C1 C2)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (COMBINE C1 C2) S N))
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(NEXT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-COMBINE)
(PRENEX)
(REWRITE)
(NEXT)

(axiom d2 (b s)
  (implies (and (in b (atomic-messages)) (not (comp-of b s)))
           (not (known-in b s))))
(SPLIT (KNOWN-IN B S))
(SIMPLIFY)
(APPLY COMP-OF-DEFINITION)
(APPLY KNOWN-IN-DEFINITION)
(INSTANTIATE (N$0 N))
(USE D2-LEMMA (S S) (N N))
(SIMPLIFY)

(rule d2-rule (b s)
  (implies (in b (atomic-messages))
           (= (known-in b s) (comp-of b s))))
(USE D2 (B B) (S S))
(REWRITE)

(rule d3 (c k s)
  (implies (and (in c (messages))
                (in k (keys))
                (not (comp-of k s)))
           (= (known-in (encrypt c k) s)
              (comp-of (encrypt c k) s))))
(SPLIT (KNOWN-IN (ENCRYPT C K) S))
(SIMPLIFY)
(APPLY COMP-OF-DEFINITION)
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(INSTANTIATE (N$0 N))
(INSTANTIATE (N$1 N))
(USE D2-LEMMA (S S) (N N))
(SIMPLIFY)
(INSTANTIATE (M C) (K$0 K))
(REARRANGE)
(REWRITE)
(INSTANTIATE (B K))
(REWRITE)

(rule d3b (c k1 k2 s)
  (implies (and (in c (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (not (or (and (comp-of k1 s) (comp-of k2 s))
                         (and (comp-of (inverse k1) s)
                              (comp-of (inverse k2) s)))))
           (= (known-in (share-encrypt c k1 k2) s)
              (comp-of (share-encrypt c k1 k2) s))))
(SPLIT (KNOWN-IN (SHARE-ENCRYPT C K1 K2) S))
(SIMPLIFY)
(APPLY COMP-OF-DEFINITION)
(APPLY KNOWN-IN-DEFINITION)
(INSTANTIATE (N$4 N))
(INSTANTIATE (N$5 N))
(INSTANTIATE (N$8 N))
(INSTANTIATE (N$9 N))
(USE D2-LEMMA (S S) (N N))
(SIMPLIFY)
(INSTANTIATE (M$0 C) (K1$0 K1) (K2$0 K2))
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(INSTANTIATE (B K1))
(INSTANTIATE (B K2))
(REWRITE)
(NEXT)
(INSTANTIATE (B (INVERSE K1)))
(INSTANTIATE (B (INVERSE K2)))
(REWRITE)
(NEXT)
(INSTANTIATE (B (INVERSE K1)))
(INSTANTIATE (B (INVERSE K2)))
(REWRITE)
(NEXT)

(rule d4 (c k s)
  (implies (and (in c (messages))
                (in k (keys))
                (not (known-in c s)))
           (= (known-in (encrypt c k) s)
              (comp-of (encrypt c k) s))))
(SPLIT (KNOWN-IN (ENCRYPT C K) S))
(SIMPLIFY)
(APPLY COMP-OF-DEFINITION)
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(INSTANTIATE (N$0 N))
(INSTANTIATE (N$1 N))
(USE D2-LEMMA (S S) (N N))
(SIMPLIFY)

(rule d5 (c1 c2 s)
  (implies (and (in c1 (messages))
                (in c2 (messages))
                (or (not (known-in c1 s))
                    (not (known-in c2 s))))
           (= (known-in (combine c1 c2) s)
              (comp-of (combine c1 c2) s))))
(SPLIT (KNOWN-IN (COMBINE C1 C2) S))
(SIMPLIFY)  ;; D1 has effect here
(REWRITE)   ;; A1A2 finishes the job

(rule d4b (c k1 k2 s)
  (implies (and (in c (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (not (known-in c s)))
           (= (known-in (share-encrypt c k1 k2) s)
              (comp-of (share-encrypt c k1 k2) s))))
(SPLIT (KNOWN-IN (SHARE-ENCRYPT C K1 K2) S))
(SIMPLIFY)
(APPLY COMP-OF-DEFINITION)
(APPLY KNOWN-IN-DEFINITION)
(PRENEX)
(INSTANTIATE (N$0 N))
(INSTANTIATE (N$1 N))
(USE D2-LEMMA (S S) (N N))
(SIMPLIFY)

(axiom d6-lemma (s n)
  (and (all (c) (implies (and (in c (messages))
                              (known-in-aux (hash c) s n))
                         (or (known-in-aux c s n)
                             (comp-of-aux (hash c) s n))))
       (true)))
(INDUCT (NAT!WEAK-INDUCTION N))
(CASES)
(INVOKE NAT!ZEROP)
(APPLY KNOWN-IN-AUX-DEFINITION)
(APPLY COMP-OF-AUX-DEFINITION)
(REWRITE)
(NEXT)
(INVOKE NAT!ZEROP)
(REWRITE)
(PRENEX)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX (HASH C) S N))
(REWRITE)
(INVOKE KNOWN-FROM-ENCRYPT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(INVOKE KNOWN-FROM-COMBINE)
(INVOKE KNOWN-FROM-HASH)
(REWRITE)
(INSTANTIATE (D1 C))
(SIMPLIFY)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX (HASH C) S N))
(REWRITE)
(INVOKE COMP-FROM-RECURSION)
(USE KNOWN-IN-AUX-MONOTONIC (N1 (- N 1)) (N2 N) (D C) (S S))
(SIMPLIFY)
(CASES)
(INVOKE KNOWN-FROM-DECRYPT)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(USE D2-LEMMA (S S) (N (- N 1)))
(INSTANTIATE (B (INVERSE K)))
(INSTANTIATE (M (HASH C)) (K$0 K))
(INSTANTIATE (K$1 K))
(REARRANGE)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(USE D2-LEMMA (S S) (N (- N 1)))
(INSTANTIATE (M$0 (HASH C)) (K1$0 K1) (K2$0 K2))
(INSTANTIATE (B K1))
(INSTANTIATE (B K2))
(INSTANTIATE (K1$1 K1) (K2$1 K2))
(REARRANGE)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(USE D2-LEMMA (S S) (N (- N 1)))
(INSTANTIATE (M$0 (HASH C)) (K1$0 K1) (K2$0 K2))
(INSTANTIATE (B (INVERSE K1)))
(INSTANTIATE (B (INVERSE K2)))
(INSTANTIATE (K1$1 K1) (K2$1 K2))
(REARRANGE)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(USE D2-LEMMA (S S) (N (- N 1)))
(INSTANTIATE (C1 (HASH C)) (C2 D2))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REARRANGE)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(USE D2-LEMMA (S S) (N (- N 1)))
(INSTANTIATE (C1 D1) (C2 (HASH C)))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REARRANGE)
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-RECURSION)
(INSTANTIATE (C$0 C))
(REWRITE)
(NEXT)

(rule d6 (c s)
  (implies (and (in c (messages))
                (not (known-in c s)))
           (= (known-in (hash c) s)
              (comp-of (hash c) s))))
(SPLIT (KNOWN-IN (HASH C) S))
(SIMPLIFY)
(INVOKE KNOWN-IN)
(INVOKE COMP-OF)
(PRENEX)
(INSTANTIATE (N$1 N))
(USE D6-LEMMA (S S) (N N))
(INSTANTIATE (C$0 C))
(SIMPLIFY)


(function is-closed-under-decombination (S) ()
  (all (m1 m2)
    (implies (and (in m1 (messages))
                  (in m2 (messages))
                  (in (combine m1 m2) S))
             (and (in m1 S)
                  (in m2 S)))))

(function is-closed-under-decoding (S) ()
  (all (m k)
    (implies (and (in m (messages))
                  (in k (keys))
                  (in (encrypt m k) S))
             (in m S))))

(function is-closed-under-share-decoding (S) ()
  (all (m k1 k2)
    (implies (and (in m (messages))
                  (in k1 (asymmetric-keys))
                  (in k2 (asymmetric-keys))
                  (in (share-encrypt m k1 k2) S))
             (in m S))))

(function is-closed-under-dehashing (S) ()
  (all (m)
    (implies (and (in m (messages))
                  (in (hash m) S))
             (in m S))))

(zf-function parts (S)
  (select (m (union S (messages)))
    (all (T) (implies (and (subset S T)
                           (is-closed-under-decombination T)
                           (is-closed-under-decoding T)
                           (is-closed-under-share-decoding T)
                           (is-closed-under-dehashing T))
                      (in m T)))))

(rule parts-contains-self (S T)
  (implies (subset S T)
           (= (subset S (parts T))
              (true))))
(INVOKE (SUBSET S (PARTS T)))
(REDUCE)
(PRENEX)
(INSTANTIATE (E$0 E))
(SIMPLIFY)

(rule parts-is-closed-under-decombination (S)
  (= (is-closed-under-decombination (parts S))
     (true)))
(INVOKE IS-CLOSED-UNDER-DECOMBINATION)
(CASES)
(REDUCE)
(PRENEX)
(INSTANTIATE (T$0 T))
(REWRITE)
(NEXT)
(REDUCE)
(INSTANTIATE (T T$0))
(REWRITE)
(NEXT)

(rule parts-is-closed-under-decoding (S)
  (= (is-closed-under-decoding (parts S))
     (true)))
(REDUCE)
(INSTANTIATE (T T$0))
(SIMPLIFY)

(rule parts-is-closed-under-share-decoding (S)
  (= (is-closed-under-share-decoding (parts S))
     (true)))
(REDUCE)
(INSTANTIATE (T T$0))
(SIMPLIFY)

(rule parts-is-closed-under-dehashing (S)
  (= (is-closed-under-dehashing (parts S))
     (true)))
(REDUCE)
(INSTANTIATE (T T$0))
(SIMPLIFY)

(rule parts-is-minimal (S T)
  (implies (and (subset S T)
                (is-closed-under-decombination T)
                (is-closed-under-decoding T)
                (is-closed-under-share-decoding T)
                (is-closed-under-dehashing T))
           (= (subset (parts S) T)
              (true))))
(INVOKE (SUBSET (PARTS S) T))
(PRENEX)
(WITH-DISABLED (SUBSET UNION.DEFINITION) (REDUCE))
(INSTANTIATE (T$0 T))
(SIMPLIFY)

(rule parts-subset-self-2 (x S)
  (implies (and (in x S)
                (in x (messages)))
           (= (in x (parts S))
              (true))))
(REDUCE)

(rule parts-null ()
  (= (parts (nullset)) (nullset)))
(APPLY =.EXTENSIONAL.SUBSET)
(APPLY PARTS-IS-MINIMAL)
(REDUCE)

(rule subset-setadd (x S T)
  (implies (subset S T)
           (= (subset S (setadd x T))
              (true))))
(REDUCE)

(rule setadd-atomic-is-closed-under-decombination (x S)
  (implies (and (in x (atomic-messages))
                (is-closed-under-decombination S))
           (= (is-closed-under-decombination (setadd x S))
              (true))))
(REDUCE)

(rule setadd-atomic-is-closed-under-decoding (x S)
  (implies (and (in x (atomic-messages))
                (is-closed-under-decoding S))
           (= (is-closed-under-decoding (setadd x S))
              (true))))
(REDUCE)

(rule setadd-atomic-is-closed-under-share-decoding (x S)
  (implies (and (in x (atomic-messages))
                (is-closed-under-share-decoding S))
           (= (is-closed-under-share-decoding (setadd x S))
              (true))))
(REDUCE)

(rule setadd-atomic-is-closed-under-dehashing (x S)
  (implies (and (in x (atomic-messages))
                (is-closed-under-dehashing S))
           (= (is-closed-under-dehashing (setadd x S))
              (true))))
(REDUCE)

(load setrules)

(rule parts-setadd-atomic (x S)
  (implies (in x (atomic-messages))
           (= (parts (setadd x S))
              (setadd x (parts S)))))
(APPLY =.EXTENSIONAL.SUBSET)
(REWRITE)

(rule setadd-combination-is-closed-1 (m1 m2 S)
  (implies (and (in m1 (messages))
                (in m2 (messages))
                (in m1 S)
                (in m2 S)
                (is-closed-under-decombination S))
           (= (is-closed-under-decombination (setadd (combine m1 m2) S))
              (true))))
(REDUCE)

(rule setadd-combination-is-closed-2 (m1 m2 S)
  (implies (and (in m1 (messages))
                (in m2 (messages))
                (in m1 S)
                (in m2 S)
                (is-closed-under-decoding S))
           (= (is-closed-under-decoding (setadd (combine m1 m2) S))
              (true))))
(REDUCE)

(rule setadd-combination-is-closed-3 (m1 m2 S)
  (implies (and (in m1 (messages))
                (in m2 (messages))
                (in m1 S)
                (in m2 S)
                (is-closed-under-share-decoding S))
           (= (is-closed-under-share-decoding (setadd (combine m1 m2) S))
              (true))))
(REDUCE)

(rule setadd-combination-is-closed-4 (m1 m2 S)
  (implies (and (in m1 (messages))
                (in m2 (messages))
                (in m1 S)
                (in m2 S)
                (is-closed-under-dehashing S))
           (= (is-closed-under-dehashing (setadd (combine m1 m2) S))
              (true))))
(REDUCE)

(rule parts-setadd-combination (m1 m2 S)
  (implies (and (in m1 (messages))
                (in m2 (messages)))
           (= (parts (setadd (combine m1 m2) S))
              (setadd (combine m1 m2)
                      (parts (setadd m1 (setadd m2 S)))))))
(APPLY =.EXTENSIONAL.SUBSET)
(REWRITE)
(APPLY PARTS-IS-MINIMAL)
(REWRITE)
(INVOKE IS-CLOSED-UNDER-DECOMBINATION)
(SIMPLIFY)


(rule setadd-encryption-is-closed-1 (m k S)
  (implies (and (in m (messages))
                (in k (keys))
                (in m S)
                (is-closed-under-decombination S))
           (= (is-closed-under-decombination (setadd (encrypt m k) S))
              (true))))
(REDUCE)

(rule setadd-encryption-is-closed-2 (m k S)
  (implies (and (in m (messages))
                (in k (keys))
                (in m S)
                (is-closed-under-decoding S))
           (= (is-closed-under-decoding (setadd (encrypt m k) S))
              (true))))
(REDUCE)

(rule setadd-encryption-is-closed-3 (m k S)
  (implies (and (in m (messages))
                (in k (keys))
                (in m S)
                (is-closed-under-share-decoding S))
           (= (is-closed-under-share-decoding (setadd (encrypt m k) S))
              (true))))
(REDUCE)

(rule setadd-encryption-is-closed-4 (m k S)
  (implies (and (in m (messages))
                (in k (keys))
                (in m S)
                (is-closed-under-dehashing S))
           (= (is-closed-under-dehashing (setadd (encrypt m k) S))
              (true))))
(REDUCE)

(rule parts-setadd-encryption (m k S)
  (implies (and (in m (messages))
                (in k (keys)))
           (= (parts (setadd (encrypt m k) S))
              (setadd (encrypt m k)
                      (parts (setadd m S))))))
(APPLY =.EXTENSIONAL.SUBSET)
(REWRITE)
(APPLY PARTS-IS-MINIMAL)
(REWRITE)
(INVOKE IS-CLOSED-UNDER-DECODING)
(SIMPLIFY)

(rule setadd-share-encryption-is-closed-1 (m k1 k2 S)
  (implies (and (in m (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (in m S)
                (is-closed-under-decombination S))
           (= (is-closed-under-decombination
                 (setadd (share-encrypt m k1 k2) S))
              (true))))
(REDUCE)

(rule setadd-share-encryption-is-closed-2 (m k1 k2 S)
  (implies (and (in m (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (in m S)
                (is-closed-under-decoding S))
           (= (is-closed-under-decoding
                (setadd (share-encrypt m k1 k2) S))
              (true))))
(REDUCE)

(rule setadd-share-encryption-is-closed-3 (m k1 k2 S)
  (implies (and (in m (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (in m S)
                (is-closed-under-share-decoding S))
           (= (is-closed-under-share-decoding
                (setadd (share-encrypt m k1 k2) S))
              (true))))
(REDUCE)

(rule setadd-share-encryption-is-closed-4 (m k1 k2 S)
  (implies (and (in m (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (in m S)
                (is-closed-under-dehashing S))
           (= (is-closed-under-dehashing
                (setadd (share-encrypt m k1 k2) S))
              (true))))
(REDUCE)

(rule parts-setadd-share-encryption (m k1 k2 S)
  (implies (and (in m (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys)))
           (= (parts (setadd (share-encrypt m k1 k2) S))
              (setadd (share-encrypt m k1 k2)
                      (parts (setadd m S))))))
(APPLY =.EXTENSIONAL.SUBSET)
(REWRITE)
(APPLY PARTS-IS-MINIMAL)
(REWRITE)
(INVOKE IS-CLOSED-UNDER-SHARE-DECODING)
(SIMPLIFY)


(rule setadd-hash-is-closed-1 (m S)
  (implies (and (in m (messages))
                (in m S)
                (is-closed-under-decombination S))
           (= (is-closed-under-decombination
                 (setadd (hash m) S))
              (true))))
(REDUCE)

(rule setadd-hash-is-closed-2 (m S)
  (implies (and (in m (messages))
                (in m S)
                (is-closed-under-decoding S))
           (= (is-closed-under-decoding (setadd (hash m) S))
              (true))))
(REDUCE)

(rule setadd-hash-is-closed-3 (m S)
  (implies (and (in m (messages))
                (in m S)
                (is-closed-under-share-decoding S))
           (= (is-closed-under-share-decoding (setadd (hash m) S))
              (true))))
(REDUCE)

(rule setadd-hash-is-closed-4 (m S)
  (implies (and (in m (messages))
                (in m S)
                (is-closed-under-dehashing S))
           (= (is-closed-under-dehashing (setadd (hash m) S))
              (true))))
(REDUCE)

(rule parts-setadd-hash (m S)
  (implies (in m (messages))
           (= (parts (setadd (hash m) S))
              (setadd (hash m)
                      (parts (setadd m S))))))
(APPLY =.EXTENSIONAL.SUBSET)
(REWRITE)
(APPLY PARTS-IS-MINIMAL)
(REWRITE)
(INVOKE IS-CLOSED-UNDER-DEHASHING)
(SIMPLIFY)


(axiom is-closed-under-decombination-consequence (m1 m2 s t)
  (implies (and (in m1 (messages))
                (in m2 (messages))
                (subset s t)
                (is-closed-under-decombination t)
                (in (combine m1 m2) s))
           (and (in m1 t) (in m2 t))))
(REDUCE)
(INSTANTIATE (M1$0 M1) (M2$0 M2))
(INSTANTIATE (E (COMBINE M1 M2)))
(SIMPLIFY)

(axiom is-closed-under-decoding-consequence (m k s t)
  (implies (and (in m (messages))
                (in k (keys))
                (subset s t)
                (is-closed-under-decoding t)
                (in (encrypt m k) s))
           (in m t)))
(REDUCE)
(INSTANTIATE (M$0 M) (K$0 K))
(INSTANTIATE (E (ENCRYPT M K)))
(SIMPLIFY)

(axiom is-closed-under-share-decoding-consequence (m k1 k2 s t)
  (implies (and (in m (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (subset s t)
                (is-closed-under-share-decoding t)
                (in (share-encrypt m k1 k2) s))
           (in m t)))
(REDUCE)
(INSTANTIATE (M$0 M) (K1$0 K1) (K2$0 K2))
(INSTANTIATE (E (SHARE-ENCRYPT M K1 K2)))
(SIMPLIFY)

(axiom is-closed-under-dehashing-consequence (m s t)
  (implies (and (in m (messages))
                (subset s t)
                (is-closed-under-dehashing t)
                (in (hash m) s))
           (in m t)))
(REDUCE)
(INSTANTIATE (M$0 M))
(INSTANTIATE (E (HASH M)))
(SIMPLIFY)

(axiom not-part-implies-not-comp-of-lemma (S n)
  (implies (>= n 0)
           (all (m) (implies (not (in m (parts S)))
                             (not (comp-of-aux m S n))))))
(INDUCT (NAT!WEAK-INDUCTION N))
(CASES)
(REDUCE)
(NEXT)
(INVOKE NAT!ZEROP)
(PRENEX)
(REWRITE)
(CASES)
(INSTANTIATE (M$0 M))
(REWRITE)
(INVOKE (COMP-OF-AUX M S (+ -1 N)))
(REWRITE)
(NEXT)
(INVOKE (COMP-OF-AUX M S N))
(REWRITE)
(CASES)
(PRENEX)
(INSTANTIATE (M$0 (ENCRYPT M K)))
(REWRITE)
(CASES)
(USE IS-CLOSED-UNDER-DECODING-CONSEQUENCE (M M) (K K) (S S) (T T))
(SIMPLIFY)
(NEXT)
(CASES)
(INSTANTIATE (T$3 T))
(USE IS-CLOSED-UNDER-DECODING-CONSEQUENCE (M M) (K K) (S T) (T T))
(REWRITE)
(NEXT)
(SPLIT (AND (IN M (MESSAGES)) (IN K (KEYS))))
(REWRITE)
(NEXT)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(REWRITE)
(CASES)
(USE IS-CLOSED-UNDER-SHARE-DECODING-CONSEQUENCE
     (M M) (K1 K1) (K2 K2) (S S) (T T))
(SIMPLIFY)
(NEXT)
(CASES)
(INSTANTIATE (T$3 T))
(USE IS-CLOSED-UNDER-SHARE-DECODING-CONSEQUENCE
     (M M) (K1 K1) (K2 K2) (S T) (T T))
(REWRITE)
(NEXT)
(SPLIT (AND (IN M (MESSAGES))
            (IN K1 (ASYMMETRIC-KEYS))
            (IN K2 (ASYMMETRIC-KEYS))))
(REWRITE)
(NEXT)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(REWRITE)
(CASES)
(USE IS-CLOSED-UNDER-SHARE-DECODING-CONSEQUENCE
     (M M) (K1 K1) (K2 K2) (S S) (T T))
(SIMPLIFY)
(NEXT)
(CASES)
(INSTANTIATE (T$3 T))
(USE IS-CLOSED-UNDER-SHARE-DECODING-CONSEQUENCE
     (M M) (K1 K1) (K2 K2) (S T) (T T))
(REWRITE)
(NEXT)
(SPLIT (AND (IN M (MESSAGES))
            (IN K1 (ASYMMETRIC-KEYS))
            (IN K2 (ASYMMETRIC-KEYS))))
(REWRITE)
(NEXT)
(PRENEX)
(INSTANTIATE (M$0 (COMBINE M D2)))
(REWRITE)
(CASES)
(USE IS-CLOSED-UNDER-DECOMBINATION-CONSEQUENCE (M1 M) (M2 D2) (S S) (T T))
(SIMPLIFY)
(NEXT)
(CASES)
(INSTANTIATE (T$3 T))
(USE IS-CLOSED-UNDER-DECOMBINATION-CONSEQUENCE (M1 M) (M2 D2) (S T) (T T))
(REWRITE)
(NEXT)
(SPLIT (AND (IN M (MESSAGES)) (IN D2 (MESSAGES))))
(REWRITE)
(NEXT)
(PRENEX)
(INSTANTIATE (M$0 (COMBINE D1 M)))
(REWRITE)
(CASES)
(USE IS-CLOSED-UNDER-DECOMBINATION-CONSEQUENCE (M1 D1) (M2 M) (S S) (T T))
(SIMPLIFY)
(NEXT)
(CASES)
(INSTANTIATE (T$3 T))
(USE IS-CLOSED-UNDER-DECOMBINATION-CONSEQUENCE (M1 D1) (M2 M) (S T) (T T))
(REWRITE)
(NEXT)
(SPLIT (AND (IN M (MESSAGES)) (IN D1 (MESSAGES))))
(REWRITE)
(NEXT)
(INSTANTIATE (M$0 M))
(REWRITE)
(NEXT)

(rule not-part-implies-not-comp-of (m S)
  (implies (not (in m (parts S)))
           (= (comp-of m S)
              (false))))
(INVOKE COMP-OF)
(WITH-DISABLED (PARTS)
 (REWRITE))
(PRENEX)
(USE NOT-PART-IMPLIES-NOT-COMP-OF-LEMMA (S S) (N N))
(REARRANGE)
(SIMPLIFY)
(INVOKE (COMP-OF-AUX M S N))
(SIMPLIFY)
(SPLIT (IN M (MESSAGES)))
(SPLIT (IN M S))
(REWRITE)

(axiom set-of-atomic-closed-under-decombination (s)
  (implies (subset s (atomic-messages))
           (is-closed-under-decombination s)))
(REDUCE)
(PRENEX)
(INSTANTIATE (E (COMBINE M1 M2)))
(REWRITE)

(axiom set-of-atomic-closed-under-decoding (s)
  (implies (subset s (atomic-messages))
           (is-closed-under-decoding s)))
(REDUCE)
(PRENEX)
(INSTANTIATE (E (ENCRYPT M K)))
(REWRITE)

(axiom set-of-atomic-closed-under-share-decoding (s)
  (implies (subset s (atomic-messages))
           (is-closed-under-share-decoding s)))
(REDUCE)
(PRENEX)
(INSTANTIATE (E (SHARE-ENCRYPT M K1 K2)))
(REWRITE)

(axiom set-of-atomic-closed-under-dehashing (s)
  (implies (subset s (atomic-messages))
           (is-closed-under-dehashing s)))
(REDUCE)
(PRENEX)
(INSTANTIATE (E (HASH M)))
(REWRITE)

(rule parts-atomic (s)
  (implies (subset s (atomic-messages))
           (= (parts s) s)))
(APPLY =.EXTENSIONAL.SUBSET)
(REWRITE)
(INVOKE (SUBSET (PARTS S) S))
(PRENEX)
(REWRITE)
(USE SET-OF-ATOMIC-CLOSED-UNDER-DECOMBINATION (S S))
(USE SET-OF-ATOMIC-CLOSED-UNDER-DECODING (S S))
(USE SET-OF-ATOMIC-CLOSED-UNDER-SHARE-DECODING (S S))
(USE SET-OF-ATOMIC-CLOSED-UNDER-DEHASHING (S S))
(INSTANTIATE (T S))
(REWRITE)

(axiom union-closed-under-decombination (s1 s2)
  (implies (and (is-closed-under-decombination s1)
                (is-closed-under-decombination s2))
           (is-closed-under-decombination (union s1 s2))))
(REDUCE)

(axiom union-closed-under-decoding (s1 s2)
  (implies (and (is-closed-under-decoding s1)
                (is-closed-under-decoding s2))
           (is-closed-under-decoding (union s1 s2))))
(REDUCE)

(axiom union-closed-under-share-decoding (s1 s2)
  (implies (and (is-closed-under-share-decoding s1)
                (is-closed-under-share-decoding s2))
           (is-closed-under-share-decoding (union s1 s2))))
(REDUCE)

(axiom union-closed-under-dehashing (s1 s2)
  (implies (and (is-closed-under-dehashing s1)
                (is-closed-under-dehashing s2))
           (is-closed-under-dehashing (union s1 s2))))
(REDUCE)

(rule parts-union (s1 s2)
  (= (parts (union s1 s2)) (union (parts s1) (parts s2))))
(APPLY =.EXTENSIONAL.SUBSET)
(REWRITE)
(INVOKE SUBSET)
(REWRITE)
(CASES)
(CASES)
(PRENEX)
(REWRITE)
(INVOKE (SUBSET S1 T))
(SIMPLIFY)
(NEXT)
(REWRITE)
(PRENEX)
(INVOKE (SUBSET S1 T))
(REWRITE)
(NEXT)
(CASES)
(PRENEX)
(INVOKE (SUBSET S2 T))
(REWRITE)
(NEXT)
(PRENEX)
(REWRITE)
(INSTANTIATE (T$1 (UNION T T$0)))
(REARRANGE)
(REWRITE)
(USE UNION-CLOSED-UNDER-DECOMBINATION (S1 T) (S2 T$0))
(USE UNION-CLOSED-UNDER-DECODING (S1 T) (S2 T$0))
(USE UNION-CLOSED-UNDER-SHARE-DECODING (S1 T) (S2 T$0))
(USE UNION-CLOSED-UNDER-DEHASHING (S1 T) (S2 T$0))
(SIMPLIFY)
(NEXT)

(axiom there-is-minimum-size (m)
  (implies (in m (messages))
           (some (n) (and (>= n 0)
                          (in m (messages-aux n))
                          (all (k) (implies (and (>= k 0)
                                                 (in m (messages-aux k)))
                                            (>= k n)))))))
(INVOKE MESSAGES)
(REWRITE)
(PRENEX)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(REWRITE)
(PRENEX)
(SPLIT (= Y (MESSAGES-AUX N)))
(EQUALITY-SUBSTITUTE)
(DELETE-HYPOTHESES (= Y (MESSAGES-AUX N)))
(CASES)
(INDUCT (NAT!STRONG-INDUCTION N))
(INVOKE NAT!ZEROP)
(REWRITE)
(CASES)
(INSTANTIATE (K (- N 1)))
(REWRITE)
(INSTANTIATE (N$1 N))
(REWRITE)
(PRENEX)
(REWRITE)
(INSTANTIATE (K$0 K))
(REWRITE)
(NEXT)
(INSTANTIATE (N$2 N))
(REWRITE)
(NEXT)

(zf-function size (m)
  (that n (if (in m (messages))
              (and (>= n 0)
                   (in m (messages-aux n))
                   (all (k) (implies (and (>= k 0)
                                          (in m (messages-aux k)))
                                     (>= k n))))
              (= n 0))))
(REWRITE)
(CASES)
(USE THERE-IS-MINIMUM-SIZE (M M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 N))
(REWRITE)
(SPLIT (= N-0 N))
(REWRITE)
(EQUALITY-SUBSTITUTE N-0)
(SIMPLIFY)
(PRENEX)
(REWRITE)
(INSTANTIATE (K$0 N))
(REWRITE)
(INSTANTIATE (K N-0))
(REWRITE)
(NEXT)
(INSTANTIATE (N$0 0))
(SIMPLIFY)
(NEXT)

(axiom combine-messages-are-constructed (x)
  (implies (in x (combine-messages))
           (some (m1 m2) (and (in m1 (messages))
                              (in m2 (messages))
                              (= x (combine m1 m2))))))
(INVOKE COMBINE-MESSAGES)
(APPLY COMBINES.DEFINITION)
(SIMPLIFY)

(axiom encrypt-messages-are-constructed (x)
  (implies (in x (encrypt-messages))
           (some (m k) (and (in m (messages))
                            (in k (keys))
                            (= x (encrypt m k))))))
(INVOKE ENCRYPT-MESSAGES)
(APPLY ENCRYPTS.DEFINITION)
(SIMPLIFY)

(axiom share-encrypt-messages-are-constructed (x)
  (implies (in x (share-encrypt-messages))
           (some (m k1 k2) (and (in m (messages))
                                (in k1 (asymmetric-keys))
                                (in k2 (asymmetric-keys))
                                (= x (share-encrypt m k1 k2))))))
(INVOKE SHARE-ENCRYPT-MESSAGES)
(APPLY SHARE-ENCRYPTS.DEFINITION)
(SIMPLIFY)

(axiom hash-messages-are-constructed (x)
  (implies (in x (hash-messages))
           (some (m) (and (in m (messages))
                          (= x (hash m))))))
(INVOKE HASH-MESSAGES)
(APPLY HASHES.DEFINITION)
(SIMPLIFY)

(frule size-cb1 (m)
  (implies (in m (combine-messages))
           (<= (size (cb1 m)) (- (size m) 1))))
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(USE SIZE.DEFINITION (M M))
(USE SIZE.DEFINITION (M (CB1 M)))
(REARRANGE)
(REWRITE)
(INVOKE (MESSAGES-AUX (SIZE M)))
(REWRITE)
(INSTANTIATE (K$0 (- (SIZE M) 1)))
(REWRITE)
(APPLY COMBINES.DEFINITION)
(PRENEX)
(INSTANTIATE (K (+ -1 (SIZE M))))
(REWRITE)

(frule size-cb2 (m)
  (implies (in m (combine-messages))
           (<= (size (cb2 m)) (- (size m) 1))))
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(USE SIZE.DEFINITION (M M))
(USE SIZE.DEFINITION (M (CB2 M)))
(REARRANGE)
(REWRITE)
(INVOKE (MESSAGES-AUX (SIZE M)))
(REWRITE)
(INSTANTIATE (K$0 (- (SIZE M) 1)))
(REWRITE)
(APPLY COMBINES.DEFINITION)
(PRENEX)
(INSTANTIATE (K (+ -1 (SIZE M))))
(REWRITE)

(frule size-endt (m)
  (implies (in m (encrypt-messages))
           (<= (size (endt m)) (- (size m) 1))))
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(USE SIZE.DEFINITION (M M))
(USE SIZE.DEFINITION (M (ENDT M)))
(REARRANGE)
(REWRITE)
(INVOKE (MESSAGES-AUX (SIZE M)))
(REWRITE)
(INSTANTIATE (K$1 (- (SIZE M) 1)))
(REWRITE)
(APPLY ENCRYPTS.DEFINITION)
(PRENEX)
(INSTANTIATE (K$1 (+ -1 (SIZE M))))
(WITH-ENABLED (ENCRYPT-INJECTIVE) (REWRITE))

(frule size-atomic (m)
  (implies (in m (atomic-messages))
           (= (size m) 0)))
(USE SIZE.DEFINITION (M M))
(REARRANGE)
(REWRITE)
(INSTANTIATE (K 0))
(INVOKE (MESSAGES-AUX 0))
(REWRITE)

(frule size-enky (m)
  (implies (in m (encrypt-messages))
           (<= (size (enky m)) (- (size m) 1))))
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(USE SIZE.DEFINITION (M M))
(REARRANGE)
(REWRITE)
(INVOKE (MESSAGES-AUX (SIZE M)))
(REWRITE)

(frule size-shendt (m)
  (implies (in m (share-encrypt-messages))
           (<= (size (shendt m)) (- (size m) 1))))
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(USE SIZE.DEFINITION (M M))
(USE SIZE.DEFINITION (M (SHENDT M)))
(REARRANGE)
(REWRITE)
(INVOKE (MESSAGES-AUX (SIZE M)))
(REWRITE)
(INSTANTIATE (K$0 (- (SIZE M) 1)))
(REWRITE)
(APPLY SHARE-ENCRYPTS.DEFINITION)
(PRENEX)
(INSTANTIATE (K (+ -1 (SIZE M))))
(WITH-ENABLED (SHARE-ENCRYPT-INJECTIVE) (REWRITE))

(frule size-shenky1 (m)
  (implies (in m (share-encrypt-messages))
           (<= (size (shenky1 m)) (- (size m) 1))))
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(USE SIZE.DEFINITION (M M))
(REARRANGE)
(REWRITE)
(INVOKE (MESSAGES-AUX (SIZE M)))
(REWRITE)

(frule size-shenky2 (m)
  (implies (in m (share-encrypt-messages))
           (<= (size (shenky2 m)) (- (size m) 1))))
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(USE SIZE.DEFINITION (M M))
(REARRANGE)
(REWRITE)

(frule size-hsdt (m)
  (implies (in m (hash-messages))
           (<= (size (hsdt m)) (- (size m) 1))))
(USE HASH-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(USE SIZE.DEFINITION (M M))
(USE SIZE.DEFINITION (M (HSDT M)))
(REARRANGE)
(REWRITE)
(INVOKE (MESSAGES-AUX (SIZE M)))
(REWRITE)
(INSTANTIATE (K$0 (- (SIZE M) 1)))
(REWRITE)
(APPLY HASHES.DEFINITION)
(PRENEX)
(INSTANTIATE (K (+ -1 (SIZE M))))
(REWRITE)

(grule size-nat (m)
  (>= (size m) 0))
(USE SIZE.DEFINITION (M M))
(REWRITE)

(function message-induction (m) ((measure (size m)))
  (if (or (not (in m (messages))) (in m (atomic-messages)))
      (true)
      (all (n) (if (< (size n) (size m)) (message-induction n) (true)))))
(REDUCE)

(frule size-non-message (m)
  (implies (not (in m (messages))) (= (size m) 0)))
(USE SIZE.DEFINITION (M M))
(SIMPLIFY)

(axiom in-encrypt-lemma (m k n)
  (implies (in (encrypt m k) (messages-aux n))
           (some (n1) (and (>= n1 0)
                           (in m (messages-aux n1))
                           (in k (keys))))))
(INDUCT)
(CASES)
(REWRITE)
(INVOKE (MESSAGES-AUX N))
(REWRITE)
(APPLY ENCRYPTS.DEFINITION)
(PRENEX)
(REWRITE)
(NEXT)
(REDUCE)
(NEXT)

(frule in-encrypt (n k)
  (implies (in (encrypt n k) (messages))
           (and (in n (messages)) (in k (keys)))))
(INVOKE MESSAGES)
(REWRITE)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(PRENEX)
(REWRITE)
(USE IN-ENCRYPT-LEMMA (M N) (N N$0) (K K))
(SIMPLIFY)
(PRENEX)
(SIMPLIFY)

(axiom in-share-encrypt-lemma (m k1 k2 n)
  (implies (in (share-encrypt m k1 k2) (messages-aux n))
           (some (n1) (and (>= n1 0)
                           (in m (messages-aux n1))
                           (in k1 (asymmetric-keys))
                           (in k2 (asymmetric-keys))))))
(INDUCT)
(CASES)
(REWRITE)
(INVOKE (MESSAGES-AUX N))
(REWRITE)
(APPLY SHARE-ENCRYPTS.DEFINITION)
(PRENEX)
(REWRITE)
(NEXT)
(REDUCE)
(NEXT)

(frule in-share-encrypt (n k1 k2)
  (implies (in (share-encrypt n k1 k2) (messages))
           (and (in n (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys)))))
(INVOKE MESSAGES)
(REWRITE)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(PRENEX)
(REWRITE)
(USE IN-SHARE-ENCRYPT-LEMMA (M N) (N N$0) (K1 K1) (K2 K2))
(SIMPLIFY)
(PRENEX)
(SIMPLIFY)

(axiom in-combine-lemma (m1 m2 n)
  (implies (in (combine m1 m2) (messages-aux n))
           (some (n1) (and (>= n1 0)
                           (in m1 (messages-aux n1))
                           (in m2 (messages-aux n1))))))
(INDUCT)
(CASES)
(REWRITE)
(INVOKE (MESSAGES-AUX N))
(REWRITE)
(APPLY COMBINES.DEFINITION)
(PRENEX)
(REWRITE)
(NEXT)
(REDUCE)
(NEXT)

(frule in-combine (m1 m2)
  (implies (in (combine m1 m2) (messages))
           (and (in m1 (messages)) (in m2 (messages)))))
(INVOKE MESSAGES)
(REWRITE)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(PRENEX)
(REWRITE)
(USE IN-COMBINE-LEMMA (M1 M1) (M2 M2) (N N))
(SIMPLIFY)
(PRENEX)
(SIMPLIFY)

(axiom in-hash-lemma (m n)
  (implies (in (hash m) (messages-aux n))
           (some (n1) (and (>= n1 0) (in m (messages-aux n1))))))
(INDUCT)
(CASES)
(REWRITE)
(INVOKE (MESSAGES-AUX N))
(REWRITE)
(APPLY HASHES.DEFINITION)
(PRENEX)
(REWRITE)
(NEXT)
(REDUCE)
(NEXT)

(frule in-hash (m)
  (implies (in (hash m) (messages))
           (in m (messages))))
(INVOKE MESSAGES)
(REWRITE)
(APPLY MESSAGES-AUX-AUX.DEFINITION)
(PRENEX)
(REWRITE)
(USE IN-HASH-LEMMA (M M) (N N))
(SIMPLIFY)
(PRENEX)
(SIMPLIFY)

(axiom known-in-aux-setadd-junk (j n s)
  (implies (not (in j (messages)))
           (all (m) (= (known-in-aux m (setadd j s) n)
                       (known-in-aux m s n)))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(CASES)
(INVOKE KNOWN-IN-AUX)
(REWRITE)
(NEXT)
(PRENEX)
(SPLIT (KNOWN-IN-AUX M S N))
(CASES)
(SIMPLIFY)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX M S N))
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(INVOKE (KNOWN-IN-AUX M (SETADD J S) N))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-ENCRYPT)
(REWRITE)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(INVOKE KNOWN-FROM-DECRYPT)
(REWRITE)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(REWRITE)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INVOKE KNOWN-FROM-COMBINE)
(REWRITE)
(SPLIT (IN D2 (MESSAGES)))
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(REWRITE)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(REWRITE)
(INVOKE KNOWN-FROM-HASH)
(REWRITE)
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)
(INVOKE KNOWN-FROM-RECURSION)
(REWRITE)
(NEXT)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX M (SETADD J S) N))
(REWRITE)
(CASES)
(INVOKE KNOWN-FROM-ENCRYPT)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (M$0 K))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (M$0 K1))
(INSTANTIATE (M$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (M$0 (INVERSE K1)))
(INSTANTIATE (M$0 (INVERSE K2)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (ENCRYPT M K)))
(INSTANTIATE (M$0 (INVERSE K)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 K1))
(INSTANTIATE (M$0 K2))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 (INVERSE K1)))
(INSTANTIATE (M$0 (INVERSE K2)))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-COMBINE)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (M$0 D2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (M$0 D2))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-HASH)
(PRENEX)
(INSTANTIATE (M$0 D1))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-RECURSION)
(INSTANTIATE (M$0 M))
(REWRITE)
(NEXT)
(SIMPLIFY)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX M S N))
(REARRANGE)
(REWRITE)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX M (SETADD J S) N))
(REWRITE)
(CASES)
(INVOKE KNOWN-FROM-ENCRYPT)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (M$0 K))
(INSTANTIATE (D1$0 D1) (K$0 K))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (M$0 K1))
(INSTANTIATE (M$0 K2))
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (M$0 (INVERSE K1)))
(INSTANTIATE (M$0 (INVERSE K2)))
(INSTANTIATE (D1$0 D1) (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (ENCRYPT M K)))
(INSTANTIATE (M$0 (INVERSE K)))
(INSTANTIATE (K$0 K))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 K1))
(INSTANTIATE (M$0 K2))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 (INVERSE K1)))
(INSTANTIATE (M$0 (INVERSE K2)))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-COMBINE)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (M$0 D2))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (M$0 D2))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-HASH)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (D1$0 D1))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-RECURSION)
(INSTANTIATE (M$0 M))
(REWRITE)
(NEXT)

(disabled
  (rule known-in-setadd-junk (m j s)
    (implies (not (in j (messages)))
             (= (known-in m (setadd j s))
                (known-in m s)))))
(SPLIT (KNOWN-IN M S))
(SIMPLIFY)
(CASES)
(INVOKE KNOWN-IN)
(PRENEX)
(USE KNOWN-IN-AUX-SETADD-JUNK (J J) (N N) (S S))
(SIMPLIFY)
(INSTANTIATE (M$0 M))
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(INVOKE KNOWN-IN)
(PRENEX)
(USE KNOWN-IN-AUX-SETADD-JUNK (J J) (N N) (S S))
(SIMPLIFY)
(INSTANTIATE (M$0 M))
(INSTANTIATE (N$0 N))
(SIMPLIFY)
(NEXT)

(axiom comp-of-aux-setadd-junk (j n s)
  (implies (not (in j (messages)))
           (all (m) (= (comp-of-aux m (setadd j s) n)
                       (comp-of-aux m s n)))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(CASES)
(INVOKE COMP-OF-AUX)
(REWRITE)
(NEXT)
(PRENEX)
(SPLIT (COMP-OF-AUX M S N))
(CASES)
(SIMPLIFY)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(INVOKE (COMP-OF-AUX M (SETADD J S) N))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECRYPT)
(REWRITE)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(REWRITE)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(INVOKE COMP-FROM-RECURSION)
(REWRITE)
(NEXT)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M (SETADD J S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (ENCRYPT M K)))
(INSTANTIATE (M$0 (INVERSE K)))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 K1))
(INSTANTIATE (M$0 K2))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 (INVERSE K1)))
(INSTANTIATE (M$0 (INVERSE K2)))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (M$0 D2))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (M$0 M))
(REWRITE)
(NEXT)
(SIMPLIFY)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(REARRANGE)
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M (SETADD J S) N))
(REWRITE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (ENCRYPT M K)))
(INSTANTIATE (M$0 (INVERSE K)))
(INSTANTIATE (K$0 K))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 K1))
(INSTANTIATE (M$0 K2))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 (INVERSE K1)))
(INSTANTIATE (M$0 (INVERSE K2)))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (M$0 D1))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (M$0 D2))
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (M$0 M))
(REWRITE)
(NEXT)

(disabled
  (rule comp-of-setadd-junk (m j s)
    (implies (not (in j (messages)))
             (= (comp-of m (setadd j s))
                (comp-of m s)))))
(SPLIT (COMP-OF M S))
(SIMPLIFY)
(CASES)
(INVOKE COMP-OF)
(PRENEX)
(USE COMP-OF-AUX-SETADD-JUNK (J J) (N N) (S S))
(SIMPLIFY)
(INSTANTIATE (M$0 M))
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(INVOKE COMP-OF)
(PRENEX)
(USE COMP-OF-AUX-SETADD-JUNK (J J) (N N) (S S))
(SIMPLIFY)
(INSTANTIATE (M$0 M))
(INSTANTIATE (N$0 N))
(SIMPLIFY)
(NEXT)

(rule known-add-encrypt-is-comp-of (m n k s)
  (implies (and (in k (keys))
                (not (known-in (inverse k) s))
                (not (known-in m s))
                (<= (size m) (size (encrypt n k))))
           (= (known-in m (setadd (encrypt n k) s))
              (comp-of m (setadd (encrypt n k) s)))))
(SPLIT (IN N (MESSAGES)))
(CASES)
(INDUCT (MESSAGE-INDUCTION M))
(CASES)
(REARRANGE)
(REWRITE)
(NEXT)
(REARRANGE)
(REWRITE)
(SPLIT (IN M (COMBINE-MESSAGES)))
(CASES)
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 M1))
(INSTANTIATE (N$0 M2))
(EQUALITY-SUBSTITUTE M)
(APPLY D5)
(REWRITE)
(NEXT)
(SPLIT (IN M (ENCRYPT-MESSAGES)))
(CASES)
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 M$0))
(EQUALITY-SUBSTITUTE M)
(APPLY D3)
(REWRITE)
(USE A3 (C M$0) (K K) (S S))
(REWRITE)
(NEXT)
(SPLIT (IN M (SHARE-ENCRYPT-MESSAGES)))
(CASES)
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 M$0))
(EQUALITY-SUBSTITUTE M)
(APPLY D3B)
(REWRITE)
(USE A3B (C M$0) (K1 K1) (K2 K2) (S S))
(REWRITE)
(NEXT)
(SPLIT (IN M (HASH-MESSAGES)))
(CASES)
(USE HASH-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(INSTANTIATE (N$0 M$0))
(EQUALITY-SUBSTITUTE M)
(APPLY A12)
(REWRITE)
(NEXT)
(USE IN-MESSAGES-LEMMA (D M))
(SIMPLIFY)
(NEXT)
(SPLIT (IN (ENCRYPT N K) (MESSAGES)))
(REWRITE)
(APPLY KNOWN-IN-SETADD-JUNK)
(APPLY COMP-OF-SETADD-JUNK)
(REWRITE)
(NEXT)

(axiom known-in-subset-lemma (s1 s2 n)
  (implies
   (subset s1 s2)
   (all (c) (implies (known-in-aux c s1 n)
                     (known-in-aux c s2 n)))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(CASES)
(REDUCE)
(NEXT)
(PRENEX)
(REARRANGE)
(REWRITE)
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S1 N))
(REWRITE)
(CASES)
(CASES)
(INVOKE SUBSET)
(INVOKE (KNOWN-IN-AUX C S2 N))
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-ENCRYPT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECRYPT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(SIMPLIFY)
(CASES)
(INVOKE KNOWN-FROM-COMBINE)
(PRENEX)
(SPLIT (AND (= C (COMBINE D1 D2))
            (IN D1 (MESSAGES))
            (IN D2 (MESSAGES))))
(EQUALITY-SUBSTITUTE)
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(SIMPLIFY)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(SIMPLIFY)
(CASES)
(INVOKE KNOWN-FROM-HASH)
(PRENEX)
(SPLIT (AND (= C (HASH D1)) (IN D1 (MESSAGES))))
(EQUALITY-SUBSTITUTE)
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-RECURSION)
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-ENCRYPT)
(PRENEX)
(INSTANTIATE (C$0 D1))
(INSTANTIATE (C$0 K))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-ENCRYPT)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(PRENEX)
(INSTANTIATE (C$0 D1))
(INSTANTIATE (C$0 K1))
(INSTANTIATE (C$0 K2))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (C$0 D1))
(INSTANTIATE (C$0 (INVERSE K1)))
(INSTANTIATE (C$0 (INVERSE K2)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-SHARE-ENCRYPT-INVERSE)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (ENCRYPT C K)))
(INSTANTIATE (C$0 (INVERSE K)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-DECRYPT)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C$0 K1))
(INSTANTIATE (C$0 K2))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C$0 (INVERSE K1)))
(INSTANTIATE (C$0 (INVERSE K2)))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-COMBINE)
(PRENEX)
(INSTANTIATE (C$0 D1))
(INSTANTIATE (C$0 D2))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-COMBINE)
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (C$0 D1))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (C$0 D2))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE KNOWN-FROM-HASH)
(PRENEX)
(INSTANTIATE (C$0 D1))
(APPLY KNOWN-IN-AUX-DEFINITION (KNOWN-IN-AUX C S2 N))
(INVOKE KNOWN-FROM-HASH)
(REWRITE)
(NEXT)
(INVOKE KNOWN-FROM-RECURSION)
(INSTANTIATE (C$0 C))
(REWRITE)
(NEXT)

(axiom known-in-subset (c s1 s2)
  (implies (and (known-in c s1)
                (subset s1 s2))
           (known-in c s2)))
(INVOKE KNOWN-IN)
(PRENEX)
(USE KNOWN-IN-SUBSET-LEMMA (S1 S1) (S2 S2) (N N))
(INSTANTIATE (C$0 C))
(SIMPLIFY)

(function shared-keys-known (k1 k2 s) ()
  (or (and (known-in k1 s) (known-in k2 s))
      (and (known-in (inverse k1) s) (known-in (inverse k2) s))))

(disabled
  (rule d3b-aux (c k1 k2 s)
    (implies (and (in c (messages))
                  (in k1 (asymmetric-keys))
                  (in k2 (asymmetric-keys))
                  (not (shared-keys-known k1 k2 s)))
             (= (known-in (share-encrypt c k1 k2) s)
                (comp-of (share-encrypt c k1 k2) s)))))
(INVOKE SHARED-KEYS-KNOWN)
(REWRITE)

(axiom known-add-share-encrypt-is-comp-of-lemma (m n k1 k2 s)
  (implies (and (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (not (shared-keys-known k1 k2 s))
                (not (known-in m s))
                (<= (size m) (size (share-encrypt n k1 k2))))
           (= (known-in m (setadd (share-encrypt n k1 k2) s))
              (comp-of m (setadd (share-encrypt n k1 k2) s)))))
(SPLIT (IN N (MESSAGES)))
(CASES)
(INDUCT (MESSAGE-INDUCTION M))
(CASES)
(REARRANGE)
(REWRITE)
(NEXT)
(REARRANGE)
(REWRITE)
(SPLIT (IN M (COMBINE-MESSAGES)))
(CASES)
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 M1))
(INSTANTIATE (N$0 M2))
(EQUALITY-SUBSTITUTE M)
(APPLY D5)
(REWRITE)
(INVOKE SHARED-KEYS-KNOWN)
(REWRITE)
(NEXT)
(SPLIT (IN M (ENCRYPT-MESSAGES)))
(CASES)
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 M$0))
(EQUALITY-SUBSTITUTE M)
(APPLY D3)
(REWRITE)
(INVOKE SHARED-KEYS-KNOWN)
(REWRITE)
(USE A3 (C M$0) (K K) (S S))
(REWRITE)
(NEXT)
(SPLIT (IN M (SHARE-ENCRYPT-MESSAGES)))
(CASES)
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 M$0))
(EQUALITY-SUBSTITUTE M)
(APPLY D3B-AUX)
(REWRITE)
(CASES)
(SPLIT (SHARED-KEYS-KNOWN K1 K2 S))
(CASES)
(SIMPLIFY)
(INVOKE (SHARED-KEYS-KNOWN K1 K2 S))
(USE A3B (C M$0) (K1 K1) (K2 K2) (S S))
(USE A3C (C M$0) (K1 K1) (K2 K2) (S S))
(SIMPLIFY)
(NEXT)
(INVOKE SHARED-KEYS-KNOWN)
(REARRANGE)
(REWRITE)
(NEXT)
(APPLY C1B (COMP-OF M$0 (SETADD (SHARE-ENCRYPT N K1$0 K2$0) S)))
(INVOKE (SHARED-KEYS-KNOWN K1$0 K2$0 S))
(REWRITE)
(NEXT)
(SPLIT (IN M (HASH-MESSAGES)))
(CASES)
(USE HASH-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(INSTANTIATE (N$0 M$0))
(EQUALITY-SUBSTITUTE M)
(APPLY A12)
(REWRITE)
(INVOKE SHARED-KEYS-KNOWN)
(REWRITE)
(NEXT)
(USE IN-MESSAGES-LEMMA (D M))
(SIMPLIFY)
(NEXT)
(SPLIT (IN (SHARE-ENCRYPT N K1 K2) S))
(REWRITE)
(APPLY KNOWN-IN-SETADD-JUNK)
(APPLY COMP-OF-SETADD-JUNK)
(REWRITE)
(NEXT)

(rule known-add-share-encrypt-is-comp-of (m n k1 k2 s)
  (implies (and (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (not (and (known-in k1 s) (known-in k2 s)))
                (not (and (known-in (inverse k1) s)
                          (known-in (inverse k2) s)))
                (not (known-in m s))
                (<= (size m) (size (share-encrypt n k1 k2))))
           (= (known-in m (setadd (share-encrypt n k1 k2) s))
              (comp-of m (setadd (share-encrypt n k1 k2) s)))))
(USE KNOWN-ADD-SHARE-ENCRYPT-IS-COMP-OF-LEMMA
     (M M) (N N) (K1 K1) (K2 K2) (S S))
(INVOKE SHARED-KEYS-KNOWN)
(SIMPLIFY)

(axiom comp-of-subset-lemma (s1 s2 n)
  (implies
   (subset s1 s2)
   (all (c) (implies (comp-of-aux c s1 n)
                     (comp-of-aux c s2 n)))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(CASES)
(REDUCE)
(NEXT)
(PRENEX)
(REARRANGE)
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S1 N))
(REWRITE)
(CASES)
(CASES)
(INVOKE SUBSET)
(INVOKE (COMP-OF-AUX C S2 N))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECRYPT)
(SIMPLIFY)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(SIMPLIFY)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(SIMPLIFY)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(SIMPLIFY)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(SIMPLIFY)
(INVOKE COMP-FROM-RECURSION)
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (ENCRYPT C K)))
(INSTANTIATE (C$0 (INVERSE K)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 N))
(INVOKE COMP-FROM-DECRYPT)
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C$0 K1))
(INSTANTIATE (C$0 K2))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 N))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(INSTANTIATE (C$0 (SHARE-ENCRYPT C K1 K2)))
(INSTANTIATE (C$0 (INVERSE K1)))
(INSTANTIATE (C$0 (INVERSE K2)))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 N))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(INSTANTIATE (C$0 D1))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 N))
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(INSTANTIATE (C$0 D2))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX C S2 N))
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(INSTANTIATE (D1$0 D1) (D2$0 D2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (C$0 C))
(REWRITE)
(NEXT)

(axiom comp-of-subset (c s1 s2)
  (implies (and (comp-of c s1)
                (subset s1 s2))
           (comp-of c s2)))
(INVOKE COMP-OF)
(PRENEX)
(USE COMP-OF-SUBSET-LEMMA (S1 S1) (S2 S2) (N N))
(INSTANTIATE (C$0 C))
(SIMPLIFY)

(rule strong-c4 (c d1 d2 s)
 (implies
  (and
   (in c (messages))
   (in d1 (messages))
   (in d2 (messages))
   (not (= c (combine d1 d2))))
  (= (comp-of c (setadd (combine d1 d2) s))
     (comp-of c (union s (make-set d1 d2))))))
(SPLIT (COMP-OF C (UNION S (SETADD D1 (SETADD D2 (NULLSET))))))
(REWRITE)
(USE COMP-OF-TRANSITIVE
     (M C) (S1 (SETADD D1 (SETADD D2 S))) (S2 (SETADD (COMBINE D1 D2) S)))
(REWRITE)
(USE B1 (C1 D1) (C2 D2) (S (SETADD (COMBINE D1 D2) S)))
(SPLIT (IN D2 (MESSAGES)))
(SPLIT (IN D1 (MESSAGES)))
(REWRITE)

(rule known-add-hash-is-comp-of (m n s)
  (implies (and (not (known-in m s))
                (<= (size m) (size (hash n))))
           (= (known-in m (setadd (hash n) s))
              (comp-of m (setadd (hash n) s)))))
(SPLIT (IN N (MESSAGES)))
(CASES)
(INDUCT (MESSAGE-INDUCTION M))
(CASES)
(REARRANGE)
(REWRITE)
(NEXT)
(REARRANGE)
(REWRITE)
(SPLIT (IN M (COMBINE-MESSAGES)))
(CASES)
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 M1))
(INSTANTIATE (N$0 M2))
(EQUALITY-SUBSTITUTE M)
(APPLY D5)
(REWRITE)
(NEXT)
(SPLIT (IN M (ENCRYPT-MESSAGES)))
(CASES)
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 M$0))
(EQUALITY-SUBSTITUTE M)
(APPLY D3)
(REWRITE)
(USE A3 (C M$0) (K K) (S S))
(REWRITE)
(NEXT)
(SPLIT (IN M (SHARE-ENCRYPT-MESSAGES)))
(CASES)
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 M$0))
(EQUALITY-SUBSTITUTE M)
(APPLY D3B-AUX)
(REWRITE)
(USE A3B (C M$0) (K1 K1) (K2 K2) (S S))
(USE A3C (C M$0) (K1 K1) (K2 K2) (S S))
(INVOKE SHARED-KEYS-KNOWN)
(REARRANGE)
(REWRITE)
(NEXT)
(SPLIT (IN M (HASH-MESSAGES)))
(CASES)
(USE HASH-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(INSTANTIATE (N$0 M$0))
(EQUALITY-SUBSTITUTE M)
(APPLY A12)
(REWRITE)
(NEXT)
(USE IN-MESSAGES-LEMMA (D M))
(SIMPLIFY)
(NEXT)
(SPLIT (IN (HASH N) (MESSAGES)))
(REWRITE)
(APPLY KNOWN-IN-SETADD-JUNK)
(APPLY COMP-OF-SETADD-JUNK)
(REWRITE)
(NEXT)


(axiom comp-of-setadd-key-lemma (k s n)
  (implies
   (and (in k (keys))
        (not (some (m2) (comp-of (encrypt m2 (inverse k)) s)))
        (not (some (m2 k2) (and (in k2 (asymmetric-keys))
                                (comp-of (share-encrypt m2 k k2) s))))
        (not (some (m2 k2) (and (in k2 (asymmetric-keys))
                                (comp-of (share-encrypt m2 (inverse k) k2)
                                         s))))
        (not (some (m2 k2) (and (in k2 (asymmetric-keys))
                                (comp-of (share-encrypt m2 k2 k) s))))
        (not (some (m2 k2) (and (in k2 (asymmetric-keys))
                                (comp-of (share-encrypt m2 k2 (inverse k))
                                         s)))))
   (all (m) (implies (and (in m (messages))
                          (not (= m k))
                          (not (comp-of-aux m s n)))
                     (not (comp-of-aux m (setadd k s) n))))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(CASES)
(INVOKE (COMP-OF-AUX M (SETADD K S) N))
(REWRITE)
(INVOKE (COMP-OF-AUX M S N))
(REWRITE)
(NEXT)
(SIMPLIFY)
(PRENEX)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M (SETADD K S) N))
(REWRITE)
(CASES)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(SPLIT (= K$0 (INVERSE K)))
(REWRITE)
(CASES)
(INSTANTIATE (M$0 (ENCRYPT M (INVERSE K))))
(REARRANGE)
(REWRITE)
(INSTANTIATE (M2 M))
(INVOKE (COMP-OF (ENCRYPT M (INVERSE K$0)) S))
(REWRITE)
(NEXT)
(INSTANTIATE (M$1 (ENCRYPT M K$0)))
(REARRANGE)
(REWRITE)
(INSTANTIATE (M$0 (INVERSE K)))
(REWRITE)
(CASES)
(SPLIT (= (INVERSE K) K$0))
(SPLIT (IN K (KEYS)))
(REWRITE)
(EQUALITY-SUBSTITUTE K$0)
(REWRITE)
(NEXT)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(INVOKE COMP-FROM-DECRYPT)
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(REWRITE)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 K1))
(INSTANTIATE (M$0 K2))
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(INSTANTIATE (M2$0 M) (K2$0 K))
(REWRITE)
(INVOKE (COMP-OF (SHARE-ENCRYPT M K K) S))
(INSTANTIATE (N$0 (- N 1)))
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(INSTANTIATE (M2$0 M) (K2$0 K2))
(REWRITE)
(INVOKE (COMP-OF (SHARE-ENCRYPT M K K2) S))
(INSTANTIATE (N$0 (- N 1)))
(SIMPLIFY)
(NEXT)
(CASES)
(SIMPLIFY)
(INSTANTIATE (M2$2 M) (K2$2 K1))
(REWRITE)
(INVOKE (COMP-OF (SHARE-ENCRYPT M K1 K) S))
(INSTANTIATE (N$0 (- N 1)))
(SIMPLIFY)
(NEXT)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(INVOKE COMP-FROM-SHARE-DECRYPT)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(SIMPLIFY)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(REWRITE)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(INSTANTIATE (M$0 (INVERSE K1)))
(INSTANTIATE (M$0 (INVERSE K2)))
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(INSTANTIATE (M2$1 M) (K2$1 K2))
(REWRITE)
(INVOKE (COMP-OF (SHARE-ENCRYPT M (INVERSE K) K2) S))
(REARRANGE)
(EQUALITY-SUBSTITUTE K)
(REWRITE)
(NEXT)
(SIMPLIFY)
(INSTANTIATE (M2$1 M) (K2$1 K2))
(REWRITE)
(INVOKE (COMP-OF (SHARE-ENCRYPT M (INVERSE K) K2) S))
(REARRANGE)
(EQUALITY-SUBSTITUTE K)
(REWRITE)
(NEXT)
(CASES)
(SIMPLIFY)
(INSTANTIATE (M2$3 M) (K2$3 K1))
(REWRITE)
(INVOKE (COMP-OF (SHARE-ENCRYPT M K1 (INVERSE K)) S))
(REARRANGE)
(EQUALITY-SUBSTITUTE K)
(REWRITE)
(NEXT)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(REWRITE)
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(REWRITE)
(INSTANTIATE (M$0 (COMBINE M D2)))
(REARRANGE)
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(REWRITE)
(INSTANTIATE (M$0 (COMBINE D1 M)))
(REARRANGE)
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (M$0 M))
(REWRITE)
(NEXT)

(axiom comp-of-setadd-key (k m s)
  (implies
   (and (in k (keys))
        (not (= m k))
        (not (comp-of m s))
        (not (some (m2) (comp-of (encrypt m2 (inverse k)) s)))
        (not (some (m2 k2) (and (in k2 (asymmetric-keys))
                                (comp-of (share-encrypt m2 k k2) s))))
        (not (some (m2 k2) (and (in k2 (asymmetric-keys))
                                (comp-of (share-encrypt m2 (inverse k) k2)
                                         s))))
        (not (some (m2 k2) (and (in k2 (asymmetric-keys))
                                (comp-of (share-encrypt m2 k2 k) s))))
        (not (some (m2 k2) (and (in k2 (asymmetric-keys))
                                (comp-of (share-encrypt m2 k2 (inverse k))
                                         s)))))
   (not (comp-of m (setadd k s)))))
(SPLIT (IN M (MESSAGES)))
(REWRITE)
(INVOKE (COMP-OF M (SETADD K S)))
(PRENEX)
(USE COMP-OF-SETADD-KEY-LEMMA (K K) (S S) (N N))
(REARRANGE)
(SIMPLIFY)
(INVOKE (COMP-OF M S))
(INSTANTIATE (N$0 N))
(SIMPLIFY)

(disabled
 (function xcomp-of (m keys msgs) ()
   (comp-of m (union keys msgs))))

(grule xcomp-of-bool (m keys msgs)
  (= (type-of (xcomp-of m keys msgs)) (bool)))
(INVOKE XCOMP-OF)
(REWRITE)

(rule xcomp-of-basic (m keys b msgs)
  (implies (and (in m (messages))
                (in b (basic-messages)))
           (= (xcomp-of m keys (setadd b msgs))
              (or (= m b)
                  (xcomp-of m keys msgs)))))
(INVOKE XCOMP-OF)
(REWRITE)

(rule xcomp-of-key (m keys k msgs)
  (implies (and (in m (messages))
                (in k (keys)))
           (= (xcomp-of m keys (setadd k msgs))
              (xcomp-of m (setadd k keys) msgs))))
(INVOKE XCOMP-OF)
(REWRITE)

(rule xcomp-of-combine (m keys m1 m2 msgs)
  (implies (and (in m (messages))
                (in m1 (messages))
                (in m2 (messages))
                (subset keys (messages))
                (subset msgs (messages)))          
           (= (xcomp-of m keys (setadd (combine m1 m2) msgs))
              (or (= m (combine m1 m2))
                  (xcomp-of m keys (setadd m1 (setadd m2 msgs)))))))
(INVOKE XCOMP-OF)
(REWRITE)

(rule xcomp-of-encryption (m keys m1 k msgs)
  (implies (and (in m (messages))
                (in m1 (messages))
                (in k (keys))
                (subset keys (messages))
                (subset msgs (messages)))
           (= (xcomp-of m keys (setadd (encrypt m1 k) msgs))
              (or (= m (encrypt m1 k))
                  (if (xcomp-of (inverse k) keys msgs)
                      (xcomp-of m keys (setadd m1 msgs))
                      (xcomp-of m keys msgs))))))
(INVOKE XCOMP-OF)
(REWRITE)
(USE COMP-OF-TRANSITIVE
     (M M1)
     (S1 (SETADD (ENCRYPT M1 K) (SETADD (INVERSE K) (UNION KEYS MSGS))))
     (S2 (UNION KEYS MSGS)))
(USE B2
     (C M1)
     (K K)
     (S (SETADD (ENCRYPT M1 K) (SETADD (INVERSE K) (UNION KEYS MSGS)))))
(USE COMP-OF-TRANSITIVE
     (M M)
     (S1 (SETADD M1 (UNION KEYS MSGS)))
     (S2 (SETADD (ENCRYPT M1 K) (UNION KEYS MSGS))))
(USE
  COMP-OF-SUBSET
  (C M1) (S1 (UNION KEYS MSGS)) (S2 (SETADD (ENCRYPT M1 K) (UNION KEYS MSGS))))
(USE B2 (C M1) (K K) (S (SETADD (ENCRYPT M1 K) (UNION KEYS MSGS))))
(USE COMP-OF-SUBSET
     (C (INVERSE K))
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (ENCRYPT M1 K) (UNION KEYS MSGS))))
(REARRANGE)
(REWRITE)

(rule xcomp-of-shared-encryption (m keys m1 k1 k2 msgs)
  (implies (and (in m (messages))
                (in m1 (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (subset keys (messages))
                (subset msgs (messages)))
           (= (xcomp-of m keys (setadd (share-encrypt m1 k1 k2) msgs))
              (or (= m (share-encrypt m1 k1 k2))
                  (if (or (and (xcomp-of (inverse k1) keys msgs)
                               (xcomp-of (inverse k2) keys msgs))
                          (and (xcomp-of k1 keys msgs)
                               (xcomp-of k2 keys msgs)))
                      (xcomp-of m keys (setadd m1 msgs))
                      (xcomp-of m keys msgs))))))
(INVOKE XCOMP-OF)
(REWRITE)
(CASES)
(CASES)
(USE
  COMP-OF-TRANSITIVE
  (M M1)
  (S1 (SETADD (SHARE-ENCRYPT M1 K1 K2)
              (SETADD (INVERSE K1) (SETADD (INVERSE K2) (UNION KEYS MSGS)))))
  (S2 (UNION KEYS MSGS)))
(USE
  B2C
  (C M1)
  (K1 K1)
  (K2 K2)
  (S (SETADD (SHARE-ENCRYPT M1 K1 K2)
             (SETADD (INVERSE K1) (SETADD (INVERSE K2) (UNION KEYS MSGS))))))
(REARRANGE)
(REWRITE)
(CASES)
(USE COMP-OF-TRANSITIVE
     (M M)
     (S1 (SETADD M1 (UNION KEYS MSGS)))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-SUBSET
     (C M1)
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(REARRANGE)
(REWRITE)
(NEXT)
(USE
  COMP-OF-TRANSITIVE
  (M M1)
  (S1 (SETADD (SHARE-ENCRYPT M1 K1 K2)
              (SETADD (INVERSE K1) (SETADD (INVERSE K2) (UNION KEYS MSGS)))))
  (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(REARRANGE)
(REWRITE)
(EQUALITY-SUBSTITUTE C)
(USE COMP-OF-SUBSET
     (C (INVERSE K1))
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-SUBSET
     (C (INVERSE K2))
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE
  COMP-OF-TRANSITIVE
  (M M1)
  (S1 (SETADD (SHARE-ENCRYPT M1 K1 K2)
              (SETADD (INVERSE K1) (SETADD (INVERSE K2) (UNION KEYS MSGS)))))
  (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-TRANSITIVE
     (M M)
     (S1 (SETADD M1 (UNION KEYS MSGS)))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(REARRANGE)
(REWRITE)
(NEXT)
(USE COMP-OF-TRANSITIVE
     (M M1)
     (S1 (SETADD (SHARE-ENCRYPT M1 K1 K2)
                 (SETADD K1 (SETADD K2 (UNION KEYS MSGS)))))
     (S2 (UNION KEYS MSGS)))
(USE B2B
     (C M1)
     (K1 K1)
     (K2 K2)
     (S (SETADD (SHARE-ENCRYPT M1 K1 K2)
                (SETADD K1 (SETADD K2 (UNION KEYS MSGS))))))
(REARRANGE)
(REWRITE)
(USE COMP-OF-TRANSITIVE
     (M M)
     (S1 (SETADD M1 (UNION KEYS MSGS)))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-SUBSET
     (C M1)
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(REARRANGE)
(REWRITE)
(USE COMP-OF-TRANSITIVE
     (M M1)
     (S1 (SETADD (SHARE-ENCRYPT M1 K1 K2)
                 (SETADD K1 (SETADD K2 (UNION KEYS MSGS)))))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(REARRANGE)
(REWRITE)
(EQUALITY-SUBSTITUTE C)
(USE COMP-OF-SUBSET
     (C K1)
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-SUBSET
     (C K2)
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-TRANSITIVE
     (M M1)
     (S1 (SETADD (SHARE-ENCRYPT M1 K1 K2)
                 (SETADD K1 (SETADD K2 (UNION KEYS MSGS)))))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-TRANSITIVE
     (M M)
     (S1 (SETADD M1 (UNION KEYS MSGS)))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(REARRANGE)
(REWRITE)
(NEXT)
(USE COMP-OF-TRANSITIVE
     (M M1)
     (S1 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS)))
     (S2 (UNION KEYS MSGS)))
(USE B2B
     (C M1)
     (K1 K1)
     (K2 K2)
     (S (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-SUBSET
     (C K1)
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-SUBSET
     (C K2)
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(REARRANGE)
(REWRITE)
(USE COMP-OF-TRANSITIVE
     (M M)
     (S1 (SETADD M1 (UNION KEYS MSGS)))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(USE COMP-OF-SUBSET
     (C M1)
     (S1 (UNION KEYS MSGS))
     (S2 (SETADD (SHARE-ENCRYPT M1 K1 K2) (UNION KEYS MSGS))))
(REARRANGE)
(REWRITE)
(NEXT)

(rule xcomp-of-base (m keys)
  (implies (subset keys (keys))
           (= (xcomp-of m keys (nullset))
              (in m keys))))
(INVOKE XCOMP-OF)
(REWRITE)
(SPLIT (IN M KEYS))
(REWRITE)
(CASES)
(INVOKE SUBSET)
(INSTANTIATE (E M))
(REWRITE)
(NEXT)
(APPLY C7)
(APPLY SET-OF-KEYS-DEFINITION)
(REWRITE)
(NEXT)

(disabled
 (rule comp-of-calculation (m msgs)
   (= (comp-of m msgs)
      (xcomp-of m (nullset) msgs))))
(WITH-ENABLED (XCOMP-OF) (REDUCE))

(disabled
 (function is-fresh (k seen) ()
  (and (not (in k (parts seen)))
       ;(not (in (inverse k) (parts seen)))
       (not (some (m) (in (encrypt m k) (parts seen))))
       (not (some (m) (in (encrypt m (inverse k)) (parts seen))))
       (all (m k2)
         (and (not (in (share-encrypt m k k2) (parts seen)))
              (not (in (share-encrypt m (inverse k) k2)
                       (parts seen)))
              (not (in (share-encrypt m k2 k) (parts seen)))
              (not (in (share-encrypt m k2 (inverse k))
                       (parts seen)))
              )))))

(rule comp-of-setadd-fresh-key (m k s)
  (implies (and (in k (keys))
                (is-fresh k s))
           (= (comp-of m (setadd k s))
              (or (= m k)
                  (comp-of m s)))))
(REDUCE)
(CASES)
(USE COMP-OF-SUBSET (C M) (S1 S) (S2 (SETADD K S)))
(REWRITE)
(NEXT)
(USE COMP-OF-SETADD-KEY (K K) (M M) (S S))
(REARRANGE)
(REWRITE)
(PRENEX)
(REWRITE)
(INVOKE IS-FRESH)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)


;;; Additional message theory rules

(rule strong-d3-d4 (c k s)
  (implies (and (in c (messages))
                (in k (keys)))
           (= (known-in (encrypt c k) s)
              (or (comp-of (encrypt c k) s)
                  (and (known-in c s)
                       (comp-of k s))))))
(REWRITE)

(rule strong-d3-d4-b (c k1 k2 s)
  (implies (and (in c (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys)))
           (= (known-in (share-encrypt c k1 k2) s)
              (or (comp-of (share-encrypt c k1 k2) s)
                  (and (known-in c s)
                       (or (and (comp-of k1 s)
                                (comp-of k2 s))
                           (and (comp-of (inverse k1) s)
                                (comp-of (inverse k2) s))))))))
(REWRITE)


;;; strong comp-of rules...

(rule non-part-not-xcomp (m k s)
  (implies (not (in m (parts (union k s))))
           (= (xcomp-of m k s)
              (false))))
(INVOKE XCOMP-OF)
(REWRITE)

(rule public-keys-are-messages ()
  (= (subset (public-keys) (messages))
     (true)))
(REDUCE)

(rule xcomp-union (m keys s)
  (= (xcomp-of m keys (union (public-keys) S))
     (xcomp-of m (union (public-keys) keys) S)))
(INVOKE XCOMP-OF)
(REWRITE)


;;; New stuff

(rule xcomp-of-hash (m keys m1 msgs)
  (implies (and (in m (messages))
                (in m1 (messages))
                (subset keys (messages))
                (subset msgs (messages)))
           (= (xcomp-of m keys (setadd (hash m1) msgs))
              (or (= m (hash m1))
                  (xcomp-of m keys msgs)))))
(INVOKE XCOMP-OF)
(REWRITE)

(rule xcomp-of-public-key (k keys msgs)
  (implies (and (in k (public-keys))
                (in k keys)
                (subset keys (messages))
                (subset msgs (messages)))
           (= (xcomp-of k keys msgs) (true))))
(INVOKE XCOMP-OF)
(REWRITE)

(axiom in-parts-subset (k s1 s2)
  (implies (and (in k (parts s2))
                (subset s2 s1))
           (in k (parts s1))))
(SPLIT (= S1 (UNION S1 S2)))
(CASES)
(EQUALITY-SUBSTITUTE S1)
(APPLY PARTS-UNION)
(APPLY UNION.DEFINITION)
(SIMPLIFY)
(NEXT)
(SPLIT (SUBSET S2 S1))
(REWRITE)
(NEXT)

(axiom is-fresh-subset (k s1 s2)
  (implies (and (is-fresh k s1)
                (subset s2 s1))
           (is-fresh k s2)))
(INVOKE IS-FRESH)
(WITH-DISABLED (PARTS)
 (REWRITE))
(USE IN-PARTS-SUBSET (S1 S1) (S2 S2))
(SPLIT (SUBSET S2 S1))
(SIMPLIFY)
(CASES)
(INSTANTIATE (K$0 K))
(SIMPLIFY)
(NEXT)
;(INSTANTIATE (K$0 (INVERSE K)))
;(SIMPLIFY)
;(NEXT)
(INSTANTIATE (K$0 (ENCRYPT M$5 K)))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (K$0 (ENCRYPT M$6 (INVERSE K))))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (K$0 (SHARE-ENCRYPT M$7 K K2$3)))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (K$0 (SHARE-ENCRYPT M$8 (INVERSE K) K2$4)))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (K$0 (SHARE-ENCRYPT M$9 K2$5 K)))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (K$0 (SHARE-ENCRYPT M$10 K2$6 (INVERSE K))))
(SIMPLIFY)
(NEXT)

(rule is-fresh-union (k s1 s2)
  (= (is-fresh k (union s1 s2))
     (and (is-fresh k s1)
          (is-fresh k s2))))
(SPLIT (IS-FRESH K (UNION S1 S2)))
(SIMPLIFY)
(CASES)
(USE IS-FRESH-SUBSET (K K) (S1 (UNION S1 S2)) (S2 S1))
(USE IS-FRESH-SUBSET (K K) (S1 (UNION S1 S2)) (S2 S2))
(SIMPLIFY)
(NEXT)
(INVOKE IS-FRESH)
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)

(rule is-fresh-atomic (k s)
  (implies (subset s (atomic-messages))
           (= (is-fresh k s)
              ;(and
               (not (in k s))
                  ; (not (in (inverse k) s)))
               )))
(INVOKE IS-FRESH)
(REWRITE)
(PRENEX)
(INVOKE SUBSET)
(CASES)
(INSTANTIATE (E (ENCRYPT M K)))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (E (ENCRYPT M$0 (INVERSE K))))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (E (SHARE-ENCRYPT M$1 K K2)))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (E (SHARE-ENCRYPT M$2 (INVERSE K) K2$0)))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (E (SHARE-ENCRYPT M$3 K2$1 K)))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (E (SHARE-ENCRYPT M$4 K2$2 (INVERSE K))))
(SIMPLIFY)
(NEXT)

(rule public-keys-are-atomic-messages ()
  (= (subset (public-keys) (atomic-messages))
     (true)))
(REDUCE)

(rule strong-d6 (c s)
  (implies (in c (messages))
           (= (known-in (hash c) s)
              (or (comp-of (hash c) s)
                  (known-in c s)))))
(REDUCE)

;;; strong-c3

(rule comp-of-setadd-basic (m b s)
  (implies (in b (basic-messages))
           (= (comp-of m (setadd b s))
              (or (= m b)
                  (comp-of m s)))))
(REDUCE)
(SPLIT (IN M (MESSAGES)))
(REWRITE)

(rule comp-of-setadd (m1 m2 s)
  (implies (comp-of m1 s)
           (= (comp-of m1 (setadd m2 s)) (true))))
(USE COMP-OF-SUBSET (C M1) (S1 S) (S2 (SETADD M2 S)))
(REDUCE)

(rule known-in-of-setadd (m1 m2 s)
  (implies (known-in m1 s)
           (= (known-in m1 (setadd m2 s)) (true))))
(USE KNOWN-IN-SUBSET (C M1) (S1 S) (S2 (SETADD M2 S)))
(REDUCE)

(frule inverse-of-secret-key-is-public (sk)
  (implies (in sk (secret-keys))
           (in (inverse sk) (public-keys))))
(APPLY INVERSE-SECKEY)
(REWRITE)

;;; New January 4th

(rule inverse-equality (k1 k2)
  (implies (and (in k1 (keys))
                (in k2 (keys)))
           (= (= (inverse k1) (inverse k2))
              (= k1 k2))))
(INVOKE INVERSE)
(REWRITE)
(CASES)
(INVOKE VALUE-OF)
(INVOKE SECKEY)
(SPLIT (= K1 K2))
(REWRITE)
(APPLY PUBLIC-KEYS.DEFINITION)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(INVOKE PUBKEY)
(REWRITE)
(NEXT)
(INVOKE VALUE-OF)
(INVOKE PUBKEY)
(SPLIT (= K1 K2))
(REWRITE)
(APPLY SECRET-KEYS.DEFINITION)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(INVOKE SECKEY)
(REWRITE)
(NEXT)

(rule known-in-setadd-combine (m m1 m2 s)
  (implies (and (in m (messages))
                (in m1 (messages))
                (in m2 (messages))
                (subset s (messages)))
           (= (known-in m (setadd (combine m1 m2) s))
              (known-in m (setadd m1 (setadd m2 s))))))
(SPLIT (KNOWN-IN M (SETADD (COMBINE M1 M2) S)))
(SIMPLIFY)
(SPLIT (AND (IN M (MESSAGES))
            (IN M1 (MESSAGES))
            (IN M2 (MESSAGES))
            (OR (KNOWN-IN M (SETADD M1 S)) (KNOWN-IN M (SETADD M2 S)))))
(REWRITE)
(CONJUNCTIVE)
(CASES)
(SPLIT (KNOWN-IN (COMBINE M1 M2) (SETADD (COMBINE M1 M2) S)))
(CASES)
(REWRITE)
(USE KNOWN-IN-TRANSITIVE
     (M M) (S1 (SETADD M2 S)) (S2 (SETADD (COMBINE M1 M2) S)))
(REARRANGE)
(SIMPLIFY)
(PRENEX)
(REWRITE)
(APPLY A7 (KNOWN-IN C (SETADD (COMBINE M1 M2) S)))
(REWRITE)
(INVOKE SUBSET)
(REWRITE)
(NEXT)
(SPLIT (AND (IN M (MESSAGES))
            (IN M1 (MESSAGES))
            (IN M2 (MESSAGES))))
(REWRITE)
(NEXT)
(USE KNOWN-IN-SUBSET (C M) (S1 (SETADD M1 S)) (S2 (SETADD M1 (SETADD M2 S))))
(REWRITE)
(NEXT)
(SPLIT (KNOWN-IN (COMBINE M1 M2) (SETADD (COMBINE M1 M2) S)))
(CASES)
(REWRITE)
(USE KNOWN-IN-TRANSITIVE
     (M M) (S1 (SETADD M1 (SETADD M2 S))) (S2 (SETADD (COMBINE M1 M2) S)))
(REARRANGE)
(SIMPLIFY)
(PRENEX)
(REWRITE)
(APPLY A7 (KNOWN-IN C (SETADD (COMBINE M1 M2) S)))
(REWRITE)
(INVOKE SUBSET)
(REWRITE)
(NEXT)
(APPLY A7 (KNOWN-IN (COMBINE M1 M2) (SETADD (COMBINE M1 M2) S)))
(SPLIT (AND (IN M (MESSAGES))
            (IN M1 (MESSAGES))
            (IN M2 (MESSAGES))))
(REWRITE)
(NEXT)
(USE KNOWN-IN-TRANSITIVE
     (M M) (S1 (SETADD (COMBINE M1 M2) S)) (S2 (SETADD M1 (SETADD M2 S))))
(REARRANGE)
(SIMPLIFY)
(PRENEX)
(REWRITE)
(APPLY A7 (KNOWN-IN C (SETADD M1 (SETADD M2 S))))
(REWRITE)
(INVOKE SUBSET)
(REWRITE)
(EQUALITY-SUBSTITUTE C)
(REWRITE)
(NEXT)

(rule principals-subset-of-messages ()
  (= (subset (principals) (messages)) (true)))
(INVOKE SUBSET)
(REWRITE)

(rule text-messages-subset-of-messages ()
  (= (subset (text-messages) (messages)) (true)))
(INVOKE SUBSET)
(REWRITE)


;;; New March 2000

(rule principal-atomic ()
  (= (subset (principals) (atomic-messages)) (true)))
(REDUCE)

(rule text-message-atomic ()
  (= (subset (text-messages) (atomic-messages)) (true)))
(REDUCE)

(axiom parts-transitive (m1 m2 s)
  (implies (and (in m1 (messages))
                (in m2 (messages))
                (in m1 (parts (setadd m2 (nullset))))
                (in m2 (parts s)))
           (in m1 (parts s))))
(REWRITE)
(INSTANTIATE (T$0 T$1))
(REWRITE)

(axiom encrypt-in-parts (m k s)
  (implies (and (in m (messages))
                (in k (keys))
                (in (encrypt m k) (parts s)))
           (in m (parts s))))
(REWRITE)
(INSTANTIATE (T T$0))
(REWRITE)
(INVOKE IS-CLOSED-UNDER-DECODING)
(INSTANTIATE (M$0 M) (K$0 K))
(REWRITE)

(axiom share-encrypt-in-parts (m k1 k2 s)
  (implies (and (in m (messages))
                (in k1 (asymmetric-keys))
                (in k2 (asymmetric-keys))
                (in (share-encrypt m k1 k2) (parts s)))
           (in m (parts s))))
(REWRITE)
(INSTANTIATE (T T$0))
(REWRITE)
(INVOKE IS-CLOSED-UNDER-SHARE-DECODING)
(INSTANTIATE (M$0 M) (K1$0 K1) (K2$0 K2))
(REWRITE)

(axiom hash-in-parts (m s)
  (implies (and (in m (messages))
                (in (hash m) (parts s)))
           (in m (parts s))))
(REWRITE)
(INSTANTIATE (T T$0))
(REWRITE)
(INVOKE IS-CLOSED-UNDER-DEHASHING)
(INSTANTIATE (M$0 M))
(REWRITE)

(axiom encrypted-message-theorem (m k m2 s)
  (implies (and (in m (messages))
                (in k (keys))
                (in m2 (messages))
                (known-in m2 s)
                (not (in (encrypt m k) (parts s)))
                (not (known-in k s)))
           (not (in (encrypt m k) (parts (setadd m2 (nullset)))))))
(INDUCT (MESSAGE-INDUCTION M2))
(CASES)
(REWRITE)
(NEXT)
(SPLIT (IN M2 (COMBINE-MESSAGES)))
(CASES)
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M2))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M1))
(INSTANTIATE (N M2$0))
(EQUALITY-SUBSTITUTE M2)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(CASES)
(CASES)
(SPLIT (= (SETADD M1 (SETADD M2$0 (NULLSET)))
          (UNION (SETADD M1 (NULLSET)) (SETADD M2$0 (NULLSET)))))
(CASES)
(EQUALITY-SUBSTITUTE (SETADD M1 (SETADD M2$0 (NULLSET))))
(APPLY PARTS-UNION)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(REWRITE)
(NEXT)
(SPLIT (KNOWN-IN (COMBINE M1 M2$0) S))
(SIMPLIFY)
(REWRITE)
(NEXT)
(CASES)
(SPLIT (KNOWN-IN (COMBINE M1 M2$0) S))
(SIMPLIFY)
(REWRITE)
(NEXT)
(SPLIT (KNOWN-IN (COMBINE M1 M2$0) S))
(SIMPLIFY)
(REWRITE)
(NEXT)
(SPLIT (IN M2 (ENCRYPT-MESSAGES)))
(CASES)
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M2))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M$0))
(EQUALITY-SUBSTITUTE M2)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(CASES)
(SPLIT (= (ENCRYPT M$0 K$0) (ENCRYPT M K)))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(SPLIT (= (ENCRYPT M$0 K$0) (ENCRYPT M K)))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(CASES)
(SPLIT (IN (ENCRYPT M$0 K$0) (PARTS S)))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(USE IN-PARTS-SUBSET (K (ENCRYPT M$0 K$0)) (S1 S) (S2 (SETADD M (NULLSET))))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(APPLY NOT-PART-IMPLIES-NOT-COMP-OF (COMP-OF (ENCRYPT M K) S))
(SPLIT (IN M (PARTS S)))
(CASES)
(USE PARTS-TRANSITIVE (M1 (ENCRYPT M$0 K$0)) (M2 M) (S S))
(REARRANGE)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(USE ENCRYPT-IN-PARTS (M M) (K K) (S S))
(SIMPLIFY)
(NEXT)
(SPLIT (IN M2 (SHARE-ENCRYPT-MESSAGES)))
(CASES)
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M2))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M$0))
(EQUALITY-SUBSTITUTE M2)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(USE IN-PARTS-SUBSET (K (ENCRYPT M$0 K)) (S1 S) (S2 (SETADD M (NULLSET))))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(APPLY NOT-PART-IMPLIES-NOT-COMP-OF (COMP-OF (SHARE-ENCRYPT M K1 K2) S))
(SPLIT (IN M (PARTS S)))
(CASES)
(USE PARTS-TRANSITIVE (M1 (ENCRYPT M$0 K)) (M2 M) (S S))
(REARRANGE)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(USE SHARE-ENCRYPT-IN-PARTS (M M) (K1 K1) (K2 K2) (S S))
(SIMPLIFY)
(NEXT)
(SPLIT (IN M2 (HASH-MESSAGES)))
(CASES)
(USE HASH-MESSAGES-ARE-CONSTRUCTED (X M2))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M$0))
(EQUALITY-SUBSTITUTE M2)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(USE IN-PARTS-SUBSET (K (ENCRYPT M$0 K)) (S1 S) (S2 (SETADD M (NULLSET))))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(APPLY NOT-PART-IMPLIES-NOT-COMP-OF (COMP-OF (HASH M) S))
(SPLIT (IN M (PARTS S)))
(CASES)
(USE PARTS-TRANSITIVE (M1 (ENCRYPT M$0 K)) (M2 M) (S S))
(REARRANGE)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(USE HASH-IN-PARTS (M M) (S S))
(SIMPLIFY)
(NEXT)
(USE IN-MESSAGES-LEMMA (D M2))
(SIMPLIFY)
(NEXT)


(axiom size-part (m1 m2)
  (implies (and (in m1 (messages))
		(in m2 (messages))
		(in m1 (parts (setadd m2 (nullset)))))
	   (>= (size m2) (size m1))))
(INDUCT (MESSAGE-INDUCTION M2))
(CASES)
(REWRITE)
(NEXT)
(SPLIT (IN M2 (COMBINE-MESSAGES)))
(CASES)
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M2))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M1$0))
(INSTANTIATE (N M2$0))
(EQUALITY-SUBSTITUTE M2)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(SPLIT (= (SETADD M1 (SETADD M2$0 (NULLSET)))
          (UNION (SETADD M1 (NULLSET)) (SETADD M2$0 (NULLSET)))))
(CASES)
(EQUALITY-SUBSTITUTE (SETADD M1 (SETADD M2$0 (NULLSET))))
(APPLY PARTS-UNION)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(REWRITE)
(NEXT)
(SPLIT (IN M2 (ENCRYPT-MESSAGES)))
(CASES)
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M2))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M))
(EQUALITY-SUBSTITUTE M2)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(SPLIT (IN M2 (SHARE-ENCRYPT-MESSAGES)))
(CASES)
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M2))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M))
(EQUALITY-SUBSTITUTE M2)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(SPLIT (IN M2 (HASH-MESSAGES)))
(CASES)
(USE HASH-MESSAGES-ARE-CONSTRUCTED (X M2))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M))
(EQUALITY-SUBSTITUTE M2)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(USE IN-MESSAGES-LEMMA (D M2))
(SIMPLIFY)
(NEXT)

(axiom encrypted-message-theorem-2 (m k m1 s)
  (implies (and (in m (messages))
		(in k (keys))
		(is-fresh k s)
		(in m1 (messages))
		(in (encrypt m k) (parts (setadd m1 (nullset))))
		(known-in m1 (setadd k s)))
	   (known-in (encrypt m k) (setadd k s))))
(INDUCT (MESSAGE-INDUCTION M1))
(CASES)
(REWRITE)
(NEXT)
(SPLIT (IN M1 (COMBINE-MESSAGES)))
(CASES)
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M1))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(REARRANGE)
(SIMPLIFY)
(INSTANTIATE (N M1$0))
(INSTANTIATE (N M2))
(EQUALITY-SUBSTITUTE M1)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(SPLIT (= (SETADD M1$0 (SETADD M2 (NULLSET)))
          (UNION (SETADD M1$0 (NULLSET)) (SETADD M2 (NULLSET)))))
(CASES)
(EQUALITY-SUBSTITUTE (SETADD M1$0 (SETADD M2 (NULLSET))))
(APPLY PARTS-UNION)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(NEXT)
(REWRITE)
(NEXT)
(SPLIT (IN M1 (ENCRYPT-MESSAGES)))
(CASES)
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M1))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M$0))
(EQUALITY-SUBSTITUTE M1)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(SPLIT (IN (ENCRYPT M K) (PARTS S)))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(USE PARTS-TRANSITIVE (M1 (ENCRYPT M$0 K$0)) (M2 M) (S S))
(REARRANGE)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(USE ENCRYPT-IN-PARTS (M M) (K K) (S S))
(SIMPLIFY)
(INVOKE IS-FRESH)
(SIMPLIFY)
(NEXT)
(SPLIT (IN M1 (SHARE-ENCRYPT-MESSAGES)))
(CASES)
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M1))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M$0))
(EQUALITY-SUBSTITUTE M1)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(SPLIT (IN (SHARE-ENCRYPT M K1 K2) (PARTS S)))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(USE PARTS-TRANSITIVE (M1 (ENCRYPT M$0 K)) (M2 M) (S S))
(REARRANGE)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(USE SHARE-ENCRYPT-IN-PARTS (M M) (K1 K1) (K2 K2) (S S))
(SIMPLIFY)
(INVOKE IS-FRESH)
(SIMPLIFY)
(NEXT)
(SPLIT (IN M1 (HASH-MESSAGES)))
(CASES)
(USE HASH-MESSAGES-ARE-CONSTRUCTED (X M1))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(PRENEX)
(INSTANTIATE (N M$0))
(EQUALITY-SUBSTITUTE M1)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(SPLIT (IN (HASH M) (PARTS S)))
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(USE PARTS-TRANSITIVE (M1 (ENCRYPT M$0 K)) (M2 M) (S S))
(REARRANGE)
(WITH-DISABLED (PARTS.DEFINITION)
 (REWRITE))
(USE HASH-IN-PARTS (M M) (S S))
(SIMPLIFY)
(INVOKE IS-FRESH)
(SIMPLIFY)
(NEXT)
(USE IN-MESSAGES-LEMMA (D M1))
(SIMPLIFY)
(NEXT)

;;; added Feb 2001

(zf-function parts-of-units (S) ;; aux definition
  (select (m (union (messages) S))
    (some (x) (and (in x s) (in m (parts (unit x)))))))

(rule self-subset-parts-of-units (s)
  (= (subset s (parts-of-units s))
     (true)))
(REDUCE)
(INSTANTIATE (X E))
(SIMPLIFY)

(rule parts-of-units-closed-under-decombination (s)
  (= (is-closed-under-decombination (parts-of-units s))
     (true)))
(INVOKE IS-CLOSED-UNDER-DECOMBINATION)
(WITH-DISABLED (PARTS.DEFINITION) (REWRITE))
(PRENEX)
(USE PARTS-TRANSITIVE (M1 M1) (M2 (COMBINE M1 M2)) (S (UNIT X)))
(USE PARTS-TRANSITIVE (M1 M2) (M2 (COMBINE M1 M2)) (S (UNIT X)))
(REARRANGE)
(WITH-DISABLED (PARTS.DEFINITION) (REWRITE))

(rule parts-of-units-closed-under-decoding (s)
  (= (is-closed-under-decoding (parts-of-units s))
     (true)))
(INVOKE IS-CLOSED-UNDER-DECODING)
(WITH-DISABLED (PARTS.DEFINITION) (REWRITE))
(PRENEX)
(USE PARTS-TRANSITIVE (M1 M) (M2 (encrypt M K)) (S (UNIT X)))
(rearrange)
(WITH-DISABLED (PARTS.DEFINITION) (REWRITE))

(rule parts-of-units-closed-under-share-decoding (s)
  (= (is-closed-under-share-decoding (parts-of-units s))
     (true)))
(INVOKE IS-CLOSED-UNDER-SHARE-DECODING)
(WITH-DISABLED (PARTS.DEFINITION) (REWRITE))
(PRENEX)
(USE PARTS-TRANSITIVE (M1 M) (M2 (share-encrypt M K1 K2)) (S (UNIT X)))
(rearrange)
(WITH-DISABLED (PARTS.DEFINITION) (REWRITE))

(rule parts-of-units-closed-under-dehashing (s)
  (= (is-closed-under-dehashing (parts-of-units s))
     (true)))
(INVOKE IS-CLOSED-UNDER-DEHASHING)
(WITH-DISABLED (PARTS.DEFINITION) (REWRITE))
(PRENEX)
(USE PARTS-TRANSITIVE (M1 M) (M2 (HASH M)) (S (UNIT X)))
(WITH-DISABLED (PARTS.DEFINITION) (REWRITE))

(axiom parts-implies-part-of-member (m s)
  (implies (in m (parts s))
	   (some (x) (and (in x s)
			  (in m (parts (unit x)))))))
(USE PARTS-IS-MINIMAL (S S) (T (PARTS-OF-UNITS S)))
(INVOKE (SUBSET (PARTS S) (PARTS-OF-UNITS S)))
(WITH-DISABLED (PARTS.DEFINITION parts-of-units.definition)
 (REWRITE))
(INSTANTIATE (E M))
(apply parts-of-units.definition)
(instantiate (x$1 x))
(rewrite)


;;; ======== Added March 2001 ========


(grule set-of-nonces-not-empty ()
  (not (= (nonces) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (NONCE 0)))
(REWRITE)

(grule set-of-principals-not-empty ()
  (not (= (principals) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (PRINCIPAL 0)))
(REWRITE)

(grule set-of-text-messages-not-empty ()
  (not (= (text-messages) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (TEXT 0)))
(REWRITE)

(grule set-of-basic-messages-not-empty ()
  (not (= (basic-messages) (nullset))))
(INVOKE BASIC-MESSAGES)
(REWRITE)

(grule set-of-public-keys-not-empty ()
  (not (= (public-keys) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (PUBKEY 0)))
(REWRITE)

(grule set-of-secret-keys-not-empty ()
  (not (= (secret-keys) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (SECKEY 0)))
(REWRITE)

(grule set-of-asymmetric-keys-not-empty ()
  (not (= (asymmetric-keys) (nullset))))
(INVOKE ASYMMETRIC-KEYS)
(REWRITE)

(grule set-of-symmetric-keys-not-empty ()
  (not (= (symmetric-keys) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (SYMKEY 0)))
(REWRITE)

(grule set-of-keys-not-empty ()
  (not (= (keys) (nullset))))
(INVOKE KEYS)
(REWRITE)

(grule set-of-atomic-messages-not-empty ()
  (not (= (atomic-messages) (nullset))))
(INVOKE ATOMIC-MESSAGES)
(REWRITE)

(grule set-of-encrypt-messages-not-empty ()
  (not (= (encrypt-messages) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (ENCRYPT (TEXT 0) (SYMKEY 0))))
(REWRITE)

(grule set-of-share-encrypt-messages-not-empty ()
  (not (= (share-encrypt-messages) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (SHARE-ENCRYPT (TEXT 0) (PUBKEY 0) (SECKEY 0))))
(REWRITE)

(grule set-of-combine-messages-not-empty ()
  (not (= (combine-messages) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (COMBINE (TEXT 0) (TEXT 1))))
(REWRITE)

(grule set-of-hash-messages-not-empty ()
  (not (= (hash-messages) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (HASH (TEXT 0))))
(REWRITE)

(grule set-of-messages-not-empty ()
  (not (= (messages) (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(INSTANTIATE (E (TEXT 0)))
(REWRITE)

(rule in-parts-setadd (m m1 s)
  (implies (not (= s (nullset)))
           (= (in m (parts (setadd m1 s)))
              (or (in m (parts (setadd m1 (nullset))))
                  (in m (parts s))))))
(SPLIT (= (SETADD M1 S) (UNION (SETADD M1 (NULLSET)) S)))
(CASES)
(EQUALITY-SUBSTITUTE (SETADD M1 S))
(APPLY PARTS-UNION)
(REWRITE)
(SPLIT (= M M1))
(REWRITE)
(NEXT)
(REWRITE)
(NEXT)

(rule in-parts-add-known-in (k m s)
  (implies (known-in m s)
           (= (in k (parts (setadd m s)))
              (or (in k (parts (setadd m (nullset))))
                  (in k (parts s))))))
(SPLIT (= S (NULLSET)))
(REWRITE)

(rule atomic-in-parts-add-known-in (k m s)
  (implies (and (known-in m s)
                (in k (atomic-messages)))
           (= (in k (parts (setadd m s)))
              (in k (parts s)))))
(INDUCT (MESSAGE-INDUCTION M))
(CASES)
(REWRITE)
(SPLIT (= K M))
(REWRITE)
(SPLIT (IN K (PARTS S)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(REWRITE)
(NEXT)
(WITH-DISABLED (PARTS)
 (REWRITE))
(APPLY IN-MESSAGES-DEFINITION)
(REARRANGE)
(WITH-DISABLED (PARTS)
 (REWRITE))
(CASES)
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(WITH-DISABLED (PARTS)
 (REWRITE))
(CASES)
(INSTANTIATE (N M$0))
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= S (NULLSET)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(USE PARTS-TRANSITIVE (M1 K$0) (M2 M$0) (S S))
(USE PARTS-TRANSITIVE (M1 M$0) (M2 (ENCRYPT M$0 K)) (S S))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(USE PARTS-TRANSITIVE (M1 K) (M2 M$0) (S S))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (N M$0))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(CASES)
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(WITH-DISABLED (PARTS)
 (REWRITE))
(CASES)
(INSTANTIATE (N M$0))
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= S (NULLSET)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(USE PARTS-TRANSITIVE (M1 K) (M2 M$0) (S S))
(USE PARTS-TRANSITIVE (M1 M$0) (M2 (SHARE-ENCRYPT M$0 K1 K2)) (S S))
(REARRANGE)
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (IN (SHARE-ENCRYPT M$0 K1 K2) (PARTS S)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(CASES)
(CASES)
(USE PARTS-TRANSITIVE (M1 K) (M2 M$0) (S S))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (N M$0))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(USE PARTS-TRANSITIVE (M1 K) (M2 M$0) (S S))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (N M$0))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(USE PARTS-TRANSITIVE (M1 K) (M2 M$0) (S S))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (N M$0))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(CASES)
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(WITH-DISABLED (PARTS)
 (REWRITE))
(CASES)
(INSTANTIATE (N M1))
(INSTANTIATE (N M2))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(INSTANTIATE (N$0 M1))
(INSTANTIATE (N M2))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(USE HASH-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(WITH-DISABLED (PARTS)
 (REWRITE))
(CASES)
(INSTANTIATE (N M$0))
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= S (NULLSET)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(USE PARTS-TRANSITIVE (M1 K) (M2 M$0) (S S))
(USE PARTS-TRANSITIVE (M1 M$0) (M2 (HASH M$0)) (S S))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(USE PARTS-TRANSITIVE (M1 K) (M2 M$0) (S S))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (N M$0))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)


(rule not-known-in-nullset (m)
  (= (known-in m (nullset)) (false)))
(INDUCT (MESSAGE-INDUCTION M))
(CASES)
(REWRITE)
(NEXT)
(REWRITE)
(APPLY IN-MESSAGES-DEFINITION)
(REARRANGE)
(REWRITE)
(CONJUNCTIVE)
(CASES)
(USE HASH-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(REWRITE)
(INSTANTIATE (N M$0))
(REWRITE)
(NEXT)
(USE COMBINE-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(REWRITE)
(INSTANTIATE (N M1))
(REWRITE)
(NEXT)
(USE SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(REWRITE)
(NEXT)
(USE ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(REWRITE)
(NEXT)

(frule inverse-in-asymmetric-keys (k)
  (implies (in (inverse k) (asymmetric-keys))
           (in k (asymmetric-keys))))
(SPLIT (IN (INVERSE K) (KEYS)))
(SIMPLIFY)
(USE INVERSE-INVERSE (K K))
(USE INVERSE-IN-KEYS (K K))
(SIMPLIFY)
(USE INVERSE-ASYMMETRIC (K (INVERSE K)))
(WITH-DISABLED (INVERSE-ASYMMETRIC)
 (SIMPLIFY))




(rule comp-of-aux-setadd (m1 m2 s n)
  (implies (comp-of-aux m1 s n)
           (= (comp-of-aux  m1 (setadd m2 s) n) (true))))
(USE COMP-OF-SUBSET-LEMMA (S1 S) (S2 (SETADD M2 S)) (N N))
(REWRITE)

(rule comp-of-aux-setadd-basic (m1 m2 s n)
  (implies (in m2 (basic-messages))
           (= (comp-of-aux m1 (setadd m2 s) n)
              (or (= m1 m2) (comp-of-aux m1 s n)))))
(SPLIT (COMP-OF-AUX M1 S N))
(REWRITE)
(CASES)
(INVOKE (COMP-OF-AUX M1 (SETADD M2 S) N))
(REWRITE)
(NEXT)
(USE C3-LEMMA (X M2) (S S) (N N))
(REWRITE)
(INSTANTIATE (C1 M1))
(REWRITE)
(NEXT)

(axiom comp-of-aux-setadd-key (k s n)
  (implies (some (m)
             (and (in k (keys))
                  (not (= m k))
                  (not (comp-of-aux m s n))
                  (comp-of-aux m (setadd k s) n)))
           (not (is-fresh k s))))
(INDUCT (NAT!WEAK-INDUCTION N))
(CASES)
(INVOKE NAT!ZEROP)
(INVOKE COMP-OF-AUX)
(REWRITE)
(NEXT)
(INVOKE NAT!ZEROP)
(REWRITE)
(PRENEX)
(INVOKE IS-FRESH)
(WITH-DISABLED (PARTS)
 (REWRITE))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M (SETADD K S) N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(CASES)
(CASES)
(INVOKE (COMP-OF-AUX M S N))
(REWRITE)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(SIMPLIFY)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(USE NOT-PART-IMPLIES-NOT-COMP-OF-LEMMA (S (SETADD K S)) (N (- N 1)))
(SIMPLIFY)
(REARRANGE)
(INSTANTIATE (M$0 (ENCRYPT M K$0)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (M$0 M))
(WITH-DISABLED (PARTS)
 (REWRITE))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INVOKE COMP-FROM-DECRYPT)
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (K$1 K$0))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (M$2 (INVERSE K$0)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (M$1 M))
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= (INVERSE K$0) K))
(WITH-DISABLED (PARTS)
 (REWRITE))
(EQUALITY-SUBSTITUTE K)
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(USE NOT-PART-IMPLIES-NOT-COMP-OF-LEMMA (S (SETADD K S)) (N (- N 1)))
(SIMPLIFY)
(REARRANGE)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (M$4 M) (K2$0 K2))
(WITH-DISABLED (PARTS)
 (REWRITE))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INVOKE (COMP-FROM-SHARE-DECRYPT M S N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (M$6 M) (K2$3 K1))
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= K K1))
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= K K2))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(CASES)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(USE NOT-PART-IMPLIES-NOT-COMP-OF-LEMMA (S (SETADD K S)) (N (- N 1)))
(SIMPLIFY)
(REARRANGE)
(INSTANTIATE (M$0 (SHARE-ENCRYPT M K1 K2)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (M$4 M) (K2$0 K2))
(WITH-DISABLED (PARTS)
 (REWRITE))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INVOKE (COMP-FROM-SHARE-DECRYPT-INVERSE M S N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (M$6 M) (K2$3 K1))
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= K K1))
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= K K2))
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= (INVERSE K1) K))
(EQUALITY-SUBSTITUTE K)
(WITH-DISABLED (PARTS)
 (REWRITE))
(SPLIT (= (INVERSE K2) K))
(EQUALITY-SUBSTITUTE K)
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (K1$0 K1) (K2$0 K2))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(USE NOT-PART-IMPLIES-NOT-COMP-OF-LEMMA (S (SETADD K S)) (N (- N 1)))
(SIMPLIFY)
(REARRANGE)
(INSTANTIATE (M$0 (COMBINE M D2)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INVOKE (COMP-FROM-DECOMBINE-LEFT M S N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (D2$0 D2))
(INSTANTIATE (M$3 (COMBINE M D2)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(CASES)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(USE NOT-PART-IMPLIES-NOT-COMP-OF-LEMMA (S (SETADD K S)) (N (- N 1)))
(SIMPLIFY)
(REARRANGE)
(INSTANTIATE (M$0 (COMBINE D1 M)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INVOKE (COMP-FROM-DECOMBINE-RIGHT M S N))
(WITH-DISABLED (PARTS)
 (REWRITE))
(INSTANTIATE (D1$0 D1))
(INSTANTIATE (M$3 (COMBINE D1 M)))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(INSTANTIATE (M$0 M))
(WITH-DISABLED (PARTS)
 (REWRITE))
(NEXT)

(rule comp-of-aux-setadd-fresh (m1 m2 s n)
  (implies (and (in m2 (atomic-messages))
                (is-fresh m2 s)
                (not (= m1 m2)))
           (= (comp-of-aux m1 (setadd m2 s) n)
              (comp-of-aux m1 s n))))
(SPLIT (COMP-OF-AUX M1 S N))
(REWRITE)
(INVOKE ATOMIC-MESSAGES)
(REWRITE)
(USE COMP-OF-AUX-SETADD-KEY (K M2) (S S) (N N))
(INSTANTIATE (M M1))
(REWRITE)

(rule comp-of-setadd-fresh (m1 m2 s)
  (implies (and (in m2 (atomic-messages))
                (is-fresh m2 s)
                (not (= m1 m2)))
           (= (comp-of m1 (setadd m2 s))
              (comp-of m1 s))))
(INVOKE COMP-OF)
(REWRITE)

;;; the inductive property of comp-of

(function is-closed-under-decryption (S) ()
  (all (m k)
    (implies (and (in m (messages))
                  (in k (keys))
                  (in (encrypt m k) S)
		  (in (inverse k) S))
             (in m S))))

(function is-closed-under-share-decryption (S) ()
  (all (m k1 k2)
    (implies (and (in m (messages))
                  (in k1 (asymmetric-keys))
                  (in k2 (asymmetric-keys))
                  (in (share-encrypt m k1 k2) S)
		  (or (subset (make-set k1 k2) S)
		      (subset (make-set (inverse k1) (inverse k2)) S)))
	     (in m S))))

;; this says { m | comp-of m S } is the smallest set T with a closure property
(axiom comp-of-smallest-closed-lemma (n S T)
  (implies (and (subset S T)
		(is-closed-under-decombination T)
		(is-closed-under-decryption T)
		(is-closed-under-share-decryption T))
	   (all (m) (implies (comp-of-aux m S n) (in m T)))))
(INDUCT (NAT!WEAK-INDUCTION N))
(INVOKE NAT!ZEROP)
(CASES)
(PRENEX)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(WITHOUT-NORMALIZATION (SIMPLIFY))
(INVOKE SUBSET)
(REWRITE)
(NEXT)
(PRENEX)
(REWRITE)
(APPLY COMP-OF-AUX-DEFINITION (COMP-OF-AUX M S N))
(WITHOUT-NORMALIZATION (SIMPLIFY))
(CONJUNCTIVE)
(CASES)
(INVOKE COMP-FROM-DECRYPT)
(PRENEX)
(REWRITE)
(INVOKE IS-CLOSED-UNDER-DECRYPTION)
(INSTANTIATE (M$0 M) (K$0 K))
(REARRANGE)
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT)
(PRENEX)
(REWRITE)
(INVOKE IS-CLOSED-UNDER-SHARE-DECRYPTION)
(INSTANTIATE (M$0 M) (K1$0 K1) (K2$0 K2))
(REARRANGE)
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE COMP-FROM-SHARE-DECRYPT-INVERSE)
(PRENEX)
(REWRITE)
(INVOKE IS-CLOSED-UNDER-SHARE-DECRYPTION)
(INSTANTIATE (M$0 M) (K1$0 K1) (K2$0 K2))
(REARRANGE)
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-LEFT)
(PRENEX)
(REWRITE)
(INVOKE IS-CLOSED-UNDER-DECOMBINATION)
(INSTANTIATE (M1 M) (M2 D2))
(REARRANGE)
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-DECOMBINE-RIGHT)
(PRENEX)
(REWRITE)
(INVOKE IS-CLOSED-UNDER-DECOMBINATION)
(INSTANTIATE (M1 D1) (M2 M))
(REARRANGE)
(REWRITE)
(NEXT)
(INVOKE COMP-FROM-RECURSION)
(SIMPLIFY)
(NEXT)
(INVOKE SUBSET)
(SIMPLIFY)
(NEXT)

(axiom comp-of-smallest-closed (m S T)
  (implies (and (comp-of m S)
		(subset S T)
		(is-closed-under-decombination T)
		(is-closed-under-decryption T)
		(is-closed-under-share-decryption T))
	   (in m T)))
(INVOKE COMP-OF)
(PRENEX)
(use comp-of-smallest-closed-lemma (S S)(T T)(N N))
(simplify)

;;; a stronger rule for comp-of-setadd-encrypt

(disabled
 (rule comp-of-setadd-encrypt (m msg key ms)
   (implies (and (in m (messages))
		 (in msg (messages))
		 (in key (keys)))
	    (= (comp-of m (setadd (encrypt msg key) ms))
	       (or (= m (encrypt msg key))
		   (comp-of m ms)
		   (and (comp-of (inverse key) ms)
			(comp-of m (setadd msg ms))))))))
(REWRITE)
(USE COMP-OF-TRANSITIVE
     (M M) (S1 (SETADD MSG MS)) (S2 (SETADD (ENCRYPT MSG KEY) MS)))
(REARRANGE)
(REWRITE)
(USE B2 (C MSG) (K KEY) (S (SETADD (ENCRYPT MSG KEY) MS)))
(REARRANGE)
(REWRITE)
