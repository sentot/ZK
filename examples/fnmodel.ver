;;;
;;; The theory of functions
;;;

(load setrules)
(load rel)

;;; is-function

(function is-function (f) ()
  (and (rel!is-relation f)
       (all (a b c)
	 (implies (and (in (pair!pair a b) f)
		       (in (pair!pair a c) f))
		  (= b c)))))

(axiom is-function-bool (f)
  (= (type-of (is-function f))
     (bool)))
(SIMPLIFY)

(grule function-is-relation (f)
  (implies (is-function f)
	   (rel!is-relation f)))
(REDUCE)

(axiom function-is-relation-2 (f)
  (implies (not (rel!is-relation f))
	   (= (is-function f) (false))))
(REDUCE)

(axiom function-property (f a b c)
  (implies (and (is-function f)
		(in (pair!pair a b) f)
		(in (pair!pair a c) f))
	   (= b c)))
(INVOKE IS-FUNCTION)
(REARRANGE)
(SIMPLIFY)


(axiom is-function-subset (x y)
  (implies (and (is-function y)
		(subset x y))
	   (is-function x)))
(REDUCE)
(INSTANTIATE (A A$0) (B B$0) (C C$0))
(USE REL!IS-RELATION-MONOTONIC (X X) (Y Y))
(REDUCE)
(SPLIT (AND (IN (PAIR!PAIR A B) X) (IN (PAIR!PAIR A C) X)))
(SIMPLIFY)


;;; apply

(zf-function apply (f x)
  (that y (if (and (is-function f)
		   (in x (rel!dom f)))
	      (in (pair!pair x y) f)
	      (= y (nullset)))))
(SPLIT (AND (IS-FUNCTION F)
	    (IN X (REL!DOM F))))
(SIMPLIFY)
(INSTANTIATE (Y$1 (NULLSET)))
(INSTANTIATE (Y$0 (NULLSET)))
(SIMPLIFY)
(WITH-ENABLED (REL!IN-DOM) (REDUCE))
(INSTANTIATE (Y B$0))
(INSTANTIATE (A X) (B$0 B) (C Y-0))
(SIMPLIFY)

(axiom apply-definition (f x)
  (implies (and (is-function f)
		(in x (rel!dom f)))
	   (in (pair!pair x (apply f x)) f)))
(USE APPLY.DEFINITION (F F) (X X))
(SIMPLIFY)

(axiom apply-unique (f x y)
  (implies (and (is-function f)
		(in (pair!pair x y) f))
	   (= y (apply f x))))
(USE APPLY.DEFINITION (F F) (X X))
(REWRITE)
(WITH-ENABLED (REL!IN-DOM) (REDUCE))

(axiom apply-in-ran (f x)
  (implies (and (is-function f)
		(in x (rel!dom f)))
	   (in (apply f x) (rel!ran f))))
(USE APPLY-DEFINITION (F F) (X X))
(REWRITE)

(axiom function-element (f x)
  (implies (is-function f)
	   (= (in x f)
	      (and (pair!is-pair x)
		   (in (pair!fst x) (rel!dom f))
		   (= (pair!snd x) (apply f (pair!fst x)))))))
(USE APPLY-UNIQUE (F F) (X (PAIR!FST X)) (Y (PAIR!SND X)))
(USE APPLY-DEFINITION (F F) (X (PAIR!FST X)))
(SPLIT (AND (IN X F)
	    (IS-FUNCTION F)))
(REWRITE)
(WITH-ENABLED (REL!IS-RELATION REL!IN-DOM) (REDUCE))
(INSTANTIATE (X$0 X))
(INSTANTIATE (B$0 (PAIR!SND X)))
(REWRITE)

(axiom function-extensionality (f g)
  (implies (and (is-function f)
		(is-function g))
	   (= (= f g)
	      (and (= (rel!dom f) (rel!dom g))
		   (all (x) (implies (in x (rel!dom f))
				     (= (apply f x) (apply g x))))))))
(USE =.EXTENSIONAL (X F) (Y G))
(SPLIT (= F G))
(SIMPLIFY)
(PRENEX)
(USE FUNCTION-ELEMENT (F F) (X E))
(USE FUNCTION-ELEMENT (F G) (X E))
(SIMPLIFY)
(INSTANTIATE (X (PAIR!FST E)))
(SIMPLIFY)

(axiom in-ran-function (x f)
  (implies (is-function f)
	   (= (in x (rel!ran f))
	      (some (y) (and (in y (rel!dom f))
			     (= x (apply f y)))))))
(SPLIT (IN X (REL!RAN F)))
(SIMPLIFY)
(WITH-ENABLED (REL!IN-RAN) (REWRITE))
(CASES)
(INSTANTIATE (Y A))
(USE APPLY-UNIQUE (F F) (X A) (Y X))
(REWRITE)
(NEXT)
(PRENEX)
(USE APPLY-DEFINITION (F F) (X Y))
(SIMPLIFY)
(INSTANTIATE (A Y))
(SIMPLIFY)
(NEXT)

(disabled
  (rule function-ran-subset (f s)
    (implies (is-function f)
	     (= (subset (rel!ran f) s)
		(all (x) (implies (in x (rel!dom f))
				  (in (apply f x) s)))))))
(SPLIT (AND (IS-FUNCTION F)
	    (SUBSET (REL!RAN F) S)))
(SIMPLIFY)
(USE APPLY-UNIQUE (F F))
(INVOKE SUBSET)
(WITH-ENABLED (REL!IN-RAN REL!IN-DOM) (REWRITE))
(CASES)
(INSTANTIATE (X X$0) (Y B))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (X A) (Y E))
(INSTANTIATE (X$0 A) (B E))
(SIMPLIFY)
(NEXT)

(axiom function-image-unit (f x)
  (implies (and (is-function f)
		(in x (rel!dom f)))
	   (= (rel!image f (unit x))
	      (unit (apply f x)))))
(APPLY SETRULES!EXTENSIONALITY)
(USE APPLY-UNIQUE (F F) (X X))
(USE APPLY.DEFINITION (F F) (X X))
(WITH-ENABLED (REL!IN-IMAGE) (REWRITE))
(INSTANTIATE (Y E))
(SIMPLIFY)

(axiom function-image-setadd (f x y)
  (implies (and (is-function f)
		(in x (rel!dom f)))
	   (= (rel!image f (setadd x y))
	      (setadd (apply f x) (rel!image f y)))))
(USE REL!IMAGE-OF-UNION (R F) (X (UNIT X)) (Y Y))
(USE FUNCTION-IMAGE-UNIT (F F) (X X))
(REWRITE)
(EQUALITY-SUBSTITUTE (REL!IMAGE F (SETADD X (NULLSET))))
(REWRITE)


(rule in-pre-image-of-function (x f y)
  (implies (is-function f)
	   (= (in x (rel!image (rel!inverse f) y))
	      (and (in x (rel!dom f))
		   (in (apply f x) y)))))
(USE REL!IN-IMAGE (R (REL!INVERSE F)) (X Y) (Y X))
(SPLIT (IN X (REL!IMAGE (REL!INVERSE F) Y)))
(REWRITE)
(CASES)
(PRENEX)
(USE APPLY-UNIQUE (F F) (X X) (Y Z))
(REWRITE)
(NEXT)
(INSTANTIATE (Z$0 (APPLY F X)))
(USE APPLY-DEFINITION (F F) (X X))
(REWRITE)
(NEXT)

(rule ran-dom-remove-function (x r)
  (implies (is-function (rel!inverse r))
	   (= (rel!ran (rel!dom-remove x r))
	      (diff (rel!ran r) (rel!image r x)))))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL) (REWRITE))
(PRENEX)
(CASES)
(PRENEX)
(USE FUNCTION-PROPERTY (F (REL!INVERSE R)) (A E) (B A) (C Z))
(REWRITE)
(NEXT)
(INSTANTIATE (Z$0 A))
(SIMPLIFY)
(NEXT)

(rule dom-ran-remove-function (r x)
  (implies (is-function r)
	   (= (rel!dom (rel!ran-remove r x))
	      (diff (rel!dom r) (rel!image (rel!inverse r) x)))))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL) (REWRITE))
(PRENEX)
(CASES)
(PRENEX)
(USE APPLY-UNIQUE (F R) (X E) (Y B))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (B$0 B))
(USE APPLY-UNIQUE (F R) (X E) (Y B))
(SIMPLIFY)
(NEXT)

(axiom apply-subset (f g x)
  (implies (and (is-function g)
		(subset f g)
		(in x (rel!dom f)))
	   (= (apply f x) (apply g x))))
(USE IS-FUNCTION-SUBSET (X F) (Y G))
(USE APPLY-UNIQUE (F G) (X X) (Y (APPLY F X)))
(USE APPLY-DEFINITION (F F) (X X))
(REARRANGE)
(INVOKE SUBSET)
(SIMPLIFY)


;;; 
;;; particular functions

;;; Nullset

(rule is-function-nullset ()
  (= (is-function (nullset))
     (true)))
(REDUCE)

;;; Unit sets

(rule is-function-unit (x)
  (= (is-function (unit x))
     (pair!is-pair x)))
(REDUCE)

(rule apply-unit-pair (x y z)
  (implies (= z x)
	   (= (apply (unit (pair!pair x y)) z)
	      y)))
(USE APPLY-DEFINITION (F (UNIT (PAIR!PAIR X Y))) (X X))
(WITH-DISABLED (SETRULES!UNIT-TO-SETADD) (REWRITE))

;;; Union

(rule is-function-union (f g)
  (= (is-function (union f g))
     (and (is-function f)
	  (is-function g)
	  (all (x) (implies (in x (inter (rel!dom f) (rel!dom g)))
			    (= (apply f x) (apply g x)))))))
(SPLIT (IS-FUNCTION (UNION F G)))
(CASES)
(SIMPLIFY)
(USE IS-FUNCTION-SUBSET (X F) (Y (UNION F G)))
(USE IS-FUNCTION-SUBSET (X G) (Y (UNION F G)))
(PRENEX)
(USE APPLY-SUBSET (F F) (G (UNION F G)) (X X))
(USE APPLY-SUBSET (F G) (G (UNION F G)) (X X))
(REARRANGE)
(REWRITE)
(NEXT)
(SIMPLIFY)
(SPLIT (AND (IS-FUNCTION F)
	    (IS-FUNCTION G)))
(SIMPLIFY)
(INVOKE (IS-FUNCTION (UNION F G)))
(PRENEX)
(REWRITE)
(CASES)
(CASES)
(USE APPLY-UNIQUE (F F) (X A) (Y B))
(USE APPLY-UNIQUE (F F) (X A) (Y C))
(SIMPLIFY)
(NEXT)
(USE APPLY-UNIQUE (F G) (X A) (Y C))
(USE APPLY-DEFINITION (F F) (X A))
(INSTANTIATE (X A))
(WITH-ENABLED (REL) (REWRITE))
(NEXT)
(CASES)
(USE APPLY-DEFINITION (F F) (X A))
(USE APPLY-UNIQUE (F G) (X A) (Y B))
(REARRANGE)
(INSTANTIATE (X A))
(REWRITE)
(NEXT)
(USE APPLY-UNIQUE (F G) (X A) (Y B))
(USE APPLY-UNIQUE (F G) (X A) (Y C))
(SIMPLIFY)
(NEXT)

(axiom apply-union-lemma (f g x)
  (implies (and (is-function (union f g))
		(in x (rel!dom f))
		(in x (rel!dom g)))
	   (= (apply f x)
	      (apply g x))))
(REWRITE)

(rule apply-union (f g x)
  (implies (and (is-function (union f g))
		(in x (rel!dom (union f g))))
	   (= (apply (union f g) x)
	      (if (in x (rel!dom f))
		  (apply f x)
		  (apply g x)))))
(USE APPLY-DEFINITION (F (UNION F G)) (X X))
(USE APPLY-UNIQUE (F F) (X X) (Y (APPLY (UNION F G) X)))
(USE APPLY-UNIQUE (F G) (X X) (Y (APPLY (UNION F G) X)))
(USE IS-FUNCTION-SUBSET (X F) (Y (UNION F G)))
(USE IS-FUNCTION-SUBSET (X G) (Y (UNION F G)))
(REARRANGE)
(WITH-DISABLED (IS-FUNCTION-UNION) (REWRITE))
(USE REL!IN-DOM-1 (A X) (B (APPLY (UNION F G) X)) (X F))
(USE REL!IN-DOM-1 (A X) (B (APPLY (UNION F G) X)) (X G))
(USE APPLY-UNION-LEMMA (F F) (G G) (X X))
(USE REL!IN-DOM (A X) (X F))
(SIMPLIFY)

;;; Setadd

(rule is-function-setadd (f x)
  (= (is-function (setadd x f))
     (and (is-function f)
	  (pair!is-pair x)
	  (implies (in (pair!fst x) (rel!dom f))
		   (in x f)))))
(USE IS-FUNCTION-UNION (F (UNIT X)) (G F))
(USE IS-FUNCTION-UNIT (X X))
(REWRITE)
(USE APPLY-DEFINITION (F F) (X (PAIR!FST X)))
(USE APPLY-DEFINITION (F (UNIT X)) (X (PAIR!FST X)))
(REARRANGE)
(EQUALITY-SUBSTITUTE X$0)
(REWRITE)
(SPLIT (IS-FUNCTION (SETADD X F)))
(USE APPLY-UNIQUE
     (F F)
     (X (PAIR!FST X))
     (Y (APPLY (SETADD X (NULLSET)) (PAIR!FST X))))
(REARRANGE)
(SIMPLIFY)

(rule apply-setadd (f x y)
  (implies (and (is-function (setadd x f))
		(in y (rel!dom (setadd x f))))
	   (= (apply (setadd x f) y)
	      (if (= y (pair!fst x))
		  (pair!snd x)
		  (apply f y)))))
(USE APPLY-UNION (F (UNIT X)) (G F) (X Y))
(USE APPLY-DEFINITION (F (UNIT X)) (X Y))
(REARRANGE)
(WITH-DISABLED (SETRULES!SUBSET-SETADD) (REWRITE))


;;; Comp

(rule is-function-comp-functions (f g)
  (implies (and (is-function f)
		(is-function g))
	   (= (is-function (rel!comp f g)) (true))))
(INVOKE (IS-FUNCTION (REL!COMP F G)))
(WITH-ENABLED (REL!IN-COMP) (REWRITE))
(PRENEX)
(USE FUNCTION-PROPERTY (F F) (A A) (B Y) (C Y$0))
(USE FUNCTION-PROPERTY (F G) (A Y) (B B) (C C))
(SIMPLIFY)

(rule apply-comp (f g x)
  (implies (and (is-function f)
		(is-function g)
		(in x (rel!dom f))
		(in (apply f x) (rel!dom g)))
	   (= (apply (rel!comp f g) x)
	      (apply g (apply f x)))))
(USE APPLY-DEFINITION (F F) (X X))
(USE APPLY-DEFINITION (F G) (X (APPLY F X)))
(USE APPLY-UNIQUE (F (REL!COMP F G)) (X X) (Y (APPLY G (APPLY F X))))
(REARRANGE)
(WITH-ENABLED (REL!IN-COMP) (REWRITE))
(INSTANTIATE (Y (APPLY F X)))
(SIMPLIFY)

;;; Id

(rule is-function-id (x)
  (= (is-function (rel!id x))
     (true)))
(REDUCE)

(rule apply-id (x y)
  (implies (in y x)
	   (= (apply (rel!id x) y)
	      y)))
(USE APPLY-DEFINITION (F (REL!ID X)) (X Y))
(REWRITE)

;;; Dom-restrict

(rule is-function-dom-restrict (x f)
  (implies (is-function f)
	   (= (is-function (rel!dom-restrict x f)) (true))))
(USE IS-FUNCTION-SUBSET (X (REL!DOM-RESTRICT X F)) (Y F))
(USE REL!DOM-RESTRICT-SUBSET (X X)(R F))
(SIMPLIFY)

(rule apply-dom-restrict-function (s f x)
  (implies (and (is-function f)
		(in x s)
		(in x (rel!dom f)))
	   (= (apply (rel!dom-restrict s f) x)
	      (apply f x))))
(USE APPLY-SUBSET (F (REL!DOM-RESTRICT S F)) (G F) (X X))
(USE REL!DOM-RESTRICT-SUBSET (X S) (R F))
(REWRITE)

;;; Ran-restrict

(rule is-function-ran-restrict (f x)
  (implies (is-function f)
	   (= (is-function (rel!ran-restrict f x)) (true))))
(USE IS-FUNCTION-SUBSET (X (REL!RAN-RESTRICT F X)) (Y F))
(USE REL!RAN-RESTRICT-SUBSET (X X)(R F))
(SIMPLIFY)

(rule apply-ran-restrict-function (s f x)
  (implies (and (is-function f)
		(in x (rel!dom f))
		(in (apply f x) s))
	   (= (apply (rel!ran-restrict f s) x)
	      (apply f x))))
(USE APPLY-SUBSET (F (REL!RAN-RESTRICT F S)) (G F) (X X))
(USE REL!RAN-RESTRICT-SUBSET (X S) (R F))
(REWRITE)

;;; Dom-restrict

(rule is-function-dom-remove (x f)
  (implies (is-function f)
	   (= (is-function (rel!dom-remove x f)) (true))))
(USE IS-FUNCTION-SUBSET (X (REL!DOM-REMOVE X F)) (Y F))
(USE REL!DOM-REMOVE-SUBSET (X X)(R F))
(SIMPLIFY)

(rule apply-dom-remove-function (s f x)
  (implies (and (is-function f)
		(not (in x s))
		(in x (rel!dom f)))
	   (= (apply (rel!dom-remove s f) x)
	      (apply f x))))
(USE APPLY-SUBSET (F (REL!DOM-REMOVE S F)) (G F) (X X))
(USE REL!DOM-REMOVE-SUBSET (X S) (R F))
(REWRITE)

;;; Ran-remove

(rule is-function-ran-remove (f x)
  (implies (is-function f)
	   (= (is-function (rel!ran-remove f x)) (true))))
(USE IS-FUNCTION-SUBSET (X (REL!RAN-REMOVE F X)) (Y F))
(USE REL!RAN-REMOVE-SUBSET (X X)(R F))
(SIMPLIFY)

(rule apply-ran-remove-function (s f x)
  (implies (and (is-function f)
		(in x (rel!dom f))
		(not (in (apply f x) s)))
	   (= (apply (rel!ran-remove f s) x)
	      (apply f x))))
(USE APPLY-SUBSET (F (REL!RAN-REMOVE F S)) (G F) (X X))
(USE REL!RAN-REMOVE-SUBSET (X S) (R F))
(REWRITE)


;;; overriding

(function override (f g) ()
  (union (rel!dom-remove (rel!dom g) f) g))

(rule is-relation-override (f g)
  (implies (and (rel!is-relation f)
		(rel!is-relation g))
	   (= (rel!is-relation (override f g)) (true))))
(REDUCE)

(rule is-function-override (f g)
  (implies (and (is-function f)
		(is-function g))
	   (= (is-function (override f g)) (true))))
(INVOKE OVERRIDE)
(REWRITE)

(rule dom-override (f g)
  (= (rel!dom (override f g))
     (union (rel!dom f) (rel!dom g))))
(APPLY SETRULES!EXTENSIONALITY)
(REDUCE)

(axiom ran-override (f g)
  (subset (rel!ran (override f g))
	  (union (rel!ran f) (rel!ran g))))
(INVOKE OVERRIDE)
(USE REL!DOM-REMOVE-SUBSET (R F) (X (REL!DOM G)))
(REWRITE)

(rule apply-override (f g x)
  (implies (and (is-function f)
		(is-function g)
		(or (in x (rel!dom f)) (in x (rel!dom g))))
	   (= (apply (override f g) x)
	      (if (in x (rel!dom g))
		  (apply g x)
		  (apply f x)))))
(USE APPLY-UNIQUE
     (F (OVERRIDE F G))
     (X X)
     (Y (IF (IN X (REL!DOM G)) (APPLY G X) (APPLY F X))))
(REARRANGE)
(REWRITE)
(USE APPLY-DEFINITION (F F) (X X))
(USE APPLY-DEFINITION (F G) (X X))
(REARRANGE)
(INVOKE OVERRIDE)
(REWRITE)

(rule override-idempotent (f)
  (= (override f f) f))
(REDUCE)

(rule override-associative (f g h)
  (= (override (override f g) h)
     (override f (override g h))))
(INVOKE OVERRIDE)
(REWRITE)
(USE =.EXTENSIONAL
     (X (UNION (REL!DOM G) (REL!DOM H)))
     (Y (UNION (DIFF (REL!DOM G) (REL!DOM H)) (REL!DOM H))))
(REWRITE)

(rule override-nullset-left (f)
  (= (override (nullset) f)
     f))
(REDUCE)

(rule override-nullset-right (f)
  (implies (rel!is-relation f)
	   (= (override f (nullset))
	      f)))
(REDUCE)


;;; function spaces
;;;

;;; (pfun X Y) - partial functions from X to Y

(zf-function pfun (x y)
    (select (f (rel!rel x y))
	    (is-function f)))

(rule in-pfun (f x y)
   (= (in f (pfun x y))
      (and (is-function f)
	   (subset (rel!dom f) x)
	   (subset (rel!ran f) y))))
(WITH-ENABLED (REL!IN-REL) (REWRITE))
(SPLIT (IS-FUNCTION F))
(SIMPLIFY)

(disabled
 (rule in-pfun-1 (f x y)
   (= (in f (pfun x y))
      (and (is-function f)
	   (subset (rel!dom f) x)
	   (all (z) (implies (in z (rel!dom f))
			     (in (apply f z) y)))))))
(SPLIT (IN F (PFUN X Y)))
(SIMPLIFY)
(WITH-ENABLED (FUNCTION-RAN-SUBSET) (REWRITE))

;;; (fun X Y) - functions from X to Y

(zf-function fun (x y)
  (select (f (pfun x y))
	  (= (rel!dom f) x)))

(rule in-fun (f x y)
   (= (in f (fun x y))
      (and (is-function f)
	   (= (rel!dom f) x)
	   (subset (rel!ran f) y))))
(REWRITE)
(USE SUBSET.SELF (S X))
(SIMPLIFY)

(disabled
 (rule in-fun-1 (f x y)
   (= (in f (fun x y))
      (and (is-function f)
	   (= (rel!dom f) x)
	   (all (z) (implies (in z x)
			     (in (apply f z) y)))))))
(SPLIT (IN F (FUN X Y)))
(SIMPLIFY)
(WITH-ENABLED (FUNCTION-RAN-SUBSET) (REWRITE))
(PRENEX)
(SIMPLIFY)

;;; (surj X Y) - functions from X onto Y

(zf-function surj (x y)
  (select (f (fun x y))
	  (= (rel!ran f) y)))

(rule in-surj (f x y)
  (= (in f (surj x y))
     (and (is-function f)
	  (= (rel!dom f) x)
	  (= (rel!ran f) y))))
(REWRITE)
(USE SUBSET.SELF (S Y))
(SIMPLIFY)

;;; (psurj X Y) - partial functions from X onto Y

(zf-function psurj (x y)
  (select (f (pfun x y))
	  (= (rel!ran f) y)))

(rule in-psurj (f x y)
  (= (in f (psurj x y))
     (and (is-function f)
	  (subset (rel!dom f) x)
	  (= (rel!ran f) y))))
(REWRITE)
(USE SUBSET.SELF (S Y))
(SIMPLIFY)

;;; (inj X Y) - injective functions from X to Y

(zf-function inj (x y)
  (select (f (fun x y))
	  (is-function (rel!inverse f))))

(axiom in-inj (f x y)
   (= (in f (inj x y))
      (and (is-function f)
	   (is-function (rel!inverse f))
	   (= (rel!dom f) x)
	   (subset (rel!ran f) y))))
(REWRITE)

;;; (pinj X Y) - injective partial functions from X to Y

(zf-function pinj (x y)
  (select (f (pfun x y))
	  (is-function (rel!inverse f))))

(rule in-pinj (f x y)
  (= (in f (pinj x y))
     (and (is-function f)
	  (is-function (rel!inverse f))
	  (subset (rel!dom f) x)
	  (subset (rel!ran f) y))))
(REWRITE)

;;; (bij X Y) - bijective functions from X to Y

(zf-function bij (x y)
  (select (f (surj x y))
	  (is-function (rel!inverse f))))

(rule in-bij (f x y)
  (= (in f (bij x y))
     (and (is-function f)
	  (is-function (rel!inverse f))
	  (= (rel!dom f) x)
	  (= (rel!ran f) y))))
(REWRITE)


;;;
;;; properties of the spaces
;;;

;;; very sketchy at the moment


(rule pfun-nullset-left (x)
  (= (pfun (nullset) x)
     (unit (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY PFUN.DEFINITION)
(REWRITE)

(rule pfun-nullset-right (x)
  (= (pfun x (nullset))
     (unit (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY PFUN.DEFINITION)
(REWRITE)

(rule fun-nullset-left (x)
  (= (fun (nullset) x)
     (unit (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY FUN.DEFINITION)
(REWRITE)

(rule fun-nullset-right (x)
  (= (fun x (nullset))
     (if (= x (nullset))
	 (unit (nullset))
	 (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY FUN.DEFINITION)
(REWRITE)
(USE SETRULES!SET-CASES (X X))
(SIMPLIFY)

(rule surj-nullset-left (x)
  (= (surj (nullset) x)
     (if (= x (nullset))
	 (unit (nullset))
	 (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY SURJ.DEFINITION)
(REWRITE)
(USE SETRULES!SET-CASES (X X))
(SIMPLIFY)

(rule surj-nullset-right (x)
  (= (surj x (nullset))
     (if (= x (nullset))
	 (unit (nullset))
	 (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY SURJ.DEFINITION)
(REWRITE)
(USE SETRULES!SET-CASES (X X))
(SIMPLIFY)

(rule psurj-nullset-left (x)
  (= (psurj (nullset) x)
     (if (= x (nullset))
	 (unit (nullset))
	 (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY PSURJ.DEFINITION)
(REWRITE)
(USE SETRULES!SET-CASES (X X))
(SIMPLIFY)

(rule psurj-nullset-right (x)
  (= (psurj x (nullset))
     (unit (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY PSURJ.DEFINITION)
(REWRITE)

(rule pinj-nullset-left (x)
  (= (pinj (nullset) x)
     (unit (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY PINJ.DEFINITION)
(REWRITE)

(rule pinj-nullset-right (x)
  (= (pinj x (nullset))
     (unit (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY PINJ.DEFINITION)
(REWRITE)

(rule inj-nullset-left (x)
  (= (inj (nullset) x)
     (unit (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY INJ.DEFINITION)
(REWRITE)

(rule inj-nullset-right (x)
  (= (inj x (nullset))
     (if (= x (nullset))
	 (unit (nullset))
	 (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY INJ.DEFINITION)
(REWRITE)
(USE SETRULES!SET-CASES (X X))
(SIMPLIFY)

(rule bij-nullset-left (x)
  (= (bij (nullset) x)
     (if (= x (nullset))
	 (unit (nullset))
	 (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY BIJ.DEFINITION)
(REWRITE)
(USE SETRULES!SET-CASES (X X))
(SIMPLIFY)

(rule bij-nullset-right (x)
  (= (bij x (nullset))
     (if (= x (nullset))
	 (unit (nullset))
	 (nullset))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY BIJ.DEFINITION)
(REWRITE)
(USE SETRULES!SET-CASES (X X))
(SIMPLIFY)

;(rule nullset-in-fun (x y)
;  (= (in (nullset) (fun x y))
;     (= x (nullset))))
;(REWRITE)

;(rule in-fun-is-function (f x y)
;  (implies (in f (fun x y))
;	   (is-function f)))
;(REWRITE)

;(rule in-fun-dom (f x y)
;  (implies (in f (fun x y))
;	   (= (rel!dom f) x)))
;(REWRITE)

;(axiom in-fun-apply (f x a b)
;  (implies (and (in f (fun a b))
;		(in x a))
;	   (in (apply f x) b)))
;(WITH-ENABLED (IN-FUN-1) (REWRITE))

;(rule comp-in-fun (f g x y z)
;  (implies (and (in f (fun x y))
;		(in g (fun y z)))
;	   (in (rel!comp f g) (fun x z))))
;(REWRITE)
;(USE REL!IMAGE-SUBSET-RAN (R G) (X (REL!RAN F)))
;(REWRITE)
