(load ms)
(load tuple)
(load seq)
(load fn)

(disabled
  (function make-state (seen-messages stores history) ()
    (tuple!3tuple seen-messages stores history)))

(disabled
  (function is-state (s) ()
    (some (m st h)
      (= s (make-state m st h)))))

(grule make-state-is-state (m st h)
  (is-state (make-state m st h)))
(WITH-ENABLED (IS-STATE)
 (REDUCE))

(grule is-state-bool (s)
  (= (type-of (is-state s)) (bool)))
(WITH-ENABLED (IS-STATE)
 (REDUCE))

(axiom state-is-constructed (s)
  (implies (is-state s)
           (some (m st h)
             (= s (make-state m st h)))))
(WITH-ENABLED (IS-STATE)
 (REDUCE))

(disabled
  (function seen-messages (state) () (tuple!p1 state)))

(disabled
  (function stores (state) () (tuple!p2 state)))

(disabled
  (function history (state) () (tuple!p3 state)))

(grule seen-messages-of-make-state (seen-messages stores history)
  (= (seen-messages (make-state seen-messages stores history))
     seen-messages))
(WITH-ENABLED (MAKE-STATE SEEN-MESSAGES) (REDUCE))

(grule stores-of-make-state (seen-messages stores history)
  (= (stores (make-state seen-messages stores history))
     stores))
(WITH-ENABLED (MAKE-STATE STORES) (REDUCE))

(grule history-of-make-state (seen-messages stores history)
  (= (history (make-state seen-messages stores history))
     history))
(WITH-ENABLED (MAKE-STATE HISTORY) (REDUCE))

(disabled (function tag-of-event (event) () (tuple!p1 event)))

(disabled
  (function make-send-event (label time message principal) ()
    (tuple!5tuple 0 label time message principal)))

(disabled
  (function make-receive-event (label time message principal) ()
    (tuple!5tuple 1 label time message principal)))

(disabled
  (function make-out-of-band-event (label time message sender receiver) ()
    (tuple!6tuple 2 label time message sender receiver)))

(disabled
  (function make-generate-event (label time message principal) ()
    (tuple!5tuple 3 label time message principal)))

(disabled
  (function make-construct-event (label time message principal) ()
    (tuple!5tuple 4 label time message principal)))

(disabled
  (function make-intruder-event (label time message) ()
    (tuple!4tuple 5 label time message)))

(grule tag-of-make-send-event (label time message principal)
  (= (tag-of-event (make-send-event label time message principal)) 0))
(WITH-ENABLED (TAG-OF-EVENT MAKE-SEND-EVENT) (REDUCE))

(grule tag-of-make-receive-event (label time message principal)
  (= (tag-of-event (make-receive-event label time message principal)) 1))
(WITH-ENABLED (TAG-OF-EVENT MAKE-RECEIVE-EVENT) (REDUCE))

(grule tag-of-make-out-of-band-event (label time message sender receiver)
  (= (tag-of-event (make-out-of-band-event label time message sender receiver))
     2))
(WITH-ENABLED (TAG-OF-EVENT MAKE-OUT-OF-BAND-EVENT) (REDUCE))

(grule tag-of-make-generate-event (label time message principal)
  (= (tag-of-event (make-generate-event label time message principal)) 3))
(WITH-ENABLED (TAG-OF-EVENT MAKE-GENERATE-EVENT) (REDUCE))

(grule tag-of-make-construct-event (label time message principal)
  (= (tag-of-event (make-construct-event label time message principal)) 4))
(WITH-ENABLED (TAG-OF-EVENT MAKE-CONSTRUCT-EVENT) (REDUCE))

(grule tag-of-make-intruder-event (label time message)
  (= (tag-of-event (make-intruder-event label time message)) 5))
(WITH-ENABLED (TAG-OF-EVENT MAKE-INTRUDER-EVENT) (REDUCE))

(zf-function send-events ()
  (map (make-send-event l t m p)
    ((l t) (nat!nat)) ((m) (ms!messages)) ((p) (ms!principals))))

(zf-function receive-events ()
  (map (make-receive-event l t m p)
    ((l t) (nat!nat)) ((m) (ms!messages)) ((p) (ms!principals))))

(zf-function out-of-band-events ()
  (map (make-out-of-band-event l t m s r)
    ((l t) (nat!nat)) ((m) (ms!messages)) ((s r) (ms!principals))))

(zf-function generate-events ()
  (map (make-generate-event l t m p)
    ((l t) (nat!nat)) ((m) (ms!messages)) ((p) (ms!principals))))

(zf-function construct-events ()
  (map (make-construct-event l t m p)
    ((l t) (nat!nat)) ((m) (ms!messages)) ((p) (ms!principals))))

(zf-function intruder-events ()
  (map (make-intruder-event l t m)
    ((l t) (nat!nat)) ((m) (ms!messages))))

(axiom send-event-is-constructed (e)
  (implies (in e (send-events))
           (some (l t m p)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in p (ms!principals))
                   (= e (make-send-event l t m p))))))
(WITH-ENABLED (SEND-EVENTS)
 (REDUCE))
(INSTANTIATE (L$0 L) (T$0 T) (M$0 M) (P$0 P))
(SIMPLIFY)

(axiom receive-event-is-constructed (e)
  (implies (in e (receive-events))
           (some (l t m p)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in p (ms!principals))
                   (= e (make-receive-event l t m p))))))
(WITH-ENABLED (RECEIVE-EVENTS)
 (REDUCE))
(INSTANTIATE (L$0 L) (T$0 T) (M$0 M) (P$0 P))
(SIMPLIFY)

(axiom out-of-band-event-is-constructed (e)
  (implies (in e (out-of-band-events))
           (some (l t m s r)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in s (ms!principals))
                   (in r (ms!principals))
                   (= e (make-out-of-band-event l t m s r))))))
(WITH-ENABLED (OUT-OF-BAND-EVENTS)
 (REDUCE))
(INSTANTIATE (L$0 L) (T$0 T) (M$0 M) (S$0 S) (R$0 R))
(SIMPLIFY)

(axiom generate-event-is-constructed (e)
  (implies (in e (generate-events))
           (some (l t m p)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in p (ms!principals))
                   (= e (make-generate-event l t m p))))))
(WITH-ENABLED (GENERATE-EVENTS)
 (REDUCE))
(INSTANTIATE (L$0 L) (T$0 T) (M$0 M) (P$0 P))
(SIMPLIFY)

(axiom construct-event-is-constructed (e)
  (implies (in e (construct-events))
           (some (l t m p)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in p (ms!principals))
                   (= e (make-construct-event l t m p))))))
(WITH-ENABLED (CONSTRUCT-EVENTS)
 (REDUCE))
(INSTANTIATE (L$0 L) (T$0 T) (M$0 M) (P$0 P))
(SIMPLIFY)

(axiom intruder-event-is-constructed (e)
  (implies (in e (intruder-events))
           (some (l t m)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (= e (make-intruder-event l t m))))))
(WITH-ENABLED (INTRUDER-EVENTS)
 (REDUCE))
(INSTANTIATE (L$0 L) (T$0 T) (M$0 M))
(SIMPLIFY)

(frule tag-of-send-event (e)
  (implies (in e (send-events))
           (= (tag-of-event e) 0)))
(USE SEND-EVENT-IS-CONSTRUCTED (E E))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(SIMPLIFY)

(frule tag-of-receive-event (e)
  (implies (in e (receive-events))
           (= (tag-of-event e) 1)))
(USE RECEIVE-EVENT-IS-CONSTRUCTED (E E))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(SIMPLIFY)

(frule tag-of-out-of-band-event (e)
  (implies (in e (out-of-band-events))
           (= (tag-of-event e) 2)))
(USE OUT-OF-BAND-EVENT-IS-CONSTRUCTED (E E))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(SIMPLIFY)

(frule tag-of-generate-event (e)
  (implies (in e (generate-events))
           (= (tag-of-event e) 3)))
(USE GENERATE-EVENT-IS-CONSTRUCTED (E E))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(SIMPLIFY)

(frule tag-of-construct-event (e)
  (implies (in e (construct-events))
           (= (tag-of-event e) 4)))
(USE CONSTRUCT-EVENT-IS-CONSTRUCTED (E E))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(SIMPLIFY)

(frule tag-of-intruder-event (e)
  (implies (in e (intruder-events))
           (= (tag-of-event e) 5)))
(USE INTRUDER-EVENT-IS-CONSTRUCTED (E E))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(SIMPLIFY)

(grule make-send-event-is-send-event (l t m p)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in p (ms!principals)))
           (in (make-send-event l t m p) (send-events))))
(WITH-ENABLED (SEND-EVENTS)
 (REWRITE))

(grule make-receive-event-is-receive-event (l t m p)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in p (ms!principals)))
           (in (make-receive-event l t m p) (receive-events))))
(WITH-ENABLED (RECEIVE-EVENTS)
 (REWRITE))

(grule make-out-of-band-event-is-out-of-band-event (l t m s r)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in s (ms!principals))
                (in r (ms!principals)))
           (in (make-out-of-band-event l t m s r) (out-of-band-events))))
(WITH-ENABLED (OUT-OF-BAND-EVENTS)
 (REWRITE))

(grule make-generate-event-is-generate-event (l t m p)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in p (ms!principals)))
           (in (make-generate-event l t m p) (generate-events))))
(WITH-ENABLED (GENERATE-EVENTS)
 (REWRITE))

(grule make-construct-event-is-construct-event (l t m p)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in p (ms!principals)))
           (in (make-construct-event l t m p) (construct-events))))
(WITH-ENABLED (CONSTRUCT-EVENTS)
 (REWRITE))

(grule make-intruder-event-is-intruder-event (l t m)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages)))
           (in (make-intruder-event l t m) (intruder-events))))
(WITH-ENABLED (INTRUDER-EVENTS)
 (REWRITE))

(disabled
  (function events () ()
    (union (send-events)
           (union (receive-events)
                  (union (out-of-band-events)
                         (union (generate-events)
                                (union (construct-events)
                                       (intruder-events))))))))

(frule send-event-is-event (e)
  (implies (in e (send-events))
           (in e (events))))
(INVOKE EVENTS)
(REWRITE)

(frule receive-event-is-event (e)
  (implies (in e (receive-events))
           (in e (events))))
(INVOKE EVENTS)
(REWRITE)

(frule out-of-band-event-is-event (e)
  (implies (in e (out-of-band-events))
           (in e (events))))
(INVOKE EVENTS)
(REWRITE)

(frule generate-event-is-event (e)
  (implies (in e (generate-events))
           (in e (events))))
(INVOKE EVENTS)
(REWRITE)

(frule construct-event-is-event (e)
  (implies (in e (construct-events))
           (in e (events))))
(INVOKE EVENTS)
(REWRITE)

(frule intruder-event-is-event (e)
  (implies (in e (intruder-events))
           (in e (events))))
(INVOKE EVENTS)
(REWRITE)

(disabled
 (function label-of-event (event) ()
   (tuple!p2 event)))

(grule label-of-send-event (l t m p)
  (= (label-of-event (make-send-event l t m p)) l))
(WITH-ENABLED (LABEL-OF-EVENT MAKE-SEND-EVENT)
 (REDUCE))

(grule label-of-receive-event (l t m p)
  (= (label-of-event (make-receive-event l t m p)) l))
(WITH-ENABLED (LABEL-OF-EVENT MAKE-RECEIVE-EVENT)
 (REDUCE))

(grule label-of-out-of-band-event (l t m s r)
  (= (label-of-event (make-out-of-band-event l t m s r)) l))
(WITH-ENABLED (LABEL-OF-EVENT MAKE-OUT-OF-BAND-EVENT)
 (REDUCE))

(grule label-of-generate-event (l t m p)
  (= (label-of-event (make-generate-event l t m p)) l))
(WITH-ENABLED (LABEL-OF-EVENT MAKE-GENERATE-EVENT)
 (REDUCE))

(grule label-of-construct-event (l t m p)
  (= (label-of-event (make-construct-event l t m p)) l))
(WITH-ENABLED (LABEL-OF-EVENT MAKE-CONSTRUCT-EVENT)
 (REDUCE))

(grule label-of-intruder-event (l t m)
  (= (label-of-event (make-intruder-event l t m)) l))
(WITH-ENABLED (LABEL-OF-EVENT MAKE-INTRUDER-EVENT)
 (REDUCE))

(disabled
 (function time-of-event (event) ()
   (tuple!p3 event)))

(grule time-of-send-event (l t m p)
  (= (time-of-event (make-send-event l t m p)) t))
(WITH-ENABLED (TIME-OF-EVENT MAKE-SEND-EVENT)
 (REDUCE))

(grule time-of-receive-event (l t m p)
  (= (time-of-event (make-receive-event l t m p)) t))
(WITH-ENABLED (TIME-OF-EVENT MAKE-RECEIVE-EVENT)
 (REDUCE))

(grule time-of-out-of-band-event (l t m s r)
  (= (time-of-event (make-out-of-band-event l t m s r)) t))
(WITH-ENABLED (TIME-OF-EVENT MAKE-OUT-OF-BAND-EVENT)
 (REDUCE))

(grule time-of-generate-event (l t m p)
  (= (time-of-event (make-generate-event l t m p)) t))
(WITH-ENABLED (TIME-OF-EVENT MAKE-GENERATE-EVENT)
 (REDUCE))

(grule time-of-construct-event (l t m p)
  (= (time-of-event (make-construct-event l t m p)) t))
(WITH-ENABLED (TIME-OF-EVENT MAKE-CONSTRUCT-EVENT)
 (REDUCE))

(grule time-of-intruder-event (l t m)
  (= (time-of-event (make-intruder-event l t m)) t))
(WITH-ENABLED (TIME-OF-EVENT MAKE-INTRUDER-EVENT)
 (REDUCE))

(disabled
 (function message-of-event (event) ()
   (tuple!p4 event)))

(grule message-of-send-event (l t m p)
  (= (message-of-event (make-send-event l t m p)) m))
(WITH-ENABLED (MESSAGE-OF-EVENT MAKE-SEND-EVENT)
 (REDUCE))

(grule message-of-receive-event (l t m p)
  (= (message-of-event (make-receive-event l t m p)) m))
(WITH-ENABLED (MESSAGE-OF-EVENT MAKE-RECEIVE-EVENT)
 (REDUCE))

(grule message-of-out-of-band-event (l t m s r)
  (= (message-of-event (make-out-of-band-event l t m s r)) m))
(WITH-ENABLED (MESSAGE-OF-EVENT MAKE-OUT-OF-BAND-EVENT)
 (REDUCE))

(grule message-of-generate-event (l t m p)
  (= (message-of-event (make-generate-event l t m p)) m))
(WITH-ENABLED (MESSAGE-OF-EVENT MAKE-GENERATE-EVENT)
 (REDUCE))

(grule message-of-construct-event (l t m p)
  (= (message-of-event (make-construct-event l t m p)) m))
(WITH-ENABLED (MESSAGE-OF-EVENT MAKE-CONSTRUCT-EVENT)
 (REDUCE))

(grule message-of-intruder-event (l t m)
  (= (message-of-event (make-intruder-event l t m)) m))
(WITH-ENABLED (MESSAGE-OF-EVENT MAKE-INTRUDER-EVENT)
 (REDUCE))

(disabled
 (function principal1-of-event (event) ()
   (tuple!p5 event)))

(grule principal1-of-send-event (l t m p)
  (= (principal1-of-event (make-send-event l t m p)) p))
(WITH-ENABLED (PRINCIPAL1-OF-EVENT MAKE-SEND-EVENT)
 (REDUCE))

(grule principal1-of-receive-event (l t m p)
  (= (principal1-of-event (make-receive-event l t m p)) p))
(WITH-ENABLED (PRINCIPAL1-OF-EVENT MAKE-RECEIVE-EVENT)
 (REDUCE))

(grule principal1-of-out-of-band-event (l t m s r)
  (= (principal1-of-event (make-out-of-band-event l t m s r)) s))
(WITH-ENABLED (PRINCIPAL1-OF-EVENT MAKE-OUT-OF-BAND-EVENT)
 (REDUCE))

(grule principal1-of-generate-event (l t m p)
  (= (principal1-of-event (make-generate-event l t m p)) p))
(WITH-ENABLED (PRINCIPAL1-OF-EVENT MAKE-GENERATE-EVENT)
 (REDUCE))

(grule principal1-of-construct-event (l t m p)
  (= (principal1-of-event (make-construct-event l t m p)) p))
(WITH-ENABLED (PRINCIPAL1-OF-EVENT MAKE-CONSTRUCT-EVENT)
 (REDUCE))

(disabled
 (function principal2-of-event (event) ()
   (tuple!p6 event)))

(grule principal2-of-out-of-band-event (l t m s r)
  (= (principal2-of-event (make-out-of-band-event l t m s r)) r))
(WITH-ENABLED (PRINCIPAL2-OF-EVENT MAKE-OUT-OF-BAND-EVENT)
 (REDUCE))

(function time-strictly-increases (history) ((measure (seq!length history)))
  (if (seq!emptyp history)
      (true)
      (if (>= (seq!length history) 2)
          (and (time-strictly-increases (seq!tail history))
               (in (time-of-event (seq!head history)) (nat!nat))
               (> (time-of-event (seq!head history))
                  (time-of-event (seq!head (seq!tail history)))))
          (in (time-of-event (seq!head history)) (nat!nat)))))
(REDUCE)

(function time-constraint (time state) ()
  (and (in time (nat!nat))
       (time-strictly-increases (history state))
       (implies (>= (seq!length (history state)) 1)
                (> time (time-of-event (seq!head (history state)))))))

(frule time-constraint-implies-nat (time state)
  (implies (time-constraint time state)
           (>= time 0)))
(REDUCE)

(axiom time-of-event-in-constrained-history-nat (event history)
  (implies (and (seq!is-sequence history)
                (seq!is-member event history)
                (time-strictly-increases history))
           (>= (time-of-event event) 0)))
(INDUCT)
(REDUCE)
(INVOKE (SEQ!LENGTH HISTORY))
(REDUCE)
(INVOKE (SEQ!LENGTH (SEQ!TAIL HISTORY)))
(REDUCE)
(INVOKE (SEQ!IS-SEQUENCE HISTORY))
(REDUCE)


;(load fn)

(function all-storage (stores) ()
  (cup (rel!ran stores)))

(function add-to-storage (stores principal messages) ()
  (fn!override 
   stores
   (make-set (pair!pair
              principal (union messages (fn!apply stores principal))))))

(grule add-to-storage-is-function (stores principal message)
  (implies (fn!is-function stores)
           (fn!is-function (add-to-storage stores principal message))))
(REDUCE)

(rule add-nullset-to-storage (stores principal)
  (implies (and (fn!is-function stores)
		(in principal (rel!dom stores)))
	   (= (add-to-storage stores principal (nullset))
	      stores)))
(APPLY FN!FUNCTION-EXTENSIONALITY)
(REDUCE)

(function storage-of (principal state) ()
  (fn!apply (stores state) principal))

(function all-messages-in-state (state) ()
  (union (ms!public-keys)
         (union (ms!text-messages)
                (union (ms!principals)
                       (union (seen-messages state)
                              (all-storage (stores state)))))))

(rule all-messages-in-state-definition (state)
  (= (all-messages-in-state state)
     (union (ms!public-keys)
         (union (ms!text-messages)
                (union (ms!principals)
                       (union (seen-messages state)
                              (all-storage (stores state))))))))
(INVOKE ALL-MESSAGES-IN-STATE)
(SIMPLIFY)


;;; Signature

(function sign (message key) ()
  (ms!combine message (ms!encrypt (ms!hash message) key)))

(grule sign-is-in-combine-messages (message key)
  (implies (and (in message (ms!messages))
                (in key (ms!keys)))
           (in (sign message key) (ms!combine-messages))))
(REDUCE)

(function 3combine (m1 m2 m3) ()
  (ms!combine m1 (ms!combine m2 m3)))

(grule 3combine-is-message (m1 m2 m3)
  (implies (and (in m1 (ms!messages))
                (in m2 (ms!messages))
                (in m3 (ms!messages)))
           (in (3combine m1 m2 m3) (ms!messages))))
(REDUCE)

(function 4combine (m1 m2 m3 m4) ()
  (ms!combine m1 (ms!combine m2 (ms!combine m3 m4))))

(grule 4combine-is-message (m1 m2 m3 m4)
  (implies (and (in m1 (ms!messages))
                (in m2 (ms!messages))
                (in m3 (ms!messages))
                (in m4 (ms!messages)))
           (in (4combine m1 m2 m3 m4) (ms!messages))))
(REDUCE)

(function 5combine (m1 m2 m3 m4 m5) ()
  (ms!combine m1 (ms!combine m2 (ms!combine m3 (ms!combine m4 m5)))))

(grule 5combine-is-message (m1 m2 m3 m4 m5)
  (implies (and (in m1 (ms!messages))
                (in m2 (ms!messages))
                (in m3 (ms!messages))
                (in m4 (ms!messages))
                (in m5 (ms!messages)))
           (in (5combine m1 m2 m3 m4 m5) (ms!messages))))
(REDUCE)

(function 6combine (m1 m2 m3 m4 m5 m6) ()
  (ms!combine
   m1 (ms!combine m2 (ms!combine m3 (ms!combine m4 (ms!combine m5 m6))))))

(grule 6combine-is-message (m1 m2 m3 m4 m5 m6)
  (implies (and (in m1 (ms!messages))
                (in m2 (ms!messages))
                (in m3 (ms!messages))
                (in m4 (ms!messages))
                (in m5 (ms!messages))
                (in m6 (ms!messages)))
           (in (6combine m1 m2 m3 m4 m5 m6) (ms!messages))))
(REDUCE)

(rule time-strictly-increases-step (event state)
  (implies (and (time-strictly-increases (history state))
                (time-constraint (time-of-event event) state))
           (= (time-strictly-increases
               (seq!tack event (history state)))
              (true))))
(REDUCE)

(function add-to-state-storage (principal message state) ()
  (make-state (seen-messages state)
              (add-to-storage (stores state) principal message)
              (history state)))

(grule add-to-state-storage-is-state (principal message state)
  (is-state (add-to-state-storage principal message state)))
(REDUCE)

(rule seen-messages-of-add-to-state-storage (principal message state)
  (= (seen-messages (add-to-state-storage principal message state))
     (seen-messages state)))
(REDUCE)

(rule stores-of-add-to-state-storage (principal message state)
  (= (stores (add-to-state-storage principal message state))
     (add-to-storage (stores state) principal message)))
(REDUCE)

(rule history-of-add-to-state-storage (principal message state)
  (= (history (add-to-state-storage principal message state))
     (history state)))
(REDUCE)

(function add-to-state-history (event state) ()
  (make-state (seen-messages state)
              (stores state)
              (seq!tack event (history state))))

(grule add-to-state-history-is-state (event state)
  (is-state (add-to-state-history event state)))
(REDUCE)

(rule seen-messages-of-add-to-state-history (event state)
  (= (seen-messages (add-to-state-history event state))
     (seen-messages state)))
(REDUCE)

(rule stores-of-add-to-state-history (event state)
  (= (stores (add-to-state-history event state))
     (stores state)))
(REDUCE)

(rule history-of-add-to-state-history (event state)
  (= (history (add-to-state-history event state))
     (seq!tack event (history state))))
(REDUCE)

(function add-to-state-seen-messages (messages state) ()
  (make-state (union messages (seen-messages state))
              (stores state)
              (history state)))

(grule add-to-state-seen-messages-is-state (message state)
  (is-state (add-to-state-seen-messages message state)))
(REDUCE)

(rule seen-messages-of-add-to-state-seen-messages (message state)
  (= (seen-messages (add-to-state-seen-messages message state))
     (union message (seen-messages state))))
(REDUCE)

(rule stores-of-add-to-state-seen-messages (message state)
  (= (stores (add-to-state-seen-messages message state))
     (stores state)))
(REDUCE)

(rule history-of-add-to-state-seen-messages (message state)
  (= (history (add-to-state-seen-messages message state))
     (history state)))
(REDUCE)

(function is-good-state (state) ()
  (and (is-state state)
       (subset (seen-messages state) (ms!messages))
       (time-strictly-increases (history state))
       (in (history state) (seq!sequence-of (events)))
       (fn!is-function (stores state))
       (= (rel!dom (stores state)) (ms!principals))
       (subset (rel!ran (stores state)) (powerset (ms!messages)))))

(frule is-good-state-implication (state)
  (implies (is-good-state state)
           (and (is-state state)
                (subset (seen-messages state) (ms!messages))
                (time-strictly-increases (history state))
                (in (history state) (seq!sequence-of (events)))
                (fn!is-function (stores state))
                (= (rel!dom (stores state)) (ms!principals))
                (subset (rel!ran (stores state)) (powerset (ms!messages))))))
(INVOKE IS-GOOD-STATE)
(SIMPLIFY)

(rule setadd-member (x s)
  (implies (in x s)
           (= (setadd x s) s)))
(WITH-ENABLED (SETRULES!SETADD-MEMBER) (REWRITE))

(rule is-good-state-add-to-state-storage (principal messages state)
  (implies (and (is-good-state state)
                (in principal (ms!principals))
                (subset messages (ms!messages)))
           (= (is-good-state (add-to-state-storage principal messages state))
              (true))))
(WITH-DISABLED (SUBSET)
 (REDUCE))
(USE
 FN!RAN-OVERRIDE
 (F (STORES STATE))
 (G (SETADD
     (PAIR!PAIR PRINCIPAL (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
     (NULLSET))))
(REWRITE)
(USE FN!APPLY-IN-RAN (F (STORES STATE)) (X PRINCIPAL))
(REWRITE)
(INVOKE FN!OVERRIDE)
(REWRITE)
(INVOKE SUBSET)
(PRENEX)
(INSTANTIATE (E$3 (FN!APPLY (STORES STATE) PRINCIPAL)))
(REWRITE)
(INVOKE SUBSET)
(REWRITE)

(rule is-good-state-add-to-state-history (event state)
  (implies (and (is-good-state state)
                (in event (events))
                (time-constraint (time-of-event event) state))
           (= (is-good-state (add-to-state-history event state))
              (true))))
(INVOKE IS-GOOD-STATE)
(REWRITE)

(rule is-good-state-add-to-state-seen-messages (messages state)
  (implies (and (is-good-state state)
                (subset messages (ms!messages)))
           (= (is-good-state (add-to-state-seen-messages messages state))
              (true))))
(INVOKE IS-GOOD-STATE)
(REWRITE)

(rule add-nullset-to-state-storage (principal state)
  (implies (and (is-good-state state)
		(in principal (ms!principals)))
	   (= (add-to-state-storage principal (nullset) state)
	      state)))
(with-disabled (add-to-storage) (reduce))
(invoke is-state)
(prenex)
(equality-substitute state)
(rewrite)


;;; Rules about storage-of

(rule storage-of-add-to-state-storage (p1 p2 state m)
  (implies (and (is-good-state state)
                (in p1 (ms!principals))
                (in p2 (ms!principals)))
           (= (storage-of p1 (add-to-state-storage p2 m state))
              (if (= p1 p2)
                  (union m (storage-of p1 state))
                  (storage-of p1 state)))))
(REDUCE)

(rule storage-of-add-to-state-history (p event state)
  (implies (is-good-state state)
           (= (storage-of p (add-to-state-history event state))
              (storage-of p state))))
(REDUCE)

(rule storage-of-add-to-state-seen-messages (p m state)
  (implies (is-good-state state)
           (= (storage-of p (add-to-state-seen-messages m state))
              (storage-of p state))))
(REDUCE)


;;; Good Steps
;;; No-op if minimal precondition not satisfied.
;;; First, define cover functions for known by principal/intruder.

(function known-by-principal (message principal state) ()
  (ms!known-in message
               (union (storage-of principal state)
                      (union (ms!public-keys)
                             (union (ms!text-messages)
                                    (ms!principals))))))

(function forgeable (message state) ()
  (ms!known-in message
               (union (seen-messages state)
                      (union (ms!public-keys)
                             (union (ms!text-messages)
                                    (ms!principals))))))

(function send-step (label time message principal state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in principal (ms!principals))
           (known-by-principal message principal state))
      (add-to-state-seen-messages
       (make-set message)
       (add-to-state-history
        (make-send-event label time message principal)
        state))
      state))

(rule send-step-preserves-good-state (label time message principal state)
  (= (is-good-state (send-step label time message principal state))
     (is-good-state state)))
(SPLIT (IS-GOOD-STATE STATE))
(INVOKE SEND-STEP)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)


(function receive-step (label time message principal state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in principal (ms!principals))
           (forgeable message state))
      (add-to-state-storage
       principal
       (make-set message)
       (add-to-state-history
        (make-receive-event label time message principal)
        state))
      state))

(rule receive-step-preserves-good-state (label time message principal state)
  (= (is-good-state (receive-step label time message principal state))
     (is-good-state state)))
(SPLIT (IS-GOOD-STATE STATE))
(INVOKE RECEIVE-STEP)
(INVOKE FORGEABLE)
(REWRITE)

(function out-of-band-step (label time message sender receiver state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in sender (ms!principals))
           (in receiver (ms!principals))
           (known-by-principal message sender state))
      (add-to-state-storage
       receiver
       (make-set message)
       (add-to-state-history
        (make-out-of-band-event label time message sender receiver)
        state))
      state))

(rule out-of-band-step-preserves-good-state
    (label time message sender receiver state)
  (= (is-good-state
      (out-of-band-step label time message sender receiver state))
     (is-good-state state)))
(SPLIT (IS-GOOD-STATE STATE))
(INVOKE OUT-OF-BAND-STEP)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(function generate-step (label time message principal state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in message (ms!atomic-messages))
           (ms!is-fresh message (all-messages-in-state state))
           (in principal (ms!principals)))
      (add-to-state-storage
       principal
       (make-set message)
       (add-to-state-history
        (make-generate-event label time message principal)
        state))
      state))

(rule generate-step-preserves-good-state (label time message principal state)
  (= (is-good-state (generate-step label time message principal state))
     (is-good-state state)))
(SPLIT (IS-GOOD-STATE STATE))
(INVOKE GENERATE-STEP)
(REWRITE)

(function construct-step (label time message principal state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in principal (ms!principals))
           (known-by-principal message principal state))
      (add-to-state-history
       (make-construct-event label time message principal)
       state)
      state))

(rule construct-step-preserves-good-state (label time message principal state)
  (= (is-good-state (construct-step label time message principal state))
     (is-good-state state)))
(SPLIT (IS-GOOD-STATE STATE))
(INVOKE CONSTRUCT-STEP)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(function intruder-step (label time message state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in message (ms!atomic-messages))
           (ms!is-fresh message (all-messages-in-state state)))
      (add-to-state-seen-messages
       (make-set message)
       (add-to-state-history
        (make-intruder-event label time message)
        state))
      state))

(rule intruder-step-preserves-good-state (label time message state)
  (= (is-good-state (intruder-step label time message state))
     (is-good-state state)))
(SPLIT (IS-GOOD-STATE STATE))
(INVOKE INTRUDER-STEP)
(REWRITE)


;;; Minimal constraints on good evolution

(function good-step (s0 s1) ()
  (and (is-good-state s0)
       (some (label time message)
         (and (time-constraint time s0)
              (>= label 0)
              (or (some (principal)
                    (and (in principal (ms!principals))
                         (known-by-principal message principal s0)
                         (= s1 (send-step label time message principal s0))))
                  (some (principal)
                    (and (in principal (ms!principals))
                         (forgeable message s0)
                         (= s1 (receive-step
                                label time message principal s0))))
                  (some (sender receiver)
                    (and (in sender (ms!principals))
                         (in receiver (ms!principals))
                         (known-by-principal message sender s0)
                         (= s1 (out-of-band-step
                                label time message sender receiver s0))))
                  (some (principal)
                    (and (in message (ms!atomic-messages))
                         (ms!is-fresh message (all-messages-in-state s0))
                         (in principal (ms!principals))
                         (= s1 (generate-step
                                label time message principal s0))))
                  (some (principal)
                    (and (in principal (ms!principals))
                         (known-by-principal message principal s0)
                         (= s1 (construct-step
                                label time message principal s0))))
                  (and (in message (ms!atomic-messages))
                       (ms!is-fresh message (all-messages-in-state s0))
                       (= s1 (intruder-step label time message s0))))))))

(function is-good-evolution-state (state)
    ((measure (seq!length (history state))))
  (if (seq!emptyp (history state))
      (is-good-state state)
      (some (previous-state)
        (if (= (history previous-state)
               (seq!tail (history state)))
            (and (is-good-evolution-state previous-state)
                 (good-step previous-state state))
            (false)))))
(REDUCE)

(frule is-good-evolution-state-is-good-state (state)
  (implies (is-good-evolution-state state)
           (is-good-state state)))
(INDUCT)
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(REWRITE)
(PRENEX)
(INSTANTIATE (PREVIOUS-STATE$0 PREVIOUS-STATE))
(SIMPLIFY)
(INVOKE (GOOD-STEP PREVIOUS-STATE STATE))
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))

(frule good-step-implies-good-states (s0 s1)
  (implies (good-step s0 s1)
           (and (is-good-state s0)
                (is-good-state s1))))
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))

(rule seen-messages-send-step (label time message principal state)
  (= (seen-messages (send-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in principal (ms!principals))
              (known-by-principal message principal state))
         (setadd message (seen-messages state))
         (seen-messages state))))
(INVOKE SEND-STEP)
(REWRITE)

(rule storage-of-send-step (p label time message principal state)
  (implies (in p (ms!principals))
           (= (storage-of p (send-step label time message principal state))
              (storage-of p state))))
(INVOKE SEND-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule history-of-send-step (label time message principal state)
  (= (history (send-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in principal (ms!principals))
              (known-by-principal message principal state))
         (seq!tack (make-send-event label time message principal)
                   (history state))
         (history state))))
(INVOKE SEND-STEP)
(REWRITE)

(rule seen-messages-receive-step (label time message principal state)
  (= (seen-messages (receive-step label time message principal state))
     (seen-messages state)))
(INVOKE RECEIVE-STEP)
(REWRITE)

(rule storage-of-receive-step (p label time message principal state)
  (implies (in p (ms!principals))
           (= (storage-of p (receive-step label time message principal state))
              (if (and (is-good-state state)
                       (time-constraint time state)
                       (>= label 0)
                       (in principal (ms!principals))
                       (forgeable message state)
                       (= p principal))
                  (setadd message (storage-of p state))
                  (storage-of p state)))))
(INVOKE RECEIVE-STEP)
(REWRITE)
(INVOKE FORGEABLE)
(REWRITE)

(rule history-of-receive-step (label time message principal state)
  (= (history (receive-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in principal (ms!principals))
              (forgeable message state))
         (seq!tack (make-receive-event label time message principal)
                   (history state))
         (history state))))
(INVOKE RECEIVE-STEP)
(REWRITE)

(rule seen-messages-out-of-band-step (label time message sender receiver state)
  (= (seen-messages
      (out-of-band-step label time message sender receiver state))
     (seen-messages state)))
(INVOKE OUT-OF-BAND-STEP)
(REWRITE)

(rule storage-of-out-of-band-step (p label time message sender receiver state)
  (implies (in p (ms!principals))
           (= (storage-of
               p (out-of-band-step label time message sender receiver state))
              (if (and (is-good-state state)
                       (time-constraint time state)
                       (>= label 0)
                       (in sender (ms!principals))
                       (in receiver (ms!principals))
                       (known-by-principal message sender state)
                       (= p receiver))
                  (setadd message (storage-of p state))
                  (storage-of p state)))))
(INVOKE OUT-OF-BAND-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule history-of-out-of-band-step (label time message sender receiver state)
  (= (history (out-of-band-step label time message sender receiver state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in sender (ms!principals))
              (in receiver (ms!principals))
              (known-by-principal message sender state))
         (seq!tack (make-out-of-band-event label time message sender receiver)
                   (history state))
         (history state))))
(INVOKE OUT-OF-BAND-STEP)
(REWRITE)

(rule seen-messages-generate-step (label time message principal state)
  (= (seen-messages (generate-step label time message principal state))
     (seen-messages state)))
(INVOKE GENERATE-STEP)
(REWRITE)

(rule storage-of-generate-step (p label time message principal state)
  (implies (in p (ms!principals))
           (= (storage-of p (generate-step label time message principal state))
              (if (and (is-good-state state)
                       (time-constraint time state)
                       (>= label 0)
                       (in message (ms!atomic-messages))
                       (ms!is-fresh message (all-messages-in-state state))
                       (in principal (ms!principals))
                       (= p principal))
                  (setadd message (storage-of p state))
                  (storage-of p state)))))
(INVOKE GENERATE-STEP)
(REWRITE)

(rule history-of-generate-step (label time message principal state)
  (= (history (generate-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in message (ms!atomic-messages))
              (ms!is-fresh message (all-messages-in-state state))
              (in principal (ms!principals)))
         (seq!tack (make-generate-event label time message principal)
                   (history state))
         (history state))))
(INVOKE GENERATE-STEP)
(REWRITE)

(rule seen-messages-construct-step (label time message principal state)
  (= (seen-messages (construct-step label time message principal state))
     (seen-messages state)))
(INVOKE CONSTRUCT-STEP)
(REWRITE)

(rule storage-of-construct-step (p label time message principal state)
  (= (storage-of p (construct-step label time message principal state))
     (storage-of p state)))
(INVOKE CONSTRUCT-STEP)
(REWRITE)

(rule history-of-construct-step (label time message principal state)
  (= (history (construct-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in principal (ms!principals))
              (known-by-principal message principal state))
         (seq!tack (make-construct-event label time message principal)
                   (history state))
         (history state))))
(INVOKE CONSTRUCT-STEP)
(REWRITE)

(rule seen-messages-intruder-step (label time message state)
  (= (seen-messages (intruder-step label time message state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in message (ms!atomic-messages))
              (ms!is-fresh message (all-messages-in-state state)))
         (setadd message (seen-messages state))
         (seen-messages state))))
(INVOKE INTRUDER-STEP)
(REWRITE)

(rule storage-of-intruder-step (p label time message state)
  (= (storage-of p (intruder-step label time message state))
     (storage-of p state)))
(INVOKE INTRUDER-STEP)
(REWRITE)

(rule history-of-intruder-step (label time message state)
  (= (history (intruder-step label time message state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in message (ms!atomic-messages))
              (ms!is-fresh message (all-messages-in-state state)))
         (seq!tack (make-intruder-event label time message)
                   (history state))
         (history state))))
(INVOKE INTRUDER-STEP)
(REWRITE)

(function is-good-evolution (sequence) ((measure (seq!length sequence)))
  (if (>= (seq!length sequence) 2)
      (and (is-good-evolution (seq!tail sequence))
           (good-step (seq!head (seq!tail sequence))
                      (seq!head sequence)))
      (if (>= (seq!length sequence) 1)
          (and (is-good-state (seq!head sequence))
               (= (history (seq!head sequence)) (seq!empty))
               (= (seq!tail sequence) (seq!empty)))
          (false))))
(REDUCE)

(grule tail-is-sequence (sequence)
  (implies (and (seq!is-sequence sequence)
                (seq!is-tack sequence))
           (seq!is-sequence (seq!tail sequence))))
(INVOKE (SEQ!IS-SEQUENCE SEQUENCE))
(REDUCE)


(disabled
 (rule history-of-head-of-tail-of-good-evolution (sequence)
   (implies (and (is-good-evolution sequence)
                 (>= (seq!length sequence) 2))
            (= (history (seq!head (seq!tail sequence)))
               (seq!tail (history (seq!head sequence)))))))
(INDUCT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(CASES)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)

(rule length-of-history-of-good-evolution (sequence)
  (implies (is-good-evolution sequence)
           (= (seq!length (history (seq!head sequence)))
              (- (seq!length sequence) 1))))
(INDUCT)
(CASES)
(REARRANGE)
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(INVOKE (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))))
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(NEXT)

(frule head-of-good-evolution (sequence)
  (implies (is-good-evolution sequence)
           (is-good-evolution-state (seq!head sequence))))
(INDUCT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)))
(REWRITE)
(INSTANTIATE (PREVIOUS-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
(REWRITE)
(APPLY HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)

(rule is-good-evolution-tail (sequence)
  (implies (and (>= (seq!length sequence) 2)
                (is-good-evolution sequence))
           (= (is-good-evolution (seq!tail sequence)) (true))))
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)


(function is-initial-evolution-state (state) ()
  (= (history state) (seq!empty)))

(grule head-of-evolution-in-evolution (sequence)
  (implies (is-good-evolution sequence)
           (seq!is-member (seq!head sequence) sequence)))
(INVOKE IS-GOOD-EVOLUTION)
(INVOKE SEQ!IS-MEMBER)
(REWRITE)

(frule good-evolution-is-sequence (sequence)
  (implies (is-good-evolution sequence)
           (seq!is-sequence sequence)))
(INDUCT)
(REWRITE)
(CASES)
(CASES)
(INVOKE (SEQ!IS-SEQUENCE SEQUENCE))
(SIMPLIFY)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(SIMPLIFY)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(INVOKE (SEQ!IS-SEQUENCE SEQUENCE))
(SIMPLIFY)
(NEXT)

(axiom state-is-good-evolution-state (state sequence)
  (implies (and (is-good-evolution sequence)
                (seq!is-member state sequence))
           (is-good-evolution-state state)))
(INDUCT)
(CASES)
(REARRANGE)
(REWRITE)
(INVOKE (SEQ!IS-MEMBER STATE SEQUENCE))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER STATE SEQUENCE))
(REWRITE)
(SPLIT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1))
(CASES)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
(INVOKE (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
(REWRITE)
(NEXT)

(grule non-initial-state-has-non-empty-history (state sequence)
  (implies (and (is-good-evolution sequence)
                (seq!is-member state sequence)
                (not (is-initial-evolution-state state)))
           (>= (seq!length (history state)) 1)))
(INVOKE IS-INITIAL-EVOLUTION-STATE)
(INVOKE (SEQ!LENGTH (HISTORY STATE)))
(REWRITE)
(SPLIT (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS))))
(CASES)
(REWRITE)
(NEXT)
(SPLIT (IS-GOOD-EVOLUTION-STATE STATE))
(REWRITE)
(SPLIT (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)))
(REWRITE)
(USE STATE-IS-GOOD-EVOLUTION-STATE (STATE STATE) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(NEXT)

(rule is-tack-equiv-non-zero-length (sequence)
  (= (seq!is-tack sequence) (>= (seq!length sequence) 1)))
(SPLIT (>= (SEQ!LENGTH SEQUENCE) 1))
(REDUCE)
(INVOKE SEQ!LENGTH)
(REWRITE)

(axiom history-of-state-is-subsequence (state sequence)
  (implies (and (is-good-evolution sequence)
                (seq!is-member state sequence))
           (some (s)
             (and (seq!is-sequence s)
                  (= (history (seq!head sequence))
                     (seq!join s (history state)))))))
(INDUCT)
(CONJUNCTIVE)
(CASES)
(INSTANTIATE (S (SEQ!EMPTY)))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER STATE SEQUENCE))
(REWRITE)
(INVOKE SEQ!IS-MEMBER)
(REWRITE)
(NEXT)
(REWRITE)
(PRENEX)
(INSTANTIATE (S$0 (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))) S)))
(REWRITE)
(EQUALITY-SUBSTITUTE (SEQ!JOIN S (HISTORY STATE)))
(SPLIT (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE))))
(REWRITE)
(SPLIT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
(CASES)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(CASES)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE SEQ!IS-MEMBER)
(REWRITE)
(INVOKE SEQ!IS-MEMBER)
(REWRITE)
(NEXT)
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(INSTANTIATE (S (SEQ!EMPTY)))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER STATE SEQUENCE))
(REWRITE)
(INVOKE SEQ!IS-MEMBER)
(REWRITE)
(NEXT)
(REWRITE)
(INVOKE (SEQ!IS-MEMBER STATE SEQUENCE))
(REWRITE)
(INSTANTIATE (S (SEQ!EMPTY)))
(REWRITE)
(NEXT)

(axiom time-of-event-strictly-increases (state)
  (implies (and (is-good-evolution-state state)
                (>= (seq!length (history state)) 2))
           (>= (time-of-event (seq!head (history state)))
               (+ (time-of-event (seq!head (seq!tail (history state)))) 1))))
(SPLIT (IS-GOOD-STATE STATE))
(CASES)
(INVOKE IS-GOOD-STATE)
(INVOKE TIME-STRICTLY-INCREASES)
(REARRANGE)
(REWRITE)
(USE TIME-OF-EVENT-IN-CONSTRAINED-HISTORY-NAT
     (EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) (HISTORY (HISTORY STATE)))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))) (HISTORY STATE)))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))
                       (SEQ!TAIL (HISTORY STATE))))
(REWRITE)
(INVOKE (SEQ!LENGTH (HISTORY STATE)))
(REWRITE)
(NEXT)
(SIMPLIFY)
(NEXT)

(axiom time-of-event-of-evolution-state (e state)
  (implies (and (is-good-evolution-state state)
                (seq!is-member e (history state)))
           (>= (time-of-event e) 0)))
(INDUCT)
(CASES)
(REDUCE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(REWRITE)
(PRENEX)
(INSTANTIATE (PREVIOUS-STATE$0 PREVIOUS-STATE))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER E (HISTORY STATE)))
(REWRITE)
(SPLIT (IS-GOOD-STATE STATE))
(CASES)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(INVOKE TIME-STRICTLY-INCREASES)
(REWRITE)
(NEXT)
(REWRITE)
(NEXT)

(axiom member-is-good-evolution-state (sequence state)
  (implies (and (is-good-evolution sequence)
                (seq!is-member state sequence))
           (is-good-evolution-state state)))
(INDUCT)
(CASES)
(REARRANGE)
(REWRITE)
(INVOKE (SEQ!IS-MEMBER STATE SEQUENCE))
(REWRITE)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION)
(REWRITE)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(REWRITE)
(INVOKE (SEQ!IS-MEMBER STATE SEQUENCE))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER STATE (SEQ!EMPTY)))
(REWRITE)
(NEXT)

(function special-induction (n1 n2 sequence) ((measure (seq!length sequence)))
  (if (>= (seq!length sequence) 1)
      (and (special-induction (- n1 1) n2 (seq!tail sequence))
           (special-induction n1 (- n2 1) (seq!tail sequence))
           (special-induction (- n1 1) (- n2 1) (seq!tail sequence)))
      (true)))
(REDUCE)

(axiom time-of-event-strictly-increases-2 (n1 n2 sequence)
  (implies (and (is-good-evolution sequence)
                (>= n1 1)
                (>= n2 (+ n1 1))
                (<= (+ n2 1) (seq!length sequence)))
           (>= (time-of-event (seq!head (history (seq!nth sequence n1))))
               (+ (time-of-event
                   (seq!head (history (seq!nth sequence n2))))
                  1))))
(INDUCT (SPECIAL-INDUCTION N1 N2 SEQUENCE))
(CASES)
(REARRANGE)
(WITH-ENABLED (HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
 (REWRITE))
(INVOKE (SEQ!NTH SEQUENCE N1))
(INVOKE (SEQ!NTH SEQUENCE N2))
(WITH-ENABLED (HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
 (REWRITE))
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(CASES)
(INVOKE (SEQ!NTH SEQUENCE 1))
(REWRITE)
(USE TIME-OF-EVENT-STRICTLY-INCREASES (STATE (SEQ!HEAD SEQUENCE)))
(REARRANGE)
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(INVOKE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
(REWRITE)
(APPLY HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(NEXT)
(SPLIT (= N1 1))
(REWRITE)
(SPLIT (= N2 2))
(REWRITE)
(INVOKE SEQ!NTH)
(REWRITE)
(INVOKE SEQ!NTH)
(REWRITE)
(USE TIME-OF-EVENT-STRICTLY-INCREASES (STATE (SEQ!HEAD SEQUENCE)))
(REARRANGE)
(WITH-ENABLED (HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
 (REWRITE))
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION)
(REWRITE)
(NEXT)

(axiom seen-messages-monotonic (sequence n1 n2)
  (implies (and (is-good-evolution sequence)
                (>= n2 1)
                (>= n1 n2)
                (>= (seq!length sequence) n1))
           (subset (seen-messages (seq!nth sequence n1))
                   (seen-messages (seq!nth sequence n2)))))
(INDUCT (SPECIAL-INDUCTION N1 N2 SEQUENCE))
(INVOKE (SEQ!NTH SEQUENCE N1))
(INVOKE (SEQ!NTH SEQUENCE N2))
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(CASES)
(SPLIT (= N2 1))
(REWRITE)
(INVOKE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(NEXT)

(axiom forgeable-is-monotonic (sequence message n1 n2)
  (implies (and (is-good-evolution sequence)
                (>= n2 1)
                (>= n1 n2)
                (>= (seq!length sequence) n1)
                (forgeable message (seq!nth sequence n1)))
           (forgeable message (seq!nth sequence n2))))
(INVOKE FORGEABLE)
(USE SEEN-MESSAGES-MONOTONIC (SEQUENCE SEQUENCE) (N1 N1) (N2 N2))
(SIMPLIFY)
(USE
  MS!KNOWN-IN-SUBSET
  (C MESSAGE)
  (S1 (UNION
        (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
        (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (S2 (UNION
        (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
        (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
(REARRANGE)
(REWRITE)

(axiom storage-of-principal-monotonic (sequence principal n1 n2)
  (implies (and (is-good-evolution sequence)
                (in principal (ms!principals))
                (>= n2 1)
                (>= n1 n2)
                (>= (seq!length sequence) n1))
           (subset (storage-of principal (seq!nth sequence n1))
                   (storage-of principal (seq!nth sequence n2)))))
(INDUCT (SPECIAL-INDUCTION N1 N2 SEQUENCE))
(INVOKE (SEQ!NTH SEQUENCE N1))
(INVOKE (SEQ!NTH SEQUENCE N2))
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(CASES)
(SPLIT (= N2 1))
(REWRITE)
(INVOKE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(NEXT)

(axiom known-by-is-monotonic (sequence principal message n1 n2)
  (implies (and (is-good-evolution sequence)
                (in principal (ms!principals))
                (>= n2 1)
                (>= n1 n2)
                (>= (seq!length sequence) n1)
                (known-by-principal message principal (seq!nth sequence n1)))
           (known-by-principal message principal (seq!nth sequence n2))))
(INVOKE KNOWN-BY-PRINCIPAL)
(USE STORAGE-OF-PRINCIPAL-MONOTONIC
     (SEQUENCE SEQUENCE) (PRINCIPAL PRINCIPAL) (N1 N1) (N2 N2))
(SIMPLIFY)
(USE
  MS!KNOWN-IN-SUBSET
  (C MESSAGE)
  (S1 (UNION
        (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
        (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (S2 (UNION
        (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
        (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
(REARRANGE)
(REWRITE)

(axiom sequence-member-can-be-accessed-using-nth (m s)
  (implies (and (seq!is-sequence s) (seq!is-member m s))
           (some (n) (and (>= n 1)
                          (= m (seq!nth s n))
                          (<= n (seq!length s))))))
(INDUCT)
(CASES)
(PRENEX)
(PRENEX)
(REARRANGE)
(INVOKE (SEQ!LENGTH S))
(REWRITE)
(CASES)
(CASES)
(INSTANTIATE (N$0 (+ N 1)))
(INVOKE (SEQ!NTH S (+ N 1)))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER M S))
(REWRITE)
(INSTANTIATE (N 1))
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-SEQUENCE S))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER M S))
(REWRITE)
(NEXT)

(axiom nth-is-member (n sequence)
  (implies (and (seq!is-sequence sequence)
                (>= n 1)
                (<= n (seq!length sequence)))
           (seq!is-member (seq!nth sequence n) sequence)))
(INDUCT (SEQ!NTH SEQUENCE N))
(CASES)
(REARRANGE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(CASES)
(INVOKE (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
(REWRITE)
(INVOKE (SEQ!NTH SEQUENCE N))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-SEQUENCE SEQUENCE))
(REWRITE)
(NEXT)
(INVOKE (SEQ!NTH SEQUENCE N))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) SEQUENCE))
(REWRITE)
(NEXT)

(axiom last-is-initial (sequence)
  (implies (is-good-evolution sequence)
           (is-initial-evolution-state 
            (seq!nth sequence (seq!length sequence)))))
(INDUCT)
(CASES)
(REARRANGE)
(REWRITE)
(INVOKE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)))
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION)
(REWRITE)
(INVOKE IS-INITIAL-EVOLUTION-STATE)
(INVOKE SEQ!NTH)
(REWRITE)
(NEXT)

(axiom subsequent-state-has-history (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= (+ n 1) (seq!length sequence)))
           (>= (seq!length (history (seq!nth sequence n))) 1)))
(INDUCT)
(INVOKE (SEQ!NTH SEQUENCE N))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)

(axiom initial-state-has-no-history (sequence)
  (implies (is-good-evolution sequence)
           (= (history (seq!nth sequence (seq!length sequence)))
              (seq!empty))))
(INDUCT)
(INVOKE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)

(function special-induction2 (n1 n2 sequence) ((measure (seq!length sequence)))
  (if (and (>= (seq!length sequence) 1) (>= n1 2) (>= n2 2))
      (special-induction2 (- n1 1) (- n2 1) (seq!tail sequence))
      (true)))
(REDUCE)

(axiom no-duplicates-in-good-evolution (n1 n2 sequence)
  (implies (and (is-good-evolution sequence)
                (>= n1 1)
                (>= n2 1)
                (<= n1 (seq!length sequence))
                (<= n2 (seq!length sequence))
                (= (seq!nth sequence n1) (seq!nth sequence n2)))
           (= n1 n2)))
(INDUCT (SPECIAL-INDUCTION2 N1 N2 SEQUENCE))
(CASES)
(REARRANGE)
(REWRITE)
(INVOKE (SEQ!NTH SEQUENCE N1))
(INVOKE (SEQ!NTH SEQUENCE N2))
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(NEXT)
(REARRANGE)
(REWRITE)
(CASES)
(SPLIT (>= N2 N1))
(SIMPLIFY)
(USE TIME-OF-EVENT-STRICTLY-INCREASES-2 (N1 N2) (N2 N1) (SEQUENCE SEQUENCE))
(REARRANGE)
(REWRITE)
(USE LAST-IS-INITIAL (SEQUENCE SEQUENCE))
(SIMPLIFY)
(USE SUBSEQUENT-STATE-HAS-HISTORY (N N2) (SEQUENCE SEQUENCE))
(USE INITIAL-STATE-HAS-NO-HISTORY (SEQUENCE SEQUENCE))
(SIMPLIFY)
(NEXT)
(SPLIT (>= N1 N2))
(SIMPLIFY)
(USE TIME-OF-EVENT-STRICTLY-INCREASES-2 (N1 N1) (N2 N2) (SEQUENCE SEQUENCE))
(REARRANGE)
(REWRITE)
(USE LAST-IS-INITIAL (SEQUENCE SEQUENCE))
(SIMPLIFY)
(USE SUBSEQUENT-STATE-HAS-HISTORY (N N1) (SEQUENCE SEQUENCE))
(USE INITIAL-STATE-HAS-NO-HISTORY (SEQUENCE SEQUENCE))
(SIMPLIFY)
(NEXT)

(axiom head-of-good-evolution-not-in-tail (sequence)
  (implies (is-good-evolution sequence)
           (not (seq!is-member (seq!head sequence) (seq!tail sequence)))))
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH
     (M (SEQ!HEAD SEQUENCE)) (S (SEQ!TAIL SEQUENCE)))
(REARRANGE)
(REWRITE)
(CASES)
(PRENEX)
(REWRITE)
(USE NO-DUPLICATES-IN-GOOD-EVOLUTION (N1 1) (N2 (+ N 1)) (SEQUENCE SEQUENCE))
(REARRANGE)
(SIMPLIFY)
(CASES)
(CASES)
(INVOKE (SEQ!NTH SEQUENCE 1))
(SIMPLIFY)
(INVOKE (SEQ!LENGTH SEQUENCE))
(SIMPLIFY)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION)
(REWRITE)
(NEXT)
(INVOKE (SEQ!NTH SEQUENCE 1))
(SIMPLIFY)
(INVOKE (SEQ!NTH SEQUENCE (+ 1 N)))
(SIMPLIFY)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION)
(SIMPLIFY)
(NEXT)

(axiom non-last-is-non-initial (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1)))
           (not (is-initial-evolution-state (seq!nth sequence n)))))
(INDUCT)
(CASES)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(INVOKE (SEQ!NTH SEQUENCE N))
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(INVOKE (IS-INITIAL-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)))
(REWRITE)
(CASES)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(REWRITE)
(NEXT)

(axiom non-initial-is-non-last (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (seq!length sequence))
                (not (is-initial-evolution-state (seq!nth sequence n))))
           (<= n (- (seq!length sequence) 1))))
(INDUCT)
(CASES)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(INVOKE (SEQ!NTH SEQUENCE N))
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(NEXT)
(USE LAST-IS-INITIAL (SEQUENCE SEQUENCE))
(REWRITE)
(NEXT)

(axiom non-initial-state-is-result-of-step (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1)))
           (good-step (seq!nth sequence (+ n 1)) (seq!nth sequence n))))
(INDUCT)
(CASES)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(INVOKE (SEQ!NTH SEQUENCE N))
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(CASES)
(INVOKE (SEQ!NTH SEQUENCE (+ 1 N)))
(REWRITE)
(NEXT)
(INVOKE (SEQ!NTH SEQUENCE 2))
(REWRITE)
(INVOKE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
(REWRITE)
(NEXT)
(REWRITE)
(NEXT)

(axiom send-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n))) (send-events)))
           (and (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal1-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence (+ n 1)))
                (forgeable
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))
(USE NON-INITIAL-STATE-IS-RESULT-OF-STEP (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE (SEQ!NTH SEQUENCE N)))
(TRIVIAL-REWRITE)
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE FORGEABLE)
(APPLY SEEN-MESSAGES-SEND-STEP)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(axiom receive-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (receive-events)))
           (and (forgeable
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence (+ n 1)))
                (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal1-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))
(USE NON-INITIAL-STATE-IS-RESULT-OF-STEP (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE (SEQ!NTH SEQUENCE N)))
(TRIVIAL-REWRITE)
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE KNOWN-BY-PRINCIPAL)
(APPLY STORAGE-OF-RECEIVE-STEP)
(REWRITE)
(INVOKE FORGEABLE)
(REWRITE)

(axiom out-of-band-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (out-of-band-events)))
           (and (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal1-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence (+ n 1)))
                (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal2-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))
(USE NON-INITIAL-STATE-IS-RESULT-OF-STEP (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE (SEQ!NTH SEQUENCE N)))
(TRIVIAL-REWRITE)
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE KNOWN-BY-PRINCIPAL)
(APPLY STORAGE-OF-OUT-OF-BAND-STEP)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(axiom generate-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (generate-events)))
           (and (ms!is-fresh
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (all-messages-in-state (seq!nth sequence (+ n 1))))
                (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal1-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))
(USE NON-INITIAL-STATE-IS-RESULT-OF-STEP (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE (SEQ!NTH SEQUENCE N)))
(TRIVIAL-REWRITE)
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE KNOWN-BY-PRINCIPAL)
(APPLY STORAGE-OF-GENERATE-STEP)
(REWRITE)

(axiom construct-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (construct-events)))
           (known-by-principal
            (message-of-event (seq!head (history (seq!nth sequence n))))
            (principal1-of-event (seq!head (history (seq!nth sequence n))))
            (seq!nth sequence (+ n 1)))))
(USE NON-INITIAL-STATE-IS-RESULT-OF-STEP (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE (SEQ!NTH SEQUENCE N)))
(TRIVIAL-REWRITE)
(WITHOUT-NORMALIZATION (REWRITE))

(axiom intruder-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (intruder-events)))
           (and (ms!is-fresh
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (all-messages-in-state (seq!nth sequence (+ n 1))))
                (forgeable
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))
(USE NON-INITIAL-STATE-IS-RESULT-OF-STEP (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE (SEQ!NTH SEQUENCE N)))
(TRIVIAL-REWRITE)
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE FORGEABLE)
(TRIVIAL-REWRITE)
(WITHOUT-NORMALIZATION (REWRITE))

;;; Need some stuff relating event histories and states.

;;; New Stuff

(axiom effective-generate-step (s0 s1 label time message principal)
  (implies (and (= s1 (generate-step label time message principal s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (in message (ms!atomic-messages))
                (ms!is-fresh message (all-messages-in-state s0))
                (in principal (ms!principals)))))
(INVOKE GENERATE-STEP)
(REWRITE)

(rule forgeable-preserved-by-generate-step (m1 label time m2 principal state)
  (= (forgeable m1 (generate-step label time m2 principal state))
     (forgeable m1 state)))
(INVOKE GENERATE-STEP)
(REWRITE)
(INVOKE FORGEABLE)
(REWRITE)

(rule known-by-principal-monotonic-over-generate-step
    (m1 principal1 label time m2 principal2 state)
  (implies (and (in principal1 (ms!principals))
                (known-by-principal m1 principal1 state))
           (= (known-by-principal
               m1 principal1 (generate-step label time m2 principal2 state))
              (true))))
(INVOKE GENERATE-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule fresh-in-storage-of-principal (message principal state)
  (implies (and (is-good-state state)
                (in principal (ms!principals))
                (ms!is-fresh message (all-storage (stores state))))
           (= (ms!is-fresh message (storage-of principal state))
              (true))))
(INVOKE ALL-STORAGE)
(INVOKE STORAGE-OF)
(USE MS!IS-FRESH-SUBSET
     (K MESSAGE)
     (S1 (CUP (REL!RAN (STORES STATE))))
     (S2 (FN!APPLY (STORES STATE) PRINCIPAL)))
(REARRANGE)
(REWRITE)
(INVOKE SUBSET)
(REWRITE)
(PRENEX)
(REWRITE)
(INSTANTIATE (Y (FN!APPLY (STORES STATE) PRINCIPAL)))
(REWRITE)
(USE FN!APPLY-IN-RAN (F (STORES STATE)) (X PRINCIPAL))
(REWRITE)

(rule known-by-principal-generate-step-atomic-case
    (m1 principal1 label time m2 principal2 state)
  (implies (and (in principal1 (ms!principals))
                (in m1 (ms!atomic-messages)))
           (= (known-by-principal
               m1 principal1 (generate-step label time m2 principal2 state))
              (or (known-by-principal m1 principal1 state)
                  (and (= m1 m2)
                       (= principal1 principal2)
                       (not (= (generate-step label time m2 principal2 state)
                               state)))))))
(REWRITE)
(CASES)
(INVOKE GENERATE-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(NEXT)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(APPLY MS!COMP-OF-SETADD-FRESH-KEY)
(REWRITE)
(INVOKE MS!ATOMIC-MESSAGES)
(REWRITE)
(NEXT)

(axiom effective-construct-step (s0 s1 label time message principal)
  (implies (and (= s1 (construct-step label time message principal s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (known-by-principal message principal s0)
                (in principal (ms!principals)))))
(INVOKE CONSTRUCT-STEP)
(REWRITE)

(rule forgeable-preserved-by-construct-step (m1 label time m2 principal state)
  (= (forgeable m1 (construct-step label time m2 principal state))
     (forgeable m1 state)))
(INVOKE CONSTRUCT-STEP)
(REWRITE)
(INVOKE FORGEABLE)
(REWRITE)

(rule known-by-principal-preserved-by-construct-step
    (m1 principal1 label time m2 principal2 state)
  (= (known-by-principal
      m1 principal1 (construct-step label time m2 principal2 state))
     (known-by-principal m1 principal1 state)))
(INVOKE CONSTRUCT-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(axiom effective-send-step (s0 s1 label time message principal)
  (implies (and (= s1 (send-step label time message principal s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (known-by-principal message principal s0)
                (in principal (ms!principals)))))
(INVOKE SEND-STEP)
(REWRITE)

(rule forgeable-monotonic-over-send-step (m1 label time m2 principal state)
  (implies (forgeable m1 state)
           (= (forgeable m1 (send-step label time m2 principal state))
              (true))))
(INVOKE SEND-STEP)
(REWRITE)
(INVOKE FORGEABLE)
(REWRITE)

(rule known-by-principal-preserved-by-send-step
    (m1 principal1 label time m2 principal2 state)
  (= (known-by-principal
      m1 principal1 (send-step label time m2 principal2 state))
     (known-by-principal m1 principal1 state)))
(INVOKE SEND-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(axiom effective-receive-step (s0 s1 label time message principal)
  (implies (and (= s1 (receive-step label time message principal s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (forgeable message s0)
                (in principal (ms!principals)))))
(INVOKE RECEIVE-STEP)
(REWRITE)

(rule forgeable-preserved-by-receive-step (m1 label time m2 principal state)
  (= (forgeable m1 (receive-step label time m2 principal state))
     (forgeable m1 state)))
(INVOKE RECEIVE-STEP)
(REWRITE)
(INVOKE FORGEABLE)
(REWRITE)

(rule known-by-principal-monotonic-over-receive-step
    (m1 principal1 label time m2 principal2 state)
  (implies (and (in principal1 (ms!principals))
                (known-by-principal m1 principal1 state))
           (= (known-by-principal
               m1 principal1 (receive-step label time m2 principal2 state))
              (true))))
(INVOKE RECEIVE-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(INVOKE FORGEABLE)
(REWRITE)

(rule known-by-principal-receive-step-non-receiver-case
    (m1 principal1 label time m2 principal2 state)
  (implies (and (in principal1 (ms!principals))
                (not (= principal1 principal2)))
           (= (known-by-principal
               m1 principal1 (receive-step label time m2 principal2 state))
              (known-by-principal m1 principal1 state))))
(INVOKE RECEIVE-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(INVOKE FORGEABLE)
(REWRITE)

(axiom effective-out-of-band-step (s0 s1 label time message sender receiver)
  (implies
   (and (= s1 (out-of-band-step label time message sender receiver s0))
        (not (= s0 s1)))
   (and (is-good-state s0)
        (time-constraint time s0)
        (>= label 0)
        (in sender (ms!principals))
        (in receiver (ms!principals))
        (known-by-principal message sender s0))))
(INVOKE OUT-OF-BAND-STEP)
(REWRITE)

(rule forgeable-preserved-by-out-of-band-step
    (m1 label time m2 sender receiver state)
  (= (forgeable
      m1 (out-of-band-step label time m2 sender receiver state))
     (forgeable m1 state)))
(INVOKE OUT-OF-BAND-STEP)
(REWRITE)
(INVOKE FORGEABLE)
(REWRITE)

(rule known-by-principal-monotonic-over-out-of-band-step
    (m1 principal1 label time m2 sender receiver state)
  (implies (and (in principal1 (ms!principals))
                (known-by-principal m1 principal1 state))
           (= (known-by-principal
               m1 principal1
               (out-of-band-step label time m2 sender receiver state))
              (true))))
(INVOKE OUT-OF-BAND-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule known-by-principal-out-of-band-step-non-receiver-case
    (m1 principal1 label time m2 sender receiver state)
  (implies (and (in principal1 (ms!principals))
                (not (= principal1 receiver)))
           (= (known-by-principal
               m1 principal1
               (out-of-band-step label time m2 sender receiver state))
              (known-by-principal m1 principal1 state))))
(INVOKE OUT-OF-BAND-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(axiom effective-intruder-step (s0 s1 label time message)
  (implies (and (= s1 (intruder-step label time message s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (in message (ms!atomic-messages))
                (ms!is-fresh message (all-messages-in-state s0)))))
(INVOKE INTRUDER-STEP)
(REWRITE)

(rule forgeable-monotonic-over-intruder-step (m1 label time m2 state)
  (implies (forgeable m1 state)
           (= (forgeable m1 (intruder-step label time m2 state))
              (true))))
(INVOKE INTRUDER-STEP)
(REWRITE)
(INVOKE FORGEABLE)
(REWRITE)

(rule known-by-principal-preserved-by-intruder-step
    (m1 principal label time m2 state)
  (= (known-by-principal m1 principal (intruder-step label time m2 state))
     (known-by-principal m1 principal state)))
(INVOKE INTRUDER-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(axiom known-by-principal-implies-not-fresh (message principal state)
  (implies (and (is-good-state state)
                (in message (ms!atomic-messages))
                (in principal (ms!principals))
                (known-by-principal message principal state))
           (not (ms!is-fresh message (all-messages-in-state state)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(APPLY MS!NOT-PART-IMPLIES-NOT-COMP-OF)
(REWRITE)
(CASES)
(INVOKE (MS!IS-FRESH MESSAGE (MS!PRINCIPALS)))
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES)))
(SIMPLIFY)
(NEXT)
(INVOKE (ALL-STORAGE (STORES STATE)))
(INVOKE (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE)))))
(REWRITE)
(INVOKE STORAGE-OF)
(SPLIT (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL)
               (CUP (REL!RAN (STORES STATE)))))
(CASES)
(USE MS!IN-PARTS-SUBSET
     (K MESSAGE)
     (S1 (CUP (REL!RAN (STORES STATE))))
     (S2 (FN!APPLY (STORES STATE) PRINCIPAL)))
(SIMPLIFY)
(NEXT)
(INVOKE SUBSET)
(REARRANGE)
(PRENEX)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(INSTANTIATE (Y (FN!APPLY (STORES STATE) PRINCIPAL)))
(REWRITE)
(USE FN!APPLY-IN-RAN (F (STORES STATE)) (X PRINCIPAL))
(REWRITE)
(NEXT)

(axiom forgeable-implies-not-fresh (message state)
  (implies (and (is-good-state state)
                (in message (ms!atomic-messages))
                (forgeable message state))
           (not (ms!is-fresh message (all-messages-in-state state)))))
(INVOKE FORGEABLE)
(REWRITE)
(APPLY MS!NOT-PART-IMPLIES-NOT-COMP-OF)
(REWRITE)
(CASES)
(INVOKE (MS!IS-FRESH MESSAGE (MS!PRINCIPALS)))
(SIMPLIFY)
(NEXT)
(CASES)
(INVOKE (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES)))
(SIMPLIFY)
(NEXT)
(INVOKE (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)))
(SIMPLIFY)
(NEXT)


;;; Equalities of events, ought to go in st

(rule send-event-equality (l1 l2 t1 t2 m1 m2 p1 p2)
  (= (= (make-send-event l1 t1 m1 p1)
        (make-send-event l2 t2 m2 p2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= p1 p2))))
(SPLIT (AND (= L1 L2)
            (= T1 T2)
            (= M1 M2)
            (= P1 P2)))
(SIMPLIFY)

(rule receive-event-equality (l1 l2 t1 t2 m1 m2 p1 p2)
  (= (= (make-receive-event l1 t1 m1 p1)
        (make-receive-event l2 t2 m2 p2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= p1 p2))))
(SPLIT (AND (= L1 L2)
            (= T1 T2)
            (= M1 M2)
            (= P1 P2)))
(SIMPLIFY)

(rule out-of-band-event-equality (l1 l2 t1 t2 m1 m2 s1 s2 r1 r2)
  (= (= (make-out-of-band-event l1 t1 m1 s1 r1)
        (make-out-of-band-event l2 t2 m2 s2 r2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= s1 s2) (= r1 r2))))
(SPLIT (AND (= L1 L2)
            (= T1 T2)
            (= M1 M2)
            (= S1 S2)
            (= R1 R2)))
(SIMPLIFY)

(rule generate-event-equality (l1 l2 t1 t2 m1 m2 p1 p2)
  (= (= (make-generate-event l1 t1 m1 p1)
        (make-generate-event l2 t2 m2 p2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= p1 p2))))
(SPLIT (AND (= L1 L2)
            (= T1 T2)
            (= M1 M2)
            (= P1 P2)))
(SIMPLIFY)

(rule construct-event-equality (l1 l2 t1 t2 m1 m2 p1 p2)
  (= (= (make-construct-event l1 t1 m1 p1)
        (make-construct-event l2 t2 m2 p2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= p1 p2))))
(SPLIT (AND (= L1 L2)
            (= T1 T2)
            (= M1 M2)
            (= P1 P2)))
(SIMPLIFY)

(rule intruder-event-equality (l1 l2 t1 t2 m1 m2)
  (= (= (make-intruder-event l1 t1 m1)
        (make-intruder-event l2 t2 m2))
     (and (= l1 l2) (= t1 t2) (= m1 m2))))
(SPLIT (AND (= L1 L2)
            (= T1 T2)
            (= M1 M2)))
(SIMPLIFY)

(rule 3combine-equality (1m1 1m2 1m3 2m1 2m2 2m3)
  (implies (and (in 1m1 (ms!messages))
                (in 1m2 (ms!messages))
                (in 1m3 (ms!messages))
                (in 2m1 (ms!messages))
                (in 2m2 (ms!messages))
                (in 2m3 (ms!messages)))
           (= (= (3combine 1m1 1m2 1m3) (3combine 2m1 2m2 2m3))
              (and (= 1m1 2m1) (= 1m2 2m2) (= 1m3 2m3)))))
(INVOKE 3COMBINE)
(REWRITE)

(rule 4combine-equality (1m1 1m2 1m3 1m4 2m1 2m2 2m3 2m4)
  (implies (and (in 1m1 (ms!messages))
                (in 1m2 (ms!messages))
                (in 1m3 (ms!messages))
                (in 1m4 (ms!messages))
                (in 2m1 (ms!messages))
                (in 2m2 (ms!messages))
                (in 2m3 (ms!messages))
                (in 2m4 (ms!messages)))
           (= (= (4combine 1m1 1m2 1m3 1m4) (4combine 2m1 2m2 2m3 2m4))
              (and (= 1m1 2m1) (= 1m2 2m2) (= 1m3 2m3) (= 1m4 2m4)))))
(INVOKE 4COMBINE)
(REWRITE)

(rule 5combine-equality (1m1 1m2 1m3 1m4 1m5 2m1 2m2 2m3 2m4 2m5)
  (implies (and (in 1m1 (ms!messages))
                (in 1m2 (ms!messages))
                (in 1m3 (ms!messages))
                (in 1m4 (ms!messages))
                (in 1m5 (ms!messages))
                (in 2m1 (ms!messages))
                (in 2m2 (ms!messages))
                (in 2m3 (ms!messages))
                (in 2m4 (ms!messages))
                (in 2m5 (ms!messages)))
           (= (= (5combine 1m1 1m2 1m3 1m4 1m5)
                 (5combine 2m1 2m2 2m3 2m4 2m5))
              (and (= 1m1 2m1) (= 1m2 2m2) (= 1m3 2m3) (= 1m4 2m4)
                   (= 1m5 2m5)))))
(INVOKE 5COMBINE)
(REWRITE)

(rule 6combine-equality (1m1 1m2 1m3 1m4 1m5 1m6 2m1 2m2 2m3 2m4 2m5 2m6)
  (implies (and (in 1m1 (ms!messages))
                (in 1m2 (ms!messages))
                (in 1m3 (ms!messages))
                (in 1m4 (ms!messages))
                (in 1m5 (ms!messages))
                (in 1m6 (ms!messages))
                (in 2m1 (ms!messages))
                (in 2m2 (ms!messages))
                (in 2m3 (ms!messages))
                (in 2m4 (ms!messages))
                (in 2m5 (ms!messages))
                (in 2m6 (ms!messages)))
           (= (= (6combine 1m1 1m2 1m3 1m4 1m5 1m6)
                 (6combine 2m1 2m2 2m3 2m4 2m5 2m6))
              (and (= 1m1 2m1) (= 1m2 2m2) (= 1m3 2m3)
                   (= 1m4 2m4) (= 1m5 2m5) (= 1m6 2m6)))))
(INVOKE 6COMBINE)
(REWRITE)

;;; New on Jan. 4th

(rule forgeable-add-to-seen-messages-and-history (m1 m2 event state)
  (implies (is-good-state state)
           (= (forgeable
                m1
                (add-to-state-seen-messages
                  m2 (add-to-state-history event state)))
              (forgeable
                m1 (add-to-state-seen-messages m2 state)))))
(INVOKE FORGEABLE)
(REWRITE)

(rule known-by-principal-add-to-seen-messages-and-history (m1 m2 p event state)
  (implies (is-good-state state)
           (= (known-by-principal
                m1 p
                (add-to-state-seen-messages
                  m2 (add-to-state-history event state)))
              (known-by-principal
                m1 p (add-to-state-seen-messages m2 state)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(INVOKE STORAGE-OF)
(REWRITE)

;;; New on Jan. 7th
(rule storage-of-subset-all-storage (principal state)
  (implies (and (in principal (ms!principals))
                (is-good-state state))
           (= (subset (storage-of principal state)
                      (all-storage (stores state)))
              (true))))
(INVOKE ALL-STORAGE)
(INVOKE SUBSET)
(INVOKE STORAGE-OF)
(REWRITE)
(PRENEX)
(USE FN!APPLY-IN-RAN (F (STORES STATE)) (X PRINCIPAL))
(REARRANGE)
(REWRITE)

;;; New Jan, 10th

(rule forgeable-add-to-state-history (message event state)
  (= (forgeable message (add-to-state-history event state))
     (forgeable message state)))
(INVOKE FORGEABLE)
(REWRITE)

(rule known-by-principal-add-to-state-history (message principal event state)
  (= (known-by-principal message principal (add-to-state-history event state))
     (known-by-principal message principal state)))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(INVOKE STORAGE-OF)
(REWRITE)

;;; Inserted Jan 11th

(rule known-by-principal-add-to-state-seen-messages (m m1 p s)
  (= (known-by-principal m p (add-to-state-seen-messages m1 s))
     (known-by-principal m p s)))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(INVOKE STORAGE-OF)
(REWRITE)

(rule forgeable-add-combine (m m1 m2 ms s)
  (implies (and (is-good-state s)
                (in m1 (ms!messages))
                (in m2 (ms!messages))
		(subset ms (ms!messages)))
           (= (forgeable
                m
		(add-to-state-seen-messages (setadd (ms!combine m1 m2) ms) s))
              (forgeable
                m (add-to-state-seen-messages (setadd m1 (setadd m2 ms)) s)))))
(INVOKE FORGEABLE)
(REWRITE)
(APPLY MS!KNOWN-IN-SETADD-COMBINE)
(REWRITE)

(rule forgeable-add-public-key (m ms p s)
  (implies (and (in p (ms!public-keys))
                (is-good-state s))
           (= (forgeable m (add-to-state-seen-messages (setadd p ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))
(INVOKE FORGEABLE)
(REWRITE)

(rule forgeable-add-text-message (m t ms s)
  (implies (and (in t (ms!text-messages))
                (is-good-state s))
           (= (forgeable m (add-to-state-seen-messages (setadd t ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))
(INVOKE FORGEABLE)
(REWRITE)

(rule forgeable-add-principal (m p ms s)
  (implies (and (in p (ms!principals))
                (is-good-state s))
           (= (forgeable m (add-to-state-seen-messages (setadd p ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))
(INVOKE FORGEABLE)
(REWRITE)

(rule forgeable-add-sign (m m1 k ms s)
  (implies (and (in k (ms!keys))
                (in m1 (ms!messages))
		(subset ms (ms!messages))
                (is-good-state s))
           (= (forgeable m (add-to-state-seen-messages (setadd (sign m1 k) ms)
						       s))
              (forgeable
                m (add-to-state-seen-messages
		   (setadd m1 (setadd (ms!encrypt (ms!hash m1) k) ms))
		   s)))))
(INVOKE SIGN)
(REWRITE)


(rule forgeable-combine (m1 m2 s)
  (= (forgeable (ms!combine m1 m2) s)
     (and (forgeable m1 s) (forgeable m2 s))))
(INVOKE FORGEABLE)
(REWRITE)

(rule forgeable-add-nonce (m n ms s)
  (implies (and (in n (ms!nonces))
                (in m (ms!atomic-messages)))
           (= (forgeable m (add-to-state-seen-messages (setadd n ms) s))
              (or (= m n)
                  (forgeable m (add-to-state-seen-messages ms s))))))
(INVOKE FORGEABLE)
(REWRITE)

(rule forgeable-add-hash (m m1 ms s)
  (implies (and (in m (ms!atomic-messages))
                (in m1 (ms!messages)))
           (= (forgeable m (add-to-state-seen-messages (setadd (ms!hash m1) ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))
(INVOKE FORGEABLE)
(REWRITE)

(rule forgeable-add-encrypt-hash (m m1 k ms s)
  (implies (and (in m (ms!atomic-messages))
                (in m1 (ms!messages))
                (in k (ms!keys)))
           (= (forgeable
                m (add-to-state-seen-messages
                    (setadd (ms!encrypt (ms!hash m1) k) ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))
(INVOKE FORGEABLE)
(REWRITE)
(APPLY MS!C2)
(REWRITE)


(rule forgeable-add-to-state-storage (m m1 p s)
  (= (forgeable m (add-to-state-storage p m1 s))
     (forgeable m s)))
(INVOKE FORGEABLE)
(REWRITE)

(grule storage-of-is-subset-messages (S P)
    (implies (AND (IS-GOOD-STATE S)
		  (IN P (MS!PRINCIPALS)))
	     (SUBSET (STORAGE-OF P S) (MS!MESSAGES))))
(INVOKE SUBSET)
(PRENEX)
(INVOKE STORAGE-OF)
(USE FN!APPLY-IN-RAN (F (STORES S)) (X P))
(REARRANGE)
(REWRITE)
(INVOKE IS-GOOD-STATE)
(INVOKE SUBSET)
(REWRITE)
(INVOKE SUBSET)
(REWRITE)
(INSTANTIATE (E$2 (FN!APPLY (STORES S) P)))
(REWRITE)


(rule known-by-principal-add-combine (m p m1 m2 ms s)
  (implies (and (is-good-state s)
                (in p (ms!principals))
                (in m1 (ms!messages))
                (in m2 (ms!messages))
		(subset ms (ms!messages)))
           (= (known-by-principal
                m p (add-to-state-storage p (setadd (ms!combine m1 m2) ms) s))
              (known-by-principal
                m p (add-to-state-storage p (setadd m1 (setadd m2 ms)) s)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(APPLY MS!KNOWN-IN-SETADD-COMBINE)
(REWRITE)

(rule known-by-principal-add-public-key (m p pk ms s)
  (implies (and (in p (ms!principals))
                (in pk (ms!public-keys))
                (is-good-state s))
           (= (known-by-principal
               m p (add-to-state-storage p (setadd pk ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule known-by-principal-add-text-message (m p t ms s)
  (implies (and (in p (ms!principals))
                (in t (ms!text-messages))
                (is-good-state s))
           (= (known-by-principal m p (add-to-state-storage p (setadd t ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule known-by-principal-add-principal (m p p1 ms s)
  (implies (and (in p (ms!principals))
                (in p1 (ms!principals))
                (is-good-state s))
           (= (known-by-principal m p (add-to-state-storage p (setadd p1 ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule known-by-principal-add-sign (m p m1 k ms s)
  (implies (and (in p (ms!principals))
                (in k (ms!keys))
                (in m1 (ms!messages))
		(subset ms (ms!messages))
                (is-good-state s))
           (= (known-by-principal
               m p (add-to-state-storage p (setadd (sign m1 k) ms) s))
              (known-by-principal
                m p (add-to-state-storage
                     p
		     (setadd m1 (setadd (ms!encrypt (ms!hash m1) k) ms))
		     s)))))
(INVOKE SIGN)
(REWRITE)

(rule known-by-principal-combine (m1 m2 p s)
  (implies (in p (ms!principals))
           (= (known-by-principal (ms!combine m1 m2) p s)
              (and (known-by-principal m1 p s) (known-by-principal m2 p s)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule known-by-principal-add-nonce (m p n ms s)
  (implies (and (is-good-state s)
                (in p (ms!principals))
                (in n (ms!nonces))
                (in m (ms!atomic-messages)))
           (= (known-by-principal m p (add-to-state-storage p (setadd n ms) s))
              (or (= m n)
                  (known-by-principal m p (add-to-state-storage p ms s))))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule known-by-principal-add-hash (m p m1 ms s)
  (implies (and (is-good-state s)
                (in m (ms!atomic-messages))
                (in p (ms!principals))
                (in m1 (ms!messages)))
           (= (known-by-principal
               m p (add-to-state-storage p (setadd (ms!hash m1) ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(rule known-by-principal-add-encrypt-hash (m p m1 k ms s)
  (implies (and (is-good-state s)
                (in m (ms!atomic-messages))
                (in p (ms!principals))
                (in m1 (ms!messages))
                (in k (ms!keys)))
           (= (known-by-principal
                m p (add-to-state-storage p
                     (setadd (ms!encrypt (ms!hash m1) k) ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(APPLY MS!C2)
(REWRITE)



;;; Added January 13th.


(disabled
 (rule permute-add-to-storage-add-to-history (p m e state)
   (= (add-to-state-storage
       p m (add-to-state-history e state))
      (add-to-state-history
       e (add-to-state-storage p m state)))))
(REDUCE)

(rule known-by-principal-add-to-storage-and-history (m1 p1 m2 p2 event state)
  (implies (and (is-good-state state)
                (in p2 (ms!principals))
                (subset m2 (ms!messages)))
           (= (known-by-principal
               m1 p1
               (add-to-state-storage
                p2 m2 (add-to-state-history event state)))
              (known-by-principal
               m1 p1 (add-to-state-storage p2 m2 state)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(APPLY PERMUTE-ADD-TO-STORAGE-ADD-TO-HISTORY)
(REWRITE)

(axiom newly-known-by-generation-not-forgeable (m1 p1 m2 p2 label time state)
  (implies (and (not (known-by-principal m1 p1 state))
                (in m1 (ms!atomic-messages))
                (in p1 (ms!principals))
                (known-by-principal
                 m1 p1 (generate-step label time m2 p2 state)))
           (and (= m1 m2)
                (= p1 p2)
                (not (forgeable m1 state)))))
(INVOKE GENERATE-STEP)
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(INVOKE FORGEABLE)
(REWRITE)
(SPLIT (AND (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS))))
(REWRITE)
(SPLIT (IN M2 (MS!SECRET-KEYS)))
(REWRITE)
(CASES)
(SPLIT (= M1 M2))
(REWRITE)
(APPLY
 MS!NOT-PART-IMPLIES-NOT-COMP-OF
 (MS!COMP-OF
  M1
  (UNION
   (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))
(REWRITE)
(INVOKE MS!IS-FRESH)
(SIMPLIFY)
(NEXT)
(USE MS!IS-FRESH-SUBSET
     (K M2) (S1 (ALL-STORAGE (STORES STATE))) (S2 (STORAGE-OF P1 STATE)))
(REARRANGE)
(REWRITE)
(NEXT)
(SPLIT (IN M2 (MS!SYMMETRIC-KEYS)))
(REWRITE)
(CASES)
(SPLIT (= M1 M2))
(REWRITE)
(APPLY
 MS!NOT-PART-IMPLIES-NOT-COMP-OF
 (MS!COMP-OF
  M1
  (UNION
   (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))
(REWRITE)
(INVOKE MS!IS-FRESH)
(SIMPLIFY)
(NEXT)
(USE MS!IS-FRESH-SUBSET
     (K M2) (S1 (ALL-STORAGE (STORES STATE))) (S2 (STORAGE-OF P1 STATE)))
(REARRANGE)
(REWRITE)
(NEXT)
(INVOKE MS!ATOMIC-MESSAGES)
(INVOKE MS!KEYS)
(INVOKE MS!ASYMMETRIC-KEYS)
(INVOKE MS!BASIC-MESSAGES)
(REWRITE)
(APPLY
 MS!NOT-PART-IMPLIES-NOT-COMP-OF
 (MS!COMP-OF
  M1
  (UNION
   (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))
(REWRITE)
(INVOKE MS!IS-FRESH)
(SIMPLIFY)

(axiom is-good-evolution-state-has-good-evolution (state)
  (implies (is-good-evolution-state state)
           (some (sequence)
             (and (is-good-evolution sequence)
                  (= (seq!head sequence) state)))))
(INDUCT)
(CASES)
(INSTANTIATE (SEQUENCE (SEQ!TACK STATE (SEQ!EMPTY))))
(INVOKE IS-GOOD-EVOLUTION)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(REWRITE)
(PRENEX)
(INSTANTIATE (PREVIOUS-STATE$0 PREVIOUS-STATE))
(REWRITE)
(INSTANTIATE (SEQUENCE$1 (SEQ!TACK STATE SEQUENCE)))
(INVOKE (IS-GOOD-EVOLUTION (SEQ!TACK STATE SEQUENCE)))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(NEXT)

(axiom time-of-event-constraint-aux (event history)
  (implies (and (in history (seq!sequence-of (events)))
                (seq!is-member event history)
                (time-strictly-increases history))
           (>= (time-of-event (seq!head history))
               (time-of-event event))))
(INDUCT)
(CASES)
(INVOKE SEQ!IS-MEMBER)
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER EVENT HISTORY))
(REARRANGE)
(REWRITE)
(CASES)
(USE TIME-OF-EVENT-IN-CONSTRAINED-HISTORY-NAT (EVENT EVENT) (HISTORY HISTORY))
(REARRANGE)
(REWRITE)
(INVOKE SEQ!IS-MEMBER)
(REWRITE)
(NEXT)
(CASES)
(CASES)
(USE TIME-OF-EVENT-IN-CONSTRAINED-HISTORY-NAT
     (EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (HISTORY HISTORY))
(REARRANGE)
(REWRITE)
(INVOKE (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY)) HISTORY))
(REWRITE)
(CASES)
(INVOKE (TIME-STRICTLY-INCREASES HISTORY))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!TAIL HISTORY)))
(REWRITE)
(CASES)
(INVOKE (TIME-STRICTLY-INCREASES HISTORY))
(REWRITE)
(SPLIT
  (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
(SPLIT (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0))
(REWRITE)
(NEXT)
(INVOKE SEQ!LENGTH)
(REWRITE)
(NEXT)
(INVOKE (SEQ!MEMBERS HISTORY))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-SEQUENCE HISTORY))
(REWRITE)
(NEXT)
(INVOKE TIME-STRICTLY-INCREASES)
(REWRITE)
(INVOKE SEQ!IS-MEMBER)
(REWRITE)
(INVOKE (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY)))
(REWRITE)
(INVOKE SEQ!LENGTH)
(REWRITE)
(NEXT)

(axiom time-of-event-constraint (event state)
  (implies (and (is-good-state state)
                (seq!is-member event (history state)))
           (>= (time-of-event (seq!head (history state)))
               (time-of-event event))))
(INVOKE IS-GOOD-STATE)
(USE TIME-OF-EVENT-CONSTRAINT-AUX (EVENT EVENT) (HISTORY (HISTORY STATE)))
(REWRITE)

(axiom forgeable-monotonic-over-step (n sequence message)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (forgeable message (seq!nth sequence (+ n 1))))
           (forgeable message (seq!nth sequence n))))
(USE NON-INITIAL-STATE-IS-RESULT-OF-STEP (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE (SEQ!NTH SEQUENCE N)))
(TRIVIAL-REWRITE)
(WITHOUT-NORMALIZATION (REWRITE))

(axiom known-by-principal-monotonic-over-step (n sequence message principal)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in principal (ms!principals))
                (known-by-principal
                 message principal (seq!nth sequence (+ n 1))))
           (known-by-principal message principal (seq!nth sequence n))))
(USE NON-INITIAL-STATE-IS-RESULT-OF-STEP (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE (SEQ!NTH SEQUENCE N)))
(TRIVIAL-REWRITE)
(WITHOUT-NORMALIZATION (REWRITE))

(disabled
 (rule history-of-nth-of-tail-of-good-evolution (n sequence)
   (implies (and (is-good-evolution sequence)
                 (>= n 1)
                 (<= n (- (seq!length sequence) 1)))
            (= (history (seq!nth (seq!tail sequence) n))
               (seq!tail (history (seq!nth sequence n)))))))
(INDUCT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(CASES)
(INVOKE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
(INVOKE (SEQ!NTH SEQUENCE N))
(REWRITE)
(NEXT)
(INVOKE SEQ!NTH)
(REWRITE)
(APPLY HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION
       (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE)))))
(REWRITE)
(APPLY HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(NEXT)

(rule nth-history-head-evolution (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (seq!length (history (seq!head sequence)))))
           (= (seq!nth (history (seq!head sequence)) n)
              (seq!head (history (seq!nth sequence n))))))
(INDUCT)
(CASES)
(REWRITE)
(APPLY HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)
(INVOKE (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N))
(INVOKE (SEQ!NTH SEQUENCE N))
(REWRITE)
(APPLY HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(INVOKE SEQ!NTH)
(REWRITE)
(NEXT)
(REWRITE)
(NEXT)

(axiom send-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (send-events))
                (seq!is-member event (history state)))
           (and (known-by-principal
                 (message-of-event event)
                 (principal1-of-event event)
                 state)
                (forgeable (message-of-event event) state))))
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH (M EVENT) (S (HISTORY STATE)))
(REWRITE)
(CASES)
(PRENEX)
(USE IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION (STATE STATE))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE STATE)
(APPLY NTH-HISTORY-HEAD-EVOLUTION)
(REWRITE)
(USE SEND-EVENT-THEOREM (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(USE KNOWN-BY-IS-MONOTONIC
     (SEQUENCE SEQUENCE)
     (PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
     (MESSAGE (MESSAGE-OF-EVENT EVENT))
     (N1 (+ N 1))
     (N2 1))
(INVOKE (SEQ!NTH SEQUENCE 1))
(REARRANGE)
(REWRITE)
(USE FORGEABLE-IS-MONOTONIC
     (SEQUENCE SEQUENCE) (MESSAGE (MESSAGE-OF-EVENT EVENT)) (N1 N) (N2 1))
(INVOKE (SEQ!NTH SEQUENCE 1))
(REARRANGE)
(REWRITE)
(USE SEND-EVENT-IS-CONSTRUCTED (E EVENT))
(PRENEX)
(SIMPLIFY)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)

(axiom receive-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (receive-events))
                (seq!is-member event (history state)))
           (and (known-by-principal
                 (message-of-event event)
                 (principal1-of-event event)
                 state)
                (forgeable (message-of-event event) state))))
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH (M EVENT) (S (HISTORY STATE)))
(REWRITE)
(CASES)
(PRENEX)
(USE IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION (STATE STATE))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE STATE)
(APPLY NTH-HISTORY-HEAD-EVOLUTION)
(REWRITE)
(USE RECEIVE-EVENT-THEOREM (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(USE KNOWN-BY-IS-MONOTONIC
     (SEQUENCE SEQUENCE)
     (PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
     (MESSAGE (MESSAGE-OF-EVENT EVENT))
     (N1 N)
     (N2 1))
(INVOKE (SEQ!NTH SEQUENCE 1))
(REARRANGE)
(REWRITE)
(USE
  FORGEABLE-IS-MONOTONIC
  (SEQUENCE SEQUENCE) (MESSAGE (MESSAGE-OF-EVENT EVENT)) (N1 (+ N 1)) (N2 1))
(INVOKE (SEQ!NTH SEQUENCE 1))
(REARRANGE)
(REWRITE)
(USE RECEIVE-EVENT-IS-CONSTRUCTED (E EVENT))
(PRENEX)
(SIMPLIFY)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)

(axiom out-of-band-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (out-of-band-events))
                (seq!is-member event (history state)))
           (and (known-by-principal
                 (message-of-event event)
                 (principal1-of-event event)
                 state)
                (known-by-principal
                 (message-of-event event)
                 (principal2-of-event event)
                 state))))
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH (M EVENT) (S (HISTORY STATE)))
(REWRITE)
(CASES)
(PRENEX)
(USE IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION (STATE STATE))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE STATE)
(APPLY NTH-HISTORY-HEAD-EVOLUTION)
(REWRITE)
(USE OUT-OF-BAND-EVENT-THEOREM (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(USE KNOWN-BY-IS-MONOTONIC
     (SEQUENCE SEQUENCE)
     (PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
     (MESSAGE (MESSAGE-OF-EVENT EVENT))
     (N1 N)
     (N2 1))
(USE KNOWN-BY-IS-MONOTONIC
     (SEQUENCE SEQUENCE)
     (PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
     (MESSAGE (MESSAGE-OF-EVENT EVENT))
     (N1 (+ N 1))
     (N2 1))
(USE KNOWN-BY-IS-MONOTONIC
     (SEQUENCE SEQUENCE)
     (PRINCIPAL (PRINCIPAL2-OF-EVENT EVENT))
     (MESSAGE (MESSAGE-OF-EVENT EVENT))
     (N1 N)
     (N2 1))
(INVOKE (SEQ!NTH SEQUENCE 1))
(REARRANGE)
(REWRITE)
(USE OUT-OF-BAND-EVENT-IS-CONSTRUCTED (E EVENT))
(PRENEX)
(SIMPLIFY)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)

(axiom generate-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (generate-events))
                (seq!is-member event (history state)))
           (known-by-principal
            (message-of-event event)
            (principal1-of-event event)
            state)))
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH (M EVENT) (S (HISTORY STATE)))
(REWRITE)
(CASES)
(PRENEX)
(USE IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION (STATE STATE))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE STATE)
(APPLY NTH-HISTORY-HEAD-EVOLUTION)
(REWRITE)
(USE GENERATE-EVENT-THEOREM (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(USE KNOWN-BY-IS-MONOTONIC
     (SEQUENCE SEQUENCE)
     (PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
     (MESSAGE (MESSAGE-OF-EVENT EVENT))
     (N1 N)
     (N2 1))
(INVOKE (SEQ!NTH SEQUENCE 1))
(REARRANGE)
(REWRITE)
(USE GENERATE-EVENT-IS-CONSTRUCTED (E EVENT))
(PRENEX)
(SIMPLIFY)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)

(axiom construct-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (construct-events))
                (seq!is-member event (history state)))
           (known-by-principal
            (message-of-event event)
            (principal1-of-event event)
            state)))
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH (M EVENT) (S (HISTORY STATE)))
(REWRITE)
(CASES)
(PRENEX)
(USE IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION (STATE STATE))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE STATE)
(APPLY NTH-HISTORY-HEAD-EVOLUTION)
(REWRITE)
(USE CONSTRUCT-EVENT-THEOREM (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(USE KNOWN-BY-IS-MONOTONIC
     (SEQUENCE SEQUENCE)
     (PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
     (MESSAGE (MESSAGE-OF-EVENT EVENT))
     (N1 (+ N 1))
     (N2 1))
(INVOKE (SEQ!NTH SEQUENCE 1))
(REARRANGE)
(REWRITE)
(USE CONSTRUCT-EVENT-IS-CONSTRUCTED (E EVENT))
(PRENEX)
(SIMPLIFY)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)

(axiom intruder-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (intruder-events))
                (seq!is-member event (history state)))
           (forgeable
            (message-of-event event)
            state)))
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH (M EVENT) (S (HISTORY STATE)))
(REWRITE)
(CASES)
(PRENEX)
(USE IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION (STATE STATE))
(SIMPLIFY)
(PRENEX)
(EQUALITY-SUBSTITUTE STATE)
(APPLY NTH-HISTORY-HEAD-EVOLUTION)
(REWRITE)
(USE INTRUDER-EVENT-THEOREM (N N) (SEQUENCE SEQUENCE))
(SIMPLIFY)
(USE FORGEABLE-IS-MONOTONIC
     (SEQUENCE SEQUENCE) (MESSAGE (MESSAGE-OF-EVENT EVENT)) (N1 N) (N2 1))
(INVOKE (SEQ!NTH SEQUENCE 1))
(REARRANGE)
(REWRITE)
(NEXT)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)


(axiom send-event-is-from-send-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (send-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message principal)
             (and (is-good-evolution-state state1)
                  (= state (send-step label time message principal state1))
                  (not (= state state1))))))
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(CONJUNCTIVE)
(CASES)
(PRENEX)
(REWRITE)
(INSTANTIATE (STATE1 PREVIOUS-STATE))
(CONTRADICT)
(CASES)
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE SEND-STEP)
(REWRITE)
(SPLIT
  (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
(CASES)
(INVOKE (SEQ!LENGTH (HISTORY STATE)))
(REWRITE)
(NEXT)
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(INVOKE IS-GOOD-STATE)
(INVOKE (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
(REWRITE)
(NEXT)

(axiom receive-event-is-from-receive-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (receive-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message principal)
             (and (is-good-evolution-state state1)
                  (= state (receive-step label time message principal state1))
                  (not (= state state1))))))
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(CONJUNCTIVE)
(CASES)
(PRENEX)
(REWRITE)
(INSTANTIATE (STATE1 PREVIOUS-STATE))
(CONTRADICT)
(CASES)
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE RECEIVE-STEP)
(REWRITE)
(SPLIT
  (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
(CASES)
(INVOKE (SEQ!LENGTH (HISTORY STATE)))
(REWRITE)
(NEXT)
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(INVOKE IS-GOOD-STATE)
(INVOKE (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
(REWRITE)
(NEXT)

(axiom out-of-band-event-is-from-out-of-band-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (out-of-band-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message sender receiver)
             (and (is-good-evolution-state state1)
                  (= state
                     (out-of-band-step
                      label time message sender receiver state1))
                  (not (= state state1))))))
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(CONJUNCTIVE)
(CASES)
(PRENEX)
(REWRITE)
(INSTANTIATE (STATE1 PREVIOUS-STATE))
(CONTRADICT)
(CASES)
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE OUT-OF-BAND-STEP)
(REWRITE)
(SPLIT
  (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
(CASES)
(INVOKE (SEQ!LENGTH (HISTORY STATE)))
(REWRITE)
(NEXT)
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(INVOKE IS-GOOD-STATE)
(INVOKE (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
(REWRITE)
(NEXT)

(axiom generate-event-is-from-generate-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (generate-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message principal)
             (and (is-good-evolution-state state1)
                  (= state (generate-step label time message principal state1))
                  (not (= state state1))))))
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(CONJUNCTIVE)
(CASES)
(PRENEX)
(REWRITE)
(INSTANTIATE (STATE1 PREVIOUS-STATE))
(CONTRADICT)
(CASES)
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE GENERATE-STEP)
(REWRITE)
(SPLIT
  (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
(CASES)
(INVOKE (SEQ!LENGTH (HISTORY STATE)))
(REWRITE)
(NEXT)
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(INVOKE IS-GOOD-STATE)
(INVOKE (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
(REWRITE)
(NEXT)

(axiom construct-event-is-from-construct-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (construct-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message principal)
             (and (is-good-evolution-state state1)
                  (= state
                     (construct-step label time message principal state1))
                  (not (= state state1))))))
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(CONJUNCTIVE)
(CASES)
(PRENEX)
(REWRITE)
(INSTANTIATE (STATE1 PREVIOUS-STATE))
(CONTRADICT)
(CASES)
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE CONSTRUCT-STEP)
(REWRITE)
(SPLIT
  (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
(CASES)
(INVOKE (SEQ!LENGTH (HISTORY STATE)))
(REWRITE)
(NEXT)
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(INVOKE IS-GOOD-STATE)
(INVOKE (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
(REWRITE)
(NEXT)

(axiom intruder-event-is-from-intruder-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (intruder-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message)
             (and (is-good-evolution-state state1)
                  (= state (intruder-step label time message state1))
                  (not (= state state1))))))
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(CONJUNCTIVE)
(CASES)
(PRENEX)
(REWRITE)
(INSTANTIATE (STATE1 PREVIOUS-STATE))
(CONTRADICT)
(CASES)
(REWRITE)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE INTRUDER-STEP)
(REWRITE)
(SPLIT
  (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
(CASES)
(INVOKE (SEQ!LENGTH (HISTORY STATE)))
(REWRITE)
(NEXT)
(SIMPLIFY)
(NEXT)
(SIMPLIFY)
(INVOKE IS-GOOD-STATE)
(INVOKE (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
(REWRITE)
(NEXT)


;;; Added February 28, 2000

(rule known-by-principal-add-encrypt (s m p m1 ms k)
  (implies (and (is-good-state s)
                (in m (ms!atomic-messages))
                (in p (ms!principals))
                (in m1 (ms!messages))
                (in k (ms!keys)))
           (= (known-by-principal
               m p (add-to-state-storage p (setadd (ms!encrypt m1 k) ms) s))
              (if (known-by-principal (ms!inverse k) p (add-to-state-storage p ms s))
                  (known-by-principal m p (add-to-state-storage p (setadd m1 ms) s))
                  (known-by-principal m p (add-to-state-storage p ms s))))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(APPLY MS!C2)
(REWRITE)
(USE
  MS!COMP-OF-TRANSITIVE
  (M M)
  (S1 (SETADD M1 (union ms
              (UNION (MS!PRINCIPALS)
                     (UNION (MS!TEXT-MESSAGES)
                            (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (S2 (SETADD (MS!ENCRYPT M1 K) (union ms
              (UNION (MS!PRINCIPALS)
                     (UNION (MS!TEXT-MESSAGES)
                            (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
(REARRANGE)
(REWRITE)
(USE MS!B2
     (C M1)
     (K K)
     (S (SETADD (MS!ENCRYPT M1 K) (union ms
                (UNION (MS!PRINCIPALS)
                       (UNION (MS!TEXT-MESSAGES)
                              (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
(REARRANGE)
(REWRITE)

(rule known-by-principal-atomic-add-sign (m p m1 k ms s)
  (implies
   (and (in m (ms!atomic-messages))
        (in p (ms!principals))
        (in k (ms!keys))
        (in m1 (ms!messages))
	(subset ms (ms!messages))
        (is-good-state s))
   (= (known-by-principal m p (add-to-state-storage p (setadd (sign m1 k) ms) s))
      (known-by-principal m p (add-to-state-storage p (setadd m1 ms) s)))))
(REWRITE)
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(SPLIT (= M M1))
(REWRITE)
(APPLY SETRULES!SETADD-COMMUTES)
(APPLY MS!C2)
(REWRITE)
(APPLY
 SETRULES!SETADD-COMMUTES
 (SETADD
  M1
  (SETADD
   (MS!HASH M1)
   (UNION ms (union
    (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
(APPLY MS!C1C)
(REWRITE)
(USE
 MS!COMP-OF-SUBSET
 (C M)
 (S1 (SETADD M1 (union ms
             (UNION (MS!PRINCIPALS)
                    (UNION (MS!TEXT-MESSAGES)
                           (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
 (S2 (SETADD
       M1 (union ms
       (SETADD (MS!ENCRYPT (MS!HASH M1) K)
               (UNION (MS!PRINCIPALS)
                      (UNION (MS!TEXT-MESSAGES)
                             (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
(REWRITE)

(rule known-by-principal-monotonic-over-add-to-state-storage (m p m1 s)
  (implies (and (is-good-state s)
                (in p (ms!principals))
                (subset m1 (ms!messages))
                (known-by-principal m p s))
           (= (known-by-principal m p (add-to-state-storage p m1 s))
              (true))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(use ms!known-in-subset (c m)
     (s1 (UNION
       (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))
     (s2 (UNION
     M1
     (UNION
       (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
(simplify)

(rule add-to-state-storage-collects (m1 m2 p s)
   (implies (is-good-state s)
            (= (add-to-state-storage p m1 (add-to-state-storage p m2 s))
               (add-to-state-storage p (union m1 m2) s))))
(INVOKE ADD-TO-STATE-STORAGE)
(REWRITE)
(INVOKE ADD-TO-STORAGE)
(REWRITE)
(INVOKE FN!OVERRIDE)
(REWRITE)

(axiom in-history-implies-is-head-of-history-of-nth (event sequence)
  (implies (and (is-good-evolution sequence)
                (seq!is-member event (history (seq!head sequence))))
           (some (n)
             (and (>= n 1)
                  (< n (seq!length sequence))
                  (= event (seq!head (history (seq!nth sequence n))))))))
(INDUCT)
(REWRITE)
(CASES)
(CASES)
(CASES)
(PRENEX)
(INSTANTIATE (N$0 (+ N 1)))
(REWRITE)
(INVOKE (SEQ!LENGTH SEQUENCE))
(REWRITE)
(INVOKE (SEQ!NTH SEQUENCE (+ 1 N)))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
(REWRITE)
(CASES)
(INSTANTIATE (N 1))
(REWRITE)
(INVOKE (SEQ!NTH SEQUENCE 1))
(REWRITE)
(NEXT)
(APPLY HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER EVENT (SEQ!EMPTY)))
(REWRITE)
(NEXT)

(axiom in-history-implies-is-head-of-history-of-subsequence (event sequence)
  (implies (and (is-good-evolution sequence)
                (seq!is-member event (history (seq!head sequence))))
           (some (s subsequence)
             (and (seq!is-sequence s)
                  (is-good-evolution subsequence)
                  (= sequence (seq!join s subsequence))
                  (= event (seq!head (history (seq!head subsequence))))))))
(INDUCT)
(REWRITE)
(CASES)
(CASES)
(CASES)
(PRENEX)
(INSTANTIATE (S$0 (SEQ!TACK (SEQ!HEAD SEQUENCE) S))
             (SUBSEQUENCE$0 SUBSEQUENCE))
(REWRITE)
(EQUALITY-SUBSTITUTE (SEQ!JOIN S SUBSEQUENCE))
(SPLIT (SEQ!IS-TACK SEQUENCE))
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(NEXT)
(INVOKE (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
(REWRITE)
(CASES)
(INSTANTIATE (S (SEQ!EMPTY)) (SUBSEQUENCE SEQUENCE))
(REWRITE)
(NEXT)
(APPLY HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION SEQUENCE))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER EVENT (SEQ!EMPTY)))
(REWRITE)
(NEXT)


(axiom fresh-implies-not-known-by-principal (message principal state)
  (implies (and (is-good-state state)
                (in principal (ms!principals))
                (in message (ms!atomic-messages))
                (ms!is-fresh message (all-messages-in-state state)))
           (not (known-by-principal message principal state))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(INVOKE MS!IS-FRESH)
(REWRITE)
(APPLY MS!NOT-PART-IMPLIES-NOT-COMP-OF)
(REWRITE)
(INVOKE ALL-STORAGE)
(USE MS!IN-PARTS-SUBSET
     (K MESSAGE)
     (S1 (CUP (REL!RAN (STORES STATE))))
     (S2 (STORAGE-OF PRINCIPAL STATE)))
(REWRITE)
(INVOKE SUBSET)
(PRENEX)
(REWRITE)
(INSTANTIATE (Y (STORAGE-OF PRINCIPAL STATE)))
(INVOKE STORAGE-OF)
(USE FN!APPLY-IN-RAN (F (STORES STATE)) (X PRINCIPAL))
(REWRITE)

(axiom fresh-in-all-messages-implies-fresh-in-storage-of-principal
    (message principal state)
  (implies (and (is-good-state state)
                (in principal (ms!principals))
                (in message (ms!atomic-messages))
                (ms!is-fresh message (all-messages-in-state state)))
           (ms!is-fresh message (storage-of principal state))))
(REWRITE)

(function fresh-outside-principal (message principal state) ()
  (and (ms!is-fresh message
                    (union (ms!public-keys)
                           (union (ms!text-messages)
                                  (union (ms!principals)
                                         (seen-messages state)))))
       (all (p) (implies (and (in p (ms!principals))
                              (not (= p principal)))
                         (ms!is-fresh message (storage-of p state))))))


;;; New, March 2000

(axiom fresh-outside-principal-implies-not-forgeable (message principal state)
  (implies (and (is-good-state state)
                (in principal (ms!principals))
                (in message (ms!atomic-messages))
                (fresh-outside-principal message principal state))
           (not (forgeable message state))))
(INVOKE FRESH-OUTSIDE-PRINCIPAL)
(INVOKE (MS!IS-FRESH
          MESSAGE
          (UNION (MS!PUBLIC-KEYS)
                 (UNION (MS!TEXT-MESSAGES)
                        (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE))))))
(INVOKE FORGEABLE)
(REWRITE)

(axiom known-by-principal-monotonic-join (m p s1 s2)
  (implies (and (in p (ms!principals))
                (is-good-evolution s1)
                (seq!is-sequence s2)
                (is-good-evolution (seq!join s2 s1))
                (known-by-principal m p (seq!head s1)))
           (known-by-principal m p (seq!head (seq!join s2 s1)))))
(INDUCT)
(CASES)
(REARRANGE)
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(CASES)
(USE KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-STEP
     (N 1) (SEQUENCE (SEQ!JOIN S2 S1)) (MESSAGE M) (PRINCIPAL P))
(REARRANGE)
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(CASES)
(INVOKE SEQ!NTH)
(INVOKE SEQ!NTH)
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(INVOKE (SEQ!JOIN S2 S1))
(REWRITE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1)))
(REWRITE)
(INVOKE (SEQ!LENGTH S2))
(REWRITE)
(NEXT)
(INVOKE (SEQ!JOIN S2 S1))
(REWRITE)
(INVOKE
  (IS-GOOD-EVOLUTION (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION S1))
(REWRITE)
(NEXT)
(SPLIT (= S2 (SEQ!EMPTY)))
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(NEXT)

(axiom forgeable-monotonic-join (m s1 s2)
  (implies (and (is-good-evolution s1)
                (seq!is-sequence s2)
                (is-good-evolution (seq!join s2 s1))
                (forgeable m (seq!head s1)))
           (forgeable m (seq!head (seq!join s2 s1)))))
(INDUCT)
(CASES)
(REARRANGE)
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(CASES)
(USE FORGEABLE-MONOTONIC-OVER-STEP
     (N 1) (SEQUENCE (SEQ!JOIN S2 S1)) (MESSAGE M))
(REARRANGE)
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(CASES)
(INVOKE SEQ!NTH)
(INVOKE SEQ!NTH)
(REWRITE)
(INVOKE (SEQ!JOIN S2 S1))
(REWRITE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1)))
(REWRITE)
(INVOKE (SEQ!LENGTH S2))
(REWRITE)
(NEXT)
(INVOKE (SEQ!JOIN S2 S1))
(REWRITE)
(INVOKE
  (IS-GOOD-EVOLUTION (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION S1))
(REWRITE)
(NEXT)
(SPLIT (= S2 (SEQ!EMPTY)))
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(NEXT)

(axiom forgeable-monotonic-over-good-step (m s0 s1)
  (implies (and (good-step s0 s1)
                (forgeable m s0))
           (forgeable m s1)))
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))

(axiom known-by-principal-monotonic-over-good-step (m p s0 s1)
  (implies (and (good-step s0 s1)
                (in p (ms!principals))
                (known-by-principal m p s0))
           (known-by-principal m p s1)))
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))


;;; ************** NEW


(function is-generated (k s) ()
  (some (l t p1)
    (and (in p1 (ms!principals))
         (seq!is-member
          (make-generate-event l t k p1)
          (history s)))))

(function encrypted-part-of-sent (m k s) ()
  (some (l2 t2 m2 p2)
    (and (>= l2 0)
         (>= t2 0)
         (in m2 (ms!messages))
         (in p2 (ms!principals))
         (in m (ms!messages))
         (in k (ms!keys))
         (is-good-evolution-state s)
         (seq!is-member (make-send-event l2 t2 m2 p2)
                        (history s))
         (in (ms!encrypt m k)
             (ms!parts (setadd m2 (nullset)))))))

(axiom encrypted-message-theorem-1 (m k s)
  (implies (and (is-good-evolution-state s)
                (in m (ms!messages))
                (in k (ms!keys))
                (not (forgeable k s))
                (in (ms!encrypt m k) (ms!parts (seen-messages s)))
                (is-generated k s))
           (encrypted-part-of-sent m k s)))
(INDUCT)
(INVOKE IS-GENERATED)
(INVOKE ENCRYPTED-PART-OF-SENT)
(CASES)
(INVOKE (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)))
(REWRITE)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)
(PRENEX)
(INVOKE (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)))
(REWRITE)
(CASES)
(INVOKE (IS-GOOD-EVOLUTION-STATE S))
(REWRITE)
(PRENEX)
(INSTANTIATE (PREVIOUS-STATE$0 PREVIOUS-STATE) (L$0 L) (T$0 T) (P1$0 P1))
(REARRANGE)
(DELETE-HYPOTHESES
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
          (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
          (IN M (MS!MESSAGES))
          (IN K (MS!KEYS))
          (NOT (FORGEABLE K PREVIOUS-STATE$0))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
          (IN P1$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
                         (HISTORY PREVIOUS-STATE$0)))
    (SOME (L2$0)
     (AND
      (>= L2$0 0)
      (SOME (T2$0)
       (AND
        (>= T2$0 0)
        (SOME (M2$0)
         (AND
          (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND
            (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
                           (HISTORY PREVIOUS-STATE$0))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))))
(CASES)
(REWRITE)
(USE FORGEABLE-MONOTONIC-OVER-GOOD-STEP (M K) (S0 PREVIOUS-STATE) (S1 S))
(REWRITE)
(CASES)
(CASES)
(PRENEX)
(INSTANTIATE (L2$0 L2) (T2$0 T2) (M2$0 M2) (P2$0 P2))
(REWRITE)
(USE KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GOOD-STEP
     (M K) (P P2) (S0 PREVIOUS-STATE) (S1 S))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S)))
(REWRITE)
(NEXT)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(INVOKE (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE)))
(INSTANTIATE (M$0 M))
(SIMPLIFY)
(NEXT)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION-STATE S))
(REWRITE)
(PRENEX)
(INSTANTIATE (PREVIOUS-STATE$0 PREVIOUS-STATE) (L$0 L) (T$0 T) (P1$0 P1))
(DELETE-HYPOTHESES
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
         (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
         (IN M (MS!MESSAGES))
         (IN K (MS!KEYS))
         (NOT (FORGEABLE K PREVIOUS-STATE$0))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
         (IN P1$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
                        (HISTORY PREVIOUS-STATE$0)))
    (SOME (L2$0)
     (AND
      (>= L2$0 0)
      (SOME (T2$0)
       (AND
        (>= T2$0 0)
        (SOME (M2$0)
         (AND
          (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND
             (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
                            (HISTORY PREVIOUS-STATE$0))
             (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))))
(CASES)
(REWRITE)
(CASES)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(CASES)
(INSTANTIATE (L2$1 L2$0) (T2$1 T2$0) (M2$1 M2$0) (P2$1 P2$0))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S)))
(REWRITE)
(NEXT)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(SPLIT
  (= (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
     (UNION (SETADD MESSAGE (NULLSET)) (SEEN-MESSAGES PREVIOUS-STATE))))
(CASES)
(EQUALITY-SUBSTITUTE (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE)))
(APPLY MS!PARTS-UNION)
(REWRITE)
(INSTANTIATE (L2 LABEL) (T2 TIME) (M2 MESSAGE) (P2 PRINCIPAL))
(REWRITE)
(INVOKE (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
(REWRITE)
(NEXT)
(REWRITE)
(NEXT)

;(function encrypted-part-of-received (m p k s) ()
;  (some (l2 t2 m2)
;    (and (>= l2 0)
;         (>= t2 0)
;         (in m2 (ms!messages))
;         (in m (ms!messages))
;         (in p (ms!principals))
;         (in k (ms!keys))
;         (is-good-evolution-state s)
;         (seq!is-member (make-receive-event l2 t2 m2 p)
;                        (history s))
;         (in (ms!encrypt m k)
;             (ms!parts (setadd m2 (nullset)))))))

(function encrypted-part-of-received (m k s) ()
  (some (l2 t2 m2 p2)
    (and (>= l2 0)
         (>= t2 0)
         (in m2 (ms!messages))
         (in p2 (ms!principals))
         (in m (ms!messages))
         (in k (ms!keys))
         (is-good-evolution-state s)
         (seq!is-member (make-receive-event l2 t2 m2 p2)
                        (history s))
         (in (ms!encrypt m k)
             (ms!parts (setadd m2 (nullset)))))))

;(function encrypted-part-of-received-out-of-band (m p k s) ()
;  (some (l3 t3 m3 p3)
;    (and (>= l3 0)
;         (>= t3 0)
;         (in m3 (ms!messages))
;         (in p3 (ms!principals))
;         (in m (ms!messages))
;         (in p (ms!principals))
;         (in k (ms!keys))
;         (is-good-evolution-state s)
;         (seq!is-member (make-out-of-band-event l3 t3 m3 p3 p)
;                        (history s))
;         (in (ms!encrypt m k)
;             (ms!parts (setadd m3 (nullset)))))))

(function encrypted-part-of-received-out-of-band (m k s) ()
  (some (l3 t3 m3 p3 p4)
    (and (>= l3 0)
         (>= t3 0)
         (in m3 (ms!messages))
         (in p3 (ms!principals))
         (in p4 (ms!principals))
         (in m (ms!messages))
         (in k (ms!keys))
         (is-good-evolution-state s)
         (seq!is-member (make-out-of-band-event l3 t3 m3 p3 p4)
                        (history s))
         (in (ms!encrypt m k)
             (ms!parts (setadd m3 (nullset)))))))


(rule in-parts-setadd (m m1 s)
  (implies (not (= s (nullset)))
           (= (in m (ms!parts (setadd m1 s)))
              (or (in m (ms!parts (setadd m1 (nullset))))
                  (in m (ms!parts s))))))
(SPLIT (= (SETADD M1 S) (UNION (SETADD M1 (NULLSET)) S)))
(CASES)
(EQUALITY-SUBSTITUTE (SETADD M1 S))
(APPLY MS!PARTS-UNION)
(REWRITE)
(NEXT)
(REWRITE)
(NEXT)

(axiom encrypted-message-theorem-2 (m p k s)
  (implies (and (is-good-evolution-state s)
                (in m (ms!messages))
                (in p (ms!principals))
                (in k (ms!keys))
                (not (forgeable k s))
                (not (known-by-principal k p s))
                (in (ms!encrypt m k) (ms!parts (storage-of p s)))
		(is-generated k s))
           (or (encrypted-part-of-received m k s)
               (encrypted-part-of-received-out-of-band m k s))))
(INDUCT)
(INVOKE IS-GENERATED)
(INVOKE ENCRYPTED-PART-OF-RECEIVED)
(INVOKE ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND)
(CASES)
(INVOKE (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)))
(REWRITE)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)
(PRENEX)
(INVOKE (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)))
(REWRITE)
(CASES)
(INVOKE (IS-GOOD-EVOLUTION-STATE S))
(REWRITE)
(PRENEX)
(INSTANTIATE (PREVIOUS-STATE$0 PREVIOUS-STATE) (L$0 L) (T$0 T) (P1$0 P1))
(REARRANGE)
(DELETE-HYPOTHESES
 (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
  (IMPLIES
   (AND
    (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS))
    (IN K (MS!KEYS))
    (NOT (FORGEABLE K PREVIOUS-STATE$0))
    (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
    (IN P1$0 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
                   (HISTORY PREVIOUS-STATE$0))
    (NOT
     (SOME (L2$0)
      (AND
       (>= L2$0 0)
       (SOME (T2$0)
        (AND
         (>= T2$0 0)
         (SOME (M2$0)
          (AND
           (IN M2$0 (MS!MESSAGES))
           (SOME (P2$0)
            (AND
             (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
                            (HISTORY PREVIOUS-STATE$0))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
   (SOME (L3$0)
    (AND
     (>= L3$0 0)
     (SOME (T3$0)
      (AND
       (>= T3$0 0)
       (SOME (M3$0)
        (AND
         (IN M3$0 (MS!MESSAGES))
         (SOME (P3$0)
          (AND
            (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND
               (IN P4$0 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
                              (HISTORY PREVIOUS-STATE$0))
               (IN (MS!ENCRYPT M K)
                   (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))))
(CASES)
(REWRITE)
(USE FORGEABLE-MONOTONIC-OVER-GOOD-STEP (M K) (S0 PREVIOUS-STATE) (S1 S))
(REWRITE)
(CASES)
(USE KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GOOD-STEP
     (M K) (P P) (S0 PREVIOUS-STATE) (S1 S))
(REWRITE)
(NEXT)
(CASES)
(CASES)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(USE FRESH-IN-ALL-MESSAGES-IMPLIES-FRESH-IN-STORAGE-OF-PRINCIPAL
     (MESSAGE MESSAGE) (PRINCIPAL P) (STATE PREVIOUS-STATE))
(INVOKE (MS!IS-FRESH MESSAGE (STORAGE-OF P PREVIOUS-STATE)))
(INSTANTIATE (M$0 M))
(REWRITE)
(NEXT)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION-STATE S))
(REWRITE)
(PRENEX)
(INSTANTIATE (PREVIOUS-STATE$0 PREVIOUS-STATE) (L$0 L) (T$0 T) (P1$0 P1))
(DELETE-HYPOTHESES
 (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
  (IMPLIES
   (AND
    (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS))
    (IN K (MS!KEYS))
    (NOT (FORGEABLE K PREVIOUS-STATE$0))
    (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
    (IN P1$0 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
                   (HISTORY PREVIOUS-STATE$0))
    (NOT
     (SOME (L2$0)
      (AND
       (>= L2$0 0)
       (SOME (T2$0)
        (AND
         (>= T2$0 0)
         (SOME (M2$0)
          (AND
           (IN M2$0 (MS!MESSAGES))
           (SOME (P2$0)
            (AND
             (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
                            (HISTORY PREVIOUS-STATE$0))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
   (SOME (L3$0)
    (AND
     (>= L3$0 0)
     (SOME (T3$0)
      (AND
       (>= T3$0 0)
       (SOME (M3$0)
        (AND
         (IN M3$0 (MS!MESSAGES))
         (SOME (P3$0)
          (AND
            (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND
               (IN P4$0 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
                              (HISTORY PREVIOUS-STATE$0))
               (IN (MS!ENCRYPT M K)
                   (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))))
(CASES)
(REWRITE)
(USE FORGEABLE-MONOTONIC-OVER-GOOD-STEP (M K) (S0 PREVIOUS-STATE) (S1 S))
(REWRITE)
(CASES)
(USE KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GOOD-STEP
     (M K) (P P) (S0 PREVIOUS-STATE) (S1 S))
(REWRITE)
(NEXT)
(CASES)
(CASES)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(INSTANTIATE (L2$0 L2) (T2$0 T2) (M2$0 M2) (P2$0 P2))
(REWRITE)
(NEXT)
(PRENEX)
(INSTANTIATE (L3$0 L3) (T3$0 T3) (M3$0 M3) (P3$0 P3) (P4$0 P4))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S)))
(REWRITE)
(NEXT)
(INVOKE GOOD-STEP)
(PRENEX)
(CONJUNCTIVE)
(WITHOUT-NORMALIZATION (EQUALITY-SUBSTITUTE))
(WITHOUT-NORMALIZATION (REWRITE))
(CASES)
(INSTANTIATE (L2 LABEL) (T2 TIME) (M2 MESSAGE) (P2 PRINCIPAL$0))
(REWRITE)
(CASES)
(APPLY IN-PARTS-SETADD)
(REWRITE)
(NEXT)
(INVOKE (FORGEABLE MESSAGE PREVIOUS-STATE))
(REWRITE)
(NEXT)
(INSTANTIATE (L3$0 LABEL)
             (T3$0 TIME)
             (M3$0 MESSAGE)
             (P3$0 SENDER)
             (P4$0 RECEIVER))
(REWRITE)
(INVOKE (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
(REWRITE)
(APPLY IN-PARTS-SETADD)
(REWRITE)
(NEXT)

(axiom good-evolution-state-has-good-evolution (state)
  (implies (is-good-evolution-state state)
           (some (s)
             (and (is-good-evolution s)
                  (= (seq!head s) state)))))
(INDUCT)
(CASES)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(REWRITE)
(CASES)
(INSTANTIATE (S (SEQ!TACK STATE (SEQ!EMPTY))))
(REWRITE)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)
(INSTANTIATE (S$0 (SEQ!TACK STATE (SEQ!EMPTY))))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION (SEQ!TACK STATE (SEQ!EMPTY))))
(REWRITE)
(SPLIT (SEQ!IS-SEQUENCE (HISTORY STATE)))
(REWRITE)
(CASES)
(INVOKE SEQ!LENGTH)
(WITH-DISABLED (IS-TACK-EQUIV-NON-ZERO-LENGTH)
 (REWRITE))
(NEXT)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION-STATE STATE))
(REWRITE)
(PRENEX)
(INSTANTIATE (PREVIOUS-STATE$0 PREVIOUS-STATE))
(REWRITE)
(INSTANTIATE (S$1 (SEQ!TACK STATE S)))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION (SEQ!TACK STATE S)))
(REWRITE)
(INVOKE (IS-GOOD-EVOLUTION S))
(REWRITE)
(NEXT)

(zf-function send-events-containing-encrypt (m k)
  (select (event (send-events))
    (in (ms!encrypt m k)
        (ms!parts (unit (message-of-event event))))))

(axiom encrypted-part-of-sent-implication (m k s)
  (implies (and (is-good-evolution-state s)
                (encrypted-part-of-sent m k s))
           (some (event)
             (and (seq!is-member event (history s))
                  (in event (send-events-containing-encrypt m k))))))
(INVOKE ENCRYPTED-PART-OF-SENT)
(PRENEX)
(REWRITE)
(INSTANTIATE (EVENT (MAKE-SEND-EVENT L2 T2 M2 P2)))
(REWRITE)

(axiom encrypted-part-of-sent-implication-2 (m k s)
  (implies (and (is-good-evolution-state s)
                (encrypted-part-of-sent m k s))
           (some (n)
             (and (>= n 1)
                  (<= n (seq!length (history s)))
                  (in (seq!nth (history s) n)
                      (send-events-containing-encrypt m k))))))
(USE ENCRYPTED-PART-OF-SENT-IMPLICATION (M M) (K K) (S S))
(SIMPLIFY)
(PRENEX)
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH (M EVENT) (S (HISTORY S)))
(SIMPLIFY)
(INSTANTIATE (N$0 N))
(REWRITE)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(REWRITE)
(INVOKE IS-GOOD-STATE)
(REWRITE)


(zf-function reverse-indices (sequence set)
  (select (n (nat!nat))
    (and (>= n 0)
         (<= n (- (seq!length sequence) 1))
         (in (seq!nth sequence (- (seq!length sequence) n)) set))))

(axiom earliest-in-sequence-with-property (sequence set)
  (implies (and (seq!is-sequence sequence)
                (some (n)
                  (and (>= n 1)
                       (<= n (seq!length sequence))
                       (in (seq!nth sequence n) set))))
           (some (n1)
             (and (>= n1 1)
                  (<= n1 (seq!length sequence))
                  (in (seq!nth sequence n1) set)
                  (not (some (n2)
                         (and (>= n2 (+ n1 1))
                              (<= n2 (seq!length sequence))
                              (in (seq!nth sequence n2) set))))))))
(PRENEX)
(USE NAT!SMALLEST-IS-SMALLEST-2
     (N (- (SEQ!LENGTH SEQUENCE) N)) (X (REVERSE-INDICES SEQUENCE SET)))
(REARRANGE)
(REWRITE)
(INSTANTIATE (N1 (- (SEQ!LENGTH SEQUENCE)
                    (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))))
(REWRITE)
(PRENEX)
(USE NAT!SMALLEST-IS-SMALLEST-2
     (N (- (SEQ!LENGTH SEQUENCE) N2)) (X (REVERSE-INDICES SEQUENCE SET)))
(REARRANGE)
(REWRITE)

(axiom encrypted-part-of-sent-implication-3 (m k s)
  (implies (and (is-good-evolution-state s)
                (encrypted-part-of-sent m k s))
           (some (n1)
             (and (>= n1 1)
                  (<= n1 (seq!length (history s)))
                  (in (seq!nth (history s) n1)
                      (send-events-containing-encrypt m k))
                  (not (some (n2)
                         (and (>= n2 (+ n1 1))
                              (<= n2 (seq!length (history s)))
                              (in (seq!nth (history s) n2)
                                  (send-events-containing-encrypt m k)))))))))
(USE ENCRYPTED-PART-OF-SENT-IMPLICATION-2 (M M) (K K) (S S))
(SIMPLIFY)
(USE EARLIEST-IN-SEQUENCE-WITH-PROPERTY
     (SEQUENCE (HISTORY S)) (SET (SEND-EVENTS-CONTAINING-ENCRYPT M K)))
(SIMPLIFY)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)

(zf-function receive-events-containing-encrypt (m k)
  (select (event (receive-events))
    (in (ms!encrypt m k)
        (ms!parts (unit (message-of-event event))))))

(zf-function out-of-band-events-containing-encrypt (m k)
  (select (event (out-of-band-events))
    (in (ms!encrypt m k)
        (ms!parts (unit (message-of-event event))))))

(axiom encrypted-part-of-received-implication (m k s)
  (implies (and (is-good-evolution-state s)
                (encrypted-part-of-received m k s))
           (some (event)
             (and (seq!is-member event (history s))
                  (in event (receive-events-containing-encrypt m k))))))
(INVOKE ENCRYPTED-PART-OF-RECEIVED)
(PRENEX)
(REWRITE)
(INSTANTIATE (EVENT (MAKE-RECEIVE-EVENT L2 T2 M2 P2)))
(REWRITE)

(axiom encrypted-part-of-received-implication-2 (m k s)
  (implies (and (is-good-evolution-state s)
                (encrypted-part-of-received m k s))
           (some (n)
             (and (>= n 1)
                  (<= n (seq!length (history s)))
                  (in (seq!nth (history s) n)
                      (receive-events-containing-encrypt m k))))))
(USE ENCRYPTED-PART-OF-RECEIVED-IMPLICATION (M M) (K K) (S S))
(SIMPLIFY)
(PRENEX)
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH (M EVENT) (S (HISTORY S)))
(SIMPLIFY)
(INSTANTIATE (N$0 N))
(REWRITE)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)

(axiom encrypted-part-of-received-implication-3 (m k s)
  (implies (and (is-good-evolution-state s)
                (encrypted-part-of-received m k s))
           (some (n1)
             (and (>= n1 1)
                  (<= n1 (seq!length (history s)))
                  (in (seq!nth (history s) n1)
                      (receive-events-containing-encrypt m k))
                  (not (some (n2)
                         (and (>= n2 (+ n1 1))
                              (<= n2 (seq!length (history s)))
                              (in (seq!nth (history s) n2)
                                  (receive-events-containing-encrypt
                                    m k)))))))))
(USE ENCRYPTED-PART-OF-RECEIVED-IMPLICATION-2 (M M) (K K) (S S))
(SIMPLIFY)
(USE EARLIEST-IN-SEQUENCE-WITH-PROPERTY
     (SEQUENCE (HISTORY S)) (SET (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))
(SIMPLIFY)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)

(axiom encrypted-part-of-received-out-of-band-implication (m k s)
  (implies (and (is-good-evolution-state s)
                (encrypted-part-of-received-out-of-band m k s))
           (some (event)
             (and (seq!is-member event (history s))
                  (in event (out-of-band-events-containing-encrypt m k))))))
(INVOKE ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND)
(PRENEX)
(REWRITE)
(INSTANTIATE (EVENT (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)))
(REWRITE)

(axiom encrypted-part-of-received-out-of-band-implication-2 (m k s)
  (implies (and (is-good-evolution-state s)
                (encrypted-part-of-received-out-of-band m k s))
           (some (n)
             (and (>= n 1)
                  (<= n (seq!length (history s)))
                  (in (seq!nth (history s) n)
                      (out-of-band-events-containing-encrypt m k))))))
(USE ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION (M M) (K K) (S S))
(SIMPLIFY)
(PRENEX)
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH (M EVENT) (S (HISTORY S)))
(SIMPLIFY)
(INSTANTIATE (N$0 N))
(REWRITE)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)

(axiom encrypted-part-of-received-out-of-band-implication-3 (m k s)
  (implies (and (is-good-evolution-state s)
                (encrypted-part-of-received-out-of-band m k s))
           (some (n1)
             (and (>= n1 1)
                  (<= n1 (seq!length (history s)))
                  (in (seq!nth (history s) n1)
                      (out-of-band-events-containing-encrypt m k))
                  (not (some (n2)
                         (and (>= n2 (+ n1 1))
                              (<= n2 (seq!length (history s)))
                              (in (seq!nth (history s) n2)
                                  (out-of-band-events-containing-encrypt
                                   m k)))))))))
(USE ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION-2 (M M) (K K) (S S))
(SIMPLIFY)
(USE EARLIEST-IN-SEQUENCE-WITH-PROPERTY
     (SEQUENCE (HISTORY S))
     (SET (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))
(SIMPLIFY)
(INVOKE IS-GOOD-EVOLUTION-STATE)
(INVOKE IS-GOOD-STATE)
(REWRITE)


(frule head-is-good-evolution-state (s)
  (implies (is-good-evolution s)
           (is-good-evolution-state (seq!head s))))
(USE HEAD-OF-GOOD-EVOLUTION)
(SIMPLIFY)

(axiom forgeable-encrypted-implies-in-parts (m k s)
  (implies (and (is-good-evolution-state s)
                (in m (ms!messages))
                (in k (ms!keys))
                (not (forgeable k s))
                (forgeable (ms!encrypt m k) s))
           (in (ms!encrypt m k) (ms!parts (seen-messages s)))))
(INVOKE FORGEABLE)
(REWRITE)
(APPLY
 MS!NOT-PART-IMPLIES-NOT-COMP-OF
 (MS!COMP-OF
  (MS!ENCRYPT M K)
  (UNION
    (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
(REWRITE)

(grule history-is-sequence (s)
  (implies (is-good-evolution-state s)
           (seq!is-sequence (history s))))
(SPLIT (IS-GOOD-STATE S))
(REWRITE)
(INVOKE IS-GOOD-STATE)
(REWRITE)

(frule known-by-principal-is-message (m p s)
  (implies (known-by-principal m p s)
           (in m (ms!messages))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)

(frule forgeable-is-message (m s)
  (implies (forgeable m s)
           (in m (ms!messages))))
(INVOKE FORGEABLE)
(REWRITE)

(function message-induction (m) ((measure (ms!size m)))
  (if (or (not (in m (ms!messages))) (in m (ms!atomic-messages)))
      (true)
      (all (n) (if (< (ms!size n) (ms!size m)) (message-induction n) (true)))))
(REDUCE)

(axiom size-proper-part (m1 m2)
  (implies (and (in m1 (ms!messages))
		(in m2 (ms!messages))
		(in m1 (ms!parts (setadd m2 (nullset))))
                (not (= m1 m2)))
	   (>= (ms!size m2) (+ (ms!size m1) 1))))
(SPLIT (IN M2 (MS!COMBINE-MESSAGES)))
(CASES)
(USE MS!COMBINE-MESSAGES-ARE-CONSTRUCTED (X M2))
(REWRITE)
(PRENEX)
(EQUALITY-SUBSTITUTE M2)
(REWRITE)
(SPLIT (= (MS!PARTS (SETADD M1$0 (SETADD M2$0 (NULLSET))))
          (MS!PARTS (UNION (SETADD M1$0 (NULLSET)) (SETADD M2$0 (NULLSET))))))
(CASES)
(APPLY MS!PARTS-UNION)
(EQUALITY-SUBSTITUTE)
(REWRITE)
(USE MS!SIZE-PART (M1 M1) (M2 M1$0))
(USE MS!SIZE-PART (M1 M1) (M2 M2$0))
(REWRITE)
(NEXT)
(REWRITE)
(NEXT)
(SPLIT (IN M2 (MS!ENCRYPT-MESSAGES)))
(CASES)
(USE MS!ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M2))
(REWRITE)
(PRENEX)
(EQUALITY-SUBSTITUTE M2)
(REWRITE)
(USE MS!SIZE-PART (M1 M1) (M2 M))
(REWRITE)
(NEXT)
(SPLIT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
(CASES)
(USE MS!SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED (X M2))
(REWRITE)
(PRENEX)
(EQUALITY-SUBSTITUTE M2)
(REWRITE)
(USE MS!SIZE-PART (M1 M1) (M2 M))
(REWRITE)
(NEXT)
(SPLIT (IN M2 (MS!HASH-MESSAGES)))
(CASES)
(USE MS!HASH-MESSAGES-ARE-CONSTRUCTED (X M2))
(REWRITE)
(PRENEX)
(EQUALITY-SUBSTITUTE M2)
(REWRITE)
(USE MS!SIZE-PART (M1 M1) (M2 M))
(REWRITE)
(NEXT)
(SPLIT (IN M2 (MS!ATOMIC-MESSAGES)))
(CASES)
(REWRITE)
(NEXT)
(APPLY MS!IN-MESSAGES-DEFINITION (IN M2 (MS!MESSAGES)))
(REWRITE)
(NEXT)


(function n-sequence-induction (n sequence) ((measure (seq!length sequence)))
  (if (seq!emptyp sequence)
      (true)
      (n-sequence-induction (- n 1) (seq!tail sequence))))
(INVOKE (SEQ!LENGTH SEQUENCE))
(REDUCE)

(rule history-of-nth-of-tail-of-good-evolution-2 (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= (+ n 1) (seq!length sequence)))
           (= (history (seq!nth (seq!tail sequence) n))
              (seq!tail (history (seq!nth sequence n))))))
(APPLY HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)

(function n1-n2-induction (n1 n2) ((measure n2))
  (if (>= n2 2)
      (n1-n2-induction (+ n1 1) (- n2 1))
      (true)))
(REDUCE)

(disabled
 (rule length-history-nth (n s)
   (implies (and (is-good-evolution s)
                 (>= n 1)
                 (<= n (seq!length s)))
            (= (seq!length (history (seq!nth s n)))
               (- (seq!length s) n)))))
(INDUCT (N-SEQUENCE-INDUCTION N S))
(CASES)
(REWRITE)
(NEXT)
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(INVOKE (SEQ!NTH S N))
(INVOKE (SEQ!LENGTH S))
(REWRITE)
(APPLY HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)
(INVOKE (SEQ!LENGTH S))
(REWRITE)
(NEXT)
(INVOKE (SEQ!LENGTH S))
(REWRITE)
(NEXT)
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(NEXT)

(rule nth-history-nth-evolution (n1 n2 s)
  (implies (and (is-good-evolution s)
                (>= n1 1)
                (<= n1 (seq!length (history (seq!head s))))
                (>= n2 1)
                (<= n2 (seq!length (history (seq!nth s n1)))))
           (= (seq!nth (history (seq!nth s n1)) n2)
              (seq!head (history (seq!nth s (- (+ n1 n2) 1)))))))
(INDUCT (N1-N2-INDUCTION N1 N2))
(CASES)
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(INVOKE (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2))
(REWRITE)
(INVOKE (SEQ!NTH S (+ 1 N1)))
(REWRITE)
(NEXT)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)
(NEXT)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)
(NEXT)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)
(INVOKE (SEQ!NTH (HISTORY (SEQ!NTH S N1)) 1))
(REWRITE)
(NEXT)

(rule head-history-in-events (s)
  (implies (and (is-good-evolution-state s)
                (>= (seq!length (history s)) 1))
           (= (in (seq!head (history s)) (events)) (true))))
(SPLIT (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))))
(CASES)
(REWRITE)
(INVOKE SUBSET)
(INVOKE SEQ!MEMBERS)
(INSTANTIATE (E (SEQ!HEAD (HISTORY S))))
(REWRITE)
(NEXT)
(SIMPLIFY)
(NEXT)

(axiom member-history-nth (n1 n2 s e)
  (implies (and (is-good-evolution s)
                (>= n1 1)
                (<= (+ n1 1) (seq!length s))
                (>= n2 1)
                (>= n1 n2)
                (seq!is-member e (history (seq!nth s n1))))
           (seq!is-member e (history (seq!nth s n2)))))
(INDUCT)
(CASES)
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(CASES)
(INVOKE (SEQ!NTH S N2))
(REWRITE)
(NEXT)
(SPLIT (= N2 1))
(REWRITE)
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER E (HISTORY (SEQ!HEAD S))))
(REWRITE)
(SPLIT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) 1))
(CASES)
(REWRITE)
(NEXT)
(APPLY LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION)
(REWRITE)
(NEXT)
(INVOKE (SEQ!NTH S N1))
(REWRITE)
(NEXT)
(INVOKE (SEQ!LENGTH S))
(REWRITE)
(NEXT)
(REWRITE)
(NEXT)

(axiom nth-in-good-evolution (n s)
  (implies (and (is-good-evolution s)
                (>= n 1)
                (<= (+ n 1) (seq!length s)))
           (and (is-good-evolution-state (seq!nth s n))
                (seq!is-tack (history (seq!nth s n)))
                (in (seq!head (history (seq!nth s n))) (events)))))
(USE MEMBER-IS-GOOD-EVOLUTION-STATE (SEQUENCE S) (STATE (SEQ!NTH S N)))
(USE NTH-IS-MEMBER (N N) (SEQUENCE S))
(REWRITE)
(SPLIT (IN (HISTORY (SEQ!NTH S N)) (SEQ!SEQUENCE-OF (EVENTS))))
(SIMPLIFY)
(REWRITE)
(SPLIT (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1))
(REWRITE)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)

(axiom encrypted-message-theorem-1-a (m k s)
  (implies
   (and (is-good-evolution s)
        (in m (ms!messages))
        (in k (ms!keys))
        (in (ms!encrypt m k)
            (ms!parts (seen-messages (seq!head s))))
        (not (forgeable k (seq!head s)))
        (is-generated k (seq!head s)))
   (some (n1)
     (and (>= n1 1)
          (<= n1 (seq!length (history (seq!head s))))
          (in (seq!nth (history (seq!head s)) n1)
              (send-events-containing-encrypt m k))
          (not (some (n2)
                 (and (>= n2 (+ n1 1))
                      (<= n2 (seq!length (history (seq!head s))))
                      (in (seq!nth (history (seq!head s)) n2)
                          (send-events-containing-encrypt m k)))))))))
(USE ENCRYPTED-MESSAGE-THEOREM-1 (M M) (K K) (S (SEQ!HEAD S)))
(REARRANGE)
(REWRITE)
(USE ENCRYPTED-PART-OF-SENT-IMPLICATION-3 (M M) (K K) (S (SEQ!HEAD S)))
(REARRANGE)
(REWRITE)

(axiom all-storage-monotonic (s n1 n2)
  (implies (and (is-good-evolution s)
                (<= 1 n2)
                (<= n2 n1)
                (<= n1 (seq!length s)))
           (subset (all-storage (stores (seq!nth s n1)))
                   (all-storage (stores (seq!nth s n2))))))
(INVOKE ALL-STORAGE)
(INVOKE SUBSET)
(REWRITE)
(PRENEX)
(USE STORAGE-OF-PRINCIPAL-MONOTONIC (SEQUENCE S) (N1 N1) (N2 N2))
(INVOKE STORAGE-OF)
(INVOKE SUBSET)
(REWRITE)
(USE MEMBER-IS-GOOD-EVOLUTION-STATE (SEQUENCE S) (STATE (SEQ!NTH S N1)))
(USE MEMBER-IS-GOOD-EVOLUTION-STATE (SEQUENCE S) (STATE (SEQ!NTH S N2)))
(USE NTH-IS-MEMBER (N N1) (SEQUENCE S))
(USE NTH-IS-MEMBER (N N2) (SEQUENCE S))
(REWRITE)
(SPLIT (IS-GOOD-STATE (SEQ!NTH S N2)))
(SIMPLIFY)
(SPLIT (IS-GOOD-STATE (SEQ!NTH S N1)))
(SIMPLIFY)
(SPLIT (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS)))
(SIMPLIFY)
(SPLIT (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS)))
(SIMPLIFY)
(APPLY FN!IN-RAN-FUNCTION)
(REWRITE)
(PRENEX)
(INSTANTIATE (PRINCIPAL Y$0))
(REWRITE)
(INSTANTIATE (E$0 E))
(REWRITE)

(axiom fresh-is-monotonic (k s n1 n2)
  (implies (and (is-good-evolution s)
                (<= 1 n2)
                (<= n2 n1)
                (<= n1 (seq!length s))
                (ms!is-fresh k (all-messages-in-state (seq!nth s n2))))
           (ms!is-fresh k (all-messages-in-state (seq!nth s n1)))))
(REWRITE)
(USE SEEN-MESSAGES-MONOTONIC (SEQUENCE S) (N1 N1) (N2 N2))
(USE ALL-STORAGE-MONOTONIC (S S) (N1 N1) (N2 N2))
(REWRITE)
(USE MS!IS-FRESH-SUBSET
     (K K)
     (S1 (ALL-STORAGE (STORES (SEQ!NTH S N2))))
     (S2 (ALL-STORAGE (STORES (SEQ!NTH S N1)))))
(USE MS!IS-FRESH-SUBSET
     (K K)
     (S1 (SEEN-MESSAGES (SEQ!NTH S N2)))
     (S2 (SEEN-MESSAGES (SEQ!NTH S N1))))
(SIMPLIFY)

(axiom is-generated-consequence (s k n)
  (implies (and (is-good-evolution s)
                (is-generated k (seq!head s))
                (<= 1 n)
                (<= n (seq!length s)))
           (or (is-generated k (seq!nth s n))
               (ms!is-fresh k (all-messages-in-state (seq!nth s n))))))
(INDUCT (NAT!WEAK-INDUCTION N))
(CASES)
(INVOKE NAT!ZEROP)
(REWRITE)
(NEXT)
(INVOKE NAT!ZEROP)
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(INVOKE (IS-GENERATED K (SEQ!NTH S (+ -1 N))))
(INVOKE (IS-GENERATED K (SEQ!NTH S N)))
(PRENEX)
(INSTANTIATE (L$0 L) (T$0 T) (P1$0 P1))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
                       (HISTORY (SEQ!NTH S (+ -1 N)))))
(INVOKE (SEQ!NTH S N))
(REWRITE)
(USE GENERATE-EVENT-THEOREM (N (- N 1)) (SEQUENCE S))
(REARRANGE)
(REWRITE)
(EQUALITY-SUBSTITUTE (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
(REWRITE)
(CASES)
(INVOKE (SEQ!NTH S N))
(REWRITE)
(NEXT)
(USE NTH-IS-MEMBER (N (- N 1)) (SEQUENCE S))
(SIMPLIFY)
(USE MEMBER-IS-GOOD-EVOLUTION-STATE
     (SEQUENCE S) (STATE (SEQ!NTH S (- N 1))))
(SIMPLIFY)
(SPLIT (IS-GOOD-STATE (SEQ!NTH S (+ -1 N))))
(SIMPLIFY)
(INVOKE IS-GOOD-STATE)
(REWRITE)
(INVOKE (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N)))) (EVENTS)))
(INSTANTIATE (E (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))))
(REWRITE)
(CASES)
(INVOKE (EVENTS))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
                       (HISTORY (SEQ!NTH S (+ -1 N)))))
(REWRITE)
(NEXT)
(USE FRESH-IS-MONOTONIC (K K) (S S) (N1 N) (N2 (- N 1)))
(REWRITE)
(NEXT)
(SPLIT (= N 1))
(REWRITE)
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(NEXT)

(axiom encrypted-message-theorem-1-b (m k s)
  (implies
   (and (is-good-evolution s)
        (in m (ms!messages))
        (in k (ms!keys))
        (in (ms!encrypt m k)
            (ms!parts (seen-messages (seq!head s))))
        (not (forgeable k (seq!head s)))
        (is-generated k (seq!head s)))
   (some (n1)
     (and (>= n1 1)
          (<= n1 (seq!length (history (seq!head s))))
          (in (seq!nth (history (seq!head s)) n1)
              (send-events-containing-encrypt m k))
          (not (some (n2)
                 (and (>= n2 (+ n1 1))
		      (<= n2 (seq!length s))
                      (in (ms!encrypt m k)
			  (ms!parts (seen-messages (seq!nth s n2)))))))))))
(USE ENCRYPTED-MESSAGE-THEOREM-1-A (M M) (K K) (S S))
(SIMPLIFY)
(INSTANTIATE (N1$0 N1))
(CONTRADICT)
(CASES)
(REWRITE)
(SPLIT
  (SOME (N2$0)
   (AND (>= N2$0 (+ 1 N1))
        (<= N2$0 (SEQ!LENGTH S))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0)))))))
(SIMPLIFY)
(PRENEX)
(SPLIT (IS-GENERATED K (SEQ!NTH S N2)))
(CASES)
(USE ENCRYPTED-MESSAGE-THEOREM-1 (M M) (K K) (S (SEQ!NTH S N2)))
(REWRITE)
(CASES)
(CASES)
(USE FORGEABLE-IS-MONOTONIC (SEQUENCE S) (MESSAGE K) (N1 N2) (N2 1))
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(NEXT)
(INVOKE ENCRYPTED-PART-OF-SENT)
(PRENEX)
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH
     (M (MAKE-SEND-EVENT L2 T2 M2 P2)) (S (HISTORY (SEQ!NTH S N2))))
(REWRITE)
(PRENEX)
(APPLY NTH-HISTORY-NTH-EVOLUTION)
(REWRITE)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)
(INSTANTIATE (N2$0 (+ -1 N N2)))
(REWRITE)
(SPLIT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2))))
(CASES)
(SPLIT (IS-GOOD-STATE (SEQ!NTH S (+ -1 N N2))))
(SIMPLIFY)
(INVOKE (IS-GOOD-STATE (SEQ!NTH S (+ -1 N N2))))
(REWRITE)
(INVOKE
  (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N N2)))) (EVENTS)))
(INSTANTIATE (E (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))))
(REWRITE)
(CASES)
(INVOKE (EVENTS))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
                       (HISTORY (SEQ!NTH S (+ -1 N N2)))))
(REWRITE)
(SPLIT (= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N N2)))) 0))
(SIMPLIFY)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)
(NEXT)
(USE MEMBER-IS-GOOD-EVOLUTION-STATE
     (SEQUENCE S) (STATE (SEQ!NTH S (+ -1 N N2))))
(SIMPLIFY)
(USE NTH-IS-MEMBER (N (+ -1 N N2)) (SEQUENCE S))
(SIMPLIFY)
(NEXT)
(USE MEMBER-IS-GOOD-EVOLUTION-STATE (SEQUENCE S) (STATE (SEQ!NTH S N2)))
(SIMPLIFY)
(USE NTH-IS-MEMBER (N N2) (SEQUENCE S))
(SIMPLIFY)
(NEXT)
(USE IS-GENERATED-CONSEQUENCE (S S) (K K) (N N2))
(REWRITE)
(INVOKE (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2))))
(SIMPLIFY)
(NEXT)

(axiom forgeable-containing-encrypted-implies-in-parts (m k m2 s)
  (implies (and (is-good-evolution-state s)
                (in m (ms!messages))
                (in k (ms!keys))
                (not (forgeable k s))
                (forgeable m2 s)
                (in (ms!encrypt m k) (ms!parts (unit m2))))
           (in (ms!encrypt m k) (ms!parts (seen-messages s)))))
(INVOKE FORGEABLE)
(REWRITE)
(USE MS!ENCRYPTED-MESSAGE-THEOREM
     (M M)
     (K K)
     (M2 M2)
     (S (UNION (MS!PRINCIPALS)
               (UNION (MS!TEXT-MESSAGES)
                      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
(REARRANGE)
(REWRITE)

(frule in-send-event (event)
  (implies
   (in event (send-events))
   (and
    (= event
       (make-send-event
        (label-of-event event)
        (time-of-event event)
        (message-of-event event)
        (principal1-of-event event)))
    (>= (label-of-event event) 0)
    (>= (time-of-event event) 0)
    (in (message-of-event event) (ms!messages))
    (in (principal1-of-event event) (ms!principals)))))
(USE SEND-EVENT-IS-CONSTRUCTED (E EVENT))
(SIMPLIFY)
(PRENEX)
(REWRITE)

(frule in-receive-event (event)
  (implies
   (in event (receive-events))
   (and
    (= event
       (make-receive-event
        (label-of-event event)
        (time-of-event event)
        (message-of-event event)
        (principal1-of-event event)))
    (>= (label-of-event event) 0)
    (>= (time-of-event event) 0)
    (in (message-of-event event) (ms!messages))
    (in (principal1-of-event event) (ms!principals)))))
(USE RECEIVE-EVENT-IS-CONSTRUCTED (E EVENT))
(SIMPLIFY)
(PRENEX)
(REWRITE)

(frule in-out-of-band-event (event)
  (implies
   (in event (out-of-band-events))
   (and
    (= event
       (make-out-of-band-event
        (label-of-event event)
        (time-of-event event)
        (message-of-event event)
        (principal1-of-event event)
        (principal2-of-event event)))
    (>= (label-of-event event) 0)
    (>= (time-of-event event) 0)
    (in (message-of-event event) (ms!messages))
    (in (principal1-of-event event) (ms!principals))
    (in (principal2-of-event event) (ms!principals)))))
(USE OUT-OF-BAND-EVENT-IS-CONSTRUCTED (E EVENT))
(SIMPLIFY)
(PRENEX)
(REWRITE)

(axiom known-by-principal-containing-encrypted-implies-in-parts (m k p m2 s)
  (implies (and (is-good-evolution-state s)
                (in m (ms!messages))
                (in k (ms!keys))
                (in p (ms!principals))
                (not (known-by-principal k p s))
                (known-by-principal m2 p s)
                (in (ms!encrypt m k) (ms!parts (unit m2))))
           (in (ms!encrypt m k) (ms!parts (storage-of p s)))))
(INVOKE KNOWN-BY-PRINCIPAL)
(REWRITE)
(USE MS!ENCRYPTED-MESSAGE-THEOREM
     (M M)
     (K K)
     (M2 M2)
     (S (UNION (MS!PRINCIPALS)
               (UNION (MS!TEXT-MESSAGES)
                      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
(REARRANGE)
(REWRITE)

(axiom is-generated-monotonic (s k n1 n2)
  (implies (and (is-good-evolution s)
                (<= 1 n1)
                (<= n1 n2)
                (<= n2 (seq!length s))
                (is-generated k (seq!nth s n2)))
           (is-generated k (seq!nth s n1))))
(INDUCT)
(REWRITE)
(CASES)
(CASES)
(CASES)
(CASES)
(INVOKE (SEQ!NTH S N1))
(REWRITE)
(NEXT)
(SPLIT (= N1 1))
(REWRITE)
(INVOKE (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) 1)))
(INVOKE (IS-GENERATED K (SEQ!NTH S 1)))
(INSTANTIATE (L$0 L) (T$0 T) (P1$0 P1))
(REWRITE)
(INVOKE (SEQ!NTH (SEQ!TAIL S) 1))
(REARRANGE)
(REWRITE)
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(INVOKE (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!HEAD S))))
(REWRITE)
(APPLY HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)
(NEXT)
(INVOKE (SEQ!NTH S N2))
(REWRITE)
(NEXT)
(INVOKE (SEQ!LENGTH S))
(REWRITE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION S))
(REWRITE)
(NEXT)

(axiom encrypted-part-of-received-monotonic (m k s n1 n2)
  (implies (and (is-good-evolution s)
                (<= 1 n1)
                (<= n1 n2)
                (<= n2 (seq!length s))
                (encrypted-part-of-received m k (seq!nth s n2)))
           (encrypted-part-of-received m k (seq!nth s n1))))
(INDUCT)
(REWRITE)
(CASES)
(CASES)
(CASES)
(CASES)
(INVOKE (SEQ!NTH S N1))
(REWRITE)
(NEXT)
(SPLIT (= N1 1))
(REWRITE)
(INVOKE (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) 1)))
(INVOKE (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)))
(INSTANTIATE (L2$0 L2) (T2$0 T2) (M2$0 M2) (P2$0 P2))
(REWRITE)
(INVOKE (SEQ!NTH (SEQ!TAIL S) 1))
(REARRANGE)
(REWRITE)
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(INVOKE
 (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY (SEQ!HEAD S))))
(REWRITE)
(APPLY HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION)
(REWRITE)
(NEXT)
(INVOKE (SEQ!NTH S N2))
(REWRITE)
(NEXT)
(INVOKE (SEQ!LENGTH S))
(REWRITE)
(NEXT)
(INVOKE (IS-GOOD-EVOLUTION S))
(REWRITE)
(NEXT)


(axiom encrypted-message-theorem (m k s)
  (implies
   (and (is-good-evolution s)
        (in m (ms!messages))
        (in k (ms!keys))
        ;; (forgeable (ms!encrypt m k) (seq!head s))
        (in (ms!encrypt m k)
            (ms!parts (seen-messages (seq!head s))))
        (not (forgeable k (seq!head s)))
        (is-generated k (seq!head s)))
   (or (some (n2 l2 t2 m2 p2)
         (and (>= n2 1)
              (< n2 (seq!length s))
              (in m2 (ms!messages))
              (in p2 (ms!principals))
              (= (seq!nth (history (seq!head s)) n2)
                 (make-send-event l2 t2 m2 p2))
              (known-by-principal k p2 (seq!nth s (+ n2 1)))
              (not (in (ms!encrypt m k)
                       (ms!parts (seen-messages (seq!nth s (+ n2 1))))))
              (in (ms!encrypt m k) (ms!parts (setadd m2 (nullset))))))
       (some (n3 l3 t3 m3 p3 p4)
         (and (>= n3 1)
              (< n3 (seq!length s))
              (in m3 (ms!messages))
              (in p3 (ms!principals))
              (in p4 (ms!principals))
              (= (seq!nth (history (seq!head s)) n3)
                 (make-out-of-band-event l3 t3 m3 p3 p4))
              (known-by-principal k p3 (seq!nth s (+ n3 1)))
              ;(not (in (ms!encrypt m k)
              ;         (ms!parts (storage-of p4 (seq!nth s (+ n3 1))))))
              (in (ms!encrypt m k)
                  (ms!parts (setadd m3 (nullset)))))))))
(USE ENCRYPTED-MESSAGE-THEOREM-1-B (M M) (K K) (S S))
(REARRANGE)
(REWRITE)
(PRENEX)
(USE SEND-EVENT-THEOREM (N N1) (SEQUENCE S))
(REWRITE)
(SPLIT (KNOWN-BY-PRINCIPAL
         K
         (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
         (SEQ!NTH S (+ 1 N1))))
(CASES)
(INSTANTIATE
  (N2 N1)
  (L2 (LABEL-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
  (T2 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
  (M2 (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
  (P2 (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))))
(REWRITE)
(NEXT)
(USE IS-GENERATED-CONSEQUENCE (S S) (K K) (N (+ N1 1)))
(REWRITE)
(CASES)
(USE ENCRYPTED-MESSAGE-THEOREM-2
     (M M)
     (P (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
     (K K)
     (S (SEQ!NTH S (+ 1 N1))))
(REARRANGE)
(REWRITE)
(CASES)
(CASES)
(USE FORGEABLE-IS-MONOTONIC (SEQUENCE S) (MESSAGE K) (N1 (+ 1 N1)) (N2 1))
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(NEXT)
(CASES)
(CASES)
(INVOKE ENCRYPTED-PART-OF-RECEIVED)
(PRENEX)
(USE
 SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH
 (M (MAKE-RECEIVE-EVENT L2 T2 M2 P2)) (S (HISTORY (SEQ!NTH S (+ 1 N1)))))
(REWRITE)
(PRENEX)
(APPLY NTH-HISTORY-NTH-EVOLUTION)
(REWRITE)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)
(USE RECEIVE-EVENT-THEOREM (N (+ N N1)) (SEQUENCE S))
(REARRANGE)
(REWRITE)
(CASES)
(USE FORGEABLE-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS
     (M M) (K K) (M2 M2) (S (SEQ!NTH S (+ 1 N N1))))
(REARRANGE)
(REWRITE)
(CASES)
(USE FORGEABLE-IS-MONOTONIC (SEQUENCE S) (MESSAGE K) (N1 (+ 1 N N1)) (N2 1))
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(NEXT)
(USE MEMBER-IS-GOOD-EVOLUTION-STATE
     (SEQUENCE S) (STATE (SEQ!NTH S (+ 1 N N1))))
(SIMPLIFY)
(USE NTH-IS-MEMBER (N (+ 1 N N1)) (SEQUENCE S))
(SIMPLIFY)
(NEXT)
(SPLIT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))))
(CASES)
(SPLIT (IS-GOOD-STATE (SEQ!NTH S (+ N N1))))
(SIMPLIFY)
(INVOKE (IS-GOOD-STATE (SEQ!NTH S (+ N N1))))
(REWRITE)
(INVOKE (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ N N1)))) (EVENTS)))
(INSTANTIATE (E (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))))
(REWRITE)
(CASES)
(INVOKE (EVENTS))
(REWRITE)
(NEXT)
(INVOKE (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
                       (HISTORY (SEQ!NTH S (+ N N1)))))
(REWRITE)
(SPLIT (= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N N1)))) 0))
(SIMPLIFY)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)
(NEXT)
(USE MEMBER-IS-GOOD-EVOLUTION-STATE
     (SEQUENCE S) (STATE (SEQ!NTH S (+ N N1))))
(SIMPLIFY)
(USE NTH-IS-MEMBER (N (+ N N1)) (SEQUENCE S))
(SIMPLIFY)
(NEXT)
(USE ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION-3
     (M M) (K K) (S (SEQ!NTH S (+ 1 N1))))
(REARRANGE)
(REWRITE)
(PRENEX)
(APPLY NTH-HISTORY-NTH-EVOLUTION)
(REWRITE)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)
(USE OUT-OF-BAND-EVENT-THEOREM (N (+ N1 N1$0)) (SEQUENCE S))
(REWRITE)
(INSTANTIATE
 (N3 (+ N1 N1$0))
 (L3 (LABEL-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
 (T3 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
 (M3 (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
 (P3 (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
 (P4 (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))))
(CONTRADICT)
(CASES)
(REWRITE)
(USE
  KNOWN-BY-PRINCIPAL-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS
  (M M)
  (K K)
  (P (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
  (M2 (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
  (S (SEQ!NTH S (+ 1 N1 N1$0))))
(REARRANGE)
(REWRITE)
(CASES)
(USE
  ENCRYPTED-MESSAGE-THEOREM-2
  (M M)
  (P (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
  (K K)
  (S (SEQ!NTH S (+ 1 N1 N1$0))))
(REARRANGE)
(REWRITE)
(CASES)
(USE FORGEABLE-IS-MONOTONIC
     (SEQUENCE S) (MESSAGE K) (N1 (+ 1 N1 N1$0)) (N2 1))
(INVOKE (SEQ!NTH S 1))
(REWRITE)
(NEXT)
(CASES)
(CASES)
(USE ENCRYPTED-PART-OF-RECEIVED-MONOTONIC
     (M M) (K K) (S S) (N1 (+ 1 N1)) (N2 (+ 1 N1 N1$0)))
(REWRITE)
(NEXT)
(INVOKE (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1 N1$0))))
(PRENEX)
(USE SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH
     (M (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (S (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))))
(REWRITE)
(PRENEX)
(APPLY NTH-HISTORY-NTH-EVOLUTION)
(REWRITE)
(APPLY LENGTH-HISTORY-NTH)
(REWRITE)
(INSTANTIATE (N2$0 (+ N N1$0)))
(REWRITE)
(SPLIT (AND (>= L3 0)
            (>= T3 0)
            (IN M3 (MS!MESSAGES))
            (IN P3 (MS!PRINCIPALS))
            (IN P4 (MS!PRINCIPALS))))
(WITHOUT-NORMALIZATION (REWRITE))
(NEXT)
(USE IS-GENERATED-CONSEQUENCE (S S) (K K) (N (+ 1 N1 N1$0)))
(REARRANGE)
(REWRITE)
(USE
  FRESH-IN-ALL-MESSAGES-IMPLIES-FRESH-IN-STORAGE-OF-PRINCIPAL
  (MESSAGE K)
  (PRINCIPAL
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
  (STATE (SEQ!NTH S (+ 1 N1 N1$0))))
(REARRANGE)
(INVOKE
  (MS!IS-FRESH
    K
    (STORAGE-OF
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0)))))
(REWRITE)
(NEXT)
(USE NTH-IS-MEMBER (N (+ 1 N1 N1$0)) (SEQUENCE S))
(USE MEMBER-IS-GOOD-EVOLUTION-STATE
     (SEQUENCE S) (STATE (SEQ!NTH S (+ 1 N1 N1$0))))
(REARRANGE)
(REWRITE)
(NEXT)
(USE SEND-EVENT-THEOREM (N N1) (SEQUENCE S))
(REWRITE)
(USE KNOWN-BY-PRINCIPAL-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS
     (M M)
     (K K)
     (P (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
     (M2 (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
     (S (SEQ!NTH S (+ 1 N1))))
(REARRANGE)
(REWRITE)
(NEXT)
(USE NTH-IS-MEMBER (N (+ 1 N1)) (SEQUENCE S))
(USE MEMBER-IS-GOOD-EVOLUTION-STATE
     (SEQUENCE S) (STATE (SEQ!NTH S (+ 1 N1))))
(REARRANGE)
(REWRITE)
(NEXT)
(USE KNOWN-BY-PRINCIPAL-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS
     (M M)
     (K K)
     (P (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
     (M2 (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
     (S (SEQ!NTH S (+ 1 N1))))
(REARRANGE)
(REWRITE)
(CASES)
(USE
  FRESH-IN-ALL-MESSAGES-IMPLIES-FRESH-IN-STORAGE-OF-PRINCIPAL
  (MESSAGE K)
  (PRINCIPAL (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
  (STATE (SEQ!NTH S (+ 1 N1))))
(REARRANGE)
(INVOKE
 (MS!IS-FRESH K
              (STORAGE-OF
                (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
                (SEQ!NTH S (+ 1 N1)))))
(REWRITE)
(NEXT)
(USE NTH-IS-MEMBER (N (+ 1 N1)) (SEQUENCE S))
(USE MEMBER-IS-GOOD-EVOLUTION-STATE
     (SEQUENCE S) (STATE (SEQ!NTH S (+ 1 N1))))
(REARRANGE)
(REWRITE)
(NEXT)


;;; Added March 2001

(rule in-parts-add-known-by-principal (k m p s)
  (implies
   (and
    (is-good-evolution-state s)
    (in p (ms!principals))
    (known-by-principal m p s)
    (in k (ms!atomic-messages))
    (not (in k (ms!principals)))
    (not (in k (ms!text-messages)))
    (not (in k (ms!public-keys))))
   (= (in k (ms!parts
             (setadd m (union (ms!principals)
                              (union (ms!text-messages)
                                     (union (ms!public-keys)
                                            (storage-of p s)))))))
      (in k (ms!parts (storage-of p s))))))
(INVOKE (KNOWN-BY-PRINCIPAL M P S))
(WITH-DISABLED (IN-PARTS-SETADD)
 (REWRITE))

(axiom in-parts-seen-implies-in-parts-forgeable (k state)
  (implies (and (is-good-state state)
                (in k (ms!atomic-messages))
                (in k (ms!parts (seen-messages state))))
           (some (message)
             (and (forgeable message state)
                  (in k (ms!parts (unit message)))))))
(USE MS!PARTS-IMPLIES-PART-OF-MEMBER (M K) (S (SEEN-MESSAGES STATE)))
(REWRITE)
(PRENEX)
(INVOKE FORGEABLE)
(REWRITE)
(INSTANTIATE (MESSAGE X))
(REWRITE)
(INVOKE (IS-GOOD-STATE STATE))
(INVOKE (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES)))
(REWRITE)



(rule send-step-is-good-step (label time message principal state)
  (implies (not (= state (send-step label time message principal state)))
           (= (good-step
               state (send-step label time message principal state))
              (true))))
(INVOKE GOOD-STEP)
(INSTANTIATE (LABEL$0 LABEL)
             (TIME$0 TIME)
             (MESSAGE$0 MESSAGE)
             (PRINCIPAL$0 PRINCIPAL))
(INVOKE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
(REWRITE)

(rule receive-step-is-good-step (label time message principal state)
  (implies (not (= state (receive-step label time message principal state)))
           (= (good-step
               state (receive-step label time message principal state))
              (true))))
(INVOKE GOOD-STEP)
(INSTANTIATE (LABEL$0 LABEL)
             (TIME$0 TIME)
             (MESSAGE$0 MESSAGE)
             (PRINCIPAL$1 PRINCIPAL))
(INVOKE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
(REWRITE)

(rule out-of-band-step-is-good-step (label time message sender receiver state)
  (implies (not (= state
                   (out-of-band-step
                    label time message sender receiver state)))
           (= (good-step
               state (out-of-band-step
                      label time message sender receiver state))
              (true))))
(INVOKE GOOD-STEP)
(INSTANTIATE (LABEL$0 LABEL)
             (TIME$0 TIME)
             (MESSAGE$0 MESSAGE)
             (SENDER$0 SENDER)
             (RECEIVER$0 RECEIVER))
(INVOKE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))
(REWRITE)

(rule generate-step-is-good-step (label time message principal state)
  (implies (not (= state
                   (generate-step label time message principal state)))
           (= (good-step
               state (generate-step label time message principal state))
              (true))))
(INVOKE GOOD-STEP)
(INSTANTIATE (LABEL$0 LABEL)
             (TIME$0 TIME)
             (MESSAGE$0 MESSAGE)
             (PRINCIPAL$2 PRINCIPAL))
(INVOKE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
(REWRITE)

(rule construct-step-is-good-step (label time message principal state)
  (implies (not (= state
                   (construct-step label time message principal state)))
           (= (good-step
               state (construct-step label time message principal state))
              (true))))
(INVOKE GOOD-STEP)
(INSTANTIATE (LABEL$0 LABEL)
             (TIME$0 TIME)
             (MESSAGE$0 MESSAGE)
             (PRINCIPAL$3 PRINCIPAL))
(INVOKE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
(REWRITE)

(rule intruder-step-is-good-step (label time message state)
  (implies (not (= state (intruder-step label time message state)))
           (= (good-step
               state (intruder-step label time message state))
              (true))))
(INVOKE GOOD-STEP)
(INSTANTIATE (LABEL$0 LABEL)
             (TIME$0 TIME)
             (MESSAGE$0 MESSAGE))
(INVOKE (INTRUDER-STEP LABEL TIME MESSAGE STATE))
(REWRITE)
