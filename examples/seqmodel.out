
Reading "/home/sentot/zk/version1/ZK/examples/seqmodel.ver"
SIZE
EMPTY
TACK
IS-TACK
HEAD
TAIL
SIZE-TACK
Beginning proof of SIZE-TACK ...
(IMPLIES (IS-TACK P) (= (SIZE P) (+ 1 (SIZE (TAIL P)))))
Which simplifies
 with invocation of TAIL, SIZE, TACK, IS-TACK
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PAIR!IS-PAIR-BOOL to ...
(IMPLIES
 (SOME (X Y)
  (IF (PAIR!IS-PAIR Y)
   (IF (>= (PAIR!FST Y) 0)
    (= P (PAIR!PAIR (+ 1 (PAIR!FST Y)) (PAIR!PAIR X Y)))
    (= P (PAIR!PAIR 1 (PAIR!PAIR X Y))))
   (= P (PAIR!PAIR 1 (PAIR!PAIR X Y)))))
 (AND (PAIR!IS-PAIR P) (>= (PAIR!FST P) 0)
  (IF (PAIR!IS-PAIR (PAIR!SND (PAIR!SND P)))
   (IF (>= (PAIR!FST (PAIR!SND (PAIR!SND P))) 0)
    (= (PAIR!FST P) (+ 1 (PAIR!FST (PAIR!SND (PAIR!SND P)))))
    (= (PAIR!FST P) 1))
   (= (PAIR!FST P) 1))))
Prenexing produces ...
(IMPLIES
 (IF (PAIR!IS-PAIR Y)
  (IF (>= (PAIR!FST Y) 0) (= P (PAIR!PAIR (+ 1 (PAIR!FST Y)) (PAIR!PAIR X Y)))
   (= P (PAIR!PAIR 1 (PAIR!PAIR X Y))))
  (= P (PAIR!PAIR 1 (PAIR!PAIR X Y))))
 (AND (PAIR!IS-PAIR P) (>= (PAIR!FST P) 0)
  (IF (PAIR!IS-PAIR (PAIR!SND (PAIR!SND P)))
   (IF (>= (PAIR!FST (PAIR!SND (PAIR!SND P))) 0)
    (= (PAIR!FST P) (+ 1 (PAIR!FST (PAIR!SND (PAIR!SND P)))))
    (= (PAIR!FST P) 1))
   (= (PAIR!FST P) 1))))
Which simplifies
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PAIR!IS-PAIR-BOOL to ...
(TRUE)
SIZE-NONNEGATIVE
Beginning proof of SIZE-NONNEGATIVE ...
(>= (SIZE X) 0)
Which simplifies
 with invocation of SIZE
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL to ...
(TRUE)
LENGTH
Beginning proof of LENGTH ...
(IF (IS-TACK S) (M< (SIZE (TAIL S)) (SIZE S)) (TRUE))
Which simplifies
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK
 with the assumptions SUCC.INT, SIZE-NONNEGATIVE to ...
(TRUE)
LENGTH-NON-NEGATIVE
Beginning proof of LENGTH-NON-NEGATIVE ...
(>= (LENGTH S) 0)
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* (TAIL S))) (*P* S))
  (IMPLIES (NOT (IS-TACK S)) (*P* S)))
 produces ...
(AND (IMPLIES (AND (IS-TACK S) (>= (LENGTH (TAIL S)) 0)) (>= (LENGTH S) 0))
 (IMPLIES (NOT (IS-TACK S)) (>= (LENGTH S) 0)))
Which simplifies
 with invocation of LENGTH
 forward chaining using >=.SAME.TYPE, SIZE-TACK to ...
(TRUE)
TYPE-OF-IS-TACK
Beginning proof of TYPE-OF-IS-TACK ...
(= (TYPE-OF (IS-TACK S)) (BOOL))
Which simplifies
 with invocation of IS-TACK
 forward chaining using SIZE-TACK to ...
(TRUE)
IS-SEQUENCE
Beginning proof of IS-SEQUENCE ...
(IF (IS-TACK S) (M< (LENGTH (TAIL S)) (LENGTH S)) (TRUE))
Which simplifies
 with invocation of LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK
 with the assumptions SUCC.INT, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
TACK-HEAD-TAIL
Beginning proof of TACK-HEAD-TAIL ...
(IMPLIES (IS-TACK S) (= S (TACK (HEAD S) (TAIL S))))
Which simplifies
 with invocation of TAIL, HEAD, TACK, IS-TACK
 forward chaining using PAIR!PAIR-COMPOSITION, >=.SAME.TYPE, SIZE-TACK
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SIZE-NONNEGATIVE, TYPE-OF-IS-TACK to ...
(IMPLIES (SOME (X Y) (= S (PAIR!PAIR (+ 1 (SIZE Y)) (PAIR!PAIR X Y))))
 (= S
  (PAIR!PAIR (+ 1 (SIZE (PAIR!SND (PAIR!SND S))))
   (PAIR!PAIR (PAIR!FST (PAIR!SND S)) (PAIR!SND (PAIR!SND S))))))
Prenexing produces ...
(IMPLIES (= S (PAIR!PAIR (+ 1 (SIZE Y)) (PAIR!PAIR X Y)))
 (= S
  (PAIR!PAIR (+ 1 (SIZE (PAIR!SND (PAIR!SND S))))
   (PAIR!PAIR (PAIR!FST (PAIR!SND S)) (PAIR!SND (PAIR!SND S))))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION, >=.SAME.TYPE
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SIZE-NONNEGATIVE to ...
(TRUE)
EMPTYP-EMPTY
Beginning proof of EMPTYP-EMPTY ...
(= (IS-TACK (EMPTY)) (FALSE))
Which simplifies
 with invocation of TACK, IS-TACK
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
PAIR!PAIR-COMPOSITION
 with the assumptions SIZE-NONNEGATIVE, TYPE-OF-IS-TACK, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
IS-TACK-TACK
Beginning proof of IS-TACK-TACK ...
(IS-TACK (TACK X S))
Which simplifies
 with invocation of IS-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions TYPE-OF-IS-TACK to ...
(TRUE)
HEAD-TACK
Beginning proof of HEAD-TACK ...
(= (HEAD (TACK X S)) X)
Which simplifies
 with invocation of HEAD, TACK
 forward chaining using PAIR!PAIR-COMPOSITION, >=.SAME.TYPE, SIZE-TACK,
TACK-HEAD-TAIL
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SIZE-NONNEGATIVE, IS-TACK-TACK to ...
(TRUE)
TAIL-TACK
Beginning proof of TAIL-TACK ...
(= (TAIL (TACK X S)) S)
Which simplifies
 with invocation of TAIL, TACK
 forward chaining using PAIR!PAIR-COMPOSITION, >=.SAME.TYPE, SIZE-TACK,
TACK-HEAD-TAIL
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SIZE-NONNEGATIVE, IS-TACK-TACK, HEAD-TACK to ...
(TRUE)
TACK-IS-INJECTIVE
Beginning proof of TACK-IS-INJECTIVE ...
(= (= (TACK X1 S1) (TACK X2 S2)) (AND (= X1 X2) (= S1 S2)))
Splitting on (AND (= X1 X2) (= S1 S2)) generates ...
(IF (AND (= X1 X2) (= S1 S2))
 (= (= (TACK X1 S1) (TACK X2 S2)) (AND (= X1 X2) (= S1 S2)))
 (= (= (TACK X1 S1) (TACK X2 S2)) (AND (= X1 X2) (= S1 S2))))
Which simplifies
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK to ...
(TRUE)
SEQP
SEQP-DEFINITION
Beginning proof of SEQP-DEFINITION ...
(= (SEQP S) (IS-SEQUENCE S))
Which simplifies
 with invocation of SEQP to ...
(TRUE)
EMPTYP
EMPTYP-DEFINITION
Beginning proof of EMPTYP-DEFINITION ...
(= (EMPTYP S) (IMPLIES (IS-TACK S) (NOT (IS-SEQUENCE S))))
Which simplifies
 with invocation of EMPTYP
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions TYPE-OF-IS-TACK to ...
(TRUE)
SEQ1
SEQ2
SEQ3
SEQ4
IS-SEQUENCE-EMPTY
Beginning proof of IS-SEQUENCE-EMPTY ...
(IS-SEQUENCE (EMPTY))
Which simplifies
 with invocation of IS-SEQUENCE
 with the assumptions TYPE-OF-IS-TACK, EMPTYP-EMPTY to ...
(TRUE)
IS-SEQUENCE-TACK
Beginning proof of IS-SEQUENCE-TACK ...
(= (IS-SEQUENCE (TACK X S)) (IS-SEQUENCE S))
Which simplifies
 with invocation of IS-SEQUENCE
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions TYPE-OF-IS-TACK, IS-TACK-TACK, HEAD-TACK, TAIL-TACK to
...
(TRUE)
LENGTH-EMPTY
Beginning proof of LENGTH-EMPTY ...
(= (LENGTH (EMPTY)) 0)
Which simplifies
 with invocation of LENGTH
 forward chaining using >=.SAME.TYPE
 with the assumptions TYPE-OF-IS-TACK, LENGTH-NON-NEGATIVE, EMPTYP-EMPTY,
IS-SEQUENCE-EMPTY to ...
(TRUE)
LENGTH-TACK
Beginning proof of LENGTH-TACK ...
(= (LENGTH (TACK X S)) (+ 1 (LENGTH S)))
Which simplifies
 with invocation of LENGTH
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions TYPE-OF-IS-TACK, LENGTH-NON-NEGATIVE, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK to ...
(TRUE)
NOT-IS-TACK-FACTS
Beginning proof of NOT-IS-TACK-FACTS ...
(IMPLIES (NOT (IS-TACK X))
 (AND (= (LENGTH X) 0) (= (IS-SEQUENCE X) (= X (EMPTY)))))
Which simplifies
 with invocation of IS-SEQUENCE, LENGTH
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, LENGTH-NON-NEGATIVE,
TYPE-OF-IS-TACK to ...
(TRUE)
JOIN
Beginning proof of JOIN ...
(IF (IS-TACK S1) (M< (LENGTH (TAIL S1)) (LENGTH S1)) (TRUE))
Which simplifies
 with invocation of LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
JOIN-TACK
Beginning proof of JOIN-TACK ...
(= (JOIN (TACK X S) T) (TACK X (JOIN S T)))
Which simplifies
 with invocation of JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions TYPE-OF-IS-TACK, IS-TACK-TACK, HEAD-TACK, TAIL-TACK,
IS-SEQUENCE-TACK to ...
(TRUE)
IS-TACK-JOIN
Beginning proof of IS-TACK-JOIN ...
(= (IS-TACK (JOIN S1 S2)) (OR (IS-TACK S1) (IS-TACK S2)))
Which simplifies
 with invocation of JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions TYPE-OF-IS-TACK to ...
(IMPLIES (IS-TACK S1) (= (IS-TACK (JOIN S1 S2)) (TRUE)))

 Returning to :
Beginning proof of IS-TACK-JOIN ...
(= (IS-TACK (JOIN S1 S2)) (OR (IS-TACK S1) (IS-TACK S2)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S1) (*P* (TAIL S1) S2)) (*P* S1 S2))
  (IMPLIES (NOT (IS-TACK S1)) (*P* S1 S2)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S1)
   (= (IS-TACK (JOIN (TAIL S1) S2)) (OR (IS-TACK (TAIL S1)) (IS-TACK S2))))
  (= (IS-TACK (JOIN S1 S2)) (OR (IS-TACK S1) (IS-TACK S2))))
 (IMPLIES (NOT (IS-TACK S1))
  (= (IS-TACK (JOIN S1 S2)) (OR (IS-TACK S1) (IS-TACK S2)))))
Which simplifies
 with invocation of JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
TYPE-OF-IS-TACK to ...
(TRUE)
IS-SEQUENCE-JOIN
Beginning proof of IS-SEQUENCE-JOIN ...
(= (IS-SEQUENCE (JOIN S1 S2)) (IS-SEQUENCE S2))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S1) (*P* (TAIL S1) S2)) (*P* S1 S2))
  (IMPLIES (NOT (IS-TACK S1)) (*P* S1 S2)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S1) (= (IS-SEQUENCE (JOIN (TAIL S1) S2)) (IS-SEQUENCE S2)))
  (= (IS-SEQUENCE (JOIN S1 S2)) (IS-SEQUENCE S2)))
 (IMPLIES (NOT (IS-TACK S1)) (= (IS-SEQUENCE (JOIN S1 S2)) (IS-SEQUENCE S2))))
Which simplifies
 with invocation of IS-SEQUENCE, JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
TYPE-OF-IS-TACK to ...
(TRUE)
JOIN-ASSOCIATIVE
Beginning proof of JOIN-ASSOCIATIVE ...
(= (JOIN (JOIN S1 S2) S3) (JOIN S1 (JOIN S2 S3)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S1) (*P* (TAIL S1) S2 S3)) (*P* S1 S2 S3))
  (IMPLIES (NOT (IS-TACK S1)) (*P* S1 S2 S3)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S1)
   (= (JOIN (JOIN (TAIL S1) S2) S3) (JOIN (TAIL S1) (JOIN S2 S3))))
  (= (JOIN (JOIN S1 S2) S3) (JOIN S1 (JOIN S2 S3))))
 (IMPLIES (NOT (IS-TACK S1))
  (= (JOIN (JOIN S1 S2) S3) (JOIN S1 (JOIN S2 S3)))))
Which simplifies
 with invocation of JOIN
 when rewriting with JOIN-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
TYPE-OF-IS-TACK to ...
(TRUE)
JOIN-EMPTY-LEFT
Beginning proof of JOIN-EMPTY-LEFT ...
(= (JOIN (EMPTY) S) S)
Which simplifies
 with invocation of JOIN
 forward chaining using NOT-IS-TACK-FACTS
 with the assumptions TYPE-OF-IS-TACK, EMPTYP-EMPTY, IS-SEQUENCE-EMPTY to ...
(TRUE)
JOIN-EMPTY-RIGHT
Beginning proof of JOIN-EMPTY-RIGHT ...
(IMPLIES (IS-SEQUENCE S) (= (JOIN S (EMPTY)) S))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* (TAIL S))) (*P* S))
  (IMPLIES (NOT (IS-TACK S)) (*P* S)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S)
   (IMPLIES (IS-SEQUENCE (TAIL S)) (= (JOIN (TAIL S) (EMPTY)) (TAIL S))))
  (IMPLIES (IS-SEQUENCE S) (= (JOIN S (EMPTY)) S)))
 (IMPLIES (NOT (IS-TACK S)) (IMPLIES (IS-SEQUENCE S) (= (JOIN S (EMPTY)) S))))
Which simplifies
 with invocation of JOIN, IS-SEQUENCE
 when rewriting with JOIN-EMPTY-LEFT
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
LENGTH-JOIN
Beginning proof of LENGTH-JOIN ...
(= (LENGTH (JOIN S1 S2)) (+ (LENGTH S1) (LENGTH S2)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S1) (*P* (TAIL S1) S2)) (*P* S1 S2))
  (IMPLIES (NOT (IS-TACK S1)) (*P* S1 S2)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S1)
   (= (LENGTH (JOIN (TAIL S1) S2)) (+ (LENGTH (TAIL S1)) (LENGTH S2))))
  (= (LENGTH (JOIN S1 S2)) (+ (LENGTH S1) (LENGTH S2))))
 (IMPLIES (NOT (IS-TACK S1))
  (= (LENGTH (JOIN S1 S2)) (+ (LENGTH S1) (LENGTH S2)))))
Which simplifies
 with invocation of LENGTH, JOIN
 when rewriting with LENGTH-TACK
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
REVERSE
Beginning proof of REVERSE ...
(IF (IS-TACK S) (M< (LENGTH (TAIL S)) (LENGTH S)) (TRUE))
Which simplifies
 with invocation of LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
REVERSE-NON-TACK
Beginning proof of REVERSE-NON-TACK ...
(IMPLIES (NOT (IS-TACK X)) (= (REVERSE X) (EMPTY)))
Which simplifies
 with invocation of REVERSE
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
IS-TACK-REVERSE
Beginning proof of IS-TACK-REVERSE ...
(= (IS-TACK (REVERSE S)) (IS-TACK S))
Invoking REVERSE gives ...
(=
 (IS-TACK
  (IF (IS-TACK S) (JOIN (REVERSE (TAIL S)) (TACK (HEAD S) (EMPTY))) (EMPTY)))
 (IS-TACK S))
Which simplifies
 when rewriting with IS-TACK-JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
IS-SEQUENCE-REVERSE
Beginning proof of IS-SEQUENCE-REVERSE ...
(= (IS-SEQUENCE (REVERSE S)) (TRUE))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* (TAIL S))) (*P* S))
  (IMPLIES (NOT (IS-TACK S)) (*P* S)))
 produces ...
(AND
 (IMPLIES (AND (IS-TACK S) (= (IS-SEQUENCE (REVERSE (TAIL S))) (TRUE)))
  (= (IS-SEQUENCE (REVERSE S)) (TRUE)))
 (IMPLIES (NOT (IS-TACK S)) (= (IS-SEQUENCE (REVERSE S)) (TRUE))))
Which simplifies
 with invocation of REVERSE
 when rewriting with REVERSE-NON-TACK, IS-SEQUENCE-JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
LENGTH-REVERSE
Beginning proof of LENGTH-REVERSE ...
(= (LENGTH (REVERSE S)) (LENGTH S))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* (TAIL S))) (*P* S))
  (IMPLIES (NOT (IS-TACK S)) (*P* S)))
 produces ...
(AND
 (IMPLIES (AND (IS-TACK S) (= (LENGTH (REVERSE (TAIL S))) (LENGTH (TAIL S))))
  (= (LENGTH (REVERSE S)) (LENGTH S)))
 (IMPLIES (NOT (IS-TACK S)) (= (LENGTH (REVERSE S)) (LENGTH S))))
Which simplifies
 with invocation of LENGTH, REVERSE
 when rewriting with REVERSE-NON-TACK, LENGTH-TACK, LENGTH-JOIN
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
REVERSE-JOIN
Beginning proof of REVERSE-JOIN ...
(= (REVERSE (JOIN S1 S2)) (JOIN (REVERSE S2) (REVERSE S1)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S1) (*P* (TAIL S1) S2)) (*P* S1 S2))
  (IMPLIES (NOT (IS-TACK S1)) (*P* S1 S2)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S1)
   (= (REVERSE (JOIN (TAIL S1) S2)) (JOIN (REVERSE S2) (REVERSE (TAIL S1)))))
  (= (REVERSE (JOIN S1 S2)) (JOIN (REVERSE S2) (REVERSE S1))))
 (IMPLIES (NOT (IS-TACK S1))
  (= (REVERSE (JOIN S1 S2)) (JOIN (REVERSE S2) (REVERSE S1)))))
Which simplifies
 with invocation of REVERSE, JOIN
 when rewriting with JOIN-EMPTY-RIGHT, IS-SEQUENCE-REVERSE, REVERSE-NON-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (IS-TACK S1)
  (= (REVERSE (JOIN (TAIL S1) S2)) (JOIN (REVERSE S2) (REVERSE (TAIL S1)))))
 (= (JOIN (REVERSE (JOIN (TAIL S1) S2)) (TACK (HEAD S1) (EMPTY)))
  (JOIN (REVERSE S2) (JOIN (REVERSE (TAIL S1)) (TACK (HEAD S1) (EMPTY))))))
Substituting (= (REVERSE (JOIN (TAIL S1) S2))
              (JOIN (REVERSE S2) (REVERSE (TAIL S1)))) produces
...
(IMPLIES
 (AND (IS-TACK S1)
  (= (REVERSE (JOIN (TAIL S1) S2)) (JOIN (REVERSE S2) (REVERSE (TAIL S1)))))
 (= (JOIN (JOIN (REVERSE S2) (REVERSE (TAIL S1))) (TACK (HEAD S1) (EMPTY)))
  (JOIN (REVERSE S2) (JOIN (REVERSE (TAIL S1)) (TACK (HEAD S1) (EMPTY))))))
Which simplifies
 when rewriting with JOIN-ASSOCIATIVE
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
REVERSE-REVERSE
Beginning proof of REVERSE-REVERSE ...
(IMPLIES (IS-SEQUENCE S) (= (REVERSE (REVERSE S)) S))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* (TAIL S))) (*P* S))
  (IMPLIES (NOT (IS-TACK S)) (*P* S)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S)
   (IMPLIES (IS-SEQUENCE (TAIL S)) (= (REVERSE (REVERSE (TAIL S))) (TAIL S))))
  (IMPLIES (IS-SEQUENCE S) (= (REVERSE (REVERSE S)) S)))
 (IMPLIES (NOT (IS-TACK S))
  (IMPLIES (IS-SEQUENCE S) (= (REVERSE (REVERSE S)) S))))
Which simplifies
 with invocation of REVERSE, IS-SEQUENCE
 when rewriting with JOIN-TACK, JOIN-EMPTY-LEFT, REVERSE-NON-TACK, REVERSE-JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
IS-MEMBER
Beginning proof of IS-MEMBER ...
(IF (IS-TACK S) (M< (LENGTH (TAIL S)) (LENGTH S)) (TRUE))
Which simplifies
 with invocation of LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
IS-MEMBER-TACK
Beginning proof of IS-MEMBER-TACK ...
(= (IS-MEMBER E (TACK X S)) (OR (= E X) (IS-MEMBER E S)))
Which simplifies
 with invocation of IS-MEMBER
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions TYPE-OF-IS-TACK, IS-TACK-TACK, HEAD-TACK, TAIL-TACK,
IS-SEQUENCE-TACK to ...
(TRUE)
IS-MEMBER-JOIN
Beginning proof of IS-MEMBER-JOIN ...
(= (IS-MEMBER E (JOIN S1 S2)) (OR (IS-MEMBER E S1) (IS-MEMBER E S2)))
Which simplifies to ...
(IF (IS-MEMBER E S1) (= (IS-MEMBER E (JOIN S1 S2)) (TRUE))
 (IF (IS-MEMBER E S2) (= (IS-MEMBER E (JOIN S1 S2)) (TRUE))
  (= (IS-MEMBER E (JOIN S1 S2)) (FALSE))))

 Returning to :
Beginning proof of IS-MEMBER-JOIN ...
(= (IS-MEMBER E (JOIN S1 S2)) (OR (IS-MEMBER E S1) (IS-MEMBER E S2)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S1) (*P* E (TAIL S1) S2)) (*P* E S1 S2))
  (IMPLIES (NOT (IS-TACK S1)) (*P* E S1 S2)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S1)
   (= (IS-MEMBER E (JOIN (TAIL S1) S2))
    (OR (IS-MEMBER E (TAIL S1)) (IS-MEMBER E S2))))
  (= (IS-MEMBER E (JOIN S1 S2)) (OR (IS-MEMBER E S1) (IS-MEMBER E S2))))
 (IMPLIES (NOT (IS-TACK S1))
  (= (IS-MEMBER E (JOIN S1 S2)) (OR (IS-MEMBER E S1) (IS-MEMBER E S2)))))
Which simplifies
 with invocation of IS-MEMBER, JOIN
 when rewriting with IS-MEMBER-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
TYPE-OF-IS-TACK to ...
(TRUE)
IS-MEMBER-REVERSE
Beginning proof of IS-MEMBER-REVERSE ...
(= (IS-MEMBER E (REVERSE S)) (IS-MEMBER E S))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* E (TAIL S))) (*P* E S))
  (IMPLIES (NOT (IS-TACK S)) (*P* E S)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S)
   (= (IS-MEMBER E (REVERSE (TAIL S))) (IS-MEMBER E (TAIL S))))
  (= (IS-MEMBER E (REVERSE S)) (IS-MEMBER E S)))
 (IMPLIES (NOT (IS-TACK S)) (= (IS-MEMBER E (REVERSE S)) (IS-MEMBER E S))))
Which simplifies
 with invocation of IS-MEMBER, REVERSE
 when rewriting with REVERSE-NON-TACK, IS-MEMBER-TACK, IS-MEMBER-JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
MEMBERS
Beginning proof of MEMBERS ...
(IF (IS-TACK S) (M< (LENGTH (TAIL S)) (LENGTH S)) (TRUE))
Which simplifies
 with invocation of LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
MEMBERS-TACK
Beginning proof of MEMBERS-TACK ...
(= (MEMBERS (TACK X S)) (SETADD X (MEMBERS S)))
Which simplifies
 with invocation of MEMBERS
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions TYPE-OF-IS-TACK, IS-TACK-TACK, HEAD-TACK, TAIL-TACK,
IS-SEQUENCE-TACK to ...
(TRUE)
IN-MEMBERS
Beginning proof of IN-MEMBERS ...
(= (IN E (MEMBERS S)) (IS-MEMBER E S))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* E (TAIL S))) (*P* E S))
  (IMPLIES (NOT (IS-TACK S)) (*P* E S)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (= (IN E (MEMBERS (TAIL S))) (IS-MEMBER E (TAIL S))))
  (= (IN E (MEMBERS S)) (IS-MEMBER E S)))
 (IMPLIES (NOT (IS-TACK S)) (= (IN E (MEMBERS S)) (IS-MEMBER E S))))
Which simplifies
 with invocation of IS-MEMBER, MEMBERS
 when rewriting with NULLSET.DEFINITION, SETADD.DEFINITION
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions TYPE-OF-IS-TACK to ...
(TRUE)
MEMBERS-JOIN
Beginning proof of MEMBERS-JOIN ...
(= (MEMBERS (JOIN S1 S2)) (UNION (MEMBERS S1) (MEMBERS S2)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S1) (*P* (TAIL S1) S2)) (*P* S1 S2))
  (IMPLIES (NOT (IS-TACK S1)) (*P* S1 S2)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S1)
   (= (MEMBERS (JOIN (TAIL S1) S2)) (UNION (MEMBERS (TAIL S1)) (MEMBERS S2))))
  (= (MEMBERS (JOIN S1 S2)) (UNION (MEMBERS S1) (MEMBERS S2))))
 (IMPLIES (NOT (IS-TACK S1))
  (= (MEMBERS (JOIN S1 S2)) (UNION (MEMBERS S1) (MEMBERS S2)))))
Which simplifies
 with invocation of MEMBERS, JOIN
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, MEMBERS-TACK, UNION.COMMUTATIVE
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
TYPE-OF-IS-TACK to ...
(TRUE)
MEMBERS-REVERSE
Beginning proof of MEMBERS-REVERSE ...
(= (MEMBERS (REVERSE S)) (MEMBERS S))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* (TAIL S))) (*P* S))
  (IMPLIES (NOT (IS-TACK S)) (*P* S)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (= (MEMBERS (REVERSE (TAIL S))) (MEMBERS (TAIL S))))
  (= (MEMBERS (REVERSE S)) (MEMBERS S)))
 (IMPLIES (NOT (IS-TACK S)) (= (MEMBERS (REVERSE S)) (MEMBERS S))))
Which simplifies
 with invocation of MEMBERS, REVERSE
 when rewriting with REVERSE-NON-TACK, SETRULES!UNION-SUBSET-LEFT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-RIGHT, MEMBERS-TACK, MEMBERS-JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, IS-TACK-TACK, HEAD-TACK, TAIL-TACK,
IS-SEQUENCE-TACK, EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER
Beginning proof of FILTER ...
(IF (IS-TACK S) (M< (LENGTH (TAIL S)) (LENGTH S)) (TRUE))
Which simplifies
 with invocation of LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-EMPTY
Beginning proof of FILTER-EMPTY ...
(= (FILTER X (EMPTY)) (EMPTY))
Which simplifies
 with invocation of FILTER
 forward chaining using NOT-IS-TACK-FACTS
 with the assumptions TYPE-OF-IS-TACK, EMPTYP-EMPTY, IS-SEQUENCE-EMPTY to ...
(TRUE)
FILTER-TACK
Beginning proof of FILTER-TACK ...
(= (FILTER Y (TACK X S)) (IF (IN X Y) (TACK X (FILTER Y S)) (FILTER Y S)))
Which simplifies
 with invocation of FILTER
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions TYPE-OF-IS-TACK, IS-TACK-TACK, HEAD-TACK, TAIL-TACK,
IS-SEQUENCE-TACK to ...
(TRUE)
IS-SEQUENCE-FILTER
Beginning proof of IS-SEQUENCE-FILTER ...
(= (IS-SEQUENCE (FILTER X S)) (TRUE))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (IS-SEQUENCE (FILTER X (TAIL S))) (TRUE)))
  (= (IS-SEQUENCE (FILTER X S)) (TRUE)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (IS-SEQUENCE (FILTER X (TAIL S))) (TRUE)))
  (= (IS-SEQUENCE (FILTER X S)) (TRUE)))
 (IMPLIES (NOT (IS-TACK S)) (= (IS-SEQUENCE (FILTER X S)) (TRUE))))
Which simplifies
 with invocation of FILTER
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-BY-NULLSET
Beginning proof of FILTER-BY-NULLSET ...
(= (FILTER (NULLSET) S) (EMPTY))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) (NULLSET)) (*P* (TAIL S))) (*P* S))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) (NULLSET))) (*P* (TAIL S)))
   (*P* S))
  (IMPLIES (NOT (IS-TACK S)) (*P* S)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) (NULLSET))
   (= (FILTER (NULLSET) (TAIL S)) (EMPTY)))
  (= (FILTER (NULLSET) S) (EMPTY)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) (NULLSET)))
   (= (FILTER (NULLSET) (TAIL S)) (EMPTY)))
  (= (FILTER (NULLSET) S) (EMPTY)))
 (IMPLIES (NOT (IS-TACK S)) (= (FILTER (NULLSET) S) (EMPTY))))
Which simplifies
 with invocation of FILTER
 when rewriting with NULLSET.DEFINITION
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-BY-ALL-MEMBERS
Beginning proof of FILTER-BY-ALL-MEMBERS ...
(IMPLIES (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X)) (= (FILTER X S) S))
Which simplifies
 with invocation of SUBSET
 when rewriting with IN-MEMBERS to ...
(IMPLIES (AND (IS-SEQUENCE S) (ALL (E) (IMPLIES (IS-MEMBER E S) (IN E X))))
 (= (FILTER X S) S))

 Returning to :
Beginning proof of FILTER-BY-ALL-MEMBERS ...
(IMPLIES (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X)) (= (FILTER X S) S))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (IMPLIES (AND (IS-SEQUENCE (TAIL S)) (SUBSET (MEMBERS (TAIL S)) X))
    (= (FILTER X (TAIL S)) (TAIL S))))
  (IMPLIES (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X)) (= (FILTER X S) S)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (IMPLIES (AND (IS-SEQUENCE (TAIL S)) (SUBSET (MEMBERS (TAIL S)) X))
    (= (FILTER X (TAIL S)) (TAIL S))))
  (IMPLIES (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X)) (= (FILTER X S) S)))
 (IMPLIES (NOT (IS-TACK S))
  (IMPLIES (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X)) (= (FILTER X S) S))))
Which simplifies
 with invocation of FILTER, MEMBERS, IS-SEQUENCE, SUBSET
 when rewriting with FILTER-EMPTY, SUBSET.NULLSET.LEFT,
SETRULES!SUBSET-SETADD, IN-MEMBERS
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-JOIN
Beginning proof of FILTER-JOIN ...
(= (FILTER X (JOIN S T)) (JOIN (FILTER X S) (FILTER X T)))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) T X)) (*P* S T X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) T X))
   (*P* S T X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S T X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (FILTER X (JOIN (TAIL S) T)) (JOIN (FILTER X (TAIL S)) (FILTER X T))))
  (= (FILTER X (JOIN S T)) (JOIN (FILTER X S) (FILTER X T))))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (FILTER X (JOIN (TAIL S) T)) (JOIN (FILTER X (TAIL S)) (FILTER X T))))
  (= (FILTER X (JOIN S T)) (JOIN (FILTER X S) (FILTER X T))))
 (IMPLIES (NOT (IS-TACK S))
  (= (FILTER X (JOIN S T)) (JOIN (FILTER X S) (FILTER X T)))))
Which simplifies
 with invocation of FILTER, JOIN
 when rewriting with JOIN-EMPTY-LEFT, JOIN-TACK, FILTER-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
TYPE-OF-IS-TACK to ...
(TRUE)
REVERSE-FILTER
Beginning proof of REVERSE-FILTER ...
(= (REVERSE (FILTER X S)) (FILTER X (REVERSE S)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (REVERSE (FILTER X (TAIL S))) (FILTER X (REVERSE (TAIL S)))))
  (= (REVERSE (FILTER X S)) (FILTER X (REVERSE S))))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (REVERSE (FILTER X (TAIL S))) (FILTER X (REVERSE (TAIL S)))))
  (= (REVERSE (FILTER X S)) (FILTER X (REVERSE S))))
 (IMPLIES (NOT (IS-TACK S)) (= (REVERSE (FILTER X S)) (FILTER X (REVERSE S)))))
Which simplifies
 with invocation of MEMBERS, REVERSE, FILTER
 when rewriting with REVERSE-NON-TACK, JOIN-EMPTY-RIGHT, IS-SEQUENCE-FILTER,
FILTER-TACK, FILTER-BY-ALL-MEMBERS, SUBSET.NULLSET.LEFT,
SETRULES!SUBSET-SETADD, MEMBERS-TACK, FILTER-JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, TYPE-OF-IS-TACK to ...
(TRUE)
IS-MEMBER-FILTER
Beginning proof of IS-MEMBER-FILTER ...
(= (IS-MEMBER E (FILTER X S)) (AND (IN E X) (IS-MEMBER E S)))
Which simplifies to ...
(IF (IN E X)
 (IF (IS-MEMBER E S) (= (IS-MEMBER E (FILTER X S)) (TRUE))
  (= (IS-MEMBER E (FILTER X S)) (FALSE)))
 (= (IS-MEMBER E (FILTER X S)) (FALSE)))

 Returning to :
Beginning proof of IS-MEMBER-FILTER ...
(= (IS-MEMBER E (FILTER X S)) (AND (IN E X) (IS-MEMBER E S)))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* E (TAIL S) X)) (*P* E S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* E (TAIL S) X))
   (*P* E S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* E S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (IS-MEMBER E (FILTER X (TAIL S)))
    (AND (IN E X) (IS-MEMBER E (TAIL S)))))
  (= (IS-MEMBER E (FILTER X S)) (AND (IN E X) (IS-MEMBER E S))))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (IS-MEMBER E (FILTER X (TAIL S)))
    (AND (IN E X) (IS-MEMBER E (TAIL S)))))
  (= (IS-MEMBER E (FILTER X S)) (AND (IN E X) (IS-MEMBER E S))))
 (IMPLIES (NOT (IS-TACK S))
  (= (IS-MEMBER E (FILTER X S)) (AND (IN E X) (IS-MEMBER E S)))))
Which simplifies
 with invocation of IS-MEMBER, FILTER
 when rewriting with IS-MEMBER-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
TYPE-OF-IS-TACK to ...
(TRUE)
MEMBERS-FILTER
Beginning proof of MEMBERS-FILTER ...
(= (MEMBERS (FILTER X S)) (INTER X (MEMBERS S)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (MEMBERS (FILTER X (TAIL S))) (INTER X (MEMBERS (TAIL S)))))
  (= (MEMBERS (FILTER X S)) (INTER X (MEMBERS S))))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (MEMBERS (FILTER X (TAIL S))) (INTER X (MEMBERS (TAIL S)))))
  (= (MEMBERS (FILTER X S)) (INTER X (MEMBERS S))))
 (IMPLIES (NOT (IS-TACK S)) (= (MEMBERS (FILTER X S)) (INTER X (MEMBERS S)))))
Which simplifies
 with invocation of MEMBERS, FILTER
 when rewriting with SETRULES!INTER-SUBSET-LEFT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-INTER-RIGHT-NONMEMBER, SETRULES!SETADD-INTER-RIGHT-MEMBER,
MEMBERS-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-FILTER
Beginning proof of FILTER-FILTER ...
(= (FILTER X (FILTER Y S)) (FILTER (INTER X Y) S))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) Y) (*P* (TAIL S) X Y)) (*P* S X Y))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) Y)) (*P* (TAIL S) X Y))
   (*P* S X Y))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X Y)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) Y)
   (= (FILTER X (FILTER Y (TAIL S))) (FILTER (INTER X Y) (TAIL S))))
  (= (FILTER X (FILTER Y S)) (FILTER (INTER X Y) S)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) Y))
   (= (FILTER X (FILTER Y (TAIL S))) (FILTER (INTER X Y) (TAIL S))))
  (= (FILTER X (FILTER Y S)) (FILTER (INTER X Y) S)))
 (IMPLIES (NOT (IS-TACK S))
  (= (FILTER X (FILTER Y S)) (FILTER (INTER X Y) S))))
Which simplifies
 with invocation of MEMBERS, FILTER
 when rewriting with FILTER-BY-ALL-MEMBERS, SUBSET.NULLSET.LEFT,
INTER.DEFINITION, FILTER-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-NOT
Beginning proof of FILTER-NOT ...
(IF (IS-TACK S) (M< (LENGTH (TAIL S)) (LENGTH S)) (TRUE))
Which simplifies
 with invocation of LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-NOT-EMPTY
Beginning proof of FILTER-NOT-EMPTY ...
(= (FILTER-NOT X (EMPTY)) (EMPTY))
Which simplifies
 with invocation of FILTER-NOT
 forward chaining using NOT-IS-TACK-FACTS
 with the assumptions TYPE-OF-IS-TACK, EMPTYP-EMPTY, IS-SEQUENCE-EMPTY to ...
(TRUE)
FILTER-NOT-TACK
Beginning proof of FILTER-NOT-TACK ...
(= (FILTER-NOT Y (TACK X S))
 (IF (IN X Y) (FILTER-NOT Y S) (TACK X (FILTER-NOT Y S))))
Which simplifies
 with invocation of FILTER-NOT
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL
 with the assumptions TYPE-OF-IS-TACK, IS-TACK-TACK, HEAD-TACK, TAIL-TACK,
IS-SEQUENCE-TACK to ...
(TRUE)
IS-SEQUENCE-FILTER-NOT
Beginning proof of IS-SEQUENCE-FILTER-NOT ...
(= (IS-SEQUENCE (FILTER-NOT X S)) (TRUE))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (IS-SEQUENCE (FILTER-NOT X (TAIL S))) (TRUE)))
  (= (IS-SEQUENCE (FILTER-NOT X S)) (TRUE)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (IS-SEQUENCE (FILTER-NOT X (TAIL S))) (TRUE)))
  (= (IS-SEQUENCE (FILTER-NOT X S)) (TRUE)))
 (IMPLIES (NOT (IS-TACK S)) (= (IS-SEQUENCE (FILTER-NOT X S)) (TRUE))))
Which simplifies
 with invocation of FILTER-NOT
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-NOT-BY-NULLSET
Beginning proof of FILTER-NOT-BY-NULLSET ...
(IMPLIES (IS-SEQUENCE S) (= (FILTER-NOT (NULLSET) S) S))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) (NULLSET)) (*P* (TAIL S))) (*P* S))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) (NULLSET))) (*P* (TAIL S)))
   (*P* S))
  (IMPLIES (NOT (IS-TACK S)) (*P* S)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) (NULLSET))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (FILTER-NOT (NULLSET) (TAIL S)) (TAIL S))))
  (IMPLIES (IS-SEQUENCE S) (= (FILTER-NOT (NULLSET) S) S)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) (NULLSET)))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (FILTER-NOT (NULLSET) (TAIL S)) (TAIL S))))
  (IMPLIES (IS-SEQUENCE S) (= (FILTER-NOT (NULLSET) S) S)))
 (IMPLIES (NOT (IS-TACK S))
  (IMPLIES (IS-SEQUENCE S) (= (FILTER-NOT (NULLSET) S) S))))
Which simplifies
 with invocation of FILTER-NOT, IS-SEQUENCE
 when rewriting with FILTER-NOT-EMPTY, NULLSET.DEFINITION
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-NOT-BY-ALL-MEMBERS
Beginning proof of FILTER-NOT-BY-ALL-MEMBERS ...
(IMPLIES (SUBSET (MEMBERS S) X) (= (FILTER-NOT X S) (EMPTY)))
Which simplifies
 with invocation of SUBSET
 when rewriting with IN-MEMBERS
 forward chaining using NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY to ...
(IMPLIES (ALL (E) (IMPLIES (IS-MEMBER E S) (IN E X)))
 (= (FILTER-NOT X S) (EMPTY)))

 Returning to :
Beginning proof of FILTER-NOT-BY-ALL-MEMBERS ...
(IMPLIES (SUBSET (MEMBERS S) X) (= (FILTER-NOT X S) (EMPTY)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (IMPLIES (SUBSET (MEMBERS (TAIL S)) X)
    (= (FILTER-NOT X (TAIL S)) (EMPTY))))
  (IMPLIES (SUBSET (MEMBERS S) X) (= (FILTER-NOT X S) (EMPTY))))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (IMPLIES (SUBSET (MEMBERS (TAIL S)) X)
    (= (FILTER-NOT X (TAIL S)) (EMPTY))))
  (IMPLIES (SUBSET (MEMBERS S) X) (= (FILTER-NOT X S) (EMPTY))))
 (IMPLIES (NOT (IS-TACK S))
  (IMPLIES (SUBSET (MEMBERS S) X) (= (FILTER-NOT X S) (EMPTY)))))
Which simplifies
 with invocation of FILTER-NOT, MEMBERS, SUBSET
 when rewriting with SUBSET.NULLSET.LEFT, SETRULES!SUBSET-SETADD, IN-MEMBERS
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-NOT-JOIN
Beginning proof of FILTER-NOT-JOIN ...
(= (FILTER-NOT X (JOIN S T)) (JOIN (FILTER-NOT X S) (FILTER-NOT X T)))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) T X)) (*P* S T X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) T X))
   (*P* S T X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S T X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (FILTER-NOT X (JOIN (TAIL S) T))
    (JOIN (FILTER-NOT X (TAIL S)) (FILTER-NOT X T))))
  (= (FILTER-NOT X (JOIN S T)) (JOIN (FILTER-NOT X S) (FILTER-NOT X T))))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (FILTER-NOT X (JOIN (TAIL S) T))
    (JOIN (FILTER-NOT X (TAIL S)) (FILTER-NOT X T))))
  (= (FILTER-NOT X (JOIN S T)) (JOIN (FILTER-NOT X S) (FILTER-NOT X T))))
 (IMPLIES (NOT (IS-TACK S))
  (= (FILTER-NOT X (JOIN S T)) (JOIN (FILTER-NOT X S) (FILTER-NOT X T)))))
Which simplifies
 with invocation of MEMBERS, FILTER-NOT, JOIN
 when rewriting with JOIN-EMPTY-LEFT, FILTER-NOT-BY-ALL-MEMBERS,
SUBSET.NULLSET.LEFT, JOIN-TACK, FILTER-NOT-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, TYPE-OF-IS-TACK to ...
(TRUE)
REVERSE-FILTER-NOT
Beginning proof of REVERSE-FILTER-NOT ...
(= (REVERSE (FILTER-NOT X S)) (FILTER-NOT X (REVERSE S)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (REVERSE (FILTER-NOT X (TAIL S))) (FILTER-NOT X (REVERSE (TAIL S)))))
  (= (REVERSE (FILTER-NOT X S)) (FILTER-NOT X (REVERSE S))))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (REVERSE (FILTER-NOT X (TAIL S))) (FILTER-NOT X (REVERSE (TAIL S)))))
  (= (REVERSE (FILTER-NOT X S)) (FILTER-NOT X (REVERSE S))))
 (IMPLIES (NOT (IS-TACK S))
  (= (REVERSE (FILTER-NOT X S)) (FILTER-NOT X (REVERSE S)))))
Which simplifies
 with invocation of MEMBERS, REVERSE, FILTER-NOT
 when rewriting with REVERSE-NON-TACK, FILTER-NOT-TACK, JOIN-EMPTY-RIGHT,
IS-SEQUENCE-FILTER-NOT, FILTER-NOT-BY-ALL-MEMBERS, SUBSET.NULLSET.LEFT,
SETRULES!SUBSET-SETADD, MEMBERS-TACK, FILTER-NOT-JOIN
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
IS-MEMBER-FILTER-NOT
Beginning proof of IS-MEMBER-FILTER-NOT ...
(= (IS-MEMBER E (FILTER-NOT X S)) (AND (NOT (IN E X)) (IS-MEMBER E S)))
Which simplifies to ...
(IF (IN E X) (= (IS-MEMBER E (FILTER-NOT X S)) (FALSE))
 (IF (IS-MEMBER E S) (= (IS-MEMBER E (FILTER-NOT X S)) (TRUE))
  (= (IS-MEMBER E (FILTER-NOT X S)) (FALSE))))

 Returning to :
Beginning proof of IS-MEMBER-FILTER-NOT ...
(= (IS-MEMBER E (FILTER-NOT X S)) (AND (NOT (IN E X)) (IS-MEMBER E S)))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* E (TAIL S) X)) (*P* E S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* E (TAIL S) X))
   (*P* E S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* E S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (IS-MEMBER E (FILTER-NOT X (TAIL S)))
    (AND (NOT (IN E X)) (IS-MEMBER E (TAIL S)))))
  (= (IS-MEMBER E (FILTER-NOT X S)) (AND (NOT (IN E X)) (IS-MEMBER E S))))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (IS-MEMBER E (FILTER-NOT X (TAIL S)))
    (AND (NOT (IN E X)) (IS-MEMBER E (TAIL S)))))
  (= (IS-MEMBER E (FILTER-NOT X S)) (AND (NOT (IN E X)) (IS-MEMBER E S))))
 (IMPLIES (NOT (IS-TACK S))
  (= (IS-MEMBER E (FILTER-NOT X S)) (AND (NOT (IN E X)) (IS-MEMBER E S)))))
Which simplifies
 with invocation of MEMBERS, IS-MEMBER, FILTER-NOT
 when rewriting with FILTER-NOT-BY-ALL-MEMBERS, SUBSET.NULLSET.LEFT,
IS-MEMBER-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, TYPE-OF-IS-TACK to ...
(TRUE)
MEMBERS-FILTER-NOT
Beginning proof of MEMBERS-FILTER-NOT ...
(= (MEMBERS (FILTER-NOT X S)) (DIFF (MEMBERS S) X))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (IN (HEAD S) X) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) X)) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) X)
   (= (MEMBERS (FILTER-NOT X (TAIL S))) (DIFF (MEMBERS (TAIL S)) X)))
  (= (MEMBERS (FILTER-NOT X S)) (DIFF (MEMBERS S) X)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) X))
   (= (MEMBERS (FILTER-NOT X (TAIL S))) (DIFF (MEMBERS (TAIL S)) X)))
  (= (MEMBERS (FILTER-NOT X S)) (DIFF (MEMBERS S) X)))
 (IMPLIES (NOT (IS-TACK S))
  (= (MEMBERS (FILTER-NOT X S)) (DIFF (MEMBERS S) X))))
Which simplifies
 with invocation of MEMBERS, FILTER-NOT
 when rewriting with SETRULES!DIFF-SUPERSET, FILTER-NOT-BY-ALL-MEMBERS,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-DIFF-LEFT-NONMEMBER, MEMBERS-TACK,
SETRULES!SETADD-DIFF-LEFT-MEMBER
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, SETRULES!SUBSET-DIFF-RELATION,
TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-NOT-FILTER-NOT
Beginning proof of FILTER-NOT-FILTER-NOT ...
(= (FILTER-NOT X (FILTER-NOT Y S)) (FILTER-NOT (UNION X Y) S))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) Y) (*P* (TAIL S) X Y)) (*P* S X Y))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) Y)) (*P* (TAIL S) X Y))
   (*P* S X Y))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X Y)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) Y)
   (= (FILTER-NOT X (FILTER-NOT Y (TAIL S)))
    (FILTER-NOT (UNION X Y) (TAIL S))))
  (= (FILTER-NOT X (FILTER-NOT Y S)) (FILTER-NOT (UNION X Y) S)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) Y))
   (= (FILTER-NOT X (FILTER-NOT Y (TAIL S)))
    (FILTER-NOT (UNION X Y) (TAIL S))))
  (= (FILTER-NOT X (FILTER-NOT Y S)) (FILTER-NOT (UNION X Y) S)))
 (IMPLIES (NOT (IS-TACK S))
  (= (FILTER-NOT X (FILTER-NOT Y S)) (FILTER-NOT (UNION X Y) S))))
Which simplifies
 with invocation of MEMBERS, FILTER-NOT
 when rewriting with SETRULES!SUBSET-UNION-RIGHT, FILTER-NOT-BY-ALL-MEMBERS,
SUBSET.NULLSET.LEFT, FILTER-NOT-TACK, UNION.DEFINITION
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, EMPTYP-EMPTY, IS-SEQUENCE-EMPTY,
IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-NOT-FILTER
Beginning proof of FILTER-NOT-FILTER ...
(= (FILTER-NOT X (FILTER Y S)) (FILTER (DIFF Y X) S))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) Y) (*P* (TAIL S) X Y)) (*P* S X Y))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) Y)) (*P* (TAIL S) X Y))
   (*P* S X Y))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X Y)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) Y)
   (= (FILTER-NOT X (FILTER Y (TAIL S))) (FILTER (DIFF Y X) (TAIL S))))
  (= (FILTER-NOT X (FILTER Y S)) (FILTER (DIFF Y X) S)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) Y))
   (= (FILTER-NOT X (FILTER Y (TAIL S))) (FILTER (DIFF Y X) (TAIL S))))
  (= (FILTER-NOT X (FILTER Y S)) (FILTER (DIFF Y X) S)))
 (IMPLIES (NOT (IS-TACK S))
  (= (FILTER-NOT X (FILTER Y S)) (FILTER (DIFF Y X) S))))
Which simplifies
 with invocation of MEMBERS, FILTER
 when rewriting with FILTER-NOT-BY-ALL-MEMBERS, SUBSET.NULLSET.LEFT,
DIFF.DEFINITION, FILTER-NOT-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
SETRULES!SUBSET-DIFF-RELATION, TYPE-OF-IS-TACK to ...
(TRUE)
FILTER-FILTER-NOT
Beginning proof of FILTER-FILTER-NOT ...
(= (FILTER X (FILTER-NOT Y S)) (FILTER (DIFF X Y) S))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IN (HEAD S) Y) (*P* (TAIL S) X Y)) (*P* S X Y))
  (IMPLIES (AND (IS-TACK S) (NOT (IN (HEAD S) Y)) (*P* (TAIL S) X Y))
   (*P* S X Y))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X Y)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IN (HEAD S) Y)
   (= (FILTER X (FILTER-NOT Y (TAIL S))) (FILTER (DIFF X Y) (TAIL S))))
  (= (FILTER X (FILTER-NOT Y S)) (FILTER (DIFF X Y) S)))
 (IMPLIES
  (AND (IS-TACK S) (NOT (IN (HEAD S) Y))
   (= (FILTER X (FILTER-NOT Y (TAIL S))) (FILTER (DIFF X Y) (TAIL S))))
  (= (FILTER X (FILTER-NOT Y S)) (FILTER (DIFF X Y) S)))
 (IMPLIES (NOT (IS-TACK S))
  (= (FILTER X (FILTER-NOT Y S)) (FILTER (DIFF X Y) S))))
Which simplifies
 with invocation of MEMBERS, FILTER, FILTER-NOT
 when rewriting with FILTER-BY-ALL-MEMBERS, FILTER-NOT-BY-ALL-MEMBERS,
SUBSET.NULLSET.LEFT, FILTER-TACK, DIFF.DEFINITION
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, IS-TACK-TACK,
HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK, SETRULES!SUBSET-DIFF-RELATION,
TYPE-OF-IS-TACK to ...
(TRUE)
NTH
Beginning proof of NTH ...
(IF (>= N 2) (M< (- N 1) N) (TRUE))
Which simplifies
 when rewriting with M<.NAT
 forward chaining using >=.SAME.TYPE
 with the assumptions SUCC.INT to ...
(TRUE)
TWO-SEQ-INDUCTION
Beginning proof of TWO-SEQ-INDUCTION ...
(IF (AND (IS-TACK S) (IS-TACK T)) (M< (LENGTH (TAIL S)) (LENGTH S)) (TRUE))
Which simplifies
 with invocation of LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
Warning RULE-LOOPS for EXTENSIONALITY:
 The rule EXTENSIONALITY loops upon itself.
EXTENSIONALITY
Beginning proof of EXTENSIONALITY ...
(IMPLIES (AND (IS-SEQUENCE S) (IS-SEQUENCE T))
 (= (= S T)
  (AND (= (LENGTH S) (LENGTH T))
   (ALL (I)
    (IMPLIES (AND (<= 1 I) (<= I (LENGTH S))) (= (NTH S I) (NTH T I)))))))
Splitting on (= S T) generates ...
(IF (= S T)
 (IMPLIES (AND (IS-SEQUENCE S) (IS-SEQUENCE T))
  (= (= S T)
   (AND (= (LENGTH S) (LENGTH T))
    (ALL (I)
     (IMPLIES (AND (<= 1 I) (<= I (LENGTH S))) (= (NTH S I) (NTH T I)))))))
 (IMPLIES (AND (IS-SEQUENCE S) (IS-SEQUENCE T))
  (= (= S T)
   (AND (= (LENGTH S) (LENGTH T))
    (ALL (I$0)
     (IMPLIES (AND (<= 1 I$0) (<= I$0 (LENGTH S)))
      (= (NTH S I$0) (NTH T I$0))))))))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (= S T)) (IS-SEQUENCE S) (IS-SEQUENCE T) (= (LENGTH S) (LENGTH T)))
 (NOT
  (ALL (I)
   (IMPLIES (AND (>= I 1) (>= (LENGTH S) I)) (= (NTH S I) (NTH T I))))))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (IS-TACK S) (IS-TACK T) (*P* (TAIL S) (TAIL T))) (*P* S T))
  (IMPLIES (NOT (AND (IS-TACK S) (IS-TACK T))) (*P* S T)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S) (IS-TACK T)
   (IMPLIES
    (AND (NOT (= (TAIL S) (TAIL T))) (IS-SEQUENCE (TAIL S))
     (IS-SEQUENCE (TAIL T)) (= (LENGTH (TAIL S)) (LENGTH (TAIL T))))
    (NOT
     (ALL (I)
      (IMPLIES (AND (>= I 1) (>= (LENGTH (TAIL S)) I))
       (= (NTH (TAIL S) I) (NTH (TAIL T) I)))))))
  (IMPLIES
   (AND (NOT (= S T)) (IS-SEQUENCE S) (IS-SEQUENCE T)
    (= (LENGTH S) (LENGTH T)))
   (NOT
    (ALL (I)
     (IMPLIES (AND (>= I 1) (>= (LENGTH S) I)) (= (NTH S I) (NTH T I)))))))
 (IMPLIES (NOT (AND (IS-TACK S) (IS-TACK T)))
  (IMPLIES
   (AND (NOT (= S T)) (IS-SEQUENCE S) (IS-SEQUENCE T)
    (= (LENGTH S) (LENGTH T)))
   (NOT
    (ALL (I)
     (IMPLIES (AND (>= I 1) (>= (LENGTH S) I)) (= (NTH S I) (NTH T I))))))))
Which simplifies
 with invocation of LENGTH, IS-SEQUENCE
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, LENGTH-NON-NEGATIVE,
TYPE-OF-IS-TACK to ...
(IF (IS-TACK S)
 (IF (IS-TACK T)
  (IF (= (TAIL S) (TAIL T))
   (IMPLIES (AND (NOT (= S T)) (IS-SEQUENCE (TAIL S)))
    (NOT
     (ALL (I)
      (IMPLIES (AND (>= I 1) (>= (+ 1 (LENGTH (TAIL S))) I))
       (= (NTH S I) (NTH T I))))))
   (IMPLIES
    (AND (IS-SEQUENCE (TAIL S)) (IS-SEQUENCE (TAIL T))
     (= (LENGTH (TAIL S)) (LENGTH (TAIL T)))
     (NOT
      (ALL (I$0)
       (IMPLIES (AND (>= I$0 1) (>= (LENGTH (TAIL S)) I$0))
        (= (NTH (TAIL S) I$0) (NTH (TAIL T) I$0))))))
    (NOT
     (ALL (I$1)
      (IMPLIES (AND (>= I$1 1) (>= (+ 1 (LENGTH (TAIL S))) I$1))
       (= (NTH S I$1) (NTH T I$1)))))))
  (IMPLIES (AND (IS-SEQUENCE S) (= T (EMPTY))) (NOT (= (LENGTH S) 0))))
 (IMPLIES (AND (NOT (= S T)) (= S (EMPTY)) (IS-SEQUENCE T))
  (NOT (= 0 (LENGTH T)))))
Starting case 2 ...
(IMPLIES (IS-TACK S)
 (IF (IS-TACK T)
  (IF (= (TAIL S) (TAIL T))
   (IMPLIES (AND (NOT (= S T)) (IS-SEQUENCE (TAIL S)))
    (NOT
     (ALL (I)
      (IMPLIES (AND (>= I 1) (>= (+ 1 (LENGTH (TAIL S))) I))
       (= (NTH S I) (NTH T I))))))
   (IMPLIES
    (AND (IS-SEQUENCE (TAIL S)) (IS-SEQUENCE (TAIL T))
     (= (LENGTH (TAIL S)) (LENGTH (TAIL T)))
     (NOT
      (ALL (I$0)
       (IMPLIES (AND (>= I$0 1) (>= (LENGTH (TAIL S)) I$0))
        (= (NTH (TAIL S) I$0) (NTH (TAIL T) I$0))))))
    (NOT
     (ALL (I$1)
      (IMPLIES (AND (>= I$1 1) (>= (+ 1 (LENGTH (TAIL S))) I$1))
       (= (NTH S I$1) (NTH T I$1)))))))
  (IMPLIES (AND (IS-SEQUENCE S) (= T (EMPTY))) (NOT (= (LENGTH S) 0)))))
Starting case 2.2 ...
(IMPLIES (AND (IS-TACK S) (IS-TACK T))
 (IF (= (TAIL S) (TAIL T))
  (IMPLIES (AND (NOT (= S T)) (IS-SEQUENCE (TAIL S)))
   (NOT
    (ALL (I)
     (IMPLIES (AND (>= I 1) (>= (+ 1 (LENGTH (TAIL S))) I))
      (= (NTH S I) (NTH T I))))))
  (IMPLIES
   (AND (IS-SEQUENCE (TAIL S)) (IS-SEQUENCE (TAIL T))
    (= (LENGTH (TAIL S)) (LENGTH (TAIL T)))
    (NOT
     (ALL (I$0)
      (IMPLIES (AND (>= I$0 1) (>= (LENGTH (TAIL S)) I$0))
       (= (NTH (TAIL S) I$0) (NTH (TAIL T) I$0))))))
   (NOT
    (ALL (I$1)
     (IMPLIES (AND (>= I$1 1) (>= (+ 1 (LENGTH (TAIL S))) I$1))
      (= (NTH S I$1) (NTH T I$1))))))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (IS-TACK S) (IS-TACK T) (= (TAIL S) (TAIL T)) (NOT (= S T))
  (IS-SEQUENCE (TAIL S)))
 (NOT
  (ALL (I)
   (IMPLIES (AND (>= I 1) (>= (+ 1 (LENGTH (TAIL S))) I))
    (= (NTH S I) (NTH T I))))))
Instantiating (= I 1) gives ...
(IMPLIES
 (AND (IS-TACK S) (IS-TACK T) (= (TAIL S) (TAIL T)) (NOT (= S T))
  (IS-SEQUENCE (TAIL S)))
 (NOT
  (AND
   (IMPLIES (AND (>= 1 1) (>= (+ 1 (LENGTH (TAIL S))) 1))
    (= (NTH S 1) (NTH T 1)))
   (ALL (I)
    (IMPLIES (AND (>= I 1) (>= (+ 1 (LENGTH (TAIL S))) I))
     (= (NTH S I) (NTH T I)))))))
Which simplifies
 with invocation of NTH
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (IS-TACK S) (IS-TACK T) (NOT (= (TAIL S) (TAIL T)))
  (IS-SEQUENCE (TAIL S)) (IS-SEQUENCE (TAIL T))
  (= (LENGTH (TAIL S)) (LENGTH (TAIL T)))
  (NOT
   (ALL (I$0)
    (IMPLIES (AND (>= I$0 1) (>= (LENGTH (TAIL S)) I$0))
     (= (NTH (TAIL S) I$0) (NTH (TAIL T) I$0))))))
 (NOT
  (ALL (I$1)
   (IMPLIES (AND (>= I$1 1) (>= (+ 1 (LENGTH (TAIL S))) I$1))
    (= (NTH S I$1) (NTH T I$1))))))
Instantiating (= I$1 (+ 1 I$0)) gives ...
(IMPLIES
 (AND (IS-TACK S) (IS-TACK T) (NOT (= (TAIL S) (TAIL T)))
  (IS-SEQUENCE (TAIL S)) (IS-SEQUENCE (TAIL T))
  (= (LENGTH (TAIL S)) (LENGTH (TAIL T)))
  (NOT
   (IMPLIES (AND (>= I 1) (>= (LENGTH (TAIL S)) I))
    (= (NTH (TAIL S) I) (NTH (TAIL T) I)))))
 (NOT
  (AND
   (IMPLIES (AND (>= (+ 1 I) 1) (>= (+ 1 (LENGTH (TAIL S))) (+ 1 I)))
    (= (NTH S (+ 1 I)) (NTH T (+ 1 I))))
   (ALL (I$0)
    (IMPLIES (AND (>= I$0 1) (>= (+ 1 (LENGTH (TAIL S))) I$0))
     (= (NTH S I$0) (NTH T I$0)))))))
Which simplifies
 with invocation of NTH
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES (AND (IS-TACK S) (NOT (IS-TACK T)) (IS-SEQUENCE S) (= T (EMPTY)))
 (NOT (= (LENGTH S) 0)))
Invoking (LENGTH S) gives ...
(IMPLIES (AND (IS-TACK S) (NOT (IS-TACK T)) (IS-SEQUENCE S) (= T (EMPTY)))
 (NOT (= (IF (IS-TACK S) (+ 1 (LENGTH (TAIL S))) 0) 0)))
Which simplifies
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions LENGTH-NON-NEGATIVE, EMPTYP-EMPTY, IS-SEQUENCE-EMPTY,
TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (NOT (IS-TACK S)) (NOT (= S T)) (= S (EMPTY)) (IS-SEQUENCE T))
 (NOT (= 0 (LENGTH T))))
Invoking (LENGTH T) gives ...
(IMPLIES (AND (NOT (IS-TACK S)) (NOT (= S T)) (= S (EMPTY)) (IS-SEQUENCE T))
 (NOT (= 0 (IF (IS-TACK T) (+ 1 (LENGTH (TAIL T))) 0))))
Which simplifies
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions LENGTH-NON-NEGATIVE, EMPTYP-EMPTY, IS-SEQUENCE-EMPTY,
TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
TACKALL
IN-TACKALL
Beginning proof of IN-TACKALL ...
(= (IN E (TACKALL X S)) (AND (IS-TACK E) (IN (HEAD E) X) (IN (TAIL E) S)))
Splitting on (AND (IS-TACK E) (AND (IN (HEAD E) X) (IN (TAIL E) S))) generates
...
(IF (AND (IS-TACK E) (IN (HEAD E) X) (IN (TAIL E) S))
 (= (IN E (TACKALL X S)) (AND (IS-TACK E) (IN (HEAD E) X) (IN (TAIL E) S)))
 (= (IN E (TACKALL X S)) (AND (IS-TACK E) (IN (HEAD E) X) (IN (TAIL E) S))))
Which simplifies
 when rewriting with TACKALL.DEFINITION
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions IS-TACK-TACK, HEAD-TACK, TAIL-TACK, IS-SEQUENCE-TACK,
TYPE-OF-IS-TACK to ...
(TRUE)
N-SEQUENCE-OF
Beginning proof of N-SEQUENCE-OF ...
(IF (>= N 1) (M< (- N 1) N) (TRUE))
Which simplifies
 when rewriting with M<.NAT
 forward chaining using >=.SAME.TYPE
 with the assumptions SUCC.INT to ...
(TRUE)
N-SEQUENCE-OF-SETS
IN-N-SEQUENCE-OF-SETS
Beginning proof of IN-N-SEQUENCE-OF-SETS ...
(= (IN S (N-SEQUENCE-OF-SETS X))
 (SOME (N) (AND (IN N (INT)) (= S (N-SEQUENCE-OF N X)))))
Splitting on (SOME (N) (AND (IN N (INT)) (= S (N-SEQUENCE-OF N X)))) generates
...
(IF (SOME (N) (AND (IN N (INT)) (= S (N-SEQUENCE-OF N X))))
 (= (IN S (N-SEQUENCE-OF-SETS X))
  (SOME (N$0) (AND (IN N$0 (INT)) (= S (N-SEQUENCE-OF N$0 X)))))
 (= (IN S (N-SEQUENCE-OF-SETS X))
  (SOME (N$1) (AND (IN N$1 (INT)) (= S (N-SEQUENCE-OF N$1 X))))))
Which simplifies
 when rewriting with N-SEQUENCE-OF-SETS.DEFINITION
 with the instantiation (= N N$1) to ...
(TRUE)
SEQUENCE-OF
IS-SEQUENCE-OF
Beginning proof of IS-SEQUENCE-OF ...
(IF (IS-TACK S) (M< (LENGTH (TAIL S)) (LENGTH S)) (TRUE))
Which simplifies
 with invocation of LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, LENGTH-NON-NEGATIVE, TYPE-OF-IS-TACK to ...
(TRUE)
FACT-1
Beginning proof of FACT-1 ...
(IMPLIES (IS-SEQUENCE-OF S X) (IN S (N-SEQUENCE-OF (LENGTH S) X)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S)
   (IMPLIES (IS-SEQUENCE-OF (TAIL S) X)
    (IN (TAIL S) (N-SEQUENCE-OF (LENGTH (TAIL S)) X))))
  (IMPLIES (IS-SEQUENCE-OF S X) (IN S (N-SEQUENCE-OF (LENGTH S) X))))
 (IMPLIES (NOT (IS-TACK S))
  (IMPLIES (IS-SEQUENCE-OF S X) (IN S (N-SEQUENCE-OF (LENGTH S) X)))))
Which simplifies
 with invocation of N-SEQUENCE-OF, LENGTH, IS-SEQUENCE-OF
 when rewriting with SETADD.DEFINITION, SETRULES!UNIT-TO-SETADD, IN-TACKALL
 forward chaining using >=.SAME.TYPE, SIZE-TACK, TACK-HEAD-TAIL,
NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, LENGTH-NON-NEGATIVE,
TYPE-OF-IS-TACK to ...
(TRUE)
INDUCTION-SCHEME-FOR-NAT-AND-SEQ
Beginning proof of INDUCTION-SCHEME-FOR-NAT-AND-SEQ ...
(IF (>= N 1) (M< (- N 1) N) (TRUE))
Which simplifies
 when rewriting with M<.NAT
 forward chaining using >=.SAME.TYPE
 with the assumptions SUCC.INT to ...
(TRUE)
FACT-2
Beginning proof of FACT-2 ...
(IMPLIES (IN S (N-SEQUENCE-OF N X)) (IS-SEQUENCE-OF S X))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (>= N 1) (*P* (- N 1) (TAIL S) X)) (*P* N S X))
  (IMPLIES (NOT (>= N 1)) (*P* N S X)))
 produces ...
(AND
 (IMPLIES
  (AND (>= N 1)
   (IMPLIES (IN (TAIL S) (N-SEQUENCE-OF (- N 1) X))
    (IS-SEQUENCE-OF (TAIL S) X)))
  (IMPLIES (IN S (N-SEQUENCE-OF N X)) (IS-SEQUENCE-OF S X)))
 (IMPLIES (NOT (>= N 1))
  (IMPLIES (IN S (N-SEQUENCE-OF N X)) (IS-SEQUENCE-OF S X))))
Which simplifies
 with invocation of IS-SEQUENCE-OF, N-SEQUENCE-OF
 when rewriting with NULLSET.DEFINITION, SETADD.DEFINITION,
SETRULES!UNIT-TO-SETADD, IN-TACKALL
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS,
>=.SAME.TYPE
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
FACT-3
Beginning proof of FACT-3 ...
(= (IN S (SEQUENCE-OF X)) (IS-SEQUENCE-OF S X))
Assuming FACT-1 with the instantiations: (= X X) (= S S) generates ...
(IMPLIES (IMPLIES (IS-SEQUENCE-OF S X) (IN S (N-SEQUENCE-OF (LENGTH S) X)))
 (= (IN S (SEQUENCE-OF X)) (IS-SEQUENCE-OF S X)))
Which simplifies
 with invocation of SEQUENCE-OF
 when rewriting with IN-N-SEQUENCE-OF-SETS, CUP.DEFINITION
 forward chaining using >=.SAME.TYPE
 with the assumptions LENGTH-NON-NEGATIVE to ...
(IF (IS-SEQUENCE-OF S X)
 (IMPLIES (IN S (N-SEQUENCE-OF (LENGTH S) X))
  (= (SOME (N) (AND (IN S (N-SEQUENCE-OF N X)) (IN N (INT)))) (TRUE)))
 (= (SOME (N$0) (AND (IN S (N-SEQUENCE-OF N$0 X)) (IN N$0 (INT)))) (FALSE)))
Prenexing produces ...
(IF (IS-SEQUENCE-OF S X)
 (IMPLIES (IN S (N-SEQUENCE-OF (LENGTH S) X))
  (SOME (N$0) (AND (IN S (N-SEQUENCE-OF N$0 X)) (IN N$0 (INT)))))
 (NOT (AND (IN S (N-SEQUENCE-OF N X)) (IN N (INT)))))
Assuming FACT-2 with the instantiations: (= X X) (= S S) (= N N) generates ...
(IMPLIES (IMPLIES (IN S (N-SEQUENCE-OF N X)) (IS-SEQUENCE-OF S X))
 (IF (IS-SEQUENCE-OF S X)
  (IMPLIES (IN S (N-SEQUENCE-OF (LENGTH S) X))
   (SOME (N$0) (AND (IN S (N-SEQUENCE-OF N$0 X)) (IN N$0 (INT)))))
  (NOT (AND (IN S (N-SEQUENCE-OF N X)) (IN N (INT))))))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions LENGTH-NON-NEGATIVE to ...
(IMPLIES (AND (IS-SEQUENCE-OF S X) (IN S (N-SEQUENCE-OF (LENGTH S) X)))
 (SOME (N) (AND (IN S (N-SEQUENCE-OF N X)) (IN N (INT)))))
Instantiating (= N (LENGTH S)) gives ...
(IMPLIES
 (AND (IS-SEQUENCE-OF S X) (IN S (N-SEQUENCE-OF (LENGTH S) X))
  (NOT (AND (IN S (N-SEQUENCE-OF (LENGTH S) X)) (IN (LENGTH S) (INT)))))
 (SOME (N) (AND (IN S (N-SEQUENCE-OF N X)) (IN N (INT)))))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions LENGTH-NON-NEGATIVE to ...
(TRUE)
IN-SEQUENCE-OF
Beginning proof of IN-SEQUENCE-OF ...
(= (IN S (SEQUENCE-OF X)) (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X)))
Splitting on (IN S (SEQUENCE-OF X)) generates ...
(IF (IN S (SEQUENCE-OF X))
 (= (IN S (SEQUENCE-OF X)) (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X)))
 (= (IN S (SEQUENCE-OF X)) (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X))))
Which simplifies
 when rewriting with FACT-3 to ...
(IF (IS-SEQUENCE-OF S X) (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X))
 (IMPLIES (IS-SEQUENCE S) (NOT (SUBSET (MEMBERS S) X))))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (IS-TACK S) (*P* (TAIL S) X)) (*P* S X))
  (IMPLIES (NOT (IS-TACK S)) (*P* S X)))
 produces ...
(AND
 (IMPLIES
  (AND (IS-TACK S)
   (IF (IS-SEQUENCE-OF (TAIL S) X)
    (AND (IS-SEQUENCE (TAIL S)) (SUBSET (MEMBERS (TAIL S)) X))
    (IMPLIES (IS-SEQUENCE (TAIL S)) (NOT (SUBSET (MEMBERS (TAIL S)) X)))))
  (IF (IS-SEQUENCE-OF S X) (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X))
   (IMPLIES (IS-SEQUENCE S) (NOT (SUBSET (MEMBERS S) X)))))
 (IMPLIES (NOT (IS-TACK S))
  (IF (IS-SEQUENCE-OF S X) (AND (IS-SEQUENCE S) (SUBSET (MEMBERS S) X))
   (IMPLIES (IS-SEQUENCE S) (NOT (SUBSET (MEMBERS S) X))))))
Which simplifies
 with invocation of MEMBERS, IS-SEQUENCE, IS-SEQUENCE-OF
 when rewriting with SUBSET.NULLSET.LEFT, SETRULES!SUBSET-SETADD
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions EMPTYP-EMPTY, IS-SEQUENCE-EMPTY, TYPE-OF-IS-TACK to ...
(TRUE)
SEQUENCE-OF-MONOTONIC
Beginning proof of SEQUENCE-OF-MONOTONIC ...
(= (SUBSET (SEQUENCE-OF X) (SEQUENCE-OF Y)) (SUBSET X Y))
Splitting on (SUBSET X Y) generates ...
(IF (SUBSET X Y) (= (SUBSET (SEQUENCE-OF X) (SEQUENCE-OF Y)) (SUBSET X Y))
 (= (SUBSET (SEQUENCE-OF X) (SEQUENCE-OF Y)) (SUBSET X Y)))
Which simplifies to ...
(IF (SUBSET X Y) (= (SUBSET (SEQUENCE-OF X) (SEQUENCE-OF Y)) (TRUE))
 (= (SUBSET (SEQUENCE-OF X) (SEQUENCE-OF Y)) (FALSE)))
Starting case 2 ...
(IMPLIES (SUBSET X Y) (= (SUBSET (SEQUENCE-OF X) (SEQUENCE-OF Y)) (TRUE)))
Invoking (SUBSET (SEQUENCE-OF X) (SEQUENCE-OF Y)) gives ...
(IMPLIES (SUBSET X Y)
 (ALL (E) (IMPLIES (IN E (SEQUENCE-OF X)) (IN E (SEQUENCE-OF Y)))))
Which simplifies
 when rewriting with SUBSET.TRANSITIVE, IN-SEQUENCE-OF to ...
(TRUE)
Starting case 1 ...
(IMPLIES (NOT (SUBSET X Y))
 (= (SUBSET (SEQUENCE-OF X) (SEQUENCE-OF Y)) (FALSE)))
Which simplifies
 with invocation of SUBSET
 when rewriting with IN-MEMBERS, IN-SEQUENCE-OF to ...
(OR (ALL (E) (IMPLIES (IN E X) (IN E Y)))
 (NOT
  (ALL (E$0)
   (IMPLIES
    (AND (IS-SEQUENCE E$0)
     (ALL (E$1) (IMPLIES (IS-MEMBER E$1 E$0) (IN E$1 X))))
    (ALL (E$2) (IMPLIES (IS-MEMBER E$2 E$0) (IN E$2 Y)))))))
Prenexing produces ...
(OR (IMPLIES (IN E X) (IN E Y))
 (NOT
  (ALL (E$0)
   (IMPLIES
    (AND (IS-SEQUENCE E$0)
     (ALL (E$1) (IMPLIES (IS-MEMBER E$1 E$0) (IN E$1 X))))
    (ALL (E$2) (IMPLIES (IS-MEMBER E$2 E$0) (IN E$2 Y)))))))
Instantiating (= E$0 (TACK E (EMPTY))) (= E$2 E) gives ...
(OR (IMPLIES (IN E X) (IN E Y))
 (NOT
  (AND
   (IMPLIES
    (AND (IS-SEQUENCE (TACK E (EMPTY)))
     (ALL (E$0) (IMPLIES (IS-MEMBER E$0 (TACK E (EMPTY))) (IN E$0 X)))
     (IS-MEMBER E (TACK E (EMPTY))))
    (IN E Y))
   (ALL (E$1 E$2)
    (IMPLIES
     (AND (IS-SEQUENCE E$1)
      (ALL (E$3) (IMPLIES (IS-MEMBER E$3 E$1) (IN E$3 X)))
      (IS-MEMBER E$2 E$1))
     (IN E$2 Y))))))
Which simplifies
 with invocation of IS-MEMBER
 when rewriting with IS-MEMBER-TACK
 forward chaining using SIZE-TACK, TACK-HEAD-TAIL, NOT-IS-TACK-FACTS
 with the assumptions TYPE-OF-IS-TACK, IS-TACK-TACK, HEAD-TACK, TAIL-TACK,
IS-SEQUENCE-TACK, EMPTYP-EMPTY, IS-SEQUENCE-EMPTY to ...
(TRUE)
Completing all cases produces ...
(TRUE)
Done.