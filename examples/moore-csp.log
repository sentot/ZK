
Reading "/home/sentot/zk/version1/ZK/examples/moore-csp.ver"
Warning RULE-LOOPS for FN!FUNCTION-EXTENSIONALITY:
 The rule FN!FUNCTION-EXTENSIONALITY loops upon itself.
IS-FUN
IS-FUN-FACTS
Beginning proof of IS-FUN-FACTS ...
(IMPLIES (IS-FUN F D R)
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) D) (SUBSET (REL!RAN F) R)))
Which simplifies
 with invocation of SUBSET, IS-FUN
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
IN-FUN
Beginning proof of IN-FUN ...
(= (IN F (FN!FUN D R)) (IS-FUN F D R))
Invoking IS-FUN gives ...
(= (IN F (FN!FUN D R))
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) D) (SUBSET (REL!RAN F) R)))
Which simplifies
 when rewriting with FN!IN-FUN
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
APPLY-IN-NOMINAL-RANGE
Beginning proof of APPLY-IN-NOMINAL-RANGE ...
(IMPLIES (AND (IS-FUN F D R) (IN X D)) (IN (FN!APPLY F X) R))
Assuming FN!APPLY-IN-RAN with the instantiations: (= F F) (= X X) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION F) (IN X (REL!DOM F)))
   (IN (FN!APPLY F X) (REL!RAN F)))
  (IS-FUN F D R) (IN X D))
 (IN (FN!APPLY F X) R))
Which simplifies
 with invocation of SUBSET, IS-FUN
 forward chaining using IS-FUN-FACTS, FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
APPLY-IN-NOMINAL-RANGE-NAT
Beginning proof of APPLY-IN-NOMINAL-RANGE-NAT ...
(IMPLIES (AND (IS-FUN F (NAT!NAT) R) (>= X 0)) (IN (FN!APPLY F X) R))
Assuming APPLY-IN-NOMINAL-RANGE with the
instantiations: (= F F) (= D (NAT!NAT)) (= R R) (= X X) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-FUN F (NAT!NAT) R) (IN X (NAT!NAT)))
   (IN (FN!APPLY F X) R))
  (IS-FUN F (NAT!NAT) R) (>= X 0))
 (IN (FN!APPLY F X) R))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS to
...
(TRUE)
APPLY-IN-NOMINAL-RANGE-FUN
Beginning proof of APPLY-IN-NOMINAL-RANGE-FUN ...
(IMPLIES (AND (IS-FUN F D1 (FN!FUN D2 R)) (IN X D1))
 (IS-FUN (FN!APPLY F X) D2 R))
Assuming APPLY-IN-NOMINAL-RANGE with the
instantiations: (= F F) (= D D1) (= R (FN!FUN D2 R)) (= X X) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-FUN F D1 (FN!FUN D2 R)) (IN X D1))
   (IN (FN!APPLY F X) (FN!FUN D2 R)))
  (IS-FUN F D1 (FN!FUN D2 R)) (IN X D1))
 (IS-FUN (FN!APPLY F X) D2 R))
Applying IN-FUN gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-FUN F D1 (FN!FUN D2 R)) (IN X D1))
   (IS-FUN (FN!APPLY F X) D2 R))
  (IS-FUN F D1 (FN!FUN D2 R)) (IN X D1))
 (IS-FUN (FN!APPLY F X) D2 R))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE to ...
(TRUE)
APPLY-IN-NOMINAL-RANGE-FUN-NAT
Beginning proof of APPLY-IN-NOMINAL-RANGE-FUN-NAT ...
(IMPLIES (AND (IS-FUN F (NAT!NAT) (FN!FUN D R)) (>= X 0))
 (IS-FUN (FN!APPLY F X) D R))
Assuming APPLY-IN-NOMINAL-RANGE-FUN with the
instantiations: (= F F) (= D1 (NAT!NAT)) (= D2 D) (= R R) generates ...
(IMPLIES
 (AND
  (ALL (X$0)
   (IMPLIES (AND (IS-FUN F (NAT!NAT) (FN!FUN D R)) (IN X$0 (NAT!NAT)))
    (IS-FUN (FN!APPLY F X$0) D R)))
  (IS-FUN F (NAT!NAT) (FN!FUN D R)) (>= X 0))
 (IS-FUN (FN!APPLY F X) D R))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT
 with the instantiation (= X$0 X) to ...
(TRUE)
IS-FUN-COMPOSITION
Beginning proof of IS-FUN-COMPOSITION ...
(IMPLIES (AND (IS-FUN F X Y) (IS-FUN G Y Z)) (IS-FUN (REL!COMP F G) X Z))
Invoking IS-FUN gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) X) (SUBSET (REL!RAN F) Y)
  (FN!IS-FUNCTION G) (= (REL!DOM G) Y) (SUBSET (REL!RAN G) Z))
 (AND (FN!IS-FUNCTION (REL!COMP F G)) (= (REL!DOM (REL!COMP F G)) X)
  (SUBSET (REL!RAN (REL!COMP F G)) Z)))
Which simplifies
 when rewriting with REL!RAN-COMP, REL!RAN-INVERSE,
REL!IMAGE-OF-SUPERSET-OF-DOM, REL!DOM-INVERSE, REL!DOM-COMP,
FN!IS-FUNCTION-COMP-FUNCTIONS
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions REL!INVERSE-INVERSE, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) X) (SUBSET (REL!RAN F) Y)
  (FN!IS-FUNCTION G) (= (REL!DOM G) Y) (SUBSET (REL!RAN G) Z))
 (SUBSET (REL!IMAGE G (REL!RAN F)) Z))
Assuming REL!IMAGE-SUBSET-RAN with the
instantiations: (= R G) (= X (REL!RAN F)) generates ...
(IMPLIES
 (AND (SUBSET (REL!IMAGE G (REL!RAN F)) (REL!RAN G)) (FN!IS-FUNCTION F)
  (= (REL!DOM F) X) (SUBSET (REL!RAN F) Y) (FN!IS-FUNCTION G)
  (= (REL!DOM G) Y) (SUBSET (REL!RAN G) Z))
 (SUBSET (REL!IMAGE G (REL!RAN F)) Z))
Which simplifies
 when rewriting with SUBSET.TRANSITIVE
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-FUN-SUBGOAL
Beginning proof of IS-FUN-SUBGOAL ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) X)
  (ALL (Z) (IMPLIES (IN Z X) (IN (FN!APPLY F Z) Y))))
 (= (IS-FUN F X Y) (TRUE)))
Invoking IS-FUN gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) X)
  (ALL (Z) (IMPLIES (IN Z X) (IN (FN!APPLY F Z) Y))))
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) X) (SUBSET (REL!RAN F) Y)))
Which simplifies
 with invocation of SUBSET
 when rewriting with FN!IN-RAN-FUNCTION
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
RELATED
RELATED-NULLSET
Beginning proof of RELATED-NULLSET ...
(= (RELATED X (NULLSET) Y) (FALSE))
Which simplifies
 with invocation of RELATED
 when rewriting with NULLSET.DEFINITION
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
RELATED-ID
Beginning proof of RELATED-ID ...
(= (RELATED X (REL!ID S) Y) (AND (IN X S) (= X Y)))
Which simplifies
 with invocation of RELATED
 when rewriting with REL!IN-ID
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR to ...
(TRUE)
RELATED-INVERSE
Beginning proof of RELATED-INVERSE ...
(= (RELATED X (REL!INVERSE R) Y) (RELATED Y R X))
Which simplifies
 with invocation of RELATED
 when rewriting with REL!FLIP-PAIR-PAIR, REL!IN-INVERSE
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions REL!FLIP-PAIR-IS-INVOLUTION, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, REL!INVERSE-INVERSE to ...
(TRUE)
RELATED-COMP
Beginning proof of RELATED-COMP ...
(= (RELATED X (REL!COMP R S) Z)
 (SOME (Y) (AND (RELATED X R Y) (RELATED Y S Z))))
Splitting on (RELATED X (REL!COMP R S) Z) generates ...
(IF (RELATED X (REL!COMP R S) Z)
 (= (RELATED X (REL!COMP R S) Z)
  (SOME (Y) (AND (RELATED X R Y) (RELATED Y S Z))))
 (= (RELATED X (REL!COMP R S) Z)
  (SOME (Y$0) (AND (RELATED X R Y$0) (RELATED Y$0 S Z)))))
Which simplifies to ...
(IF (RELATED X (REL!COMP R S) Z)
 (= (TRUE) (SOME (Y) (AND (RELATED X R Y) (RELATED Y S Z))))
 (= (FALSE) (SOME (Y$0) (AND (RELATED X R Y$0) (RELATED Y$0 S Z)))))
Which simplifies
 with invocation of RELATED
 when rewriting with REL!IN-COMP
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR to ...
(TRUE)
RELATED-DOM-RAN
Beginning proof of RELATED-DOM-RAN ...
(IMPLIES (RELATED X R Y) (AND (IN X (REL!DOM R)) (IN Y (REL!RAN R))))
Which simplifies
 with invocation of RELATED
 when rewriting with REL!IN-RAN-1, REL!IN-DOM-1
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
IS-TRANSITIVE
TRANSITIVE
Beginning proof of TRANSITIVE ...
(IMPLIES (AND (IS-TRANSITIVE R) (RELATED X R Y) (RELATED Y R Z))
 (RELATED X R Z))
Which simplifies
 with invocation of IS-TRANSITIVE
 forward chaining using RELATED-DOM-RAN to ...
(TRUE)
IS-TRANSITIVE-INVERSE
Beginning proof of IS-TRANSITIVE-INVERSE ...
(= (IS-TRANSITIVE (REL!INVERSE R)) (IS-TRANSITIVE R))
Splitting on (IS-TRANSITIVE R) generates ...
(IF (IS-TRANSITIVE R) (= (IS-TRANSITIVE (REL!INVERSE R)) (IS-TRANSITIVE R))
 (= (IS-TRANSITIVE (REL!INVERSE R)) (IS-TRANSITIVE R)))
Which simplifies
 with the assumptions REL!INVERSE-INVERSE to ...
(IF (IS-TRANSITIVE R) (= (IS-TRANSITIVE (REL!INVERSE R)) (TRUE))
 (= (IS-TRANSITIVE (REL!INVERSE R)) (FALSE)))
Which simplifies
 with invocation of IS-TRANSITIVE
 when rewriting with RELATED-INVERSE
 forward chaining using RELATED-DOM-RAN
 with the assumptions REL!INVERSE-INVERSE to ...
(OR
 (ALL (X Y Z) (IMPLIES (AND (RELATED X R Y) (RELATED Y R Z)) (RELATED X R Z)))
 (=
  (ALL (X$0 Y$0 Z$0)
   (IMPLIES (AND (RELATED Y$0 R X$0) (RELATED Z$0 R Y$0))
    (RELATED Z$0 R X$0)))
  (FALSE)))
Instantiating (= X$0 Z) (= Y$0 Y) (= Z$0 X) gives ...
(OR (IMPLIES (AND (RELATED X R Y) (RELATED Y R Z)) (RELATED X R Z))
 (NOT
  (AND (IMPLIES (AND (RELATED Y R Z) (RELATED X R Y)) (RELATED X R Z))
   (ALL (X$0 Y$0 Z$0)
    (IMPLIES (AND (RELATED Y$0 R X$0) (RELATED Z$0 R Y$0))
     (RELATED Z$0 R X$0))))))
Which simplifies
 forward chaining using RELATED-DOM-RAN to ...
(TRUE)
IS-PO
IS-PO-BASIC
Beginning proof of IS-PO-BASIC ...
(IMPLIES (IS-PO R)
 (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!RAN R) (REL!DOM R))))
Invoking IS-PO gives ...
(IMPLIES
 (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
  (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))))
 (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!RAN R) (REL!DOM R))))
Which simplifies
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, REL!INVERSE-INVERSE, REL!IS-RELATION-BOOL to
...
(TRUE)
IS-PO-INVERSE
Beginning proof of IS-PO-INVERSE ...
(= (IS-PO (REL!INVERSE R)) (IS-PO R))
Which simplifies
 with invocation of IS-PO
 when rewriting with INTER.COMMUTATIVE, REL!RAN-INVERSE, REL!DOM-INVERSE,
IS-TRANSITIVE-INVERSE, REL!IS-RELATION-INVERSE
 forward chaining using IS-PO-BASIC
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, REL!IS-RELATION-BOOL, REL!INVERSE-INVERSE to
...
(TRUE)
RELATED-PO-SELF
Beginning proof of RELATED-PO-SELF ...
(IMPLIES (IS-PO R) (= (RELATED X R X) (IN X (REL!DOM R))))
Which simplifies
 with invocation of RELATED, IS-PO
 forward chaining using PAIR!PAIR-COMPOSITION, RELATED-DOM-RAN, IS-PO-BASIC
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
REL!INVERSE-INVERSE, REL!IS-RELATION-BOOL to ...
(IMPLIES
 (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
  (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))))
 (= (IN (PAIR!PAIR X X) R) (IN X (REL!DOM R))))
Splitting on (SUBSET (REL!ID (REL!DOM R)) R) generates ...
(IF (SUBSET (REL!ID (REL!DOM R)) R)
 (IMPLIES
  (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
   (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))))
  (= (IN (PAIR!PAIR X X) R) (IN X (REL!DOM R))))
 (IMPLIES
  (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
   (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))))
  (= (IN (PAIR!PAIR X X) R) (IN X (REL!DOM R)))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
REL!INVERSE-INVERSE, REL!IS-RELATION-BOOL to ...
(IMPLIES
 (AND (SUBSET (REL!ID (REL!DOM R)) R) (REL!IS-RELATION R) (IS-TRANSITIVE R)
  (= (REL!DOM R) (REL!RAN R))
  (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))))
 (= (IN (PAIR!PAIR X X) R) (IN X (REL!DOM R))))
Invoking SUBSET gives ...
(IMPLIES
 (AND (ALL (E) (IMPLIES (IN E (REL!ID (REL!DOM R))) (IN E R)))
  (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
  (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))))
 (= (IN (PAIR!PAIR X X) R) (IN X (REL!DOM R))))
Instantiating (= E (PAIR!PAIR X X)) gives ...
(IMPLIES
 (AND
  (IMPLIES (IN (PAIR!PAIR X X) (REL!ID (REL!DOM R))) (IN (PAIR!PAIR X X) R))
  (ALL (E) (IMPLIES (IN E (REL!ID (REL!DOM R))) (IN E R))) (REL!IS-RELATION R)
  (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
  (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))))
 (= (IN (PAIR!PAIR X X) R) (IN X (REL!DOM R))))
Which simplifies
 when rewriting with REL!IN-DOM-1, REL!IN-DOM, REL!IN-ID
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, REL!INVERSE-INVERSE, REL!IS-RELATION-BOOL,
PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
PO-TRANSITIVE
Beginning proof of PO-TRANSITIVE ...
(IMPLIES (AND (IS-PO R) (RELATED X R Y) (RELATED Y R Z)) (RELATED X R Z))
Invoking IS-PO gives ...
(IMPLIES
 (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
  (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))) (RELATED X R Y)
  (RELATED Y R Z))
 (RELATED X R Z))
Assuming TRANSITIVE with the
instantiations: (= R R) (= X X) (= Y Y) (= Z Z) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-TRANSITIVE R) (RELATED X R Y) (RELATED Y R Z))
   (RELATED X R Z))
  (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
  (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))) (RELATED X R Y)
  (RELATED Y R Z))
 (RELATED X R Z))
Which simplifies
 forward chaining using RELATED-DOM-RAN
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, REL!INVERSE-INVERSE, REL!IS-RELATION-BOOL to
...
(TRUE)
PO-ASYMMETRY
Beginning proof of PO-ASYMMETRY ...
(IMPLIES (AND (IS-PO R) (RELATED X R Y) (RELATED Y R X)) (= X Y))
Which simplifies
 with invocation of RELATED, IS-PO
 forward chaining using PAIR!PAIR-COMPOSITION, RELATED-DOM-RAN, IS-PO-BASIC
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
REL!INVERSE-INVERSE, REL!IS-RELATION-BOOL to ...
(IMPLIES
 (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
  (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))) (IN (PAIR!PAIR X Y) R)
  (IN (PAIR!PAIR Y X) R))
 (= X Y))
Applying SETRULES!EXTENSIONALITY to
 (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))) gives ...
(IMPLIES
 (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
  (ALL (E)
   (IF (IN E (INTER R (REL!INVERSE R))) (IN E (REL!ID (REL!DOM R)))
    (NOT (IN E (REL!ID (REL!DOM R))))))
  (IN (PAIR!PAIR X Y) R) (IN (PAIR!PAIR Y X) R))
 (= X Y))
Instantiating (= E (PAIR!PAIR X Y)) gives ...
(IMPLIES
 (AND (REL!IS-RELATION R) (IS-TRANSITIVE R) (= (REL!DOM R) (REL!RAN R))
  (IF (IN (PAIR!PAIR X Y) (INTER R (REL!INVERSE R)))
   (IN (PAIR!PAIR X Y) (REL!ID (REL!DOM R)))
   (NOT (IN (PAIR!PAIR X Y) (REL!ID (REL!DOM R)))))
  (ALL (E)
   (IF (IN E (INTER R (REL!INVERSE R))) (IN E (REL!ID (REL!DOM R)))
    (NOT (IN E (REL!ID (REL!DOM R))))))
  (IN (PAIR!PAIR X Y) R) (IN (PAIR!PAIR Y X) R))
 (= X Y))
Which simplifies
 when rewriting with REL!IN-DOM-1, REL!IN-ID, REL!FLIP-PAIR-PAIR,
REL!IN-INVERSE, INTER.DEFINITION
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, REL!FLIP-PAIR-IS-INVOLUTION,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
REL!INVERSE-INVERSE, PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
REL!IS-RELATION-BOOL to ...
(TRUE)
IS-BOTTOM
IS-BOTTOM-IMPLIES-IN-DOM
Beginning proof of IS-BOTTOM-IMPLIES-IN-DOM ...
(IMPLIES (IS-BOTTOM B R) (IN B (REL!DOM R)))
Invoking IS-BOTTOM gives ...
(IMPLIES
 (AND (IN B (REL!DOM R))
  (ALL (X) (IMPLIES (IN X (REL!DOM R)) (RELATED B R X))))
 (IN B (REL!DOM R)))
Which simplifies
 forward chaining using RELATED-DOM-RAN to ...
(TRUE)
HAS-BOTTOM
BOTTOM-UNIQUE
Beginning proof of BOTTOM-UNIQUE ...
(IMPLIES (AND (IS-PO R) (IS-BOTTOM B1 R) (IS-BOTTOM B2 R)) (= B1 B2))
Invoking IS-BOTTOM gives ...
(IMPLIES
 (AND (IS-PO R) (IN B1 (REL!DOM R))
  (ALL (X) (IMPLIES (IN X (REL!DOM R)) (RELATED B1 R X))) (IN B2 (REL!DOM R))
  (ALL (X$0) (IMPLIES (IN X$0 (REL!DOM R)) (RELATED B2 R X$0))))
 (= B1 B2))
Assuming PO-ASYMMETRY with the
instantiations: (= R R) (= X B1) (= Y B2) generates ...
(IMPLIES
 (AND (IMPLIES (AND (IS-PO R) (RELATED B1 R B2) (RELATED B2 R B1)) (= B1 B2))
  (IS-PO R) (IN B1 (REL!DOM R))
  (ALL (X) (IMPLIES (IN X (REL!DOM R)) (RELATED B1 R X))) (IN B2 (REL!DOM R))
  (ALL (X$0) (IMPLIES (IN X$0 (REL!DOM R)) (RELATED B2 R X$0))))
 (= B1 B2))
Which simplifies
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC
 with the instantiation (= X$0 B1) to ...
(IMPLIES
 (AND (IS-PO R) (NOT (RELATED B1 R B2)) (IN B1 (REL!DOM R))
  (ALL (X) (IMPLIES (IN X (REL!DOM R)) (RELATED B1 R X))) (IN B2 (REL!DOM R))
  (ALL (X$0) (IMPLIES (IN X$0 (REL!DOM R)) (RELATED B2 R X$0))))
 (= B1 B2))
Instantiating (= X B2) gives ...
(IMPLIES
 (AND (IS-PO R) (NOT (RELATED B1 R B2)) (IN B1 (REL!DOM R))
  (IMPLIES (IN B2 (REL!DOM R)) (RELATED B1 R B2))
  (ALL (X) (IMPLIES (IN X (REL!DOM R)) (RELATED B1 R X))) (IN B2 (REL!DOM R))
  (ALL (X$0) (IMPLIES (IN X$0 (REL!DOM R)) (RELATED B2 R X$0))))
 (= B1 B2))
Which simplifies
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC to ...
(TRUE)
BOTTOM
Beginning proof of BOTTOM ...
(SOME (X)
 (ALL (X-0)
  (= (IF (AND (IS-PO R) (HAS-BOTTOM R)) (IS-BOTTOM X-0 R) (= X-0 0))
   (= X-0 X))))
Instantiating (= X 0) gives ...
(OR
 (ALL (X-0)
  (= (IF (AND (IS-PO R) (HAS-BOTTOM R)) (IS-BOTTOM X-0 R) (= X-0 0))
   (= X-0 0)))
 (SOME (X)
  (ALL (X-0$0)
   (= (IF (AND (IS-PO R) (HAS-BOTTOM R)) (IS-BOTTOM X-0$0 R) (= X-0$0 0))
    (= X-0$0 X)))))
Which simplifies
 forward chaining using IS-BOTTOM-IMPLIES-IN-DOM, IS-PO-BASIC to ...
(IMPLIES
 (AND (IS-PO R) (HAS-BOTTOM R)
  (NOT (ALL (X-0) (= (IS-BOTTOM X-0 R) (= X-0 0)))))
 (SOME (X) (ALL (X-0$0) (= (IS-BOTTOM X-0$0 R) (= X-0$0 X)))))
Invoking HAS-BOTTOM gives ...
(IMPLIES
 (AND (IS-PO R) (SOME (B) (IS-BOTTOM B R))
  (NOT (ALL (X-0) (= (IS-BOTTOM X-0 R) (= X-0 0)))))
 (SOME (X) (ALL (X-0$0) (= (IS-BOTTOM X-0$0 R) (= X-0$0 X)))))
Instantiating (= X B) gives ...
(IMPLIES
 (AND (IS-PO R) (IS-BOTTOM B R)
  (NOT (ALL (X-0) (= (IS-BOTTOM X-0 R) (= X-0 0))))
  (NOT (ALL (X-0$0) (= (IS-BOTTOM X-0$0 R) (= X-0$0 B)))))
 (SOME (X) (ALL (X-0$1) (= (IS-BOTTOM X-0$1 R) (= X-0$1 X)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-PO R) (IS-BOTTOM B R) (NOT (= (IS-BOTTOM X-0 R) (= X-0 0)))
  (NOT (= (IS-BOTTOM X-0$0 R) (= X-0$0 B))))
 (SOME (X) (ALL (X-0$1) (= (IS-BOTTOM X-0$1 R) (= X-0$1 X)))))
Assuming BOTTOM-UNIQUE with the
instantiations: (= R R) (= B1 B) (= B2 X-0$0) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PO R) (IS-BOTTOM B R) (IS-BOTTOM X-0$0 R)) (= B X-0$0))
  (IS-PO R) (IS-BOTTOM B R) (NOT (= (IS-BOTTOM X-0 R) (= X-0 0)))
  (NOT (= (IS-BOTTOM X-0$0 R) (= X-0$0 B))))
 (SOME (X) (ALL (X-0$1) (= (IS-BOTTOM X-0$1 R) (= X-0$1 X)))))
Which simplifies
 forward chaining using IS-BOTTOM-IMPLIES-IN-DOM, IS-PO-BASIC to ...
(TRUE)
BOTTOM-IS-BOTTOM
Beginning proof of BOTTOM-IS-BOTTOM ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R)) (= (IS-BOTTOM (BOTTOM R) R) (TRUE)))
Assuming BOTTOM.DEFINITION with the instantiations: (= R R) generates ...
(IMPLIES
 (AND
  (=
   (IF (AND (IS-PO R) (HAS-BOTTOM R)) (IS-BOTTOM (BOTTOM R) R)
    (= (BOTTOM R) 0))
   (TRUE))
  (IS-PO R) (HAS-BOTTOM R))
 (IS-BOTTOM (BOTTOM R) R))
Which simplifies
 forward chaining using IS-BOTTOM-IMPLIES-IN-DOM, IS-PO-BASIC to ...
(TRUE)
BOTTOM-IN-DOM
Beginning proof of BOTTOM-IN-DOM ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R)) (= (IN (BOTTOM R) (REL!DOM R)) (TRUE)))
Assuming BOTTOM.DEFINITION with the instantiations: (= R R) generates ...
(IMPLIES
 (AND
  (=
   (IF (AND (IS-PO R) (HAS-BOTTOM R)) (IS-BOTTOM (BOTTOM R) R)
    (= (BOTTOM R) 0))
   (TRUE))
  (IS-PO R) (HAS-BOTTOM R))
 (IN (BOTTOM R) (REL!DOM R)))
Invoking IS-BOTTOM gives ...
(IMPLIES
 (AND
  (IF (AND (IS-PO R) (HAS-BOTTOM R))
   (AND (IN (BOTTOM R) (REL!DOM R))
    (ALL (X) (IMPLIES (IN X (REL!DOM R)) (RELATED (BOTTOM R) R X))))
   (= (BOTTOM R) 0))
  (IS-PO R) (HAS-BOTTOM R))
 (IN (BOTTOM R) (REL!DOM R)))
Which simplifies
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC to ...
(TRUE)
BOTTOM-LESS
Beginning proof of BOTTOM-LESS ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R) (IN X (REL!DOM R)))
 (= (RELATED (BOTTOM R) R X) (TRUE)))
Assuming BOTTOM.DEFINITION with the instantiations: (= R R) generates ...
(IMPLIES
 (AND
  (=
   (IF (AND (IS-PO R) (HAS-BOTTOM R)) (IS-BOTTOM (BOTTOM R) R)
    (= (BOTTOM R) 0))
   (TRUE))
  (IS-PO R) (HAS-BOTTOM R) (IN X (REL!DOM R)))
 (RELATED (BOTTOM R) R X))
Invoking IS-BOTTOM gives ...
(IMPLIES
 (AND
  (IF (AND (IS-PO R) (HAS-BOTTOM R))
   (AND (IN (BOTTOM R) (REL!DOM R))
    (ALL (X$0) (IMPLIES (IN X$0 (REL!DOM R)) (RELATED (BOTTOM R) R X$0))))
   (= (BOTTOM R) 0))
  (IS-PO R) (HAS-BOTTOM R) (IN X (REL!DOM R)))
 (RELATED (BOTTOM R) R X))
Which simplifies
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC
 with the instantiation (= X$0 X) to ...
(TRUE)
IS-MONOTONIC
IS-MONOTONIC-FACTS
Beginning proof of IS-MONOTONIC-FACTS ...
(IMPLIES (IS-MONOTONIC F R1 R2) (IS-FUN F (REL!DOM R1) (REL!DOM R2)))
Invoking IS-MONOTONIC gives ...
(IMPLIES
 (AND (IS-FUN F (REL!DOM R1) (REL!DOM R2))
  (ALL (X Y)
   (IMPLIES (RELATED X R1 Y) (RELATED (FN!APPLY F X) R2 (FN!APPLY F Y)))))
 (IS-FUN F (REL!DOM R1) (REL!DOM R2)))
Which simplifies
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE to ...
(TRUE)
IS-MONOTONIC-FACT
Beginning proof of IS-MONOTONIC-FACT ...
(IMPLIES (AND (IS-MONOTONIC F R1 R2) (RELATED X R1 Y))
 (= (RELATED (FN!APPLY F X) R2 (FN!APPLY F Y)) (TRUE)))
Which simplifies
 with invocation of IS-MONOTONIC
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-MONOTONIC-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE to ...
(TRUE)
IS-CHAIN
CHAIN-IS-FUN
Beginning proof of CHAIN-IS-FUN ...
(IMPLIES (IS-CHAIN F R) (IS-FUN F (NAT!NAT) (REL!DOM R)))
Invoking IS-CHAIN gives ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM R))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY F N) R (FN!APPLY F (+ 1 N))))))
 (IS-FUN F (NAT!NAT) (REL!DOM R)))
Which simplifies
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE to ...
(TRUE)
DOM-CHAIN
Beginning proof of DOM-CHAIN ...
(IMPLIES (IS-CHAIN F R) (= (REL!DOM F) (NAT!NAT)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN to
...
(TRUE)
CHAIN-APPLICATIONS-RELATED-LEMMA
Beginning proof of CHAIN-APPLICATIONS-RELATED-LEMMA ...
(IMPLIES (AND (IS-CHAIN F R) (IS-PO R) (<= 0 N1) (<= 0 N2))
 (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 N2))))
Inducting using the following scheme ...
 (AND (IMPLIES (NAT!ZEROP N2) (*P* F N1 N2 R))
  (IMPLIES (AND (NOT (NAT!ZEROP N2)) (*P* F N1 (- N2 1) R)) (*P* F N1 N2 R)))
 produces ...
(AND
 (IMPLIES (NAT!ZEROP N2)
  (IMPLIES (AND (IS-CHAIN F R) (IS-PO R) (<= 0 N1) (<= 0 N2))
   (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 N2)))))
 (IMPLIES
  (AND (NOT (NAT!ZEROP N2))
   (IMPLIES (AND (IS-CHAIN F R) (IS-PO R) (<= 0 N1) (<= 0 (- N2 1)))
    (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 (- N2 1))))))
  (IMPLIES (AND (IS-CHAIN F R) (IS-PO R) (<= 0 N1) (<= 0 N2))
   (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 N2))))))
Which simplifies
 with invocation of NAT!ZEROP
 when rewriting with RELATED-PO-SELF
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, CHAIN-IS-FUN, >=.SAME.TYPE
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT to ...
(IMPLIES
 (AND (>= N2 1) (IS-CHAIN F R) (IS-PO R) (>= N1 0)
  (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ -1 N1 N2))))
 (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 N2))))
Invoking IS-CHAIN gives ...
(IMPLIES
 (AND (>= N2 1) (IS-FUN F (NAT!NAT) (REL!DOM R))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R (FN!APPLY F (+ 1 N)))))
  (IS-PO R) (>= N1 0) (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ -1 N1 N2))))
 (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 N2))))
Instantiating (= N (+ -1 (+ N1 N2))) gives ...
(IMPLIES
 (AND (>= N2 1) (IS-FUN F (NAT!NAT) (REL!DOM R))
  (IMPLIES (IN (+ -1 N1 N2) (NAT!NAT))
   (RELATED (FN!APPLY F (+ -1 N1 N2)) R (FN!APPLY F (+ 1 -1 N1 N2))))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R (FN!APPLY F (+ 1 N)))))
  (IS-PO R) (>= N1 0) (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ -1 N1 N2))))
 (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 N2))))
Assuming PO-TRANSITIVE with the
instantiations: (= R R) (= X (FN!APPLY F N1))
                (= Y (FN!APPLY F (+ -1 (+ N1 N2))))
                (= Z (FN!APPLY F (+ N1 N2))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PO R) (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ -1 N1 N2)))
    (RELATED (FN!APPLY F (+ -1 N1 N2)) R (FN!APPLY F (+ N1 N2))))
   (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 N2))))
  (>= N2 1) (IS-FUN F (NAT!NAT) (REL!DOM R))
  (IMPLIES (IN (+ -1 N1 N2) (NAT!NAT))
   (RELATED (FN!APPLY F (+ -1 N1 N2)) R (FN!APPLY F (+ 1 -1 N1 N2))))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R (FN!APPLY F (+ 1 N)))))
  (IS-PO R) (>= N1 0) (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ -1 N1 N2))))
 (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 N2))))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, >=.SAME.TYPE,
RELATED-DOM-RAN, IS-PO-BASIC
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT to ...
(TRUE)
CHAIN-APPLICATIONS-RELATED
Beginning proof of CHAIN-APPLICATIONS-RELATED ...
(IMPLIES (AND (IS-CHAIN F R) (IS-PO R) (<= 0 N1) (<= N1 N2))
 (= (RELATED (FN!APPLY F N1) R (FN!APPLY F N2)) (TRUE)))
Assuming CHAIN-APPLICATIONS-RELATED-LEMMA with the
instantiations: (= F F) (= R R) (= N1 N1) (= N2 (- N2 N1)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-CHAIN F R) (IS-PO R) (<= 0 N1) (<= 0 (- N2 N1)))
   (RELATED (FN!APPLY F N1) R (FN!APPLY F (+ N1 (- N2 N1)))))
  (IS-CHAIN F R) (IS-PO R) (>= N1 0) (>= N2 N1))
 (RELATED (FN!APPLY F N1) R (FN!APPLY F N2)))
Which simplifies
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE, IS-PO-BASIC,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT to ...
(TRUE)
IS-CHAIN-COMP
Beginning proof of IS-CHAIN-COMP ...
(IMPLIES (AND (IS-MONOTONIC G R1 R2) (IS-CHAIN F R1) (IS-PO R1))
 (= (IS-CHAIN (REL!COMP F G) R2) (TRUE)))
Invoking (IS-CHAIN (REL!COMP F G) R2) gives ...
(IMPLIES (AND (IS-MONOTONIC G R1 R2) (IS-CHAIN F R1) (IS-PO R1))
 (AND (IS-FUN (REL!COMP F G) (NAT!NAT) (REL!DOM R2))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY (REL!COMP F G) N) R2
     (FN!APPLY (REL!COMP F G) (+ 1 N)))))))
Which simplifies
 when rewriting with IS-MONOTONIC-FACT, CHAIN-APPLICATIONS-RELATED,
FN!APPLY-COMP, NAT!IN-NAT
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE, IS-PO-BASIC,
CHAIN-IS-FUN, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-MONOTONIC-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE, FN!IS-FUNCTION-BOOL,
APPLY-IN-NOMINAL-RANGE-NAT, IS-FUN-COMPOSITION to ...
(TRUE)
IS-CHAIN-BOUND
IS-CHAIN-LIMIT
CHAIN-LIMIT-UNIQUE
Beginning proof of CHAIN-LIMIT-UNIQUE ...
(IMPLIES (AND (IS-PO R) (IS-CHAIN-LIMIT F X R) (IS-CHAIN-LIMIT F Y R)) (= X Y))
Invoking IS-CHAIN-LIMIT gives ...
(IMPLIES
 (AND (IS-PO R) (IS-CHAIN-BOUND F X R)
  (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED X R B)))
  (IS-CHAIN-BOUND F Y R)
  (ALL (B$0) (IMPLIES (IS-CHAIN-BOUND F B$0 R) (RELATED Y R B$0))))
 (= X Y))
Assuming PO-ASYMMETRY with the
instantiations: (= R R) (= X X) (= Y Y) generates ...
(IMPLIES
 (AND (IMPLIES (AND (IS-PO R) (RELATED X R Y) (RELATED Y R X)) (= X Y))
  (IS-PO R) (IS-CHAIN-BOUND F X R)
  (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED X R B)))
  (IS-CHAIN-BOUND F Y R)
  (ALL (B$0) (IMPLIES (IS-CHAIN-BOUND F B$0 R) (RELATED Y R B$0))))
 (= X Y))
Rearranging gives ...
(IMPLIES
 (AND (IS-PO R) (IS-CHAIN-BOUND F X R) (IS-CHAIN-BOUND F Y R)
  (IMPLIES (AND (IS-PO R) (RELATED X R Y) (RELATED Y R X)) (= X Y))
  (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED X R B)))
  (ALL (B$0) (IMPLIES (IS-CHAIN-BOUND F B$0 R) (RELATED Y R B$0))))
 (= X Y))
Which simplifies
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC
 with the instantiations (= B$0 X) (= B Y) to ...
(TRUE)
IS-COMPLETE-PO
COMPLETE-PO-IS-PO
Beginning proof of COMPLETE-PO-IS-PO ...
(IMPLIES (IS-COMPLETE-PO R) (IS-PO R))
Invoking IS-COMPLETE-PO gives ...
(IMPLIES
 (AND (IS-PO R)
  (ALL (F) (IMPLIES (IS-CHAIN F R) (SOME (B) (IS-CHAIN-LIMIT F B R)))))
 (IS-PO R))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN,
IS-PO-BASIC to ...
(TRUE)
LIMIT
Beginning proof of LIMIT ...
(SOME (X)
 (ALL (X-0)
  (=
   (IF (AND (IS-PO R) (SOME (B) (IS-CHAIN-LIMIT F B R)))
    (IS-CHAIN-LIMIT F X-0 R) (= X-0 0))
   (= X-0 X))))
Instantiating (= X 0) gives ...
(OR
 (ALL (X-0)
  (=
   (IF (AND (IS-PO R) (SOME (B) (IS-CHAIN-LIMIT F B R)))
    (IS-CHAIN-LIMIT F X-0 R) (= X-0 0))
   (= X-0 0)))
 (SOME (X)
  (ALL (X-0$0)
   (=
    (IF (AND (IS-PO R) (SOME (B$0) (IS-CHAIN-LIMIT F B$0 R)))
     (IS-CHAIN-LIMIT F X-0$0 R) (= X-0$0 0))
    (= X-0$0 X)))))
Which simplifies
 forward chaining using IS-PO-BASIC to ...
(IMPLIES
 (AND (IS-PO R) (SOME (B) (IS-CHAIN-LIMIT F B R))
  (NOT (ALL (X-0) (= (IS-CHAIN-LIMIT F X-0 R) (= X-0 0)))))
 (SOME (X) (ALL (X-0$0) (= (IS-CHAIN-LIMIT F X-0$0 R) (= X-0$0 X)))))
Instantiating (= X B) gives ...
(IMPLIES
 (AND (IS-PO R) (IS-CHAIN-LIMIT F B R)
  (NOT (ALL (X-0) (= (IS-CHAIN-LIMIT F X-0 R) (= X-0 0))))
  (NOT (ALL (X-0$0) (= (IS-CHAIN-LIMIT F X-0$0 R) (= X-0$0 B)))))
 (SOME (X) (ALL (X-0$1) (= (IS-CHAIN-LIMIT F X-0$1 R) (= X-0$1 X)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-PO R) (IS-CHAIN-LIMIT F B R)
  (NOT (= (IS-CHAIN-LIMIT F X-0 R) (= X-0 0)))
  (NOT (= (IS-CHAIN-LIMIT F X-0$0 R) (= X-0$0 B))))
 (SOME (X) (ALL (X-0$1) (= (IS-CHAIN-LIMIT F X-0$1 R) (= X-0$1 X)))))
Assuming CHAIN-LIMIT-UNIQUE with the
instantiations: (= R R) (= F F) (= X B) (= Y X-0$0) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PO R) (IS-CHAIN-LIMIT F B R) (IS-CHAIN-LIMIT F X-0$0 R))
   (= B X-0$0))
  (IS-PO R) (IS-CHAIN-LIMIT F B R)
  (NOT (= (IS-CHAIN-LIMIT F X-0 R) (= X-0 0)))
  (NOT (= (IS-CHAIN-LIMIT F X-0$0 R) (= X-0$0 B))))
 (SOME (X) (ALL (X-0$1) (= (IS-CHAIN-LIMIT F X-0$1 R) (= X-0$1 X)))))
Which simplifies
 forward chaining using IS-PO-BASIC to ...
(TRUE)
LIMIT-IS-CHAIN-LIMIT
Beginning proof of LIMIT-IS-CHAIN-LIMIT ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
 (IS-CHAIN-LIMIT F (LIMIT F R) R))
Assuming LIMIT.DEFINITION with the instantiations: (= F F) (= R R) generates
...
(IMPLIES
 (AND
  (=
   (IF (AND (IS-PO R) (SOME (B) (IS-CHAIN-LIMIT F B R)))
    (IS-CHAIN-LIMIT F (LIMIT F R) R) (= (LIMIT F R) 0))
   (TRUE))
  (IS-COMPLETE-PO R) (IS-CHAIN F R))
 (IS-CHAIN-LIMIT F (LIMIT F R) R))
Invoking IS-COMPLETE-PO gives ...
(IMPLIES
 (AND
  (IF (AND (IS-PO R) (SOME (B) (IS-CHAIN-LIMIT F B R)))
   (IS-CHAIN-LIMIT F (LIMIT F R) R) (= (LIMIT F R) 0))
  (IS-PO R)
  (ALL (F$0)
   (IMPLIES (IS-CHAIN F$0 R) (SOME (B$0) (IS-CHAIN-LIMIT F$0 B$0 R))))
  (IS-CHAIN F R))
 (IS-CHAIN-LIMIT F (LIMIT F R) R))
Instantiating (= F$0 F) gives ...
(IMPLIES
 (AND
  (IF (AND (IS-PO R) (SOME (B) (IS-CHAIN-LIMIT F B R)))
   (IS-CHAIN-LIMIT F (LIMIT F R) R) (= (LIMIT F R) 0))
  (IS-PO R) (IMPLIES (IS-CHAIN F R) (SOME (B$0) (IS-CHAIN-LIMIT F B$0 R)))
  (ALL (F$0)
   (IMPLIES (IS-CHAIN F$0 R) (SOME (B$1) (IS-CHAIN-LIMIT F$0 B$1 R))))
  (IS-CHAIN F R))
 (IS-CHAIN-LIMIT F (LIMIT F R) R))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN,
IS-PO-BASIC
 with the instantiation (= B B$0) to ...
(TRUE)
LIMIT-IN-DOM
Beginning proof of LIMIT-IN-DOM ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R)) (IN (LIMIT F R) (REL!DOM R)))
Assuming LIMIT-IS-CHAIN-LIMIT with the
instantiations: (= F F) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (IS-CHAIN-LIMIT F (LIMIT F R) R))
  (IS-COMPLETE-PO R) (IS-CHAIN F R))
 (IN (LIMIT F R) (REL!DOM R)))
Invoking (IS-CHAIN-LIMIT F (LIMIT F R) R) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (AND (IS-CHAIN-BOUND F (LIMIT F R) R)
    (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED (LIMIT F R) R B)))))
  (IS-COMPLETE-PO R) (IS-CHAIN F R))
 (IN (LIMIT F R) (REL!DOM R)))
Invoking (IS-CHAIN-BOUND F (LIMIT F R) R) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (AND (IS-CHAIN F R) (IN (LIMIT F R) (REL!DOM R))
    (ALL (N)
     (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R (LIMIT F R))))
    (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED (LIMIT F R) R B)))))
  (IS-COMPLETE-PO R) (IS-CHAIN F R))
 (IN (LIMIT F R) (REL!DOM R)))
Which simplifies
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE to ...
(TRUE)
LIMIT-IS-UPPER-BOUND
Beginning proof of LIMIT-IS-UPPER-BOUND ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (>= N 0))
 (= (RELATED (FN!APPLY F N) R (LIMIT F R)) (TRUE)))
Assuming LIMIT-IS-CHAIN-LIMIT with the
instantiations: (= F F) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (IS-CHAIN-LIMIT F (LIMIT F R) R))
  (IS-COMPLETE-PO R) (IS-CHAIN F R) (>= N 0))
 (RELATED (FN!APPLY F N) R (LIMIT F R)))
Invoking (IS-CHAIN-LIMIT F (LIMIT F R) R) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (AND (IS-CHAIN-BOUND F (LIMIT F R) R)
    (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED (LIMIT F R) R B)))))
  (IS-COMPLETE-PO R) (IS-CHAIN F R) (>= N 0))
 (RELATED (FN!APPLY F N) R (LIMIT F R)))
Invoking (IS-CHAIN-BOUND F (LIMIT F R) R) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (AND (IS-CHAIN F R) (IN (LIMIT F R) (REL!DOM R))
    (ALL (N$0)
     (IMPLIES (IN N$0 (NAT!NAT)) (RELATED (FN!APPLY F N$0) R (LIMIT F R))))
    (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED (LIMIT F R) R B)))))
  (IS-COMPLETE-PO R) (IS-CHAIN F R) (>= N 0))
 (RELATED (FN!APPLY F N) R (LIMIT F R)))
Instantiating (= N$0 N) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (AND (IS-CHAIN F R) (IN (LIMIT F R) (REL!DOM R))
    (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R (LIMIT F R)))
    (ALL (N$0)
     (IMPLIES (IN N$0 (NAT!NAT)) (RELATED (FN!APPLY F N$0) R (LIMIT F R))))
    (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED (LIMIT F R) R B)))))
  (IS-COMPLETE-PO R) (IS-CHAIN F R) (>= N 0))
 (RELATED (FN!APPLY F N) R (LIMIT F R)))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, LIMIT-IN-DOM to ...
(TRUE)
LIMIT-BELOW
Beginning proof of LIMIT-BELOW ...
(IMPLIES (AND (IS-CHAIN F R) (IS-COMPLETE-PO R) (IN X (REL!DOM R)))
 (= (RELATED (LIMIT F R) R X)
  (ALL (N) (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R X)))))
Splitting on (RELATED (LIMIT F R) R X) generates ...
(IF (RELATED (LIMIT F R) R X)
 (IMPLIES (AND (IS-CHAIN F R) (IS-COMPLETE-PO R) (IN X (REL!DOM R)))
  (= (RELATED (LIMIT F R) R X)
   (ALL (N) (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R X)))))
 (IMPLIES (AND (IS-CHAIN F R) (IS-COMPLETE-PO R) (IN X (REL!DOM R)))
  (= (RELATED (LIMIT F R) R X)
   (ALL (N$0) (IMPLIES (IN N$0 (NAT!NAT)) (RELATED (FN!APPLY F N$0) R X))))))
Which simplifies
 forward chaining using IS-PO-BASIC, COMPLETE-PO-IS-PO,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, RELATED-DOM-RAN
 with the assumptions APPLY-IN-NOMINAL-RANGE, LIMIT-IN-DOM to ...
(IF (RELATED (LIMIT F R) R X)
 (IMPLIES (AND (IS-CHAIN F R) (IS-COMPLETE-PO R))
  (= (TRUE)
   (ALL (N) (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R X)))))
 (IMPLIES (AND (IS-CHAIN F R) (IS-COMPLETE-PO R) (IN X (REL!DOM R)))
  (= (FALSE)
   (ALL (N$0) (IMPLIES (IN N$0 (NAT!NAT)) (RELATED (FN!APPLY F N$0) R X))))))
Starting case 2 ...
(IMPLIES (AND (RELATED (LIMIT F R) R X) (IS-CHAIN F R) (IS-COMPLETE-PO R))
 (= (TRUE) (ALL (N) (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R X)))))
Prenexing produces ...
(IMPLIES
 (AND (RELATED (LIMIT F R) R X) (IS-CHAIN F R) (IS-COMPLETE-PO R)
  (IN N (NAT!NAT)))
 (RELATED (FN!APPLY F N) R X))
Assuming PO-TRANSITIVE with the
instantiations: (= R R) (= X (FN!APPLY F N)) (= Y (LIMIT F R))
                (= Z X) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PO R) (RELATED (FN!APPLY F N) R (LIMIT F R))
    (RELATED (LIMIT F R) R X))
   (RELATED (FN!APPLY F N) R X))
  (RELATED (LIMIT F R) R X) (IS-CHAIN F R) (IS-COMPLETE-PO R)
  (IN N (NAT!NAT)))
 (RELATED (FN!APPLY F N) R X))
Rearranging gives ...
(IMPLIES
 (AND (RELATED (LIMIT F R) R X) (IS-CHAIN F R) (IS-COMPLETE-PO R)
  (IN N (NAT!NAT))
  (IMPLIES
   (AND (IS-PO R) (RELATED (FN!APPLY F N) R (LIMIT F R))
    (RELATED (LIMIT F R) R X))
   (RELATED (FN!APPLY F N) R X)))
 (RELATED (FN!APPLY F N) R X))
Which simplifies
 when rewriting with LIMIT-IS-UPPER-BOUND, NAT!IN-NAT
 forward chaining using >=.SAME.TYPE, IS-PO-BASIC, COMPLETE-PO-IS-PO,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, RELATED-DOM-RAN
 with the assumptions LIMIT-IN-DOM, APPLY-IN-NOMINAL-RANGE-NAT to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (RELATED (LIMIT F R) R X)) (IS-CHAIN F R) (IS-COMPLETE-PO R)
  (IN X (REL!DOM R)))
 (= (FALSE)
  (ALL (N$0) (IMPLIES (IN N$0 (NAT!NAT)) (RELATED (FN!APPLY F N$0) R X)))))
Assuming LIMIT-IS-CHAIN-LIMIT with the
instantiations: (= F F) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (IS-CHAIN-LIMIT F (LIMIT F R) R))
  (NOT (RELATED (LIMIT F R) R X)) (IS-CHAIN F R) (IS-COMPLETE-PO R)
  (IN X (REL!DOM R)))
 (NOT (ALL (N) (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R X)))))
Invoking IS-CHAIN-LIMIT gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (AND (IS-CHAIN-BOUND F (LIMIT F R) R)
    (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED (LIMIT F R) R B)))))
  (NOT (RELATED (LIMIT F R) R X)) (IS-CHAIN F R) (IS-COMPLETE-PO R)
  (IN X (REL!DOM R)))
 (NOT (ALL (N) (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R X)))))
Instantiating (= B X) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (AND (IS-CHAIN-BOUND F (LIMIT F R) R)
    (IMPLIES (IS-CHAIN-BOUND F X R) (RELATED (LIMIT F R) R X))
    (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED (LIMIT F R) R B)))))
  (NOT (RELATED (LIMIT F R) R X)) (IS-CHAIN F R) (IS-COMPLETE-PO R)
  (IN X (REL!DOM R)))
 (NOT (ALL (N) (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R X)))))
Invoking (IS-CHAIN-BOUND F X R) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (AND (IS-CHAIN-BOUND F (LIMIT F R) R)
    (IMPLIES
     (AND (IS-CHAIN F R) (IN X (REL!DOM R))
      (ALL (N) (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) R X))))
     (RELATED (LIMIT F R) R X))
    (ALL (B) (IMPLIES (IS-CHAIN-BOUND F B R) (RELATED (LIMIT F R) R B)))))
  (NOT (RELATED (LIMIT F R) R X)) (IS-CHAIN F R) (IS-COMPLETE-PO R)
  (IN X (REL!DOM R)))
 (NOT (ALL (N$0) (IMPLIES (IN N$0 (NAT!NAT)) (RELATED (FN!APPLY F N$0) R X)))))
Which simplifies
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE, LIMIT-IN-DOM to ...
(TRUE)
Completing all cases produces ...
(TRUE)
IS-CONTINUOUS
CONTINUOUS-IMPLIES-MONOTONIC
Beginning proof of CONTINUOUS-IMPLIES-MONOTONIC ...
(IMPLIES (IS-CONTINUOUS F R) (IS-MONOTONIC F R R))
Invoking IS-CONTINUOUS gives ...
(IMPLIES
 (AND (IS-MONOTONIC F R R)
  (ALL (G)
   (IMPLIES (IS-CHAIN G R)
    (= (LIMIT (REL!COMP G F) R) (FN!APPLY F (LIMIT G R))))))
 (IS-MONOTONIC F R R))
Which simplifies
 forward chaining using CHAIN-IS-FUN, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
IS-MONOTONIC-FACTS
 with the assumptions IS-FUN-COMPOSITION to ...
(TRUE)
CONTINUITY-FACT
Beginning proof of CONTINUITY-FACT ...
(IMPLIES (AND (IS-CONTINUOUS F R) (IS-CHAIN G R))
 (= (FN!APPLY F (LIMIT G R)) (LIMIT (REL!COMP G F) R)))
Invoking IS-CONTINUOUS gives ...
(IMPLIES
 (AND (IS-MONOTONIC F R R)
  (ALL (G$0)
   (IMPLIES (IS-CHAIN G$0 R)
    (= (LIMIT (REL!COMP G$0 F) R) (FN!APPLY F (LIMIT G$0 R)))))
  (IS-CHAIN G R))
 (= (FN!APPLY F (LIMIT G R)) (LIMIT (REL!COMP G F) R)))
Instantiating (= G$0 G) gives ...
(IMPLIES
 (AND (IS-MONOTONIC F R R)
  (IMPLIES (IS-CHAIN G R)
   (= (LIMIT (REL!COMP G F) R) (FN!APPLY F (LIMIT G R))))
  (ALL (G$0)
   (IMPLIES (IS-CHAIN G$0 R)
    (= (LIMIT (REL!COMP G$0 F) R) (FN!APPLY F (LIMIT G$0 R)))))
  (IS-CHAIN G R))
 (= (FN!APPLY F (LIMIT G R)) (LIMIT (REL!COMP G F) R)))
Which simplifies
 forward chaining using CHAIN-IS-FUN, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
IS-MONOTONIC-FACTS
 with the assumptions IS-FUN-COMPOSITION to ...
(TRUE)
CONTINUITY-SUBGOAL
Beginning proof of CONTINUITY-SUBGOAL ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-MONOTONIC F R R)
  (ALL (G)
   (IMPLIES (IS-CHAIN G R)
    (RELATED (FN!APPLY F (LIMIT G R)) R (LIMIT (REL!COMP G F) R)))))
 (IS-CONTINUOUS F R))
Invoking IS-CONTINUOUS gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-MONOTONIC F R R)
  (ALL (G)
   (IMPLIES (IS-CHAIN G R)
    (RELATED (FN!APPLY F (LIMIT G R)) R (LIMIT (REL!COMP G F) R)))))
 (AND (IS-MONOTONIC F R R)
  (ALL (G$0)
   (IMPLIES (IS-CHAIN G$0 R)
    (= (LIMIT (REL!COMP G$0 F) R) (FN!APPLY F (LIMIT G$0 R)))))))
Instantiating (= G G$0) gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-MONOTONIC F R R)
  (IMPLIES (IS-CHAIN G R)
   (RELATED (FN!APPLY F (LIMIT G R)) R (LIMIT (REL!COMP G F) R)))
  (ALL (G$0)
   (IMPLIES (IS-CHAIN G$0 R)
    (RELATED (FN!APPLY F (LIMIT G$0 R)) R (LIMIT (REL!COMP G$0 F) R)))))
 (AND (IS-MONOTONIC F R R)
  (IMPLIES (IS-CHAIN G R)
   (= (LIMIT (REL!COMP G F) R) (FN!APPLY F (LIMIT G R))))))
Assuming PO-ASYMMETRY with the
instantiations: (= R R) (= X (FN!APPLY F (LIMIT G R)))
                (= Y (LIMIT (REL!COMP G F) R)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PO R)
    (RELATED (FN!APPLY F (LIMIT G R)) R (LIMIT (REL!COMP G F) R))
    (RELATED (LIMIT (REL!COMP G F) R) R (FN!APPLY F (LIMIT G R))))
   (= (FN!APPLY F (LIMIT G R)) (LIMIT (REL!COMP G F) R)))
  (IS-COMPLETE-PO R) (IS-MONOTONIC F R R)
  (IMPLIES (IS-CHAIN G R)
   (RELATED (FN!APPLY F (LIMIT G R)) R (LIMIT (REL!COMP G F) R)))
  (ALL (G$0)
   (IMPLIES (IS-CHAIN G$0 R)
    (RELATED (FN!APPLY F (LIMIT G$0 R)) R (LIMIT (REL!COMP G$0 F) R)))))
 (AND (IS-MONOTONIC F R R)
  (IMPLIES (IS-CHAIN G R)
   (= (LIMIT (REL!COMP G F) R) (FN!APPLY F (LIMIT G R))))))
Splitting
on (AND (IS-COMPLETE-PO R)
    (AND (IS-MONOTONIC F R R) (IS-CHAIN G R))) generates
...
(IF (AND (IS-COMPLETE-PO R) (IS-MONOTONIC F R R) (IS-CHAIN G R))
 (IMPLIES
  (AND
   (IMPLIES
    (AND (IS-PO R)
     (RELATED (FN!APPLY F (LIMIT G R)) R (LIMIT (REL!COMP G F) R))
     (RELATED (LIMIT (REL!COMP G F) R) R (FN!APPLY F (LIMIT G R))))
    (= (FN!APPLY F (LIMIT G R)) (LIMIT (REL!COMP G F) R)))
   (IS-COMPLETE-PO R) (IS-MONOTONIC F R R)
   (IMPLIES (IS-CHAIN G R)
    (RELATED (FN!APPLY F (LIMIT G R)) R (LIMIT (REL!COMP G F) R)))
   (ALL (G$0)
    (IMPLIES (IS-CHAIN G$0 R)
     (RELATED (FN!APPLY F (LIMIT G$0 R)) R (LIMIT (REL!COMP G$0 F) R)))))
  (AND (IS-MONOTONIC F R R)
   (IMPLIES (IS-CHAIN G R)
    (= (LIMIT (REL!COMP G F) R) (FN!APPLY F (LIMIT G R))))))
 (IMPLIES
  (AND
   (IMPLIES
    (AND (IS-PO R)
     (RELATED (FN!APPLY F (LIMIT G R)) R (LIMIT (REL!COMP G F) R))
     (RELATED (LIMIT (REL!COMP G F) R) R (FN!APPLY F (LIMIT G R))))
    (= (FN!APPLY F (LIMIT G R)) (LIMIT (REL!COMP G F) R)))
   (IS-COMPLETE-PO R) (IS-MONOTONIC F R R)
   (IMPLIES (IS-CHAIN G R)
    (RELATED (FN!APPLY F (LIMIT G R)) R (LIMIT (REL!COMP G F) R)))
   (ALL (G$1)
    (IMPLIES (IS-CHAIN G$1 R)
     (RELATED (FN!APPLY F (LIMIT G$1 R)) R (LIMIT (REL!COMP G$1 F) R)))))
  (AND (IS-MONOTONIC F R R)
   (IMPLIES (IS-CHAIN G R)
    (= (LIMIT (REL!COMP G F) R) (FN!APPLY F (LIMIT G R)))))))
Which simplifies
 when rewriting with IS-MONOTONIC-FACT, LIMIT-IS-UPPER-BOUND, FN!APPLY-COMP,
NAT!IN-NAT, LIMIT-BELOW, IS-CHAIN-COMP
 forward chaining using >=.SAME.TYPE, RELATED-DOM-RAN, CHAIN-IS-FUN,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-MONOTONIC-FACTS, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions FN!IS-FUNCTION-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
IS-FUN-COMPOSITION, APPLY-IN-NOMINAL-RANGE, LIMIT-IN-DOM to ...
(TRUE)
ITERATE
Beginning proof of ITERATE ...
(IF (>= N 1) (M< (+ -1 N) N) (TRUE))
Which simplifies
 when rewriting with M<.NAT
 forward chaining using >=.SAME.TYPE
 with the assumptions SUCC.INT to ...
(TRUE)
ITERATE-IN-DOM
Beginning proof of ITERATE-IN-DOM ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F)) (IN X (REL!DOM F)))
 (= (IN (ITERATE F N X) (REL!DOM F)) (TRUE)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (>= N 1) (*P* F (+ -1 N) X)) (*P* F N X))
  (IMPLIES (NOT (>= N 1)) (*P* F N X)))
 produces ...
(AND
 (IMPLIES
  (AND (>= N 1)
   (IMPLIES
    (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F))
     (IN X (REL!DOM F)))
    (= (IN (ITERATE F (+ -1 N) X) (REL!DOM F)) (TRUE))))
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F))
    (IN X (REL!DOM F)))
   (= (IN (ITERATE F N X) (REL!DOM F)) (TRUE))))
 (IMPLIES (NOT (>= N 1))
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F))
    (IN X (REL!DOM F)))
   (= (IN (ITERATE F N X) (REL!DOM F)) (TRUE)))))
Which simplifies
 with invocation of ITERATE, SUBSET
 forward chaining using FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (>= N 1) (FN!IS-FUNCTION F)
  (ALL (E) (IMPLIES (IN E (REL!RAN F)) (IN E (REL!DOM F)))) (IN X (REL!DOM F))
  (IN (ITERATE F (+ -1 N) X) (REL!DOM F)))
 (IN (FN!APPLY F (ITERATE F (+ -1 N) X)) (REL!DOM F)))
Assuming FN!APPLY-IN-RAN with the
instantiations: (= F F) (= X (ITERATE F (+ -1 N) X)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION F) (IN (ITERATE F (+ -1 N) X) (REL!DOM F)))
   (IN (FN!APPLY F (ITERATE F (+ -1 N) X)) (REL!RAN F)))
  (>= N 1) (FN!IS-FUNCTION F)
  (ALL (E) (IMPLIES (IN E (REL!RAN F)) (IN E (REL!DOM F)))) (IN X (REL!DOM F))
  (IN (ITERATE F (+ -1 N) X) (REL!DOM F)))
 (IN (FN!APPLY F (ITERATE F (+ -1 N) X)) (REL!DOM F)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL
 with the instantiation (= E (FN!APPLY F (ITERATE F (+ -1 N) X))) to ...
(TRUE)
ITERATES-OF-BOTTOM-RELATED
Beginning proof of ITERATES-OF-BOTTOM-RELATED ...
(IMPLIES (AND (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= N 0))
 (= (RELATED (ITERATE F N B) R (ITERATE F (+ 1 N) B)) (TRUE)))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (>= N 1) (*P* B F (+ -1 N) R)) (*P* B F N R))
  (IMPLIES (NOT (>= N 1)) (*P* B F N R)))
 produces ...
(AND
 (IMPLIES
  (AND (>= N 1)
   (IMPLIES
    (AND (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= (+ -1 N) 0))
    (= (RELATED (ITERATE F (+ -1 N) B) R (ITERATE F (+ 1 -1 N) B)) (TRUE))))
  (IMPLIES (AND (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= N 0))
   (= (RELATED (ITERATE F N B) R (ITERATE F (+ 1 N) B)) (TRUE))))
 (IMPLIES (NOT (>= N 1))
  (IMPLIES (AND (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= N 0))
   (= (RELATED (ITERATE F N B) R (ITERATE F (+ 1 N) B)) (TRUE)))))
Starting case 2 ...
(IMPLIES
 (AND (>= N 1)
  (IMPLIES
   (AND (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= (+ -1 N) 0))
   (= (RELATED (ITERATE F (+ -1 N) B) R (ITERATE F (+ 1 -1 N) B)) (TRUE)))
  (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= N 0))
 (= (RELATED (ITERATE F N B) R (ITERATE F (+ 1 N) B)) (TRUE)))
Invoking (ITERATE F N B) gives ...
(IMPLIES
 (AND (>= N 1)
  (IMPLIES
   (AND (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= (+ -1 N) 0))
   (RELATED (ITERATE F (+ -1 N) B) R (ITERATE F (+ 1 -1 N) B)))
  (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= N 0))
 (RELATED (IF (>= N 1) (FN!APPLY F (ITERATE F (+ -1 N) B)) B) R
  (ITERATE F (+ 1 N) B)))
Invoking (ITERATE F (+ 1 N) B) gives ...
(IMPLIES
 (AND (>= N 1)
  (IMPLIES
   (AND (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= (+ -1 N) 0))
   (RELATED (ITERATE F (+ -1 N) B) R (ITERATE F (+ 1 -1 N) B)))
  (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= N 0))
 (RELATED (IF (>= N 1) (FN!APPLY F (ITERATE F (+ -1 N) B)) B) R
  (IF (>= (+ 1 N) 1) (FN!APPLY F (ITERATE F (+ -1 1 N) B)) B)))
Which simplifies
 when rewriting with IS-MONOTONIC-FACT
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-MONOTONIC-FACTS, IS-BOTTOM-IMPLIES-IN-DOM, IS-PO-BASIC,
>=.SAME.TYPE
 with the assumptions APPLY-IN-NOMINAL-RANGE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= N 1)) (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= N 0))
 (= (RELATED (ITERATE F N B) R (ITERATE F (+ 1 N) B)) (TRUE)))
Invoking (ITERATE F N B) gives ...
(IMPLIES
 (AND (NOT (>= N 1)) (IS-PO R) (IS-BOTTOM B R) (IS-MONOTONIC F R R) (>= N 0))
 (RELATED (IF (>= N 1) (FN!APPLY F (ITERATE F (+ -1 N) B)) B) R
  (ITERATE F (+ 1 N) B)))
Invoking IS-BOTTOM gives ...
(IMPLIES
 (AND (NOT (>= N 1)) (IS-PO R) (IN B (REL!DOM R))
  (ALL (X) (IMPLIES (IN X (REL!DOM R)) (RELATED B R X))) (IS-MONOTONIC F R R)
  (>= N 0))
 (RELATED (IF (>= N 1) (FN!APPLY F (ITERATE F (+ -1 N) B)) B) R
  (ITERATE F (+ 1 N) B)))
Instantiating (= X (ITERATE F 1 B)) gives ...
(IMPLIES
 (AND (NOT (>= N 1)) (IS-PO R) (IN B (REL!DOM R))
  (IMPLIES (IN (ITERATE F 1 B) (REL!DOM R)) (RELATED B R (ITERATE F 1 B)))
  (ALL (X) (IMPLIES (IN X (REL!DOM R)) (RELATED B R X))) (IS-MONOTONIC F R R)
  (>= N 0))
 (RELATED (IF (>= N 1) (FN!APPLY F (ITERATE F (+ -1 N) B)) B) R
  (ITERATE F (+ 1 N) B)))
Assuming ITERATE-IN-DOM with the
instantiations: (= F F) (= N 1) (= X B) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F))
    (IN B (REL!DOM F)))
   (= (IN (ITERATE F 1 B) (REL!DOM F)) (TRUE)))
  (NOT (>= N 1)) (IS-PO R) (IN B (REL!DOM R))
  (IMPLIES (IN (ITERATE F 1 B) (REL!DOM R)) (RELATED B R (ITERATE F 1 B)))
  (ALL (X) (IMPLIES (IN X (REL!DOM R)) (RELATED B R X))) (IS-MONOTONIC F R R)
  (>= N 0))
 (RELATED (IF (>= N 1) (FN!APPLY F (ITERATE F (+ -1 N) B)) B) R
  (ITERATE F (+ 1 N) B)))
Which simplifies
 forward chaining using IS-FUN-FACTS, IS-MONOTONIC-FACTS, RELATED-DOM-RAN,
IS-PO-BASIC, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
ITERATION-CHAIN
DOM-ITERATION-CHAIN
Beginning proof of DOM-ITERATION-CHAIN ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F)) (IN X (REL!DOM F)))
 (= (REL!DOM (ITERATION-CHAIN F X)) (NAT!NAT)))
Applying SETRULES!EXTENSIONALITY gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F)) (IN X (REL!DOM F)))
 (ALL (E)
  (IF (IN E (REL!DOM (ITERATION-CHAIN F X))) (IN E (NAT!NAT))
   (NOT (IN E (NAT!NAT))))))
Applying REL!IN-DOM to
 (IN E (REL!DOM (ITERATION-CHAIN F X))) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F)) (IN X (REL!DOM F)))
 (ALL (E)
  (IF (SOME (B) (IN (PAIR!PAIR E B) (ITERATION-CHAIN F X))) (IN E (NAT!NAT))
   (NOT (IN E (NAT!NAT))))))
Which simplifies
 when rewriting with ITERATE-IN-DOM, NAT!IN-NAT, PAIR!IN-CROSS,
ITERATION-CHAIN.DEFINITION
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL
 with the instantiation (= B (ITERATE F E X)) to ...
(TRUE)
RAN-ITERATION-CHAIN
Beginning proof of RAN-ITERATION-CHAIN ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F)) (IN X (REL!DOM F)))
 (= (SUBSET (REL!RAN (ITERATION-CHAIN F X)) (REL!DOM F)) (TRUE)))
Which simplifies
 with invocation of SUBSET
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION F)
  (ALL (E) (IMPLIES (IN E (REL!RAN F)) (IN E (REL!DOM F))))
  (IN X (REL!DOM F)))
 (ALL (E$0)
  (IMPLIES (IN E$0 (REL!RAN (ITERATION-CHAIN F X))) (IN E$0 (REL!DOM F)))))
Which simplifies
 when rewriting with NAT!IN-NAT, PAIR!IN-CROSS, ITERATION-CHAIN.DEFINITION,
REL!IN-RAN
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-FUNCTION-ITERATION-CHAIN
Beginning proof of IS-FUNCTION-ITERATION-CHAIN ...
(= (FN!IS-FUNCTION (ITERATION-CHAIN F X)) (TRUE))
Which simplifies
 with invocation of REL!IS-RELATION, FN!IS-FUNCTION
 when rewriting with NAT!IN-NAT, PAIR!IN-CROSS, ITERATION-CHAIN.DEFINITION
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PAIR!IS-PAIR-BOOL, FN!IS-FUNCTION-BOOL to ...
(TRUE)
APPLY-ITERATION-CHAIN
Beginning proof of APPLY-ITERATION-CHAIN ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F)) (IN X (REL!DOM F))
  (>= N 0))
 (= (FN!APPLY (ITERATION-CHAIN F X) N) (ITERATE F N X)))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F (ITERATION-CHAIN F X)) (= X N) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (ITERATION-CHAIN F X))
    (IN N (REL!DOM (ITERATION-CHAIN F X))))
   (IN (PAIR!PAIR N (FN!APPLY (ITERATION-CHAIN F X) N))
    (ITERATION-CHAIN F X)))
  (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F)) (IN X (REL!DOM F))
  (>= N 0))
 (= (FN!APPLY (ITERATION-CHAIN F X) N) (ITERATE F N X)))
Rearranging gives ...
(IMPLIES
 (AND (>= N 0) (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F))
  (IN X (REL!DOM F))
  (IMPLIES
   (AND (FN!IS-FUNCTION (ITERATION-CHAIN F X))
    (IN N (REL!DOM (ITERATION-CHAIN F X))))
   (IN (PAIR!PAIR N (FN!APPLY (ITERATION-CHAIN F X) N))
    (ITERATION-CHAIN F X))))
 (= (FN!APPLY (ITERATION-CHAIN F X) N) (ITERATE F N X)))
Which simplifies
 when rewriting with PAIR!IN-CROSS, ITERATION-CHAIN.DEFINITION, NAT!IN-NAT,
DOM-ITERATION-CHAIN, IS-FUNCTION-ITERATION-CHAIN
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
>=.SAME.TYPE
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL to ...
(TRUE)
ITERATION-CHAIN-IS-CHAIN
Beginning proof of ITERATION-CHAIN-IS-CHAIN ...
(IMPLIES (AND (IS-PO R) (IS-MONOTONIC F R R) (IS-BOTTOM B R))
 (IS-CHAIN (ITERATION-CHAIN F B) R))
Invoking IS-CHAIN gives ...
(IMPLIES (AND (IS-PO R) (IS-MONOTONIC F R R) (IS-BOTTOM B R))
 (AND (IS-FUN (ITERATION-CHAIN F B) (NAT!NAT) (REL!DOM R))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY (ITERATION-CHAIN F B) N) R
     (FN!APPLY (ITERATION-CHAIN F B) (+ 1 N)))))))
Invoking IS-FUN gives ...
(IMPLIES (AND (IS-PO R) (IS-MONOTONIC F R R) (IS-BOTTOM B R))
 (AND (FN!IS-FUNCTION (ITERATION-CHAIN F B))
  (= (REL!DOM (ITERATION-CHAIN F B)) (NAT!NAT))
  (SUBSET (REL!RAN (ITERATION-CHAIN F B)) (REL!DOM R))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY (ITERATION-CHAIN F B) N) R
     (FN!APPLY (ITERATION-CHAIN F B) (+ 1 N)))))))
Which simplifies
 when rewriting with ITERATES-OF-BOTTOM-RELATED, APPLY-ITERATION-CHAIN,
NAT!IN-NAT, DOM-ITERATION-CHAIN, IS-FUNCTION-ITERATION-CHAIN
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
IS-BOTTOM-IMPLIES-IN-DOM, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
IS-MONOTONIC-FACTS, IS-PO-BASIC
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(IMPLIES (AND (IS-PO R) (IS-MONOTONIC F R R) (IS-BOTTOM B R))
 (SUBSET (REL!RAN (ITERATION-CHAIN F B)) (REL!DOM R)))
Assuming RAN-ITERATION-CHAIN with the
instantiations: (= F F) (= X B) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F))
    (IN B (REL!DOM F)))
   (= (SUBSET (REL!RAN (ITERATION-CHAIN F B)) (REL!DOM F)) (TRUE)))
  (IS-PO R) (IS-MONOTONIC F R R) (IS-BOTTOM B R))
 (SUBSET (REL!RAN (ITERATION-CHAIN F B)) (REL!DOM R)))
Which simplifies
 forward chaining using IS-BOTTOM-IMPLIES-IN-DOM, IS-FUN-FACTS,
IS-MONOTONIC-FACTS, IS-PO-BASIC, FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
FIXEDPOINT-LEMMA
Beginning proof of FIXEDPOINT-LEMMA ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (ALL (N) (IMPLIES (>= N 0) (= (FN!APPLY F N) (FN!APPLY G (+ 1 N))))))
 (= (LIMIT F R) (LIMIT G R)))
Assuming PO-ASYMMETRY with the
instantiations: (= R R) (= X (LIMIT F R)) (= Y (LIMIT G R)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PO R) (RELATED (LIMIT F R) R (LIMIT G R))
    (RELATED (LIMIT G R) R (LIMIT F R)))
   (= (LIMIT F R) (LIMIT G R)))
  (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (ALL (N) (IMPLIES (>= N 0) (= (FN!APPLY F N) (FN!APPLY G (+ 1 N))))))
 (= (LIMIT F R) (LIMIT G R)))
Rearranging gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (IMPLIES
   (AND (IS-PO R) (RELATED (LIMIT F R) R (LIMIT G R))
    (RELATED (LIMIT G R) R (LIMIT F R)))
   (= (LIMIT F R) (LIMIT G R)))
  (ALL (N) (IMPLIES (>= N 0) (= (FN!APPLY F N) (FN!APPLY G (+ 1 N))))))
 (= (LIMIT F R) (LIMIT G R)))
Which simplifies
 forward chaining using >=.SAME.TYPE, RELATED-DOM-RAN,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, LIMIT-IN-DOM to ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R))
 (IF (RELATED (LIMIT F R) R (LIMIT G R))
  (OR (RELATED (LIMIT G R) R (LIMIT F R))
   (NOT (ALL (N) (IMPLIES (>= N 0) (= (FN!APPLY F N) (FN!APPLY G (+ 1 N)))))))
  (IMPLIES
   (ALL (N$0)
    (IMPLIES (>= N$0 0) (= (FN!APPLY F N$0) (FN!APPLY G (+ 1 N$0)))))
   (= (LIMIT F R) (LIMIT G R)))))
Starting case 2 ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (RELATED (LIMIT F R) R (LIMIT G R))
  (NOT (RELATED (LIMIT G R) R (LIMIT F R))))
 (NOT (ALL (N) (IMPLIES (>= N 0) (= (FN!APPLY F N) (FN!APPLY G (+ 1 N)))))))
Which simplifies
 when rewriting with NAT!IN-NAT, LIMIT-BELOW
 forward chaining using >=.SAME.TYPE, RELATED-DOM-RAN,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, LIMIT-IN-DOM to ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (ALL (N) (IMPLIES (>= N 0) (RELATED (FN!APPLY F N) R (LIMIT G R))))
  (NOT
   (ALL (N$0) (IMPLIES (>= N$0 0) (RELATED (FN!APPLY G N$0) R (LIMIT F R))))))
 (NOT
  (ALL (N$1)
   (IMPLIES (>= N$1 0) (= (FN!APPLY F N$1) (FN!APPLY G (+ 1 N$1)))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (ALL (N$0) (IMPLIES (>= N$0 0) (RELATED (FN!APPLY F N$0) R (LIMIT G R))))
  (NOT (IMPLIES (>= N 0) (RELATED (FN!APPLY G N) R (LIMIT F R)))))
 (NOT
  (ALL (N$1)
   (IMPLIES (>= N$1 0) (= (FN!APPLY F N$1) (FN!APPLY G (+ 1 N$1)))))))
Assuming PO-TRANSITIVE with the
instantiations: (= R R) (= X (FN!APPLY G N)) (= Y (FN!APPLY G (+ 1 N)))
                (= Z (LIMIT F R)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PO R) (RELATED (FN!APPLY G N) R (FN!APPLY G (+ 1 N)))
    (RELATED (FN!APPLY G (+ 1 N)) R (LIMIT F R)))
   (RELATED (FN!APPLY G N) R (LIMIT F R)))
  (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (ALL (N$0) (IMPLIES (>= N$0 0) (RELATED (FN!APPLY F N$0) R (LIMIT G R))))
  (NOT (IMPLIES (>= N 0) (RELATED (FN!APPLY G N) R (LIMIT F R)))))
 (NOT
  (ALL (N$1)
   (IMPLIES (>= N$1 0) (= (FN!APPLY F N$1) (FN!APPLY G (+ 1 N$1)))))))
Assuming LIMIT-IS-UPPER-BOUND with the
instantiations: (= R R) (= F F) (= N N) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (>= N 0))
   (= (RELATED (FN!APPLY F N) R (LIMIT F R)) (TRUE)))
  (IMPLIES
   (AND (IS-PO R) (RELATED (FN!APPLY G N) R (FN!APPLY G (+ 1 N)))
    (RELATED (FN!APPLY G (+ 1 N)) R (LIMIT F R)))
   (RELATED (FN!APPLY G N) R (LIMIT F R)))
  (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (ALL (N$0) (IMPLIES (>= N$0 0) (RELATED (FN!APPLY F N$0) R (LIMIT G R))))
  (NOT (IMPLIES (>= N 0) (RELATED (FN!APPLY G N) R (LIMIT F R)))))
 (NOT
  (ALL (N$1)
   (IMPLIES (>= N$1 0) (= (FN!APPLY F N$1) (FN!APPLY G (+ 1 N$1)))))))
Rearranging gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (NOT (IMPLIES (>= N 0) (RELATED (FN!APPLY G N) R (LIMIT F R))))
  (IMPLIES (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (= (RELATED (FN!APPLY F N) R (LIMIT F R)) (TRUE)))
  (IMPLIES
   (AND (IS-PO R) (RELATED (FN!APPLY G N) R (FN!APPLY G (+ 1 N)))
    (RELATED (FN!APPLY G (+ 1 N)) R (LIMIT F R)))
   (RELATED (FN!APPLY G N) R (LIMIT F R)))
  (ALL (N$0) (IMPLIES (>= N$0 0) (RELATED (FN!APPLY F N$0) R (LIMIT G R)))))
 (NOT
  (ALL (N$1)
   (IMPLIES (>= N$1 0) (= (FN!APPLY F N$1) (FN!APPLY G (+ 1 N$1)))))))
Instantiating (= N$1 N) gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (NOT (IMPLIES (>= N 0) (RELATED (FN!APPLY G N) R (LIMIT F R))))
  (IMPLIES (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN F R))
   (RELATED (FN!APPLY F N) R (LIMIT F R)))
  (IMPLIES
   (AND (IS-PO R) (RELATED (FN!APPLY G N) R (FN!APPLY G (+ 1 N)))
    (RELATED (FN!APPLY G (+ 1 N)) R (LIMIT F R)))
   (RELATED (FN!APPLY G N) R (LIMIT F R)))
  (ALL (N$0) (IMPLIES (>= N$0 0) (RELATED (FN!APPLY F N$0) R (LIMIT G R)))))
 (NOT
  (AND (IMPLIES (>= N 0) (= (FN!APPLY F N) (FN!APPLY G (+ 1 N))))
   (ALL (N$1)
    (IMPLIES (>= N$1 0) (= (FN!APPLY F N$1) (FN!APPLY G (+ 1 N$1))))))))
Which simplifies
 when rewriting with CHAIN-APPLICATIONS-RELATED, LIMIT-IS-UPPER-BOUND
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, APPLY-IN-NOMINAL-RANGE-NAT to ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R) (>= N 0)
  (NOT (RELATED (FN!APPLY G N) R (LIMIT F R)))
  (NOT (RELATED (FN!APPLY G (+ 1 N)) R (LIMIT F R)))
  (ALL (N$0) (IMPLIES (>= N$0 0) (RELATED (FN!APPLY F N$0) R (LIMIT G R))))
  (= (FN!APPLY F N) (FN!APPLY G (+ 1 N))))
 (NOT
  (ALL (N$1)
   (IMPLIES (>= N$1 0) (= (FN!APPLY F N$1) (FN!APPLY G (+ 1 N$1)))))))
Assuming LIMIT-IS-UPPER-BOUND with the
instantiations: (= R R) (= F F) (= N N) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (>= N 0))
   (= (RELATED (FN!APPLY F N) R (LIMIT F R)) (TRUE)))
  (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R) (>= N 0)
  (NOT (RELATED (FN!APPLY G N) R (LIMIT F R)))
  (NOT (RELATED (FN!APPLY G (+ 1 N)) R (LIMIT F R)))
  (ALL (N$0) (IMPLIES (>= N$0 0) (RELATED (FN!APPLY F N$0) R (LIMIT G R))))
  (= (FN!APPLY F N) (FN!APPLY G (+ 1 N))))
 (NOT
  (ALL (N$1)
   (IMPLIES (>= N$1 0) (= (FN!APPLY F N$1) (FN!APPLY G (+ 1 N$1)))))))
Which simplifies
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, APPLY-IN-NOMINAL-RANGE-NAT to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (NOT (RELATED (LIMIT F R) R (LIMIT G R)))
  (ALL (N$0)
   (IMPLIES (>= N$0 0) (= (FN!APPLY F N$0) (FN!APPLY G (+ 1 N$0))))))
 (= (LIMIT F R) (LIMIT G R)))
Which simplifies
 when rewriting with NAT!IN-NAT, LIMIT-BELOW
 forward chaining using >=.SAME.TYPE, RELATED-DOM-RAN,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, LIMIT-IN-DOM to ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (NOT (ALL (N) (IMPLIES (>= N 0) (RELATED (FN!APPLY F N) R (LIMIT G R)))))
  (ALL (N$0)
   (IMPLIES (>= N$0 0) (= (FN!APPLY F N$0) (FN!APPLY G (+ 1 N$0))))))
 (= (LIMIT F R) (LIMIT G R)))
Prenexing produces ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (NOT (IMPLIES (>= N 0) (RELATED (FN!APPLY F N) R (LIMIT G R))))
  (ALL (N$0)
   (IMPLIES (>= N$0 0) (= (FN!APPLY F N$0) (FN!APPLY G (+ 1 N$0))))))
 (= (LIMIT F R) (LIMIT G R)))
Instantiating (= N$0 N) gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (NOT (IMPLIES (>= N 0) (RELATED (FN!APPLY F N) R (LIMIT G R))))
  (IMPLIES (>= N 0) (= (FN!APPLY F N) (FN!APPLY G (+ 1 N))))
  (ALL (N$0)
   (IMPLIES (>= N$0 0) (= (FN!APPLY F N$0) (FN!APPLY G (+ 1 N$0))))))
 (= (LIMIT F R) (LIMIT G R)))
Assuming LIMIT-IS-UPPER-BOUND with the
instantiations: (= N (+ 1 N)) (= F G) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN G R) (>= (+ 1 N) 0))
   (= (RELATED (FN!APPLY G (+ 1 N)) R (LIMIT G R)) (TRUE)))
  (IS-COMPLETE-PO R) (IS-CHAIN F R) (IS-CHAIN G R)
  (NOT (IMPLIES (>= N 0) (RELATED (FN!APPLY F N) R (LIMIT G R))))
  (IMPLIES (>= N 0) (= (FN!APPLY F N) (FN!APPLY G (+ 1 N))))
  (ALL (N$0)
   (IMPLIES (>= N$0 0) (= (FN!APPLY F N$0) (FN!APPLY G (+ 1 N$0))))))
 (= (LIMIT F R) (LIMIT G R)))
Which simplifies
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, APPLY-IN-NOMINAL-RANGE-NAT to ...
(TRUE)
Completing all cases produces ...
(TRUE)
FIXPT
FIXPT-IS-FIXEDPOINT
Beginning proof of FIXPT-IS-FIXEDPOINT ...
(IMPLIES (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R))
 (AND (IN (FIXPT F R) (REL!DOM F)) (= (FN!APPLY F (FIXPT F R)) (FIXPT F R))))
Invoking FIXPT gives ...
(IMPLIES (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R))
 (AND (IN (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R) (REL!DOM F))
  (= (FN!APPLY F (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R))
   (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R))))
Starting case 2 ...
(IMPLIES (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R))
 (IN (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R) (REL!DOM F)))
Assuming ITERATION-CHAIN-IS-CHAIN with the
instantiations: (= F F) (= B (BOTTOM R)) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PO R) (IS-MONOTONIC F R R) (IS-BOTTOM (BOTTOM R) R))
   (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R))
  (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R))
 (IN (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R) (REL!DOM F)))
Rearranging gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IMPLIES (AND (IS-PO R) (IS-MONOTONIC F R R) (IS-BOTTOM (BOTTOM R) R))
   (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R)))
 (IN (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R) (REL!DOM F)))
Which simplifies
 when rewriting with BOTTOM-IS-BOTTOM
 forward chaining using CHAIN-IS-FUN, IS-BOTTOM-IMPLIES-IN-DOM,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-MONOTONIC-FACTS,
CONTINUOUS-IMPLIES-MONOTONIC, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R))
 (= (FN!APPLY F (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R))
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Applying CONTINUITY-FACT gives ...
(IMPLIES (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R))
 (=
  (IF (AND (IS-CONTINUOUS F R) (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R))
   (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
   (FN!APPLY F (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Assuming ITERATION-CHAIN-IS-CHAIN with the
instantiations: (= F F) (= B (BOTTOM R)) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PO R) (IS-MONOTONIC F R R) (IS-BOTTOM (BOTTOM R) R))
   (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R))
  (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R))
 (=
  (IF (AND (IS-CONTINUOUS F R) (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R))
   (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
   (FN!APPLY F (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Rearranging gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IMPLIES (AND (IS-PO R) (IS-MONOTONIC F R R) (IS-BOTTOM (BOTTOM R) R))
   (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R)))
 (=
  (IF (AND (IS-CONTINUOUS F R) (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R))
   (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
   (FN!APPLY F (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Which simplifies
 when rewriting with BOTTOM-IS-BOTTOM
 forward chaining using CHAIN-IS-FUN, IS-BOTTOM-IMPLIES-IN-DOM,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-MONOTONIC-FACTS,
CONTINUOUS-IMPLIES-MONOTONIC, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, IS-FUN-COMPOSITION to ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Assuming FIXEDPOINT-LEMMA with the
instantiations: (= R R) (= F (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F))
                (= G (ITERATION-CHAIN F (BOTTOM R))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-COMPLETE-PO R)
    (IS-CHAIN (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
    (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R)
    (ALL (N)
     (IMPLIES (>= N 0)
      (= (FN!APPLY (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) N)
       (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) (+ 1 N))))))
   (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
    (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
  (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Rearranging gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R)
  (IMPLIES
   (AND (IS-COMPLETE-PO R)
    (IS-CHAIN (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
    (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R)
    (ALL (N)
     (IMPLIES (>= N 0)
      (= (FN!APPLY (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) N)
       (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) (+ 1 N))))))
   (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
    (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R))))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Which simplifies
 when rewriting with FN!APPLY-COMP, NAT!IN-NAT, IS-CHAIN-COMP
 forward chaining using >=.SAME.TYPE, CHAIN-IS-FUN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-MONOTONIC-FACTS, CONTINUOUS-IMPLIES-MONOTONIC, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, APPLY-IN-NOMINAL-RANGE,
FN!IS-FUNCTION-BOOL, APPLY-IN-NOMINAL-RANGE-NAT, IS-FUN-COMPOSITION to ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R)
  (NOT
   (ALL (N)
    (IMPLIES (>= N 0)
     (= (FN!APPLY F (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) N))
      (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) (+ 1 N)))))))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Prenexing produces ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R)
  (NOT
   (IMPLIES (>= N 0)
    (= (FN!APPLY F (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) N))
     (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) (+ 1 N))))))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Applying APPLY-ITERATION-CHAIN gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R)
  (NOT
   (IMPLIES (>= N 0)
    (=
     (FN!APPLY F
      (IF
       (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F))
        (IN (BOTTOM R) (REL!DOM F)) (>= N 0))
       (ITERATE F N (BOTTOM R)) (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) N)))
     (IF
      (AND (FN!IS-FUNCTION F) (SUBSET (REL!RAN F) (REL!DOM F))
       (IN (BOTTOM R) (REL!DOM F)) (>= (+ 1 N) 0))
      (ITERATE F (+ 1 N) (BOTTOM R))
      (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) (+ 1 N)))))))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Which simplifies
 forward chaining using >=.SAME.TYPE, CHAIN-IS-FUN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-MONOTONIC-FACTS, CONTINUOUS-IMPLIES-MONOTONIC, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, IS-FUN-COMPOSITION,
APPLY-IN-NOMINAL-RANGE, APPLY-IN-NOMINAL-RANGE-NAT, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R) (>= N 0)
  (NOT
   (IF (IN (BOTTOM R) (REL!DOM F))
    (= (FN!APPLY F (ITERATE F N (BOTTOM R))) (ITERATE F (+ 1 N) (BOTTOM R)))
    (= (FN!APPLY F (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) N))
     (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) (+ 1 N))))))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Invoking (ITERATE F (+ 1 N) (BOTTOM R)) gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R) (>= N 0)
  (NOT
   (IF (IN (BOTTOM R) (REL!DOM F))
    (= (FN!APPLY F (ITERATE F N (BOTTOM R)))
     (IF (>= (+ 1 N) 1) (FN!APPLY F (ITERATE F (+ -1 1 N) (BOTTOM R)))
      (BOTTOM R)))
    (= (FN!APPLY F (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) N))
     (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) (+ 1 N))))))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Which simplifies
 forward chaining using >=.SAME.TYPE, CHAIN-IS-FUN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-MONOTONIC-FACTS, CONTINUOUS-IMPLIES-MONOTONIC, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, IS-FUN-COMPOSITION,
APPLY-IN-NOMINAL-RANGE, APPLY-IN-NOMINAL-RANGE-NAT to ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R) (>= N 0)
  (NOT (IN (BOTTOM R) (REL!DOM F)))
  (NOT
   (= (FN!APPLY F (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) N))
    (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) (+ 1 N)))))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Assuming BOTTOM-IN-DOM with the instantiations: (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PO R) (HAS-BOTTOM R))
   (= (IN (BOTTOM R) (REL!DOM R)) (TRUE)))
  (IS-COMPLETE-PO R) (HAS-BOTTOM R) (IS-CONTINUOUS F R)
  (IS-CHAIN (ITERATION-CHAIN F (BOTTOM R)) R) (>= N 0)
  (NOT (IN (BOTTOM R) (REL!DOM F)))
  (NOT
   (= (FN!APPLY F (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) N))
    (FN!APPLY (ITERATION-CHAIN F (BOTTOM R)) (+ 1 N)))))
 (= (LIMIT (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F) R)
  (LIMIT (ITERATION-CHAIN F (BOTTOM R)) R)))
Which simplifies
 forward chaining using >=.SAME.TYPE, CHAIN-IS-FUN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-MONOTONIC-FACTS, CONTINUOUS-IMPLIES-MONOTONIC,
COMPLETE-PO-IS-PO, IS-PO-BASIC to ...
(TRUE)
Completing all cases produces ...
(TRUE)
POINTWISE-RELATED
POINTWISE-RELATED-SELF
Beginning proof of POINTWISE-RELATED-SELF ...
(IMPLIES (AND (FN!IS-FUNCTION F) (IS-PO R) (SUBSET (REL!RAN F) (REL!DOM R)))
 (= (POINTWISE-RELATED F R F) (TRUE)))
Invoking POINTWISE-RELATED gives ...
(IMPLIES (AND (FN!IS-FUNCTION F) (IS-PO R) (SUBSET (REL!RAN F) (REL!DOM R)))
 (ALL (X)
  (IMPLIES (IN X (REL!DOM F)) (RELATED (FN!APPLY F X) R (FN!APPLY F X)))))
Prenexing produces ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (IS-PO R) (SUBSET (REL!RAN F) (REL!DOM R))
  (IN X (REL!DOM F)))
 (RELATED (FN!APPLY F X) R (FN!APPLY F X)))
Assuming FN!APPLY-IN-RAN with the instantiations: (= F F) (= X X) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION F) (IN X (REL!DOM F)))
   (IN (FN!APPLY F X) (REL!RAN F)))
  (FN!IS-FUNCTION F) (IS-PO R) (SUBSET (REL!RAN F) (REL!DOM R))
  (IN X (REL!DOM F)))
 (RELATED (FN!APPLY F X) R (FN!APPLY F X)))
Which simplifies
 with invocation of SUBSET
 when rewriting with RELATED-PO-SELF
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC, FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
FN-ORDER
IS-RELATION-FN-ORDER
Beginning proof of IS-RELATION-FN-ORDER ...
(= (REL!IS-RELATION (FN-ORDER D R)) (TRUE))
Which simplifies
 with invocation of REL!IS-RELATION
 when rewriting with IN-FUN, PAIR!IN-CROSS, FN-ORDER.DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, REL!IS-RELATION-BOOL to ...
(TRUE)
RELATED-BY-FN-ORDER
Beginning proof of RELATED-BY-FN-ORDER ...
(= (RELATED F (FN-ORDER D R) G)
 (AND (IN F (FN!FUN D (REL!DOM R))) (IN G (FN!FUN D (REL!DOM R)))
  (POINTWISE-RELATED F R G)))
Which simplifies
 with invocation of RELATED
 when rewriting with IN-FUN, PAIR!IN-CROSS, FN-ORDER.DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
PAIR!PAIR-COMPOSITION, RELATED-DOM-RAN
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR to ...
(TRUE)
FN-ORDER-1
Beginning proof of FN-ORDER-1 ...
(IMPLIES (AND (IN F (FN!FUN D (REL!DOM R))) (IS-PO R))
 (= (IN (PAIR!PAIR F F) (FN-ORDER D R)) (TRUE)))
Which simplifies
 when rewriting with POINTWISE-RELATED-SELF, PAIR!IN-CROSS,
FN-ORDER.DEFINITION, IN-FUN
 forward chaining using PAIR!PAIR-COMPOSITION, IS-PO-BASIC,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
DOM-FN-ORDER
Beginning proof of DOM-FN-ORDER ...
(IMPLIES (IS-PO R) (= (REL!DOM (FN-ORDER D R)) (FN!FUN D (REL!DOM R))))
Applying SETRULES!EXTENSIONALITY gives ...
(IMPLIES (IS-PO R)
 (ALL (E)
  (IF (IN E (REL!DOM (FN-ORDER D R))) (IN E (FN!FUN D (REL!DOM R)))
   (NOT (IN E (FN!FUN D (REL!DOM R)))))))
Which simplifies
 when rewriting with IN-FUN, PAIR!IN-CROSS, FN-ORDER.DEFINITION, REL!IN-DOM
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
PAIR!PAIR-COMPOSITION, IS-PO-BASIC
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR to ...
(IMPLIES (IS-PO R)
 (ALL (E)
  (IMPLIES (IS-FUN E D (REL!DOM R))
   (SOME (B) (AND (IS-FUN B D (REL!DOM R)) (POINTWISE-RELATED E R B))))))
Instantiating (= B E) gives ...
(IMPLIES (IS-PO R)
 (ALL (E)
  (IMPLIES
   (AND (IS-FUN E D (REL!DOM R))
    (NOT (AND (IS-FUN E D (REL!DOM R)) (POINTWISE-RELATED E R E))))
   (SOME (B) (AND (IS-FUN B D (REL!DOM R)) (POINTWISE-RELATED E R B))))))
Which simplifies
 when rewriting with POINTWISE-RELATED-SELF
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-PO-BASIC
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
RAN-FN-ORDER
Beginning proof of RAN-FN-ORDER ...
(IMPLIES (IS-PO R) (= (REL!RAN (FN-ORDER D R)) (FN!FUN D (REL!DOM R))))
Applying SETRULES!EXTENSIONALITY gives ...
(IMPLIES (IS-PO R)
 (ALL (E)
  (IF (IN E (REL!RAN (FN-ORDER D R))) (IN E (FN!FUN D (REL!DOM R)))
   (NOT (IN E (FN!FUN D (REL!DOM R)))))))
Which simplifies
 when rewriting with IN-FUN, PAIR!IN-CROSS, FN-ORDER.DEFINITION, REL!IN-RAN
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
PAIR!PAIR-COMPOSITION, IS-PO-BASIC
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR to ...
(IMPLIES (IS-PO R)
 (ALL (E)
  (IF
   (SOME (A)
    (AND (IS-FUN A D (REL!DOM R)) (IS-FUN E D (REL!DOM R))
     (POINTWISE-RELATED A R E)))
   (IS-FUN E D (REL!DOM R)) (NOT (IS-FUN E D (REL!DOM R))))))
Instantiating (= A E) gives ...
(IMPLIES (IS-PO R)
 (ALL (E)
  (IF
   (OR
    (AND (IS-FUN E D (REL!DOM R)) (IS-FUN E D (REL!DOM R))
     (POINTWISE-RELATED E R E))
    (SOME (A)
     (AND (IS-FUN A D (REL!DOM R)) (IS-FUN E D (REL!DOM R))
      (POINTWISE-RELATED A R E))))
   (IS-FUN E D (REL!DOM R)) (NOT (IS-FUN E D (REL!DOM R))))))
Which simplifies
 when rewriting with POINTWISE-RELATED-SELF
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-PO-BASIC
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-TRANSITIVE-FN-ORDER
Beginning proof of IS-TRANSITIVE-FN-ORDER ...
(IMPLIES (IS-TRANSITIVE R) (= (IS-TRANSITIVE (FN-ORDER D R)) (TRUE)))
Invoking (IS-TRANSITIVE (FN-ORDER D R)) gives ...
(IMPLIES (IS-TRANSITIVE R)
 (ALL (X Y Z)
  (IMPLIES (AND (RELATED X (FN-ORDER D R) Y) (RELATED Y (FN-ORDER D R) Z))
   (RELATED X (FN-ORDER D R) Z))))
Which simplifies
 with invocation of POINTWISE-RELATED
 when rewriting with IN-FUN, RELATED-BY-FN-ORDER
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, RELATED-DOM-RAN
 with the assumptions APPLY-IN-NOMINAL-RANGE to ...
(IMPLIES (IS-TRANSITIVE R)
 (ALL (X Y Z)
  (IMPLIES
   (AND (IS-FUN X D (REL!DOM R)) (IS-FUN Y D (REL!DOM R))
    (ALL (X$0)
     (IMPLIES (IN X$0 (REL!DOM X))
      (RELATED (FN!APPLY X X$0) R (FN!APPLY Y X$0))))
    (IS-FUN Z D (REL!DOM R))
    (ALL (X$1)
     (IMPLIES (IN X$1 (REL!DOM Y))
      (RELATED (FN!APPLY Y X$1) R (FN!APPLY Z X$1)))))
   (ALL (X$2)
    (IMPLIES (IN X$2 (REL!DOM X))
     (RELATED (FN!APPLY X X$2) R (FN!APPLY Z X$2)))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-TRANSITIVE R) (IS-FUN X D (REL!DOM R)) (IS-FUN Y D (REL!DOM R))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM X))
    (RELATED (FN!APPLY X X$1) R (FN!APPLY Y X$1))))
  (IS-FUN Z D (REL!DOM R))
  (ALL (X$2)
   (IMPLIES (IN X$2 (REL!DOM Y))
    (RELATED (FN!APPLY Y X$2) R (FN!APPLY Z X$2))))
  (IN X$0 (REL!DOM X)))
 (RELATED (FN!APPLY X X$0) R (FN!APPLY Z X$0)))
Instantiating (= X$1 X$0) gives ...
(IMPLIES
 (AND (IS-TRANSITIVE R) (IS-FUN X D (REL!DOM R)) (IS-FUN Y D (REL!DOM R))
  (IMPLIES (IN X$0 (REL!DOM X)) (RELATED (FN!APPLY X X$0) R (FN!APPLY Y X$0)))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM X))
    (RELATED (FN!APPLY X X$1) R (FN!APPLY Y X$1))))
  (IS-FUN Z D (REL!DOM R))
  (ALL (X$2)
   (IMPLIES (IN X$2 (REL!DOM Y))
    (RELATED (FN!APPLY Y X$2) R (FN!APPLY Z X$2))))
  (IN X$0 (REL!DOM X)))
 (RELATED (FN!APPLY X X$0) R (FN!APPLY Z X$0)))
Instantiating (= X$2 X$0) gives ...
(IMPLIES
 (AND (IS-TRANSITIVE R) (IS-FUN X D (REL!DOM R)) (IS-FUN Y D (REL!DOM R))
  (IMPLIES (IN X$0 (REL!DOM X)) (RELATED (FN!APPLY X X$0) R (FN!APPLY Y X$0)))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM X))
    (RELATED (FN!APPLY X X$1) R (FN!APPLY Y X$1))))
  (IS-FUN Z D (REL!DOM R))
  (IMPLIES (IN X$0 (REL!DOM Y)) (RELATED (FN!APPLY Y X$0) R (FN!APPLY Z X$0)))
  (ALL (X$2)
   (IMPLIES (IN X$2 (REL!DOM Y))
    (RELATED (FN!APPLY Y X$2) R (FN!APPLY Z X$2))))
  (IN X$0 (REL!DOM X)))
 (RELATED (FN!APPLY X X$0) R (FN!APPLY Z X$0)))
Assuming TRANSITIVE with the
instantiations: (= R R) (= X (FN!APPLY X X$0)) (= Y (FN!APPLY Y X$0))
                (= Z (FN!APPLY Z X$0)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-TRANSITIVE R) (RELATED (FN!APPLY X X$0) R (FN!APPLY Y X$0))
    (RELATED (FN!APPLY Y X$0) R (FN!APPLY Z X$0)))
   (RELATED (FN!APPLY X X$0) R (FN!APPLY Z X$0)))
  (IS-TRANSITIVE R) (IS-FUN X D (REL!DOM R)) (IS-FUN Y D (REL!DOM R))
  (IMPLIES (IN X$0 (REL!DOM X)) (RELATED (FN!APPLY X X$0) R (FN!APPLY Y X$0)))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM X))
    (RELATED (FN!APPLY X X$1) R (FN!APPLY Y X$1))))
  (IS-FUN Z D (REL!DOM R))
  (IMPLIES (IN X$0 (REL!DOM Y)) (RELATED (FN!APPLY Y X$0) R (FN!APPLY Z X$0)))
  (ALL (X$2)
   (IMPLIES (IN X$2 (REL!DOM Y))
    (RELATED (FN!APPLY Y X$2) R (FN!APPLY Z X$2))))
  (IN X$0 (REL!DOM X)))
 (RELATED (FN!APPLY X X$0) R (FN!APPLY Z X$0)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, RELATED-DOM-RAN
 with the assumptions APPLY-IN-NOMINAL-RANGE to ...
(TRUE)
IS-PO-FN-ORDER
Beginning proof of IS-PO-FN-ORDER ...
(IMPLIES (IS-PO R) (= (IS-PO (FN-ORDER D R)) (TRUE)))
Invoking (IS-PO (FN-ORDER D R)) gives ...
(IMPLIES (IS-PO R)
 (AND (REL!IS-RELATION (FN-ORDER D R)) (IS-TRANSITIVE (FN-ORDER D R))
  (= (REL!DOM (FN-ORDER D R)) (REL!RAN (FN-ORDER D R)))
  (= (INTER (FN-ORDER D R) (REL!INVERSE (FN-ORDER D R)))
   (REL!ID (REL!DOM (FN-ORDER D R))))))
Which simplifies
 when rewriting with RAN-FN-ORDER, DOM-FN-ORDER, IS-TRANSITIVE-FN-ORDER,
IS-RELATION-FN-ORDER
 forward chaining using IS-PO-BASIC
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, REL!INVERSE-INVERSE, REL!IS-RELATION-BOOL to
...
(IMPLIES (IS-PO R)
 (= (INTER (FN-ORDER D R) (REL!INVERSE (FN-ORDER D R)))
  (REL!ID (FN!FUN D (REL!DOM R)))))
Applying SETRULES!EXTENSIONALITY gives ...
(IMPLIES (IS-PO R)
 (ALL (E)
  (IF (IN E (INTER (FN-ORDER D R) (REL!INVERSE (FN-ORDER D R))))
   (IN E (REL!ID (FN!FUN D (REL!DOM R))))
   (NOT (IN E (REL!ID (FN!FUN D (REL!DOM R))))))))
Which simplifies
 when rewriting with REL!IN-ID, REL!SND-FLIP-PAIR, REL!FST-FLIP-PAIR,
REL!IS-PAIR-FLIP-PAIR, REL!IN-INVERSE, IN-FUN, PAIR!IN-CROSS,
FN-ORDER.DEFINITION, INTER.DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
PAIR!PAIR-COMPOSITION, IS-PO-BASIC
 with the assumptions REL!FLIP-PAIR-IS-INVOLUTION, PAIR!IS-PAIR-BOOL,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
REL!INVERSE-INVERSE to ...
(IMPLIES (IS-PO R)
 (ALL (E)
  (IMPLIES
   (AND (PAIR!IS-PAIR E) (IS-FUN (PAIR!FST E) D (REL!DOM R))
    (IS-FUN (PAIR!SND E) D (REL!DOM R)))
   (IF (POINTWISE-RELATED (PAIR!FST E) R (PAIR!SND E))
    (IMPLIES (POINTWISE-RELATED (PAIR!SND E) R (PAIR!FST E))
     (= (PAIR!SND E) (PAIR!FST E)))
    (NOT (= (PAIR!SND E) (PAIR!FST E)))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-PO R) (PAIR!IS-PAIR E) (IS-FUN (PAIR!FST E) D (REL!DOM R))
  (IS-FUN (PAIR!SND E) D (REL!DOM R)))
 (IF (POINTWISE-RELATED (PAIR!FST E) R (PAIR!SND E))
  (IMPLIES (POINTWISE-RELATED (PAIR!SND E) R (PAIR!FST E))
   (= (PAIR!SND E) (PAIR!FST E)))
  (NOT (= (PAIR!SND E) (PAIR!FST E)))))
Assuming POINTWISE-RELATED-SELF with the
instantiations: (= F (PAIR!FST E)) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (PAIR!FST E)) (IS-PO R)
    (SUBSET (REL!RAN (PAIR!FST E)) (REL!DOM R)))
   (= (POINTWISE-RELATED (PAIR!FST E) R (PAIR!FST E)) (TRUE)))
  (IS-PO R) (PAIR!IS-PAIR E) (IS-FUN (PAIR!FST E) D (REL!DOM R))
  (IS-FUN (PAIR!SND E) D (REL!DOM R)))
 (IF (POINTWISE-RELATED (PAIR!FST E) R (PAIR!SND E))
  (IMPLIES (POINTWISE-RELATED (PAIR!SND E) R (PAIR!FST E))
   (= (PAIR!SND E) (PAIR!FST E)))
  (NOT (= (PAIR!SND E) (PAIR!FST E)))))
Which simplifies
 forward chaining using IS-FUN-FACTS, PAIR!PAIR-COMPOSITION, IS-PO-BASIC,
FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!IS-PAIR-BOOL, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION (PAIR!FST E)) (IS-PO R)
  (SUBSET (REL!RAN (PAIR!FST E)) (REL!DOM R))
  (POINTWISE-RELATED (PAIR!FST E) R (PAIR!FST E)) (PAIR!IS-PAIR E)
  (IS-FUN (PAIR!FST E) D (REL!DOM R)) (IS-FUN (PAIR!SND E) D (REL!DOM R))
  (POINTWISE-RELATED (PAIR!FST E) R (PAIR!SND E))
  (POINTWISE-RELATED (PAIR!SND E) R (PAIR!FST E)))
 (= (PAIR!SND E) (PAIR!FST E)))
Applying FN!FUNCTION-EXTENSIONALITY gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION (PAIR!FST E)) (IS-PO R)
  (SUBSET (REL!RAN (PAIR!FST E)) (REL!DOM R))
  (POINTWISE-RELATED (PAIR!FST E) R (PAIR!FST E)) (PAIR!IS-PAIR E)
  (IS-FUN (PAIR!FST E) D (REL!DOM R)) (IS-FUN (PAIR!SND E) D (REL!DOM R))
  (POINTWISE-RELATED (PAIR!FST E) R (PAIR!SND E))
  (POINTWISE-RELATED (PAIR!SND E) R (PAIR!FST E)))
 (IF (AND (FN!IS-FUNCTION (PAIR!SND E)) (FN!IS-FUNCTION (PAIR!FST E)))
  (AND (= (REL!DOM (PAIR!SND E)) (REL!DOM (PAIR!FST E)))
   (ALL (X)
    (IMPLIES (IN X (REL!DOM (PAIR!SND E)))
     (= (FN!APPLY (PAIR!SND E) X) (FN!APPLY (PAIR!FST E) X)))))
  (= (PAIR!SND E) (PAIR!FST E))))
Invoking POINTWISE-RELATED gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION (PAIR!FST E)) (IS-PO R)
  (SUBSET (REL!RAN (PAIR!FST E)) (REL!DOM R))
  (ALL (X)
   (IMPLIES (IN X (REL!DOM (PAIR!FST E)))
    (RELATED (FN!APPLY (PAIR!FST E) X) R (FN!APPLY (PAIR!FST E) X))))
  (PAIR!IS-PAIR E) (IS-FUN (PAIR!FST E) D (REL!DOM R))
  (IS-FUN (PAIR!SND E) D (REL!DOM R))
  (ALL (X$0)
   (IMPLIES (IN X$0 (REL!DOM (PAIR!FST E)))
    (RELATED (FN!APPLY (PAIR!FST E) X$0) R (FN!APPLY (PAIR!SND E) X$0))))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM (PAIR!SND E)))
    (RELATED (FN!APPLY (PAIR!SND E) X$1) R (FN!APPLY (PAIR!FST E) X$1)))))
 (IF (AND (FN!IS-FUNCTION (PAIR!SND E)) (FN!IS-FUNCTION (PAIR!FST E)))
  (AND (= (REL!DOM (PAIR!SND E)) (REL!DOM (PAIR!FST E)))
   (ALL (X$2)
    (IMPLIES (IN X$2 (REL!DOM (PAIR!SND E)))
     (= (FN!APPLY (PAIR!SND E) X$2) (FN!APPLY (PAIR!FST E) X$2)))))
  (= (PAIR!SND E) (PAIR!FST E))))
Which simplifies
 when rewriting with RELATED-PO-SELF
 forward chaining using IS-FUN-FACTS, PAIR!PAIR-COMPOSITION, RELATED-DOM-RAN,
IS-PO-BASIC, FN!FUNCTION-IS-RELATION
 with the assumptions APPLY-IN-NOMINAL-RANGE, PAIR!IS-PAIR-BOOL,
FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION (PAIR!FST E)) (IS-PO R)
  (SUBSET (REL!RAN (PAIR!FST E)) (REL!DOM R))
  (ALL (X)
   (IMPLIES (IN X (REL!DOM (PAIR!FST E)))
    (IN (FN!APPLY (PAIR!FST E) X) (REL!DOM R))))
  (PAIR!IS-PAIR E) (IS-FUN (PAIR!FST E) D (REL!DOM R))
  (IS-FUN (PAIR!SND E) D (REL!DOM R))
  (ALL (X$0)
   (IMPLIES (IN X$0 (REL!DOM (PAIR!FST E)))
    (RELATED (FN!APPLY (PAIR!FST E) X$0) R (FN!APPLY (PAIR!SND E) X$0))))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM (PAIR!SND E)))
    (RELATED (FN!APPLY (PAIR!SND E) X$1) R (FN!APPLY (PAIR!FST E) X$1)))))
 (ALL (X$2)
  (IMPLIES (IN X$2 (REL!DOM (PAIR!SND E)))
   (= (FN!APPLY (PAIR!SND E) X$2) (FN!APPLY (PAIR!FST E) X$2)))))
Instantiating (= X$0 X$2) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION (PAIR!FST E)) (IS-PO R)
  (SUBSET (REL!RAN (PAIR!FST E)) (REL!DOM R))
  (ALL (X$0)
   (IMPLIES (IN X$0 (REL!DOM (PAIR!FST E)))
    (IN (FN!APPLY (PAIR!FST E) X$0) (REL!DOM R))))
  (PAIR!IS-PAIR E) (IS-FUN (PAIR!FST E) D (REL!DOM R))
  (IS-FUN (PAIR!SND E) D (REL!DOM R))
  (IMPLIES (IN X (REL!DOM (PAIR!FST E)))
   (RELATED (FN!APPLY (PAIR!FST E) X) R (FN!APPLY (PAIR!SND E) X)))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM (PAIR!FST E)))
    (RELATED (FN!APPLY (PAIR!FST E) X$1) R (FN!APPLY (PAIR!SND E) X$1))))
  (ALL (X$2)
   (IMPLIES (IN X$2 (REL!DOM (PAIR!SND E)))
    (RELATED (FN!APPLY (PAIR!SND E) X$2) R (FN!APPLY (PAIR!FST E) X$2))))
  (IN X (REL!DOM (PAIR!SND E))))
 (= (FN!APPLY (PAIR!SND E) X) (FN!APPLY (PAIR!FST E) X)))
Instantiating (= X$2 X) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION (PAIR!FST E)) (IS-PO R)
  (SUBSET (REL!RAN (PAIR!FST E)) (REL!DOM R))
  (ALL (X$0)
   (IMPLIES (IN X$0 (REL!DOM (PAIR!FST E)))
    (IN (FN!APPLY (PAIR!FST E) X$0) (REL!DOM R))))
  (PAIR!IS-PAIR E) (IS-FUN (PAIR!FST E) D (REL!DOM R))
  (IS-FUN (PAIR!SND E) D (REL!DOM R))
  (IMPLIES (IN X (REL!DOM (PAIR!FST E)))
   (RELATED (FN!APPLY (PAIR!FST E) X) R (FN!APPLY (PAIR!SND E) X)))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM (PAIR!FST E)))
    (RELATED (FN!APPLY (PAIR!FST E) X$1) R (FN!APPLY (PAIR!SND E) X$1))))
  (IMPLIES (IN X (REL!DOM (PAIR!SND E)))
   (RELATED (FN!APPLY (PAIR!SND E) X) R (FN!APPLY (PAIR!FST E) X)))
  (ALL (X$2)
   (IMPLIES (IN X$2 (REL!DOM (PAIR!SND E)))
    (RELATED (FN!APPLY (PAIR!SND E) X$2) R (FN!APPLY (PAIR!FST E) X$2))))
  (IN X (REL!DOM (PAIR!SND E))))
 (= (FN!APPLY (PAIR!SND E) X) (FN!APPLY (PAIR!FST E) X)))
Which simplifies
 forward chaining using RELATED-DOM-RAN, IS-FUN-FACTS, PAIR!PAIR-COMPOSITION,
IS-PO-BASIC, FN!FUNCTION-IS-RELATION
 with the assumptions APPLY-IN-NOMINAL-RANGE, PAIR!IS-PAIR-BOOL,
FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION (PAIR!FST E)) (IS-PO R)
  (SUBSET (REL!RAN (PAIR!FST E)) (REL!DOM R))
  (ALL (X$0)
   (IMPLIES (IN X$0 (REL!DOM (PAIR!FST E)))
    (IN (FN!APPLY (PAIR!FST E) X$0) (REL!DOM R))))
  (PAIR!IS-PAIR E) (IS-FUN (PAIR!FST E) D (REL!DOM R))
  (IS-FUN (PAIR!SND E) D (REL!DOM R)) (IN X (REL!DOM (PAIR!FST E)))
  (RELATED (FN!APPLY (PAIR!FST E) X) R (FN!APPLY (PAIR!SND E) X))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM (PAIR!FST E)))
    (RELATED (FN!APPLY (PAIR!FST E) X$1) R (FN!APPLY (PAIR!SND E) X$1))))
  (RELATED (FN!APPLY (PAIR!SND E) X) R (FN!APPLY (PAIR!FST E) X))
  (ALL (X$2)
   (IMPLIES (IN X$2 (REL!DOM (PAIR!SND E)))
    (RELATED (FN!APPLY (PAIR!SND E) X$2) R (FN!APPLY (PAIR!FST E) X$2)))))
 (= (FN!APPLY (PAIR!SND E) X) (FN!APPLY (PAIR!FST E) X)))
Assuming PO-ASYMMETRY with the
instantiations: (= R R) (= X (FN!APPLY (PAIR!FST E) X))
                (= Y (FN!APPLY (PAIR!SND E) X)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PO R)
    (RELATED (FN!APPLY (PAIR!FST E) X) R (FN!APPLY (PAIR!SND E) X))
    (RELATED (FN!APPLY (PAIR!SND E) X) R (FN!APPLY (PAIR!FST E) X)))
   (= (FN!APPLY (PAIR!FST E) X) (FN!APPLY (PAIR!SND E) X)))
  (FN!IS-FUNCTION (PAIR!FST E)) (IS-PO R)
  (SUBSET (REL!RAN (PAIR!FST E)) (REL!DOM R))
  (ALL (X$0)
   (IMPLIES (IN X$0 (REL!DOM (PAIR!FST E)))
    (IN (FN!APPLY (PAIR!FST E) X$0) (REL!DOM R))))
  (PAIR!IS-PAIR E) (IS-FUN (PAIR!FST E) D (REL!DOM R))
  (IS-FUN (PAIR!SND E) D (REL!DOM R)) (IN X (REL!DOM (PAIR!FST E)))
  (RELATED (FN!APPLY (PAIR!FST E) X) R (FN!APPLY (PAIR!SND E) X))
  (ALL (X$1)
   (IMPLIES (IN X$1 (REL!DOM (PAIR!FST E)))
    (RELATED (FN!APPLY (PAIR!FST E) X$1) R (FN!APPLY (PAIR!SND E) X$1))))
  (RELATED (FN!APPLY (PAIR!SND E) X) R (FN!APPLY (PAIR!FST E) X))
  (ALL (X$2)
   (IMPLIES (IN X$2 (REL!DOM (PAIR!SND E)))
    (RELATED (FN!APPLY (PAIR!SND E) X$2) R (FN!APPLY (PAIR!FST E) X$2)))))
 (= (FN!APPLY (PAIR!SND E) X) (FN!APPLY (PAIR!FST E) X)))
Which simplifies
 forward chaining using IS-FUN-FACTS, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION, RELATED-DOM-RAN, IS-PO-BASIC
 with the assumptions APPLY-IN-NOMINAL-RANGE, PAIR!IS-PAIR-BOOL,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
CONST-FN
CONT-FN-IS-FUN
Beginning proof of CONT-FN-IS-FUN ...
(IS-FUN (CONST-FN D V) D (UNIT V))
Which simplifies
 with invocation of FN!IS-FUNCTION, IS-FUN, CONST-FN
 when rewriting with SETRULES!SUBSET-SETADD, SUBSET.NULLSET.LEFT,
REL!RAN-CROSS, SETRULES!SETADD-LEFT-EQUALITY-TEST, REL!DOM-CROSS,
NULLSET.DEFINITION, SETADD.DEFINITION, PAIR!IN-CROSS, REL!IS-RELATION-CROSS,
SETRULES!UNIT-TO-SETADD
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL to ...
(TRUE)
RAN-CONST-FUN
Beginning proof of RAN-CONST-FUN ...
(= (REL!RAN (CONST-FN D V)) (IF (= D (NULLSET)) (NULLSET) (UNIT V)))
Which simplifies
 with invocation of CONST-FN
 when rewriting with REL!RAN-CROSS, SETRULES!UNIT-TO-SETADD
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions CONT-FN-IS-FUN to ...
(TRUE)
APPLY-CONST-FN
Beginning proof of APPLY-CONST-FN ...
(IMPLIES (IN X D) (= (FN!APPLY (CONST-FN D V) X) V))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F (CONST-FN D V)) (= X X) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (CONST-FN D V)) (IN X (REL!DOM (CONST-FN D V))))
   (IN (PAIR!PAIR X (FN!APPLY (CONST-FN D V) X)) (CONST-FN D V)))
  (IN X D))
 (= (FN!APPLY (CONST-FN D V) X) V))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
APPLY-IN-NOMINAL-RANGE, FN!IS-FUNCTION-BOOL, CONT-FN-IS-FUN to ...
(IMPLIES
 (AND (IN X D) (IN (PAIR!PAIR X (FN!APPLY (CONST-FN D V) X)) (CONST-FN D V)))
 (= (FN!APPLY (CONST-FN D V) X) V))
Which simplifies
 with invocation of CONST-FN
 when rewriting with NULLSET.DEFINITION, SETADD.DEFINITION, PAIR!IN-CROSS,
SETRULES!UNIT-TO-SETADD
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, CONT-FN-IS-FUN to ...
(TRUE)
FN-ORDER-BOTTOM
Beginning proof of FN-ORDER-BOTTOM ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R))
 (IS-BOTTOM (CONST-FN D (BOTTOM R)) (FN-ORDER D R)))
Invoking IS-BOTTOM gives ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R))
 (AND (IN (CONST-FN D (BOTTOM R)) (REL!DOM (FN-ORDER D R)))
  (ALL (X)
   (IMPLIES (IN X (REL!DOM (FN-ORDER D R)))
    (RELATED (CONST-FN D (BOTTOM R)) (FN-ORDER D R) X)))))
Which simplifies
 when rewriting with RELATED-BY-FN-ORDER, IN-FUN, DOM-FN-ORDER
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-PO-BASIC
 with the assumptions CONT-FN-IS-FUN to ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R))
 (AND (IS-FUN (CONST-FN D (BOTTOM R)) D (REL!DOM R))
  (ALL (X)
   (IMPLIES (IS-FUN X D (REL!DOM R))
    (POINTWISE-RELATED (CONST-FN D (BOTTOM R)) R X)))))
Invoking POINTWISE-RELATED gives ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R))
 (AND (IS-FUN (CONST-FN D (BOTTOM R)) D (REL!DOM R))
  (ALL (X)
   (IMPLIES (IS-FUN X D (REL!DOM R))
    (ALL (X$0)
     (IMPLIES (IN X$0 (REL!DOM (CONST-FN D (BOTTOM R))))
      (RELATED (FN!APPLY (CONST-FN D (BOTTOM R)) X$0) R (FN!APPLY X X$0))))))))
Which simplifies
 when rewriting with BOTTOM-LESS, APPLY-CONST-FN
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-PO-BASIC
 with the assumptions APPLY-IN-NOMINAL-RANGE, CONT-FN-IS-FUN to ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R))
 (IS-FUN (CONST-FN D (BOTTOM R)) D (REL!DOM R)))
Invoking IS-FUN gives ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R))
 (AND (FN!IS-FUNCTION (CONST-FN D (BOTTOM R)))
  (= (REL!DOM (CONST-FN D (BOTTOM R))) D)
  (SUBSET (REL!RAN (CONST-FN D (BOTTOM R))) (REL!DOM R))))
Which simplifies
 when rewriting with BOTTOM-IN-DOM, SETRULES!SUBSET-SETADD,
SUBSET.NULLSET.LEFT, SETRULES!UNIT-TO-SETADD, RAN-CONST-FUN
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-PO-BASIC
 with the assumptions FN!IS-FUNCTION-BOOL, CONT-FN-IS-FUN to ...
(TRUE)
HAS-BOTTOM-FN-ORDER
Beginning proof of HAS-BOTTOM-FN-ORDER ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R)) (= (HAS-BOTTOM (FN-ORDER D R)) (TRUE)))
Invoking (HAS-BOTTOM (FN-ORDER D R)) gives ...
(IMPLIES (AND (IS-PO R) (HAS-BOTTOM R))
 (SOME (B) (IS-BOTTOM B (FN-ORDER D R))))
Instantiating (= B (CONST-FN D (BOTTOM R))) gives ...
(IMPLIES
 (AND (IS-PO R) (HAS-BOTTOM R)
  (NOT (IS-BOTTOM (CONST-FN D (BOTTOM R)) (FN-ORDER D R))))
 (SOME (B) (IS-BOTTOM B (FN-ORDER D R))))
Assuming FN-ORDER-BOTTOM with the instantiations: (= D D) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PO R) (HAS-BOTTOM R))
   (IS-BOTTOM (CONST-FN D (BOTTOM R)) (FN-ORDER D R)))
  (IS-PO R) (HAS-BOTTOM R)
  (NOT (IS-BOTTOM (CONST-FN D (BOTTOM R)) (FN-ORDER D R))))
 (SOME (B) (IS-BOTTOM B (FN-ORDER D R))))
Which simplifies
 forward chaining using IS-BOTTOM-IMPLIES-IN-DOM, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-PO-BASIC
 with the assumptions CONT-FN-IS-FUN to ...
(TRUE)
SECTION
IN-SECTION
Beginning proof of IN-SECTION ...
(= (IN P (SECTION F X))
 (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) (REL!DOM F))
  (= (PAIR!SND P) (FN!APPLY (FN!APPLY F (PAIR!FST P)) X))))
Splitting
on (AND (PAIR!IS-PAIR P)
    (AND (IN (PAIR!FST P) (REL!DOM F))
     (= (PAIR!SND P) (FN!APPLY (FN!APPLY F (PAIR!FST P)) X)))) generates
...
(IF
 (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) (REL!DOM F))
  (= (PAIR!SND P) (FN!APPLY (FN!APPLY F (PAIR!FST P)) X)))
 (= (IN P (SECTION F X))
  (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) (REL!DOM F))
   (= (PAIR!SND P) (FN!APPLY (FN!APPLY F (PAIR!FST P)) X))))
 (= (IN P (SECTION F X))
  (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) (REL!DOM F))
   (= (PAIR!SND P) (FN!APPLY (FN!APPLY F (PAIR!FST P)) X)))))
Which simplifies
 when rewriting with SECTION.DEFINITION
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PAIR!IS-PAIR-BOOL to ...
(IMPLIES
 (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) (REL!DOM F))
  (= (PAIR!SND P) (FN!APPLY (FN!APPLY F (PAIR!FST P)) X)))
 (=
  (SOME (N)
   (AND (IN N (REL!DOM F)) (= P (PAIR!PAIR N (FN!APPLY (FN!APPLY F N) X)))))
  (TRUE)))
Instantiating (= N (PAIR!FST P)) gives ...
(IMPLIES
 (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) (REL!DOM F))
  (= (PAIR!SND P) (FN!APPLY (FN!APPLY F (PAIR!FST P)) X))
  (NOT
   (AND (IN (PAIR!FST P) (REL!DOM F))
    (= P (PAIR!PAIR (PAIR!FST P) (FN!APPLY (FN!APPLY F (PAIR!FST P)) X))))))
 (SOME (N)
  (AND (IN N (REL!DOM F)) (= P (PAIR!PAIR N (FN!APPLY (FN!APPLY F N) X))))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PAIR!IS-PAIR-BOOL to ...
(TRUE)
IS-FUNCTION-SECTION
Beginning proof of IS-FUNCTION-SECTION ...
(= (FN!IS-FUNCTION (SECTION F X)) (TRUE))
Which simplifies
 with invocation of REL!IS-RELATION, FN!IS-FUNCTION
 when rewriting with IN-SECTION
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PAIR!IS-PAIR-BOOL, FN!IS-FUNCTION-BOOL to ...
(TRUE)
DOM-SECTION
Beginning proof of DOM-SECTION ...
(= (REL!DOM (SECTION F X)) (REL!DOM F))
Applying SETRULES!EXTENSIONALITY gives ...
(IF (IN E (REL!DOM (SECTION F X))) (IN E (REL!DOM F)) (NOT (IN E (REL!DOM F))))
Which simplifies
 when rewriting with IN-SECTION, REL!IN-DOM
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR to ...
(TRUE)
APPLY-SECTION
Beginning proof of APPLY-SECTION ...
(IMPLIES (IN N (REL!DOM F))
 (= (FN!APPLY (SECTION F X) N) (FN!APPLY (FN!APPLY F N) X)))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F (SECTION F X)) (= X N) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION (SECTION F X)) (IN N (REL!DOM (SECTION F X))))
   (IN (PAIR!PAIR N (FN!APPLY (SECTION F X) N)) (SECTION F X)))
  (IN N (REL!DOM F)))
 (= (FN!APPLY (SECTION F X) N) (FN!APPLY (FN!APPLY F N) X)))
Which simplifies
 when rewriting with IN-SECTION, DOM-SECTION, IS-FUNCTION-SECTION
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-FUN-SECTION
Beginning proof of IS-FUN-SECTION ...
(IMPLIES (AND (IS-FUN F D1 (FN!FUN D2 R)) (IN X D2))
 (IS-FUN (SECTION F X) D1 R))
Invoking (IS-FUN (SECTION F X) D1 R) gives ...
(IMPLIES (AND (IS-FUN F D1 (FN!FUN D2 R)) (IN X D2))
 (AND (FN!IS-FUNCTION (SECTION F X)) (= (REL!DOM (SECTION F X)) D1)
  (SUBSET (REL!RAN (SECTION F X)) R)))
Which simplifies
 with invocation of SUBSET
 when rewriting with IN-SECTION, REL!IN-RAN, DOM-SECTION, IS-FUNCTION-SECTION
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE, APPLY-IN-NOMINAL-RANGE-FUN,
PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
SECTION-IS-CHAIN
Beginning proof of SECTION-IS-CHAIN ...
(IMPLIES (AND (IS-CHAIN F (FN-ORDER D R)) (IN X D)) (IS-CHAIN (SECTION F X) R))
Invoking IS-CHAIN gives ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY F N) (FN-ORDER D R) (FN!APPLY F (+ 1 N)))))
  (IN X D))
 (AND (IS-FUN (SECTION F X) (NAT!NAT) (REL!DOM R))
  (ALL (N$0)
   (IMPLIES (IN N$0 (NAT!NAT))
    (RELATED (FN!APPLY (SECTION F X) N$0) R
     (FN!APPLY (SECTION F X) (+ 1 N$0)))))))
Starting case 2 ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY F N) (FN-ORDER D R) (FN!APPLY F (+ 1 N)))))
  (IN X D))
 (IS-FUN (SECTION F X) (NAT!NAT) (REL!DOM R)))
Invoking (IS-FUN (SECTION F X) (NAT!NAT) (REL!DOM R)) gives ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY F N) (FN-ORDER D R) (FN!APPLY F (+ 1 N)))))
  (IN X D))
 (AND (FN!IS-FUNCTION (SECTION F X)) (= (REL!DOM (SECTION F X)) (NAT!NAT))
  (SUBSET (REL!RAN (SECTION F X)) (REL!DOM R))))
Which simplifies
 with invocation of SUBSET
 when rewriting with APPLY-SECTION, FN!IN-RAN-FUNCTION, DOM-SECTION,
IS-FUNCTION-SECTION, IN-FUN, RELATED-BY-FN-ORDER, NAT!IN-NAT
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, APPLY-IN-NOMINAL-RANGE-NAT to ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
     (IS-FUN (FN!APPLY F (+ 1 N)) D (REL!DOM R))
     (POINTWISE-RELATED (FN!APPLY F N) R (FN!APPLY F (+ 1 N))))))
  (IN X D))
 (ALL (Y) (IMPLIES (>= Y 0) (IN (FN!APPLY (FN!APPLY F Y) X) (REL!DOM R)))))
Instantiating (= N Y) gives ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
  (IMPLIES (>= Y 0)
   (AND (IS-FUN (FN!APPLY F Y) D (REL!DOM R))
    (IS-FUN (FN!APPLY F (+ 1 Y)) D (REL!DOM R))
    (POINTWISE-RELATED (FN!APPLY F Y) R (FN!APPLY F (+ 1 Y)))))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
     (IS-FUN (FN!APPLY F (+ 1 N)) D (REL!DOM R))
     (POINTWISE-RELATED (FN!APPLY F N) R (FN!APPLY F (+ 1 N))))))
  (IN X D) (>= Y 0))
 (IN (FN!APPLY (FN!APPLY F Y) X) (REL!DOM R)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE, APPLY-IN-NOMINAL-RANGE-NAT to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY F N) (FN-ORDER D R) (FN!APPLY F (+ 1 N)))))
  (IN X D))
 (ALL (N$0)
  (IMPLIES (IN N$0 (NAT!NAT))
   (RELATED (FN!APPLY (SECTION F X) N$0) R
    (FN!APPLY (SECTION F X) (+ 1 N$0))))))
Which simplifies
 when rewriting with APPLY-SECTION, IN-FUN, RELATED-BY-FN-ORDER, NAT!IN-NAT
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT to ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
     (IS-FUN (FN!APPLY F (+ 1 N)) D (REL!DOM R))
     (POINTWISE-RELATED (FN!APPLY F N) R (FN!APPLY F (+ 1 N))))))
  (IN X D))
 (ALL (N$0)
  (IMPLIES (>= N$0 0)
   (RELATED (FN!APPLY (FN!APPLY F N$0) X) R
    (FN!APPLY (FN!APPLY F (+ 1 N$0)) X)))))
Invoking POINTWISE-RELATED gives ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
     (IS-FUN (FN!APPLY F (+ 1 N)) D (REL!DOM R))
     (ALL (X$0)
      (IMPLIES (IN X$0 (REL!DOM (FN!APPLY F N)))
       (RELATED (FN!APPLY (FN!APPLY F N) X$0) R
        (FN!APPLY (FN!APPLY F (+ 1 N)) X$0)))))))
  (IN X D))
 (ALL (N$0)
  (IMPLIES (>= N$0 0)
   (RELATED (FN!APPLY (FN!APPLY F N$0) X) R
    (FN!APPLY (FN!APPLY F (+ 1 N$0)) X)))))
Instantiating (= N N$0) gives ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
  (IMPLIES (>= N 0)
   (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
    (IS-FUN (FN!APPLY F (+ 1 N)) D (REL!DOM R))
    (ALL (X$0)
     (IMPLIES (IN X$0 (REL!DOM (FN!APPLY F N)))
      (RELATED (FN!APPLY (FN!APPLY F N) X$0) R
       (FN!APPLY (FN!APPLY F (+ 1 N)) X$0))))))
  (ALL (N$0)
   (IMPLIES (>= N$0 0)
    (AND (IS-FUN (FN!APPLY F N$0) D (REL!DOM R))
     (IS-FUN (FN!APPLY F (+ 1 N$0)) D (REL!DOM R))
     (ALL (X$1)
      (IMPLIES (IN X$1 (REL!DOM (FN!APPLY F N$0)))
       (RELATED (FN!APPLY (FN!APPLY F N$0) X$1) R
        (FN!APPLY (FN!APPLY F (+ 1 N$0)) X$1)))))))
  (IN X D) (>= N 0))
 (RELATED (FN!APPLY (FN!APPLY F N) X) R (FN!APPLY (FN!APPLY F (+ 1 N)) X)))
Which simplifies
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE, APPLY-IN-NOMINAL-RANGE-NAT
 with the instantiation (= X$0 X) to ...
(TRUE)
Completing all cases produces ...
(TRUE)
SECTION-IS-CHAIN-NAT
Beginning proof of SECTION-IS-CHAIN-NAT ...
(IMPLIES (AND (IS-CHAIN F (FN-ORDER (NAT!NAT) R)) (>= X 0))
 (IS-CHAIN (SECTION F X) R))
Assuming SECTION-IS-CHAIN with the
instantiations: (= F F) (= X X) (= D (NAT!NAT)) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-CHAIN F (FN-ORDER (NAT!NAT) R)) (IN X (NAT!NAT)))
   (IS-CHAIN (SECTION F X) R))
  (IS-CHAIN F (FN-ORDER (NAT!NAT) R)) (>= X 0))
 (IS-CHAIN (SECTION F X) R))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN to ...
(TRUE)
POINTWISE-LIMIT
IN-POINTWISE-LIMIT
Beginning proof of IN-POINTWISE-LIMIT ...
(= (IN P (POINTWISE-LIMIT F D R))
 (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) D)
  (= (PAIR!SND P) (LIMIT (SECTION F (PAIR!FST P)) R))))
Splitting
on (AND (PAIR!IS-PAIR P)
    (AND (IN (PAIR!FST P) D)
     (= (PAIR!SND P) (LIMIT (SECTION F (PAIR!FST P)) R)))) generates
...
(IF
 (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) D)
  (= (PAIR!SND P) (LIMIT (SECTION F (PAIR!FST P)) R)))
 (= (IN P (POINTWISE-LIMIT F D R))
  (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) D)
   (= (PAIR!SND P) (LIMIT (SECTION F (PAIR!FST P)) R))))
 (= (IN P (POINTWISE-LIMIT F D R))
  (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) D)
   (= (PAIR!SND P) (LIMIT (SECTION F (PAIR!FST P)) R)))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL to ...
(IF (PAIR!IS-PAIR P)
 (IF (IN (PAIR!FST P) D)
  (IF (= (PAIR!SND P) (LIMIT (SECTION F (PAIR!FST P)) R))
   (= (IN P (POINTWISE-LIMIT F D R)) (TRUE))
   (= (IN P (POINTWISE-LIMIT F D R)) (FALSE)))
  (= (IN P (POINTWISE-LIMIT F D R)) (FALSE)))
 (= (IN P (POINTWISE-LIMIT F D R)) (FALSE)))
Which simplifies
 when rewriting with POINTWISE-LIMIT.DEFINITION
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PAIR!IS-PAIR-BOOL to ...
(IMPLIES
 (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) D)
  (= (PAIR!SND P) (LIMIT (SECTION F (PAIR!FST P)) R)))
 (SOME (X) (AND (IN X D) (= P (PAIR!PAIR X (LIMIT (SECTION F X) R))))))
Instantiating (= X (PAIR!FST P)) gives ...
(IMPLIES
 (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) D)
  (= (PAIR!SND P) (LIMIT (SECTION F (PAIR!FST P)) R))
  (NOT
   (AND (IN (PAIR!FST P) D)
    (= P (PAIR!PAIR (PAIR!FST P) (LIMIT (SECTION F (PAIR!FST P)) R))))))
 (SOME (X) (AND (IN X D) (= P (PAIR!PAIR X (LIMIT (SECTION F X) R))))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PAIR!IS-PAIR-BOOL to ...
(TRUE)
IS-FUNCTION-POINTWISE-LIMIT
Beginning proof of IS-FUNCTION-POINTWISE-LIMIT ...
(FN!IS-FUNCTION (POINTWISE-LIMIT F D R))
Which simplifies
 with invocation of REL!IS-RELATION, FN!IS-FUNCTION
 when rewriting with IN-POINTWISE-LIMIT
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PAIR!IS-PAIR-BOOL, FN!IS-FUNCTION-BOOL to ...
(TRUE)
DOM-POINTWISE-LIMIT
Beginning proof of DOM-POINTWISE-LIMIT ...
(= (REL!DOM (POINTWISE-LIMIT F D R)) D)
Applying SETRULES!EXTENSIONALITY gives ...
(IF (IN E (REL!DOM (POINTWISE-LIMIT F D R))) (IN E D) (NOT (IN E D)))
Which simplifies
 when rewriting with IN-POINTWISE-LIMIT, REL!IN-DOM
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-FUNCTION-POINTWISE-LIMIT to ...
(TRUE)
APPLY-POINTWISE-LIMIT
Beginning proof of APPLY-POINTWISE-LIMIT ...
(IMPLIES (IN X D)
 (= (FN!APPLY (POINTWISE-LIMIT F D R) X) (LIMIT (SECTION F X) R)))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F (POINTWISE-LIMIT F D R)) (= X X) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (POINTWISE-LIMIT F D R))
    (IN X (REL!DOM (POINTWISE-LIMIT F D R))))
   (IN (PAIR!PAIR X (FN!APPLY (POINTWISE-LIMIT F D R) X))
    (POINTWISE-LIMIT F D R)))
  (IN X D))
 (= (FN!APPLY (POINTWISE-LIMIT F D R) X) (LIMIT (SECTION F X) R)))
Which simplifies
 when rewriting with IN-POINTWISE-LIMIT, DOM-POINTWISE-LIMIT
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IS-FUNCTION-POINTWISE-LIMIT to ...
(TRUE)
POINTWISE-LIMIT-IS-LIMIT
Beginning proof of POINTWISE-LIMIT-IS-LIMIT ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (IS-CHAIN-LIMIT F (POINTWISE-LIMIT F D R) (FN-ORDER D R)))
Invoking IS-CHAIN-LIMIT gives ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (AND (IS-CHAIN-BOUND F (POINTWISE-LIMIT F D R) (FN-ORDER D R))
  (ALL (B)
   (IMPLIES (IS-CHAIN-BOUND F B (FN-ORDER D R))
    (RELATED (POINTWISE-LIMIT F D R) (FN-ORDER D R) B)))))
Starting case 2 ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (IS-CHAIN-BOUND F (POINTWISE-LIMIT F D R) (FN-ORDER D R)))
Invoking IS-CHAIN-BOUND gives ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (AND (IS-CHAIN F (FN-ORDER D R))
  (IN (POINTWISE-LIMIT F D R) (REL!DOM (FN-ORDER D R)))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY F N) (FN-ORDER D R) (POINTWISE-LIMIT F D R))))))
Which simplifies
 when rewriting with RELATED-BY-FN-ORDER, NAT!IN-NAT, IS-FUN-SUBGOAL,
APPLY-POINTWISE-LIMIT, DOM-POINTWISE-LIMIT, IN-FUN, DOM-FN-ORDER
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, LIMIT-IN-DOM,
SECTION-IS-CHAIN, FN!IS-FUNCTION-BOOL, IS-FUNCTION-POINTWISE-LIMIT to ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (ALL (N)
  (IMPLIES (>= N 0)
   (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
    (POINTWISE-RELATED (FN!APPLY F N) R (POINTWISE-LIMIT F D R))))))
Invoking POINTWISE-RELATED gives ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (ALL (N)
  (IMPLIES (>= N 0)
   (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
    (ALL (X)
     (IMPLIES (IN X (REL!DOM (FN!APPLY F N)))
      (RELATED (FN!APPLY (FN!APPLY F N) X) R
       (FN!APPLY (POINTWISE-LIMIT F D R) X))))))))
Which simplifies
 when rewriting with APPLY-POINTWISE-LIMIT
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, SECTION-IS-CHAIN,
IS-FUNCTION-POINTWISE-LIMIT, APPLY-IN-NOMINAL-RANGE,
APPLY-IN-NOMINAL-RANGE-NAT to ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (ALL (N)
  (IMPLIES (>= N 0)
   (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
    (ALL (X)
     (IMPLIES (IN X (REL!DOM (FN!APPLY F N)))
      (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R))))))))
Prenexing produces ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)) (>= N 0))
 (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
  (IMPLIES (IN X (REL!DOM (FN!APPLY F N)))
   (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R)))))
Assuming LIMIT-IS-UPPER-BOUND with the
instantiations: (= F (SECTION F X)) (= R R) (= N N) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN (SECTION F X) R) (>= N 0))
   (= (RELATED (FN!APPLY (SECTION F X) N) R (LIMIT (SECTION F X) R)) (TRUE)))
  (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)) (>= N 0))
 (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
  (IMPLIES (IN X (REL!DOM (FN!APPLY F N)))
   (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R)))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R))
  (IMPLIES (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN (SECTION F X) R))
   (= (RELATED (FN!APPLY (SECTION F X) N) R (LIMIT (SECTION F X) R)) (TRUE))))
 (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
  (IMPLIES (IN X (REL!DOM (FN!APPLY F N)))
   (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R)))))
Splitting on (IN X D) generates ...
(IF (IN X D)
 (IMPLIES
  (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R))
   (IMPLIES (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN (SECTION F X) R))
    (= (RELATED (FN!APPLY (SECTION F X) N) R (LIMIT (SECTION F X) R))
     (TRUE))))
  (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
   (IMPLIES (IN X (REL!DOM (FN!APPLY F N)))
    (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R)))))
 (IMPLIES
  (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R))
   (IMPLIES (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN (SECTION F X) R))
    (= (RELATED (FN!APPLY (SECTION F X) N) R (LIMIT (SECTION F X) R))
     (TRUE))))
  (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
   (IMPLIES (IN X (REL!DOM (FN!APPLY F N)))
    (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R))))))
Which simplifies
 when rewriting with APPLY-SECTION, NAT!IN-NAT
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO, >=.SAME.TYPE
 with the assumptions APPLY-IN-NOMINAL-RANGE, LIMIT-IN-DOM,
APPLY-IN-NOMINAL-RANGE-NAT, SECTION-IS-CHAIN to ...
(IF (IN X D)
 (IMPLIES
  (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R))
   (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R)))
  (IS-FUN (FN!APPLY F N) D (REL!DOM R)))
 (IMPLIES (AND (>= N 0) (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
  (IF (IS-CHAIN (SECTION F X) R)
   (IMPLIES (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R))
    (IS-FUN (FN!APPLY F N) D (REL!DOM R)))
   (IS-FUN (FN!APPLY F N) D (REL!DOM R)))))
Invoking IS-CHAIN gives ...
(IF (IN X D)
 (IMPLIES
  (AND (>= N 0) (IS-COMPLETE-PO R)
   (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
   (ALL (N$0)
    (IMPLIES (IN N$0 (NAT!NAT))
     (RELATED (FN!APPLY F N$0) (FN-ORDER D R) (FN!APPLY F (+ 1 N$0)))))
   (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R)))
  (IS-FUN (FN!APPLY F N) D (REL!DOM R)))
 (IMPLIES
  (AND (>= N 0) (IS-COMPLETE-PO R)
   (IS-FUN F (NAT!NAT) (REL!DOM (FN-ORDER D R)))
   (ALL (N$1)
    (IMPLIES (IN N$1 (NAT!NAT))
     (RELATED (FN!APPLY F N$1) (FN-ORDER D R) (FN!APPLY F (+ 1 N$1))))))
  (IF
   (AND (IS-FUN (SECTION F X) (NAT!NAT) (REL!DOM R))
    (ALL (N$2)
     (IMPLIES (IN N$2 (NAT!NAT))
      (RELATED (FN!APPLY (SECTION F X) N$2) R
       (FN!APPLY (SECTION F X) (+ 1 N$2))))))
   (IMPLIES (RELATED (FN!APPLY (FN!APPLY F N) X) R (LIMIT (SECTION F X) R))
    (IS-FUN (FN!APPLY F N) D (REL!DOM R)))
   (IS-FUN (FN!APPLY F N) D (REL!DOM R)))))
Which simplifies
 when rewriting with APPLY-SECTION, RELATED-BY-FN-ORDER, NAT!IN-NAT,
DOM-FN-ORDER
 forward chaining using RELATED-DOM-RAN, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, IS-PO-BASIC, COMPLETE-PO-IS-PO, >=.SAME.TYPE
 with the assumptions IS-FUN-SECTION, APPLY-IN-NOMINAL-RANGE,
APPLY-IN-NOMINAL-RANGE-NAT, APPLY-IN-NOMINAL-RANGE-FUN-NAT to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (ALL (B)
  (IMPLIES (IS-CHAIN-BOUND F B (FN-ORDER D R))
   (RELATED (POINTWISE-LIMIT F D R) (FN-ORDER D R) B))))
Invoking IS-CHAIN-BOUND gives ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (ALL (B)
  (IMPLIES
   (AND (IS-CHAIN F (FN-ORDER D R)) (IN B (REL!DOM (FN-ORDER D R)))
    (ALL (N)
     (IMPLIES (IN N (NAT!NAT)) (RELATED (FN!APPLY F N) (FN-ORDER D R) B))))
   (RELATED (POINTWISE-LIMIT F D R) (FN-ORDER D R) B))))
Which simplifies
 when rewriting with IS-FUN-SUBGOAL, APPLY-POINTWISE-LIMIT,
DOM-POINTWISE-LIMIT, RELATED-BY-FN-ORDER, NAT!IN-NAT, IN-FUN, DOM-FN-ORDER
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, SECTION-IS-CHAIN, FN!IS-FUNCTION-BOOL,
IS-FUNCTION-POINTWISE-LIMIT, APPLY-IN-NOMINAL-RANGE-NAT to ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (ALL (B)
  (IMPLIES
   (AND (IS-FUN B D (REL!DOM R))
    (ALL (N)
     (IMPLIES (>= N 0)
      (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
       (POINTWISE-RELATED (FN!APPLY F N) R B)))))
   (POINTWISE-RELATED (POINTWISE-LIMIT F D R) R B))))
Invoking POINTWISE-RELATED gives ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (ALL (B)
  (IMPLIES
   (AND (IS-FUN B D (REL!DOM R))
    (ALL (N)
     (IMPLIES (>= N 0)
      (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
       (ALL (X)
        (IMPLIES (IN X (REL!DOM (FN!APPLY F N)))
         (RELATED (FN!APPLY (FN!APPLY F N) X) R (FN!APPLY B X))))))))
   (ALL (X$0)
    (IMPLIES (IN X$0 (REL!DOM (POINTWISE-LIMIT F D R)))
     (RELATED (FN!APPLY (POINTWISE-LIMIT F D R) X$0) R (FN!APPLY B X$0)))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)) (IS-FUN B D (REL!DOM R))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
     (ALL (X$0)
      (IMPLIES (IN X$0 (REL!DOM (FN!APPLY F N)))
       (RELATED (FN!APPLY (FN!APPLY F N) X$0) R (FN!APPLY B X$0)))))))
  (IN X (REL!DOM (POINTWISE-LIMIT F D R))))
 (RELATED (FN!APPLY (POINTWISE-LIMIT F D R) X) R (FN!APPLY B X)))
Which simplifies
 when rewriting with APPLY-SECTION, NAT!IN-NAT, LIMIT-BELOW,
APPLY-POINTWISE-LIMIT, DOM-POINTWISE-LIMIT
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, SECTION-IS-CHAIN,
IS-FUNCTION-POINTWISE-LIMIT, APPLY-IN-NOMINAL-RANGE,
APPLY-IN-NOMINAL-RANGE-NAT to ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)) (IS-FUN B D (REL!DOM R))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
     (ALL (X$0)
      (IMPLIES (IN X$0 (REL!DOM (FN!APPLY F N)))
       (RELATED (FN!APPLY (FN!APPLY F N) X$0) R (FN!APPLY B X$0)))))))
  (IN X D))
 (ALL (N$0)
  (IMPLIES (>= N$0 0)
   (RELATED (FN!APPLY (FN!APPLY F N$0) X) R (FN!APPLY B X)))))
Instantiating (= N N$0) (= X$0 X) gives ...
(IMPLIES
 (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)) (IS-FUN B D (REL!DOM R))
  (IMPLIES (>= N 0)
   (AND (IS-FUN (FN!APPLY F N) D (REL!DOM R))
    (IMPLIES (IN X (REL!DOM (FN!APPLY F N)))
     (RELATED (FN!APPLY (FN!APPLY F N) X) R (FN!APPLY B X)))))
  (ALL (N$0 X$0)
   (IMPLIES (>= N$0 0)
    (AND (IS-FUN (FN!APPLY F N$0) D (REL!DOM R))
     (IMPLIES (IN X$0 (REL!DOM (FN!APPLY F N$0)))
      (RELATED (FN!APPLY (FN!APPLY F N$0) X$0) R (FN!APPLY B X$0))))))
  (IN X D) (>= N 0))
 (RELATED (FN!APPLY (FN!APPLY F N) X) R (FN!APPLY B X)))
Which simplifies
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE, APPLY-IN-NOMINAL-RANGE-NAT to ...
(TRUE)
Completing all cases produces ...
(TRUE)
IS-FUN-POINTWISE-LIMIT
Beginning proof of IS-FUN-POINTWISE-LIMIT ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (IS-FUN (POINTWISE-LIMIT F D R) D (REL!DOM R)))
Assuming POINTWISE-LIMIT-IS-LIMIT with the
instantiations: (= F F) (= D D) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
   (IS-CHAIN-LIMIT F (POINTWISE-LIMIT F D R) (FN-ORDER D R)))
  (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (IS-FUN (POINTWISE-LIMIT F D R) D (REL!DOM R)))
Invoking IS-CHAIN-LIMIT gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
   (AND (IS-CHAIN-BOUND F (POINTWISE-LIMIT F D R) (FN-ORDER D R))
    (ALL (B)
     (IMPLIES (IS-CHAIN-BOUND F B (FN-ORDER D R))
      (RELATED (POINTWISE-LIMIT F D R) (FN-ORDER D R) B)))))
  (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (IS-FUN (POINTWISE-LIMIT F D R) D (REL!DOM R)))
Invoking IS-CHAIN-BOUND gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
   (AND (IS-CHAIN F (FN-ORDER D R))
    (IN (POINTWISE-LIMIT F D R) (REL!DOM (FN-ORDER D R)))
    (ALL (N)
     (IMPLIES (IN N (NAT!NAT))
      (RELATED (FN!APPLY F N) (FN-ORDER D R) (POINTWISE-LIMIT F D R))))
    (ALL (B)
     (IMPLIES
      (AND (IS-CHAIN F (FN-ORDER D R)) (IN B (REL!DOM (FN-ORDER D R)))
       (ALL (N$0)
        (IMPLIES (IN N$0 (NAT!NAT))
         (RELATED (FN!APPLY F N$0) (FN-ORDER D R) B))))
      (RELATED (POINTWISE-LIMIT F D R) (FN-ORDER D R) B)))))
  (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (IS-FUN (POINTWISE-LIMIT F D R) D (REL!DOM R)))
Which simplifies
 when rewriting with RELATED-BY-FN-ORDER, NAT!IN-NAT, IN-FUN, DOM-FN-ORDER
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, IS-FUNCTION-POINTWISE-LIMIT
 with the instantiation (= N N$0) to ...
(TRUE)
IS-FUN-POINTWISE-LIMIT-2
Beginning proof of IS-FUN-POINTWISE-LIMIT-2 ...
(IMPLIES
 (AND (IS-COMPLETE-PO R1) (IS-CHAIN F (FN-ORDER D R1)) (= R2 (REL!DOM R1)))
 (= (IS-FUN (POINTWISE-LIMIT F D R1) D R2) (TRUE)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN,
IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions IS-FUNCTION-POINTWISE-LIMIT, IS-FUN-POINTWISE-LIMIT to
...
(TRUE)
FUNCTION-ORDER-COMPLETE
Beginning proof of FUNCTION-ORDER-COMPLETE ...
(IMPLIES (IS-COMPLETE-PO R) (IS-COMPLETE-PO (FN-ORDER D R)))
Invoking (IS-COMPLETE-PO (FN-ORDER D R)) gives ...
(IMPLIES (IS-COMPLETE-PO R)
 (AND (IS-PO (FN-ORDER D R))
  (ALL (F)
   (IMPLIES (IS-CHAIN F (FN-ORDER D R))
    (SOME (B) (IS-CHAIN-LIMIT F B (FN-ORDER D R)))))))
Which simplifies
 when rewriting with IS-PO-FN-ORDER
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN,
IS-PO-BASIC, COMPLETE-PO-IS-PO to ...
(IMPLIES (IS-COMPLETE-PO R)
 (ALL (F)
  (IMPLIES (IS-CHAIN F (FN-ORDER D R))
   (SOME (B) (IS-CHAIN-LIMIT F B (FN-ORDER D R))))))
Prenexing produces ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (SOME (B) (IS-CHAIN-LIMIT F B (FN-ORDER D R))))
Assuming POINTWISE-LIMIT-IS-LIMIT with the
instantiations: (= F F) (= D D) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
   (IS-CHAIN-LIMIT F (POINTWISE-LIMIT F D R) (FN-ORDER D R)))
  (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (SOME (B) (IS-CHAIN-LIMIT F B (FN-ORDER D R))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN,
IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions IS-FUNCTION-POINTWISE-LIMIT, IS-FUN-POINTWISE-LIMIT
 with the instantiation (= B (POINTWISE-LIMIT F D R)) to ...
(TRUE)
FN-ORDER-LIMIT
Beginning proof of FN-ORDER-LIMIT ...
(IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (= (LIMIT F (FN-ORDER D R)) (POINTWISE-LIMIT F D R)))
Assuming CHAIN-LIMIT-UNIQUE with the
instantiations: (= F F) (= X (LIMIT F (FN-ORDER D R)))
                (= Y (POINTWISE-LIMIT F D R)) (= R (FN-ORDER D R)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PO (FN-ORDER D R))
    (IS-CHAIN-LIMIT F (LIMIT F (FN-ORDER D R)) (FN-ORDER D R))
    (IS-CHAIN-LIMIT F (POINTWISE-LIMIT F D R) (FN-ORDER D R)))
   (= (LIMIT F (FN-ORDER D R)) (POINTWISE-LIMIT F D R)))
  (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (= (LIMIT F (FN-ORDER D R)) (POINTWISE-LIMIT F D R)))
Assuming LIMIT-IS-CHAIN-LIMIT with the
instantiations: (= F F) (= R (FN-ORDER D R)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO (FN-ORDER D R)) (IS-CHAIN F (FN-ORDER D R)))
   (IS-CHAIN-LIMIT F (LIMIT F (FN-ORDER D R)) (FN-ORDER D R)))
  (IMPLIES
   (AND (IS-PO (FN-ORDER D R))
    (IS-CHAIN-LIMIT F (LIMIT F (FN-ORDER D R)) (FN-ORDER D R))
    (IS-CHAIN-LIMIT F (POINTWISE-LIMIT F D R) (FN-ORDER D R)))
   (= (LIMIT F (FN-ORDER D R)) (POINTWISE-LIMIT F D R)))
  (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (= (LIMIT F (FN-ORDER D R)) (POINTWISE-LIMIT F D R)))
Assuming POINTWISE-LIMIT-IS-LIMIT with the
instantiations: (= F F) (= D D) (= R R) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
   (IS-CHAIN-LIMIT F (POINTWISE-LIMIT F D R) (FN-ORDER D R)))
  (IMPLIES (AND (IS-COMPLETE-PO (FN-ORDER D R)) (IS-CHAIN F (FN-ORDER D R)))
   (IS-CHAIN-LIMIT F (LIMIT F (FN-ORDER D R)) (FN-ORDER D R)))
  (IMPLIES
   (AND (IS-PO (FN-ORDER D R))
    (IS-CHAIN-LIMIT F (LIMIT F (FN-ORDER D R)) (FN-ORDER D R))
    (IS-CHAIN-LIMIT F (POINTWISE-LIMIT F D R) (FN-ORDER D R)))
   (= (LIMIT F (FN-ORDER D R)) (POINTWISE-LIMIT F D R)))
  (IS-COMPLETE-PO R) (IS-CHAIN F (FN-ORDER D R)))
 (= (LIMIT F (FN-ORDER D R)) (POINTWISE-LIMIT F D R)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN,
IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, IS-FUNCTION-POINTWISE-LIMIT,
IS-FUN-POINTWISE-LIMIT, FUNCTION-ORDER-COMPLETE to ...
(TRUE)
PROCESS-TRACE-SETS
PROCESSES
IN-PROCESSES
Beginning proof of IN-PROCESSES ...
(= (IN X (PROCESSES A)) (AND (PR!IS-PROCESS X) (= (PR!PROCESS-ALPHABET X) A)))
Splitting on (IN X (PROCESSES A)) generates ...
(IF (IN X (PROCESSES A))
 (= (IN X (PROCESSES A))
  (AND (PR!IS-PROCESS X) (= (PR!PROCESS-ALPHABET X) A)))
 (= (IN X (PROCESSES A))
  (AND (PR!IS-PROCESS X) (= (PR!PROCESS-ALPHABET X) A))))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION
 with the assumptions PR!IS-PROCESS-BOOL to ...
(IF (IN X (PROCESSES A)) (AND (PR!IS-PROCESS X) (= (PR!PROCESS-ALPHABET X) A))
 (IMPLIES (PR!IS-PROCESS X) (NOT (= (PR!PROCESS-ALPHABET X) A))))
Which simplifies
 when rewriting with PR!MAKE-PROCESS-IS-PROCESS, POWERSET.DEFINITION,
PROCESS-TRACE-SETS.DEFINITION, PROCESSES.DEFINITION
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PR!PROCESS-COMPOSITION
 with the assumptions PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PR!IS-PROCESS-BOOL, PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS to ...
(IF
 (SOME (T)
  (AND (SUBSET T (TR!TRACE-OF A)) (IN (TR!EMPTY) T) (PR!PREFIX-CLOSED T)
   (= X (PR!MAKE-PROCESS A T))))
 (AND (PR!IS-PROCESS X) (= (PR!PROCESS-ALPHABET X) A))
 (IMPLIES (PR!IS-PROCESS X) (NOT (= (PR!PROCESS-ALPHABET X) A))))
Starting case 2 ...
(IMPLIES
 (SOME (T)
  (AND (SUBSET T (TR!TRACE-OF A)) (IN (TR!EMPTY) T) (PR!PREFIX-CLOSED T)
   (= X (PR!MAKE-PROCESS A T))))
 (AND (PR!IS-PROCESS X) (= (PR!PROCESS-ALPHABET X) A)))
Prenexing produces ...
(IMPLIES
 (AND (SUBSET T (TR!TRACE-OF A)) (IN (TR!EMPTY) T) (PR!PREFIX-CLOSED T)
  (= X (PR!MAKE-PROCESS A T)))
 (AND (PR!IS-PROCESS X) (= (PR!PROCESS-ALPHABET X) A)))
Substituting (= X (PR!MAKE-PROCESS A T)) produces ...
(IMPLIES
 (AND (SUBSET T (TR!TRACE-OF A)) (IN (TR!EMPTY) T) (PR!PREFIX-CLOSED T)
  (= X (PR!MAKE-PROCESS A T)))
 (AND (PR!IS-PROCESS (PR!MAKE-PROCESS A T))
  (= (PR!PROCESS-ALPHABET (PR!MAKE-PROCESS A T)) A)))
Which simplifies
 when rewriting with PR!MAKE-PROCESS-IS-PROCESS
 forward chaining using PR!PROCESS-COMPOSITION, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ
 with the assumptions PR!IS-PROCESS-BOOL, PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS, PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND
  (NOT
   (SOME (T)
    (AND (SUBSET T (TR!TRACE-OF A)) (IN (TR!EMPTY) T) (PR!PREFIX-CLOSED T)
     (= X (PR!MAKE-PROCESS A T)))))
  (PR!IS-PROCESS X))
 (NOT (= (PR!PROCESS-ALPHABET X) A)))
Instantiating (= T (PR!PROCESS-TRACES X)) gives ...
(IMPLIES
 (AND
  (NOT
   (OR
    (AND (SUBSET (PR!PROCESS-TRACES X) (TR!TRACE-OF A))
     (IN (TR!EMPTY) (PR!PROCESS-TRACES X))
     (PR!PREFIX-CLOSED (PR!PROCESS-TRACES X))
     (= X (PR!MAKE-PROCESS A (PR!PROCESS-TRACES X))))
    (SOME (T)
     (AND (SUBSET T (TR!TRACE-OF A)) (IN (TR!EMPTY) T) (PR!PREFIX-CLOSED T)
      (= X (PR!MAKE-PROCESS A T))))))
  (PR!IS-PROCESS X))
 (NOT (= (PR!PROCESS-ALPHABET X) A)))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ
 with the assumptions PR!IS-PROCESS-BOOL, PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS, PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY to ...
(IF (SUBSET (PR!PROCESS-TRACES X) (TR!TRACE-OF A))
 (IF (IN (TR!EMPTY) (PR!PROCESS-TRACES X))
  (IMPLIES
   (AND (NOT (PR!PREFIX-CLOSED (PR!PROCESS-TRACES X))) (PR!IS-PROCESS X))
   (NOT (= (PR!PROCESS-ALPHABET X) A)))
  (IMPLIES (PR!IS-PROCESS X) (NOT (= (PR!PROCESS-ALPHABET X) A))))
 (IMPLIES (PR!IS-PROCESS X) (NOT (= (PR!PROCESS-ALPHABET X) A))))
Assuming PR!MAKE-PROCESS-IS-PROCESS with the
instantiations: (= A (PR!PROCESS-ALPHABET X))
                (= T (PR!PROCESS-TRACES X)) generates
...
(IMPLIES
 (AND
  (=
   (PR!IS-PROCESS
    (PR!MAKE-PROCESS (PR!PROCESS-ALPHABET X) (PR!PROCESS-TRACES X)))
   (AND (SUBSET (PR!PROCESS-TRACES X) (TR!TRACE-OF (PR!PROCESS-ALPHABET X)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES X))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES X))))
  (IF (SUBSET (PR!PROCESS-TRACES X) (TR!TRACE-OF A))
   (IF (IN (TR!EMPTY) (PR!PROCESS-TRACES X))
    (AND (NOT (PR!PREFIX-CLOSED (PR!PROCESS-TRACES X))) (PR!IS-PROCESS X))
    (PR!IS-PROCESS X))
   (PR!IS-PROCESS X)))
 (NOT (= (PR!PROCESS-ALPHABET X) A)))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PR!PROCESS-COMPOSITION
 with the assumptions PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PR!IS-PROCESS-BOOL, PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS to ...
(TRUE)
Completing all cases produces ...
(TRUE)
APPLY-IS-PROCESS
Beginning proof of APPLY-IS-PROCESS ...
(IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IN X D))
 (PR!IS-PROCESS (FN!APPLY F X)))
Assuming APPLY-IN-NOMINAL-RANGE with the
instantiations: (= F F) (= X X) (= D D) (= R (PROCESSES A)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IN X D))
   (IN (FN!APPLY F X) (PROCESSES A)))
  (IS-FUN F D (PROCESSES A)) (IN X D))
 (PR!IS-PROCESS (FN!APPLY F X)))
Applying IN-PROCESSES gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IN X D))
   (AND (PR!IS-PROCESS (FN!APPLY F X))
    (= (PR!PROCESS-ALPHABET (FN!APPLY F X)) A)))
  (IS-FUN F D (PROCESSES A)) (IN X D))
 (PR!IS-PROCESS (FN!APPLY F X)))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE to ...
(TRUE)
PROCESS-ALPHABET-APPLY
Beginning proof of PROCESS-ALPHABET-APPLY ...
(IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IN X D))
 (= (PR!PROCESS-ALPHABET (FN!APPLY F X)) A))
Assuming APPLY-IN-NOMINAL-RANGE with the
instantiations: (= F F) (= X X) (= D D) (= R (PROCESSES A)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IN X D))
   (IN (FN!APPLY F X) (PROCESSES A)))
  (IS-FUN F D (PROCESSES A)) (IN X D))
 (= (PR!PROCESS-ALPHABET (FN!APPLY F X)) A))
Applying IN-PROCESSES gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IN X D))
   (AND (PR!IS-PROCESS (FN!APPLY F X))
    (= (PR!PROCESS-ALPHABET (FN!APPLY F X)) A)))
  (IS-FUN F D (PROCESSES A)) (IN X D))
 (= (PR!PROCESS-ALPHABET (FN!APPLY F X)) A))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE,
APPLY-IS-PROCESS to ...
(TRUE)
APPLY-IS-PROCESS-NAT
Beginning proof of APPLY-IS-PROCESS-NAT ...
(IMPLIES (AND (IS-FUN F (NAT!NAT) (PROCESSES A)) (>= X 0))
 (PR!IS-PROCESS (FN!APPLY F X)))
Assuming APPLY-IS-PROCESS with the
instantiations: (= F F) (= X X) (= D (NAT!NAT)) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-FUN F (NAT!NAT) (PROCESSES A)) (IN X (NAT!NAT)))
   (PR!IS-PROCESS (FN!APPLY F X)))
  (IS-FUN F (NAT!NAT) (PROCESSES A)) (>= X 0))
 (PR!IS-PROCESS (FN!APPLY F X)))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE-NAT to ...
(TRUE)
PROCESS-ALPHABET-APPLY-NAT
Beginning proof of PROCESS-ALPHABET-APPLY-NAT ...
(IMPLIES (AND (IS-FUN F (NAT!NAT) (PROCESSES A)) (>= X 0))
 (= (PR!PROCESS-ALPHABET (FN!APPLY F X)) A))
Assuming PROCESS-ALPHABET-APPLY with the
instantiations: (= F F) (= X X) (= D (NAT!NAT)) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-FUN F (NAT!NAT) (PROCESSES A)) (IN X (NAT!NAT)))
   (= (PR!PROCESS-ALPHABET (FN!APPLY F X)) A))
  (IS-FUN F (NAT!NAT) (PROCESSES A)) (>= X 0))
 (= (PR!PROCESS-ALPHABET (FN!APPLY F X)) A))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, APPLY-IS-PROCESS-NAT to ...
(TRUE)
PROCESS-PO
RELATED-BY-PROCESS-PO
Beginning proof of RELATED-BY-PROCESS-PO ...
(= (RELATED P1 (PROCESS-PO ALPHABET) P2)
 (AND (PR!IS-PROCESS P1) (= (PR!PROCESS-ALPHABET P1) ALPHABET)
  (PR!IS-PROCESS P2) (= (PR!PROCESS-ALPHABET P2) ALPHABET)
  (PR!PROCESS-INCLUDED P1 P2)))
Invoking RELATED gives ...
(= (IN (PAIR!PAIR P1 P2) (PROCESS-PO ALPHABET))
 (AND (PR!IS-PROCESS P1) (= (PR!PROCESS-ALPHABET P1) ALPHABET)
  (PR!IS-PROCESS P2) (= (PR!PROCESS-ALPHABET P2) ALPHABET)
  (PR!PROCESS-INCLUDED P1 P2)))
Which simplifies
 when rewriting with IN-PROCESSES, PAIR!IN-CROSS, PROCESS-PO.DEFINITION
 forward chaining using PR!PROCESS-COMPOSITION, PAIR!PAIR-COMPOSITION
 with the assumptions PR!IS-PROCESS-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
DOM-PROCESS-PO
Beginning proof of DOM-PROCESS-PO ...
(= (REL!DOM (PROCESS-PO A)) (PROCESSES A))
Applying SETRULES!EXTENSIONALITY gives ...
(IF (IN E (REL!DOM (PROCESS-PO A))) (IN E (PROCESSES A))
 (NOT (IN E (PROCESSES A))))
Which simplifies
 when rewriting with IN-PROCESSES, PAIR!IN-CROSS, PROCESS-PO.DEFINITION,
REL!IN-DOM
 forward chaining using PR!PROCESS-COMPOSITION, PAIR!PAIR-COMPOSITION
 with the assumptions PR!IS-PROCESS-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(IMPLIES (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) A))
 (SOME (B)
  (AND (PR!IS-PROCESS B) (= (PR!PROCESS-ALPHABET B) A)
   (PR!PROCESS-INCLUDED E B))))
Instantiating (= B E) gives ...
(IMPLIES
 (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) A)
  (NOT
   (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) A)
    (PR!PROCESS-INCLUDED E E))))
 (SOME (B)
  (AND (PR!IS-PROCESS B) (= (PR!PROCESS-ALPHABET B) A)
   (PR!PROCESS-INCLUDED E B))))
Assuming PR!PROCESS-INCLUDED-REFLEXIVE with the
instantiations: (= P E) generates ...
(IMPLIES
 (AND (PR!PROCESS-INCLUDED E E) (PR!IS-PROCESS E)
  (= (PR!PROCESS-ALPHABET E) A)
  (NOT
   (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) A)
    (PR!PROCESS-INCLUDED E E))))
 (SOME (B)
  (AND (PR!IS-PROCESS B) (= (PR!PROCESS-ALPHABET B) A)
   (PR!PROCESS-INCLUDED E B))))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION
 with the assumptions PR!IS-PROCESS-BOOL to ...
(TRUE)
RAN-PROCESS-PO
Beginning proof of RAN-PROCESS-PO ...
(= (REL!RAN (PROCESS-PO A)) (PROCESSES A))
Applying SETRULES!EXTENSIONALITY gives ...
(IF (IN E (REL!RAN (PROCESS-PO A))) (IN E (PROCESSES A))
 (NOT (IN E (PROCESSES A))))
Which simplifies
 when rewriting with IN-PROCESSES, PAIR!IN-CROSS, PROCESS-PO.DEFINITION,
REL!IN-RAN
 forward chaining using PR!PROCESS-COMPOSITION, PAIR!PAIR-COMPOSITION
 with the assumptions PR!IS-PROCESS-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(IF
 (SOME (A$0)
  (AND (PR!IS-PROCESS A$0) (= (PR!PROCESS-ALPHABET A$0) A) (PR!IS-PROCESS E)
   (= (PR!PROCESS-ALPHABET E) A) (PR!PROCESS-INCLUDED A$0 E)))
 (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) A))
 (IMPLIES (PR!IS-PROCESS E) (NOT (= (PR!PROCESS-ALPHABET E) A))))
Instantiating (= A$0 E) gives ...
(IF
 (OR
  (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) A) (PR!IS-PROCESS E)
   (= (PR!PROCESS-ALPHABET E) A) (PR!PROCESS-INCLUDED E E))
  (SOME (A$0)
   (AND (PR!IS-PROCESS A$0) (= (PR!PROCESS-ALPHABET A$0) A) (PR!IS-PROCESS E)
    (= (PR!PROCESS-ALPHABET E) A) (PR!PROCESS-INCLUDED A$0 E))))
 (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) A))
 (IMPLIES (PR!IS-PROCESS E) (NOT (= (PR!PROCESS-ALPHABET E) A))))
Assuming PR!PROCESS-INCLUDED-REFLEXIVE with the
instantiations: (= P E) generates ...
(IMPLIES (PR!PROCESS-INCLUDED E E)
 (IF
  (OR
   (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) A) (PR!IS-PROCESS E)
    (= (PR!PROCESS-ALPHABET E) A) (PR!PROCESS-INCLUDED E E))
   (SOME (A$0)
    (AND (PR!IS-PROCESS A$0) (= (PR!PROCESS-ALPHABET A$0) A) (PR!IS-PROCESS E)
     (= (PR!PROCESS-ALPHABET E) A) (PR!PROCESS-INCLUDED A$0 E))))
  (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) A))
  (IMPLIES (PR!IS-PROCESS E) (NOT (= (PR!PROCESS-ALPHABET E) A)))))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION
 with the assumptions PR!IS-PROCESS-BOOL to ...
(TRUE)
PROCESS-PO-IS-PO
Beginning proof of PROCESS-PO-IS-PO ...
(IS-PO (PROCESS-PO A))
Invoking IS-PO gives ...
(AND (REL!IS-RELATION (PROCESS-PO A)) (IS-TRANSITIVE (PROCESS-PO A))
 (= (REL!DOM (PROCESS-PO A)) (REL!RAN (PROCESS-PO A)))
 (= (INTER (PROCESS-PO A) (REL!INVERSE (PROCESS-PO A)))
  (REL!ID (REL!DOM (PROCESS-PO A)))))
Which simplifies
 with invocation of REL!IS-RELATION
 when rewriting with RAN-PROCESS-PO, DOM-PROCESS-PO, IN-PROCESSES,
PAIR!IN-CROSS, PROCESS-PO.DEFINITION
 forward chaining using PR!PROCESS-COMPOSITION, PAIR!PAIR-COMPOSITION
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, REL!INVERSE-INVERSE, PR!IS-PROCESS-BOOL,
PAIR!IS-PAIR-BOOL, REL!IS-RELATION-BOOL to ...
(AND (IS-TRANSITIVE (PROCESS-PO A))
 (= (INTER (PROCESS-PO A) (REL!INVERSE (PROCESS-PO A)))
  (REL!ID (PROCESSES A))))
Starting case 2 ...
(IS-TRANSITIVE (PROCESS-PO A))
Which simplifies
 with invocation of IS-TRANSITIVE
 when rewriting with RELATED-BY-PROCESS-PO
 forward chaining using PR!PROCESS-COMPOSITION, RELATED-DOM-RAN
 with the assumptions PR!IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (PR!IS-PROCESS X) (= (PR!PROCESS-ALPHABET X) A) (PR!IS-PROCESS Y)
  (= (PR!PROCESS-ALPHABET Y) A) (PR!PROCESS-INCLUDED X Y) (PR!IS-PROCESS Z)
  (= (PR!PROCESS-ALPHABET Z) A) (PR!PROCESS-INCLUDED Y Z))
 (PR!PROCESS-INCLUDED X Z))
Assuming PR!PROCESS-INCLUDED-TRANSITIVE with the
instantiations: (= P1 X) (= P2 Y) (= P3 Z) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (PR!PROCESS-INCLUDED X Y) (PR!PROCESS-INCLUDED Y Z))
   (PR!PROCESS-INCLUDED X Z))
  (PR!IS-PROCESS X) (= (PR!PROCESS-ALPHABET X) A) (PR!IS-PROCESS Y)
  (= (PR!PROCESS-ALPHABET Y) A) (PR!PROCESS-INCLUDED X Y) (PR!IS-PROCESS Z)
  (= (PR!PROCESS-ALPHABET Z) A) (PR!PROCESS-INCLUDED Y Z))
 (PR!PROCESS-INCLUDED X Z))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION
 with the assumptions PR!IS-PROCESS-BOOL to ...
(TRUE)
Starting case 1 ...
(= (INTER (PROCESS-PO A) (REL!INVERSE (PROCESS-PO A))) (REL!ID (PROCESSES A)))
Applying SETRULES!EXTENSIONALITY gives ...
(IF (IN E (INTER (PROCESS-PO A) (REL!INVERSE (PROCESS-PO A))))
 (IN E (REL!ID (PROCESSES A))) (NOT (IN E (REL!ID (PROCESSES A)))))
Which simplifies
 when rewriting with REL!IN-ID, REL!SND-FLIP-PAIR, REL!FST-FLIP-PAIR,
REL!IS-PAIR-FLIP-PAIR, REL!IN-INVERSE, IN-PROCESSES, PAIR!IN-CROSS,
PROCESS-PO.DEFINITION, INTER.DEFINITION
 forward chaining using PR!PROCESS-COMPOSITION, PAIR!PAIR-COMPOSITION
 with the assumptions REL!FLIP-PAIR-IS-INVOLUTION, PR!IS-PROCESS-BOOL,
PAIR!IS-PAIR-BOOL, SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, REL!INVERSE-INVERSE to ...
(IMPLIES
 (AND (PAIR!IS-PAIR E) (PR!IS-PROCESS (PAIR!FST E))
  (= (PR!PROCESS-ALPHABET (PAIR!FST E)) A) (PR!IS-PROCESS (PAIR!SND E))
  (= (PR!PROCESS-ALPHABET (PAIR!SND E)) A))
 (IF (PR!PROCESS-INCLUDED (PAIR!FST E) (PAIR!SND E))
  (IMPLIES (PR!PROCESS-INCLUDED (PAIR!SND E) (PAIR!FST E))
   (= (PAIR!SND E) (PAIR!FST E)))
  (NOT (= (PAIR!SND E) (PAIR!FST E)))))
Assuming PR!PROCESS-INCLUDED-REFLEXIVE with the
instantiations: (= P (PAIR!FST E)) generates ...
(IMPLIES
 (AND (PR!PROCESS-INCLUDED (PAIR!FST E) (PAIR!FST E)) (PAIR!IS-PAIR E)
  (PR!IS-PROCESS (PAIR!FST E)) (= (PR!PROCESS-ALPHABET (PAIR!FST E)) A)
  (PR!IS-PROCESS (PAIR!SND E)) (= (PR!PROCESS-ALPHABET (PAIR!SND E)) A))
 (IF (PR!PROCESS-INCLUDED (PAIR!FST E) (PAIR!SND E))
  (IMPLIES (PR!PROCESS-INCLUDED (PAIR!SND E) (PAIR!FST E))
   (= (PAIR!SND E) (PAIR!FST E)))
  (NOT (= (PAIR!SND E) (PAIR!FST E)))))
Assuming PR!PROCESS-INCLUDED-ANTI-SYMMETRIC with the
instantiations: (= P1 (PAIR!FST E)) (= P2 (PAIR!SND E)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (PR!IS-PROCESS (PAIR!FST E)) (PR!IS-PROCESS (PAIR!SND E))
    (PR!PROCESS-INCLUDED (PAIR!FST E) (PAIR!SND E))
    (PR!PROCESS-INCLUDED (PAIR!SND E) (PAIR!FST E)))
   (= (PAIR!FST E) (PAIR!SND E)))
  (PR!PROCESS-INCLUDED (PAIR!FST E) (PAIR!FST E)) (PAIR!IS-PAIR E)
  (PR!IS-PROCESS (PAIR!FST E)) (= (PR!PROCESS-ALPHABET (PAIR!FST E)) A)
  (PR!IS-PROCESS (PAIR!SND E)) (= (PR!PROCESS-ALPHABET (PAIR!SND E)) A))
 (IF (PR!PROCESS-INCLUDED (PAIR!FST E) (PAIR!SND E))
  (IMPLIES (PR!PROCESS-INCLUDED (PAIR!SND E) (PAIR!FST E))
   (= (PAIR!SND E) (PAIR!FST E)))
  (NOT (= (PAIR!SND E) (PAIR!FST E)))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION, PR!PROCESS-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, PR!IS-PROCESS-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
PROCESS-PO-BOTTOM
Beginning proof of PROCESS-PO-BOTTOM ...
(IS-BOTTOM (PR!STOP A) (PROCESS-PO A))
Invoking IS-BOTTOM gives ...
(AND (IN (PR!STOP A) (REL!DOM (PROCESS-PO A)))
 (ALL (X)
  (IMPLIES (IN X (REL!DOM (PROCESS-PO A)))
   (RELATED (PR!STOP A) (PROCESS-PO A) X))))
Which simplifies
 when rewriting with PR!STOP-IS-LEAST, RELATED-BY-PROCESS-PO,
PR!PROCESS-ALPHABET-STOP, IN-PROCESSES, DOM-PROCESS-PO
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC, PR!PROCESS-COMPOSITION
 with the assumptions PR!IS-PROCESS-BOOL, PROCESS-PO-IS-PO,
PR!IS-PROCESS-STOP to ...
(TRUE)
HAS-BOTTOM-PROCESS-PO
Beginning proof of HAS-BOTTOM-PROCESS-PO ...
(HAS-BOTTOM (PROCESS-PO A))
Assuming PROCESS-PO-BOTTOM with the instantiations: (= A A) generates ...
(IMPLIES (IS-BOTTOM (PR!STOP A) (PROCESS-PO A)) (HAS-BOTTOM (PROCESS-PO A)))
Invoking HAS-BOTTOM gives ...
(IMPLIES (IS-BOTTOM (PR!STOP A) (PROCESS-PO A))
 (SOME (B) (IS-BOTTOM B (PROCESS-PO A))))
Which simplifies
 forward chaining using IS-BOTTOM-IMPLIES-IN-DOM, IS-PO-BASIC,
PR!PROCESS-COMPOSITION
 with the assumptions PROCESS-PO-IS-PO, PR!IS-PROCESS-STOP
 with the instantiation (= B (PR!STOP A)) to ...
(TRUE)
BOTTOM-PROCESS-PO
Beginning proof of BOTTOM-PROCESS-PO ...
(= (BOTTOM (PROCESS-PO A)) (PR!STOP A))
Assuming PROCESS-PO-BOTTOM with the instantiations: (= A A) generates ...
(IMPLIES (IS-BOTTOM (PR!STOP A) (PROCESS-PO A))
 (= (BOTTOM (PROCESS-PO A)) (PR!STOP A)))
Assuming BOTTOM-UNIQUE with the
instantiations: (= R (PROCESS-PO A)) (= B1 (PR!STOP A))
                (= B2 (BOTTOM (PROCESS-PO A))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PO (PROCESS-PO A)) (IS-BOTTOM (PR!STOP A) (PROCESS-PO A))
    (IS-BOTTOM (BOTTOM (PROCESS-PO A)) (PROCESS-PO A)))
   (= (PR!STOP A) (BOTTOM (PROCESS-PO A))))
  (IS-BOTTOM (PR!STOP A) (PROCESS-PO A)))
 (= (BOTTOM (PROCESS-PO A)) (PR!STOP A)))
Which simplifies
 when rewriting with BOTTOM-IS-BOTTOM
 forward chaining using IS-BOTTOM-IMPLIES-IN-DOM, PR!PROCESS-COMPOSITION,
IS-PO-BASIC
 with the assumptions PR!IS-PROCESS-STOP, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO to ...
(TRUE)
PROCESS-CHAIN-BRIDGE
Beginning proof of PROCESS-CHAIN-BRIDGE ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A)) (= (PR!IS-PROCESS-CHAIN F) (TRUE)))
Invoking PR!IS-PROCESS-CHAIN gives ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (NAT!NAT))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (PR!PROCESS-INCLUDED (FN!APPLY F N) (FN!APPLY F (+ N 1)))))))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, FN!IS-FUNCTION-BOOL,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO to ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (ALL (N)
  (IMPLIES (>= N 0)
   (PR!PROCESS-INCLUDED (FN!APPLY F N) (FN!APPLY F (+ 1 N))))))
Invoking IS-CHAIN gives ...
(IMPLIES
 (AND (IS-FUN F (NAT!NAT) (REL!DOM (PROCESS-PO A)))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY F N) (PROCESS-PO A) (FN!APPLY F (+ 1 N))))))
 (ALL (N$0)
  (IMPLIES (>= N$0 0)
   (PR!PROCESS-INCLUDED (FN!APPLY F N$0) (FN!APPLY F (+ 1 N$0))))))
Which simplifies
 when rewriting with RELATED-BY-PROCESS-PO, NAT!IN-NAT, DOM-PROCESS-PO
 forward chaining using RELATED-DOM-RAN, PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-PO-BASIC
 with the assumptions PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO
 with the instantiation (= N N$0) to ...
(TRUE)
IS-PROCESS-APPLY-PROCESS-CHAIN
Beginning proof of IS-PROCESS-APPLY-PROCESS-CHAIN ...
(IMPLIES (AND (>= N 0) (IS-CHAIN F (PROCESS-PO A)))
 (= (PR!IS-PROCESS (FN!APPLY F N)) (TRUE)))
Invoking IS-CHAIN gives ...
(IMPLIES
 (AND (>= N 0) (IS-FUN F (NAT!NAT) (REL!DOM (PROCESS-PO A)))
  (ALL (N$0)
   (IMPLIES (IN N$0 (NAT!NAT))
    (RELATED (FN!APPLY F N$0) (PROCESS-PO A) (FN!APPLY F (+ 1 N$0))))))
 (PR!IS-PROCESS (FN!APPLY F N)))
Assuming APPLY-IN-NOMINAL-RANGE with the
instantiations: (= F F) (= D (NAT!NAT)) (= R (REL!DOM (PROCESS-PO A)))
                (= X N) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-FUN F (NAT!NAT) (REL!DOM (PROCESS-PO A))) (IN N (NAT!NAT)))
   (IN (FN!APPLY F N) (REL!DOM (PROCESS-PO A))))
  (>= N 0) (IS-FUN F (NAT!NAT) (REL!DOM (PROCESS-PO A)))
  (ALL (N$0)
   (IMPLIES (IN N$0 (NAT!NAT))
    (RELATED (FN!APPLY F N$0) (PROCESS-PO A) (FN!APPLY F (+ 1 N$0))))))
 (PR!IS-PROCESS (FN!APPLY F N)))
Which simplifies
 when rewriting with RELATED-BY-PROCESS-PO, NAT!IN-NAT, DOM-PROCESS-PO
 forward chaining using RELATED-DOM-RAN, PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-PO-BASIC
 with the assumptions PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO to ...
(TRUE)
ALPHABET-APPLY-PROCESS-CHAIN
Beginning proof of ALPHABET-APPLY-PROCESS-CHAIN ...
(IMPLIES (AND (>= N 0) (IS-CHAIN F (PROCESS-PO A)))
 (= (PR!PROCESS-ALPHABET (FN!APPLY F N)) A))
Invoking IS-CHAIN gives ...
(IMPLIES
 (AND (>= N 0) (IS-FUN F (NAT!NAT) (REL!DOM (PROCESS-PO A)))
  (ALL (N$0)
   (IMPLIES (IN N$0 (NAT!NAT))
    (RELATED (FN!APPLY F N$0) (PROCESS-PO A) (FN!APPLY F (+ 1 N$0))))))
 (= (PR!PROCESS-ALPHABET (FN!APPLY F N)) A))
Assuming APPLY-IN-NOMINAL-RANGE with the
instantiations: (= F F) (= D (NAT!NAT)) (= R (REL!DOM (PROCESS-PO A)))
                (= X N) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-FUN F (NAT!NAT) (REL!DOM (PROCESS-PO A))) (IN N (NAT!NAT)))
   (IN (FN!APPLY F N) (REL!DOM (PROCESS-PO A))))
  (>= N 0) (IS-FUN F (NAT!NAT) (REL!DOM (PROCESS-PO A)))
  (ALL (N$0)
   (IMPLIES (IN N$0 (NAT!NAT))
    (RELATED (FN!APPLY F N$0) (PROCESS-PO A) (FN!APPLY F (+ 1 N$0))))))
 (= (PR!PROCESS-ALPHABET (FN!APPLY F N)) A))
Which simplifies
 when rewriting with RELATED-BY-PROCESS-PO, NAT!IN-NAT, DOM-PROCESS-PO
 forward chaining using RELATED-DOM-RAN, PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-PO-BASIC
 with the assumptions PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO to ...
(TRUE)
IS-PROCESS-FACTS
Beginning proof of IS-PROCESS-FACTS ...
(IMPLIES (PR!IS-PROCESS P)
 (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
  (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
  (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
Assuming PR!PROCESS-COMPOSITION with the instantiations: (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES (PR!IS-PROCESS P)
   (= (PR!MAKE-PROCESS (PR!PROCESS-ALPHABET P) (PR!PROCESS-TRACES P)) P))
  (PR!IS-PROCESS P))
 (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
  (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
  (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
Assuming PR!MAKE-PROCESS-IS-PROCESS with the
instantiations: (= A (PR!PROCESS-ALPHABET P))
                (= T (PR!PROCESS-TRACES P)) generates
...
(IMPLIES
 (AND
  (=
   (PR!IS-PROCESS
    (PR!MAKE-PROCESS (PR!PROCESS-ALPHABET P) (PR!PROCESS-TRACES P)))
   (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
  (IMPLIES (PR!IS-PROCESS P)
   (= (PR!MAKE-PROCESS (PR!PROCESS-ALPHABET P) (PR!PROCESS-TRACES P)) P))
  (PR!IS-PROCESS P))
 (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
  (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
  (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PR!PROCESS-COMPOSITION
 with the assumptions PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PR!IS-PROCESS-BOOL, PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS to ...
(TRUE)
PREFIX-CLOSED-CUP
Beginning proof of PREFIX-CLOSED-CUP ...
(IMPLIES (ALL (Y) (IMPLIES (IN Y X) (PR!PREFIX-CLOSED Y)))
 (= (PR!PREFIX-CLOSED (CUP X)) (TRUE)))
Invoking PR!PREFIX-CLOSED gives ...
(IMPLIES
 (ALL (Y)
  (IMPLIES (IN Y X)
   (ALL (S T)
    (IMPLIES (AND (TR!IS-TRACE S) (TR!IS-TRACE T) (IN (TR!APPEND S T) Y))
     (IN S Y)))))
 (ALL (S$0 T$0)
  (IMPLIES
   (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T$0) (IN (TR!APPEND S$0 T$0) (CUP X)))
   (IN S$0 (CUP X)))))
Which simplifies
 when rewriting with CUP.DEFINITION
 forward chaining using TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-BOOL to ...
(IMPLIES
 (ALL (Y)
  (IMPLIES (IN Y X)
   (ALL (S T)
    (IMPLIES (AND (TR!IS-TRACE S) (TR!IS-TRACE T) (IN (TR!APPEND S T) Y))
     (IN S Y)))))
 (ALL (S$0 T$0 Y$0)
  (IMPLIES
   (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T$0) (IN (TR!APPEND S$0 T$0) Y$0)
    (IN Y$0 X))
   (SOME (Y$1) (AND (IN S$0 Y$1) (IN Y$1 X))))))
Prenexing produces ...
(IMPLIES
 (AND
  (ALL (Y$0)
   (IMPLIES (IN Y$0 X)
    (ALL (S$0 T$0)
     (IMPLIES
      (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T$0) (IN (TR!APPEND S$0 T$0) Y$0))
      (IN S$0 Y$0)))))
  (TR!IS-TRACE S) (TR!IS-TRACE T) (IN (TR!APPEND S T) Y) (IN Y X))
 (SOME (Y$1) (AND (IN S Y$1) (IN Y$1 X))))
Instantiating (= Y$0 Y) (= S$0 S) (= T$0 T) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN Y X) (TR!IS-TRACE S) (TR!IS-TRACE T) (IN (TR!APPEND S T) Y))
   (IN S Y))
  (ALL (Y$0 S$0 T$0)
   (IMPLIES
    (AND (IN Y$0 X) (TR!IS-TRACE S$0) (TR!IS-TRACE T$0)
     (IN (TR!APPEND S$0 T$0) Y$0))
    (IN S$0 Y$0)))
  (TR!IS-TRACE S) (TR!IS-TRACE T) (IN (TR!APPEND S T) Y) (IN Y X))
 (SOME (Y$1) (AND (IN S Y$1) (IN Y$1 X))))
Which simplifies
 forward chaining using TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL
 with the instantiation (= Y$1 Y) to ...
(TRUE)
PROCESS-LIMIT-LEMMA
Beginning proof of PROCESS-LIMIT-LEMMA ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (IN (PR!PROCESS-CHAIN-LIMIT F) (PROCESSES A)))
Invoking PR!PROCESS-CHAIN-LIMIT gives ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (IN
  (PR!MAKE-PROCESS (PR!PROCESS-ALPHABET (FN!APPLY F 0))
   (CUP (PR!COLLECT-TRACES F)))
  (PROCESSES A)))
Which simplifies
 when rewriting with CUP.DEFINITION, PR!MAKE-PROCESS-IS-PROCESS, IN-PROCESSES,
ALPHABET-APPLY-PROCESS-CHAIN
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PR!PROCESS-COMPOSITION, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PR!IS-PROCESS-BOOL, PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS, APPLY-IN-NOMINAL-RANGE-NAT, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO to ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (AND (SUBSET (CUP (PR!COLLECT-TRACES F)) (TR!TRACE-OF A))
  (SOME (Y) (AND (IN (TR!EMPTY) Y) (IN Y (PR!COLLECT-TRACES F))))
  (PR!PREFIX-CLOSED (CUP (PR!COLLECT-TRACES F)))))
Applying PREFIX-CLOSED-CUP gives ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (AND (SUBSET (CUP (PR!COLLECT-TRACES F)) (TR!TRACE-OF A))
  (SOME (Y) (AND (IN (TR!EMPTY) Y) (IN Y (PR!COLLECT-TRACES F))))
  (OR
   (ALL (Y$0) (IMPLIES (IN Y$0 (PR!COLLECT-TRACES F)) (PR!PREFIX-CLOSED Y$0)))
   (PR!PREFIX-CLOSED (CUP (PR!COLLECT-TRACES F))))))
Which simplifies
 when rewriting with NAT!IN-NAT, FN!IN-RAN-FUNCTION,
PR!COLLECT-TRACES.DEFINITION, SETRULES!CUP-SUBSET
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, APPLY-IN-NOMINAL-RANGE-NAT, FN!IS-FUNCTION-BOOL,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO to ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (AND
  (ALL (Y)
   (IMPLIES (>= Y 0)
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F Y)) (TR!TRACE-OF A))))
  (SOME (Y$0)
   (AND (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y$0))) (>= Y$0 0)))
  (OR
   (ALL (Y$1)
    (IMPLIES (>= Y$1 0)
     (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F Y$1)))))
   (PR!PREFIX-CLOSED (CUP (PR!COLLECT-TRACES F))))))
Starting case 3 ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (ALL (Y)
  (IMPLIES (>= Y 0)
   (SUBSET (PR!PROCESS-TRACES (FN!APPLY F Y)) (TR!TRACE-OF A)))))
Prenexing produces ...
(IMPLIES (AND (IS-CHAIN F (PROCESS-PO A)) (>= Y 0))
 (SUBSET (PR!PROCESS-TRACES (FN!APPLY F Y)) (TR!TRACE-OF A)))
Assuming IS-PROCESS-FACTS with the
instantiations: (= P (FN!APPLY F Y)) generates ...
(IMPLIES
 (AND
  (IMPLIES (PR!IS-PROCESS (FN!APPLY F Y))
   (AND
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F Y))
     (TR!TRACE-OF (PR!PROCESS-ALPHABET (FN!APPLY F Y))))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y)))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F Y)))))
  (IS-CHAIN F (PROCESS-PO A)) (>= Y 0))
 (SUBSET (PR!PROCESS-TRACES (FN!APPLY F Y)) (TR!TRACE-OF A)))
Rearranging gives ...
(IMPLIES
 (AND (>= Y 0) (IS-CHAIN F (PROCESS-PO A))
  (IMPLIES (PR!IS-PROCESS (FN!APPLY F Y))
   (AND
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F Y))
     (TR!TRACE-OF (PR!PROCESS-ALPHABET (FN!APPLY F Y))))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y)))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F Y))))))
 (SUBSET (PR!PROCESS-TRACES (FN!APPLY F Y)) (TR!TRACE-OF A)))
Which simplifies
 when rewriting with ALPHABET-APPLY-PROCESS-CHAIN,
IS-PROCESS-APPLY-PROCESS-CHAIN
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN,
IS-PO-BASIC, >=.SAME.TYPE
 with the assumptions PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO to ...
(TRUE)
Starting case 2 ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (SOME (Y$0)
  (AND (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y$0))) (>= Y$0 0))))
Instantiating (= Y$0 0) gives ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT (AND (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F 0))) (>= 0 0))))
 (SOME (Y) (AND (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y))) (>= Y 0))))
Which simplifies
 forward chaining using >=.SAME.TYPE, TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO to ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F 0)))))
 (SOME (Y) (AND (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y))) (>= Y 0))))
Assuming IS-PROCESS-FACTS with the
instantiations: (= P (FN!APPLY F 0)) generates ...
(IMPLIES
 (AND
  (IMPLIES (PR!IS-PROCESS (FN!APPLY F 0))
   (AND
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F 0))
     (TR!TRACE-OF (PR!PROCESS-ALPHABET (FN!APPLY F 0))))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F 0)))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F 0)))))
  (IS-CHAIN F (PROCESS-PO A))
  (NOT (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F 0)))))
 (SOME (Y) (AND (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y))) (>= Y 0))))
Rearranging gives ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F 0))))
  (IMPLIES (PR!IS-PROCESS (FN!APPLY F 0))
   (AND
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F 0))
     (TR!TRACE-OF (PR!PROCESS-ALPHABET (FN!APPLY F 0))))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F 0)))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F 0))))))
 (SOME (Y) (AND (>= Y 0) (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y))))))
Which simplifies
 when rewriting with ALPHABET-APPLY-PROCESS-CHAIN,
IS-PROCESS-APPLY-PROCESS-CHAIN
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT
   (ALL (Y$1)
    (IMPLIES (>= Y$1 0)
     (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F Y$1)))))))
 (PR!PREFIX-CLOSED (CUP (PR!COLLECT-TRACES F))))
Prenexing produces ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT
   (IMPLIES (>= Y 0) (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F Y))))))
 (PR!PREFIX-CLOSED (CUP (PR!COLLECT-TRACES F))))
Assuming IS-PROCESS-FACTS with the
instantiations: (= P (FN!APPLY F Y)) generates ...
(IMPLIES
 (AND
  (IMPLIES (PR!IS-PROCESS (FN!APPLY F Y))
   (AND
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F Y))
     (TR!TRACE-OF (PR!PROCESS-ALPHABET (FN!APPLY F Y))))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y)))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F Y)))))
  (IS-CHAIN F (PROCESS-PO A))
  (NOT
   (IMPLIES (>= Y 0) (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F Y))))))
 (PR!PREFIX-CLOSED (CUP (PR!COLLECT-TRACES F))))
Rearranging gives ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT
   (IMPLIES (>= Y 0) (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F Y)))))
  (IMPLIES (PR!IS-PROCESS (FN!APPLY F Y))
   (AND
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F Y))
     (TR!TRACE-OF (PR!PROCESS-ALPHABET (FN!APPLY F Y))))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES (FN!APPLY F Y)))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES (FN!APPLY F Y))))))
 (PR!PREFIX-CLOSED (CUP (PR!COLLECT-TRACES F))))
Which simplifies
 when rewriting with ALPHABET-APPLY-PROCESS-CHAIN,
IS-PROCESS-APPLY-PROCESS-CHAIN
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PR!PROCESS-COMPOSITION, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
PR!IS-PROCESS-BOOL, PR!PREFIX-CLOSED-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO to ...
(TRUE)
Completing all cases produces ...
(TRUE)
LIMIT-IS-PROCESS
Beginning proof of LIMIT-IS-PROCESS ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (= (PR!IS-PROCESS (PR!PROCESS-CHAIN-LIMIT F)) (TRUE)))
Assuming PROCESS-LIMIT-LEMMA with the
instantiations: (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-CHAIN F (PROCESS-PO A))
   (IN (PR!PROCESS-CHAIN-LIMIT F) (PROCESSES A)))
  (IS-CHAIN F (PROCESS-PO A)))
 (PR!IS-PROCESS (PR!PROCESS-CHAIN-LIMIT F)))
Which simplifies
 when rewriting with IN-PROCESSES
 forward chaining using PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions PR!IS-PROCESS-BOOL, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO to ...
(TRUE)
PROCESS-ALPHABET-LIMIT
Beginning proof of PROCESS-ALPHABET-LIMIT ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (= (PR!PROCESS-ALPHABET (PR!PROCESS-CHAIN-LIMIT F)) A))
Assuming PROCESS-LIMIT-LEMMA with the
instantiations: (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-CHAIN F (PROCESS-PO A))
   (IN (PR!PROCESS-CHAIN-LIMIT F) (PROCESSES A)))
  (IS-CHAIN F (PROCESS-PO A)))
 (= (PR!PROCESS-ALPHABET (PR!PROCESS-CHAIN-LIMIT F)) A))
Which simplifies
 when rewriting with LIMIT-IS-PROCESS, IN-PROCESSES
 forward chaining using PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions PR!IS-PROCESS-BOOL, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO to ...
(TRUE)
PROCESS-CHAINS-HAVE-LIMITS
Beginning proof of PROCESS-CHAINS-HAVE-LIMITS ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (IS-CHAIN-LIMIT F (PR!PROCESS-CHAIN-LIMIT F) (PROCESS-PO A)))
Invoking IS-CHAIN-LIMIT gives ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (AND (IS-CHAIN-BOUND F (PR!PROCESS-CHAIN-LIMIT F) (PROCESS-PO A))
  (ALL (B)
   (IMPLIES (IS-CHAIN-BOUND F B (PROCESS-PO A))
    (RELATED (PR!PROCESS-CHAIN-LIMIT F) (PROCESS-PO A) B)))))
Invoking IS-CHAIN-BOUND gives ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (AND (IS-CHAIN F (PROCESS-PO A))
  (IN (PR!PROCESS-CHAIN-LIMIT F) (REL!DOM (PROCESS-PO A)))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (RELATED (FN!APPLY F N) (PROCESS-PO A) (PR!PROCESS-CHAIN-LIMIT F))))
  (ALL (B)
   (IMPLIES
    (AND (IS-CHAIN F (PROCESS-PO A)) (IN B (REL!DOM (PROCESS-PO A)))
     (ALL (N$0)
      (IMPLIES (IN N$0 (NAT!NAT))
       (RELATED (FN!APPLY F N$0) (PROCESS-PO A) B))))
    (RELATED (PR!PROCESS-CHAIN-LIMIT F) (PROCESS-PO A) B)))))
Which simplifies
 when rewriting with ALPHABET-APPLY-PROCESS-CHAIN,
IS-PROCESS-APPLY-PROCESS-CHAIN, RELATED-BY-PROCESS-PO, NAT!IN-NAT,
PROCESS-ALPHABET-LIMIT, LIMIT-IS-PROCESS, IN-PROCESSES, DOM-PROCESS-PO
 forward chaining using RELATED-DOM-RAN, >=.SAME.TYPE, PR!PROCESS-COMPOSITION,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, PR!IS-PROCESS-BOOL,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO to ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (AND
  (ALL (N)
   (IMPLIES (>= N 0)
    (PR!PROCESS-INCLUDED (FN!APPLY F N) (PR!PROCESS-CHAIN-LIMIT F))))
  (ALL (B)
   (IMPLIES
    (AND (PR!IS-PROCESS B) (= (PR!PROCESS-ALPHABET B) A)
     (ALL (N$0)
      (IMPLIES (>= N$0 0) (PR!PROCESS-INCLUDED (FN!APPLY F N$0) B))))
    (PR!PROCESS-INCLUDED (PR!PROCESS-CHAIN-LIMIT F) B)))))
Prenexing produces ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (AND
  (IMPLIES (>= N 0)
   (PR!PROCESS-INCLUDED (FN!APPLY F N) (PR!PROCESS-CHAIN-LIMIT F)))
  (IMPLIES
   (AND (PR!IS-PROCESS B) (= (PR!PROCESS-ALPHABET B) A)
    (ALL (N$0) (IMPLIES (>= N$0 0) (PR!PROCESS-INCLUDED (FN!APPLY F N$0) B))))
   (PR!PROCESS-INCLUDED (PR!PROCESS-CHAIN-LIMIT F) B))))
Assuming PR!ELEMENT-INCLUDED-IN-LIMIT with the
instantiations: (= PC F) (= I N) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IN N (NAT!NAT)) (PR!IS-PROCESS-CHAIN F))
   (PR!PROCESS-INCLUDED (FN!APPLY F N) (PR!PROCESS-CHAIN-LIMIT F)))
  (IS-CHAIN F (PROCESS-PO A)))
 (AND
  (IMPLIES (>= N 0)
   (PR!PROCESS-INCLUDED (FN!APPLY F N) (PR!PROCESS-CHAIN-LIMIT F)))
  (IMPLIES
   (AND (PR!IS-PROCESS B) (= (PR!PROCESS-ALPHABET B) A)
    (ALL (N$0) (IMPLIES (>= N$0 0) (PR!PROCESS-INCLUDED (FN!APPLY F N$0) B))))
   (PR!PROCESS-INCLUDED (PR!PROCESS-CHAIN-LIMIT F) B))))
Assuming PR!UPPER-BOUND-AXIOM with the
instantiations: (= PC F) (= Q B) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (PR!IS-PROCESS-CHAIN F) (PR!IS-PROCESS B)
    (ALL (I)
     (IMPLIES (IN I (NAT!NAT)) (PR!PROCESS-INCLUDED (FN!APPLY F I) B))))
   (PR!PROCESS-INCLUDED (PR!PROCESS-CHAIN-LIMIT F) B))
  (IMPLIES (AND (IN N (NAT!NAT)) (PR!IS-PROCESS-CHAIN F))
   (PR!PROCESS-INCLUDED (FN!APPLY F N) (PR!PROCESS-CHAIN-LIMIT F)))
  (IS-CHAIN F (PROCESS-PO A)))
 (AND
  (IMPLIES (>= N 0)
   (PR!PROCESS-INCLUDED (FN!APPLY F N) (PR!PROCESS-CHAIN-LIMIT F)))
  (IMPLIES
   (AND (PR!IS-PROCESS B) (= (PR!PROCESS-ALPHABET B) A)
    (ALL (N$0) (IMPLIES (>= N$0 0) (PR!PROCESS-INCLUDED (FN!APPLY F N$0) B))))
   (PR!PROCESS-INCLUDED (PR!PROCESS-CHAIN-LIMIT F) B))))
Rearranging gives ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (IMPLIES (AND (IN N (NAT!NAT)) (PR!IS-PROCESS-CHAIN F))
   (PR!PROCESS-INCLUDED (FN!APPLY F N) (PR!PROCESS-CHAIN-LIMIT F)))
  (IMPLIES
   (AND (PR!IS-PROCESS-CHAIN F) (PR!IS-PROCESS B)
    (ALL (I)
     (IMPLIES (IN I (NAT!NAT)) (PR!PROCESS-INCLUDED (FN!APPLY F I) B))))
   (PR!PROCESS-INCLUDED (PR!PROCESS-CHAIN-LIMIT F) B)))
 (AND
  (IMPLIES (>= N 0)
   (PR!PROCESS-INCLUDED (FN!APPLY F N) (PR!PROCESS-CHAIN-LIMIT F)))
  (IMPLIES
   (AND (= (PR!PROCESS-ALPHABET B) A) (PR!IS-PROCESS B)
    (ALL (N$0) (IMPLIES (>= N$0 0) (PR!PROCESS-INCLUDED (FN!APPLY F N$0) B))))
   (PR!PROCESS-INCLUDED (PR!PROCESS-CHAIN-LIMIT F) B))))
Which simplifies
 when rewriting with PROCESS-CHAIN-BRIDGE, NAT!IN-NAT
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC
 with the assumptions PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO
 with the instantiation (= I N$0) to ...
(TRUE)
PROCESS-PO-IS-COMPLETE
Beginning proof of PROCESS-PO-IS-COMPLETE ...
(IS-COMPLETE-PO (PROCESS-PO A))
Invoking IS-COMPLETE-PO gives ...
(AND (IS-PO (PROCESS-PO A))
 (ALL (F)
  (IMPLIES (IS-CHAIN F (PROCESS-PO A))
   (SOME (B) (IS-CHAIN-LIMIT F B (PROCESS-PO A))))))
Prenexing produces ...
(AND (IS-PO (PROCESS-PO A))
 (IMPLIES (IS-CHAIN F (PROCESS-PO A))
  (SOME (B) (IS-CHAIN-LIMIT F B (PROCESS-PO A)))))
Assuming PROCESS-CHAINS-HAVE-LIMITS with the
instantiations: (= F F) (= A A) generates ...
(IMPLIES
 (IMPLIES (IS-CHAIN F (PROCESS-PO A))
  (IS-CHAIN-LIMIT F (PR!PROCESS-CHAIN-LIMIT F) (PROCESS-PO A)))
 (AND (IS-PO (PROCESS-PO A))
  (IMPLIES (IS-CHAIN F (PROCESS-PO A))
   (SOME (B) (IS-CHAIN-LIMIT F B (PROCESS-PO A))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN,
IS-PO-BASIC
 with the assumptions PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO
 with the instantiation (= B (PR!PROCESS-CHAIN-LIMIT F)) to ...
(TRUE)
PROCESS-PO-LIMIT
Beginning proof of PROCESS-PO-LIMIT ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (= (LIMIT F (PROCESS-PO A)) (PR!PROCESS-CHAIN-LIMIT F)))
Assuming CHAIN-LIMIT-UNIQUE with the
instantiations: (= F F) (= R (PROCESS-PO A)) (= X (LIMIT F (PROCESS-PO A)))
                (= Y (PR!PROCESS-CHAIN-LIMIT F)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PO (PROCESS-PO A))
    (IS-CHAIN-LIMIT F (LIMIT F (PROCESS-PO A)) (PROCESS-PO A))
    (IS-CHAIN-LIMIT F (PR!PROCESS-CHAIN-LIMIT F) (PROCESS-PO A)))
   (= (LIMIT F (PROCESS-PO A)) (PR!PROCESS-CHAIN-LIMIT F)))
  (IS-CHAIN F (PROCESS-PO A)))
 (= (LIMIT F (PROCESS-PO A)) (PR!PROCESS-CHAIN-LIMIT F)))
Assuming LIMIT-IS-CHAIN-LIMIT with the
instantiations: (= F F) (= R (PROCESS-PO A)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-COMPLETE-PO (PROCESS-PO A)) (IS-CHAIN F (PROCESS-PO A)))
   (IS-CHAIN-LIMIT F (LIMIT F (PROCESS-PO A)) (PROCESS-PO A)))
  (IMPLIES
   (AND (IS-PO (PROCESS-PO A))
    (IS-CHAIN-LIMIT F (LIMIT F (PROCESS-PO A)) (PROCESS-PO A))
    (IS-CHAIN-LIMIT F (PR!PROCESS-CHAIN-LIMIT F) (PROCESS-PO A)))
   (= (LIMIT F (PROCESS-PO A)) (PR!PROCESS-CHAIN-LIMIT F)))
  (IS-CHAIN F (PROCESS-PO A)))
 (= (LIMIT F (PROCESS-PO A)) (PR!PROCESS-CHAIN-LIMIT F)))
Assuming PROCESS-CHAINS-HAVE-LIMITS with the
instantiations: (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-CHAIN F (PROCESS-PO A))
   (IS-CHAIN-LIMIT F (PR!PROCESS-CHAIN-LIMIT F) (PROCESS-PO A)))
  (IMPLIES (AND (IS-COMPLETE-PO (PROCESS-PO A)) (IS-CHAIN F (PROCESS-PO A)))
   (IS-CHAIN-LIMIT F (LIMIT F (PROCESS-PO A)) (PROCESS-PO A)))
  (IMPLIES
   (AND (IS-PO (PROCESS-PO A))
    (IS-CHAIN-LIMIT F (LIMIT F (PROCESS-PO A)) (PROCESS-PO A))
    (IS-CHAIN-LIMIT F (PR!PROCESS-CHAIN-LIMIT F) (PROCESS-PO A)))
   (= (LIMIT F (PROCESS-PO A)) (PR!PROCESS-CHAIN-LIMIT F)))
  (IS-CHAIN F (PROCESS-PO A)))
 (= (LIMIT F (PROCESS-PO A)) (PR!PROCESS-CHAIN-LIMIT F)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, CHAIN-IS-FUN,
IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions LIMIT-IN-DOM, PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO,
PROCESS-PO-IS-COMPLETE to ...
(TRUE)
EMPTY-IN-TRACES
Beginning proof of EMPTY-IN-TRACES ...
(IMPLIES (PR!IS-PROCESS P) (= (IN (TR!EMPTY) (PR!PROCESS-TRACES P)) (TRUE)))
Assuming PR!MAKE-PROCESS-IS-PROCESS with the
instantiations: (= A (PR!PROCESS-ALPHABET P))
                (= T (PR!PROCESS-TRACES P)) generates
...
(IMPLIES
 (AND
  (=
   (PR!IS-PROCESS
    (PR!MAKE-PROCESS (PR!PROCESS-ALPHABET P) (PR!PROCESS-TRACES P)))
   (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
  (PR!IS-PROCESS P))
 (IN (TR!EMPTY) (PR!PROCESS-TRACES P)))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PR!PROCESS-COMPOSITION
 with the assumptions PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PR!IS-PROCESS-BOOL, PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS to ...
(TRUE)
IN-MAP-TACK
Beginning proof of IN-MAP-TACK ...
(IMPLIES (PR!IS-PROCESS P)
 (= (IN T (PR!MAP-TACK X (PR!PROCESS-TRACES P)))
  (AND (NOT (TR!IS-EMPTY T)) (= (TR!HEAD T) X)
   (IN (TR!TAIL T) (PR!PROCESS-TRACES P)))))
Which simplifies
 when rewriting with PR!MAP-TACK.DEFINITION
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL,
PR!IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (NOT (TR!IS-EMPTY T)) (= (TR!HEAD T) X)
  (NOT (IN (TR!TAIL T) (PR!PROCESS-TRACES P))))
 (= (SOME (S) (AND (IN S (PR!PROCESS-TRACES P)) (= T (TR!TACK X S)))) (FALSE)))
Instantiating (= S (TR!TAIL T)) gives ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (NOT (TR!IS-EMPTY T)) (= (TR!HEAD T) X)
  (NOT (IN (TR!TAIL T) (PR!PROCESS-TRACES P))))
 (NOT
  (OR
   (AND (IN (TR!TAIL T) (PR!PROCESS-TRACES P)) (= T (TR!TACK X (TR!TAIL T))))
   (SOME (S) (AND (IN S (PR!PROCESS-TRACES P)) (= T (TR!TACK X S)))))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!TACK-HEAD-TAIL, PR!PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!IS-TRACE-BOOL, TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!IS-EMPTY-BOOL,
PR!IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (NOT (TR!IS-EMPTY T)) (= (TR!HEAD T) X)
  (NOT (IN (TR!TAIL T) (PR!PROCESS-TRACES P))))
 (NOT (SOME (S) (AND (IN S (PR!PROCESS-TRACES P)) (= T (TR!TACK X S))))))
Prenexing produces ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (NOT (TR!IS-EMPTY T)) (= (TR!HEAD T) X)
  (NOT (IN (TR!TAIL T) (PR!PROCESS-TRACES P))))
 (NOT (AND (IN S (PR!PROCESS-TRACES P)) (= T (TR!TACK X S)))))
Assuming PR!IN-PROCESS-TRACES with the
instantiations: (= S S) (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (PR!IS-PROCESS P) (IN S (PR!PROCESS-TRACES P)))
   (TR!IS-TRACE-OF S (PR!PROCESS-ALPHABET P)))
  (PR!IS-PROCESS P) (NOT (TR!IS-EMPTY T)) (= (TR!HEAD T) X)
  (NOT (IN (TR!TAIL T) (PR!PROCESS-TRACES P))))
 (NOT (AND (IN S (PR!PROCESS-TRACES P)) (= T (TR!TACK X S)))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PR!PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!IS-TRACE-TAIL, TR!SIZE-TAIL,
TR!IS-EMPTY-BOOL, PR!IS-PROCESS-BOOL to ...
(TRUE)
SUBSET-SETADD
Beginning proof of SUBSET-SETADD ...
(IMPLIES (SUBSET X Y) (= (SUBSET X (SETADD E Y)) (TRUE)))
Which simplifies
 with invocation of SUBSET
 when rewriting with SETADD.DEFINITION to ...
(TRUE)
SUBSET-MAP-TACK
Beginning proof of SUBSET-MAP-TACK ...
(IMPLIES (SUBSET X Y) (= (SUBSET (PR!MAP-TACK A X) (PR!MAP-TACK A Y)) (TRUE)))
Which simplifies
 with invocation of SUBSET
 when rewriting with PR!MAP-TACK.DEFINITION
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL to ...
(IMPLIES (ALL (E) (IMPLIES (IN E X) (IN E Y)))
 (ALL (S)
  (IMPLIES (IN S X)
   (SOME (S$0) (AND (IN S$0 Y) (= (TR!TACK A S) (TR!TACK A S$0)))))))
Instantiating (= S$0 S) gives ...
(IMPLIES (ALL (E) (IMPLIES (IN E X) (IN E Y)))
 (ALL (S)
  (IMPLIES (AND (IN S X) (NOT (AND (IN S Y) (= (TR!TACK A S) (TR!TACK A S)))))
   (SOME (S$0) (AND (IN S$0 Y) (= (TR!TACK A S) (TR!TACK A S$0)))))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL
 with the instantiation (= E S) to ...
(TRUE)
PREFIX-INCLUDED
Beginning proof of PREFIX-INCLUDED ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
  (IN B (PR!PROCESS-ALPHABET Q)))
 (= (PR!PROCESS-INCLUDED (PR!PREFIX A P) (PR!PREFIX B Q))
  (AND (= A B) (PR!PROCESS-INCLUDED P Q))))
Splitting on (PR!PROCESS-INCLUDED P Q) generates ...
(IF (PR!PROCESS-INCLUDED P Q)
 (IMPLIES
  (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
   (IN B (PR!PROCESS-ALPHABET Q)))
  (= (PR!PROCESS-INCLUDED (PR!PREFIX A P) (PR!PREFIX B Q))
   (AND (= A B) (PR!PROCESS-INCLUDED P Q))))
 (IMPLIES
  (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
   (IN B (PR!PROCESS-ALPHABET Q)))
  (= (PR!PROCESS-INCLUDED (PR!PREFIX A P) (PR!PREFIX B Q))
   (AND (= A B) (PR!PROCESS-INCLUDED P Q)))))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION
 with the assumptions PR!PREFIX-IS-PROCESS, PR!IS-PROCESS-BOOL to ...
(IF (PR!PROCESS-INCLUDED P Q)
 (IMPLIES
  (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
   (IN B (PR!PROCESS-ALPHABET Q)))
  (IF (= A B) (= (PR!PROCESS-INCLUDED (PR!PREFIX A P) (PR!PREFIX B Q)) (TRUE))
   (= (PR!PROCESS-INCLUDED (PR!PREFIX A P) (PR!PREFIX B Q)) (FALSE))))
 (IMPLIES
  (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
   (IN B (PR!PROCESS-ALPHABET Q)))
  (= (PR!PROCESS-INCLUDED (PR!PREFIX A P) (PR!PREFIX B Q)) (FALSE))))
Which simplifies
 with invocation of SUBSET, PR!PROCESS-INCLUDED
 when rewriting with SUBSET-SETADD, IN-MAP-TACK, SETADD.DEFINITION,
SETRULES!SUBSET-SETADD, SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD, PR!PROCESS-TRACES-PREFIX,
PR!PROCESS-ALPHABET-PREFIX
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!IS-EMPTY-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PR!PREFIX-IS-PROCESS,
PR!IS-PROCESS-BOOL to ...
(IMPLIES (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
 (IF
  (ALL (E)
   (IMPLIES (IN E (PR!PROCESS-TRACES P)) (IN E (PR!PROCESS-TRACES Q))))
  (IMPLIES
   (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
    (IN B (PR!PROCESS-ALPHABET Q)) (NOT (= A B)))
   (NOT
    (ALL (E$0)
     (IMPLIES (AND (NOT (TR!IS-EMPTY E$0)) (= (TR!HEAD E$0) A))
      (NOT (IN (TR!TAIL E$0) (PR!PROCESS-TRACES P)))))))
  (IMPLIES
   (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
    (IN B (PR!PROCESS-ALPHABET Q)))
   (NOT
    (ALL (E$1)
     (IMPLIES
      (AND (NOT (TR!IS-EMPTY E$1)) (= (TR!HEAD E$1) A)
       (IN (TR!TAIL E$1) (PR!PROCESS-TRACES P)))
      (AND (= (TR!HEAD E$1) B) (IN (TR!TAIL E$1) (PR!PROCESS-TRACES Q)))))))))
Starting case 2 ...
(IMPLIES
 (AND (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
  (ALL (E)
   (IMPLIES (IN E (PR!PROCESS-TRACES P)) (IN E (PR!PROCESS-TRACES Q))))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
  (IN B (PR!PROCESS-ALPHABET Q)) (NOT (= A B)))
 (NOT
  (ALL (E$0)
   (IMPLIES (AND (NOT (TR!IS-EMPTY E$0)) (= (TR!HEAD E$0) A))
    (NOT (IN (TR!TAIL E$0) (PR!PROCESS-TRACES P)))))))
Splitting on (= A B) generates ...
(IF (= A B)
 (IMPLIES
  (AND (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
   (ALL (E)
    (IMPLIES (IN E (PR!PROCESS-TRACES P)) (IN E (PR!PROCESS-TRACES Q))))
   (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
   (IN B (PR!PROCESS-ALPHABET Q)) (NOT (= A B)))
  (NOT
   (ALL (E$0)
    (IMPLIES (AND (NOT (TR!IS-EMPTY E$0)) (= (TR!HEAD E$0) A))
     (NOT (IN (TR!TAIL E$0) (PR!PROCESS-TRACES P)))))))
 (IMPLIES
  (AND (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
   (ALL (E$1)
    (IMPLIES (IN E$1 (PR!PROCESS-TRACES P)) (IN E$1 (PR!PROCESS-TRACES Q))))
   (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
   (IN B (PR!PROCESS-ALPHABET Q)) (NOT (= A B)))
  (NOT
   (ALL (E$2)
    (IMPLIES (AND (NOT (TR!IS-EMPTY E$2)) (= (TR!HEAD E$2) A))
     (NOT (IN (TR!TAIL E$2) (PR!PROCESS-TRACES P))))))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!TACK-HEAD-TAIL, PR!PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!IS-EMPTY-BOOL,
PR!IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (NOT (= A B)) (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
  (ALL (E)
   (IMPLIES (IN E (PR!PROCESS-TRACES P)) (IN E (PR!PROCESS-TRACES Q))))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
  (IN B (PR!PROCESS-ALPHABET Q)))
 (NOT
  (ALL (E$0)
   (IMPLIES (AND (NOT (TR!IS-EMPTY E$0)) (= (TR!HEAD E$0) A))
    (NOT (IN (TR!TAIL E$0) (PR!PROCESS-TRACES P)))))))
Instantiating (= E$0 (TR!TACK A (TR!EMPTY))) gives ...
(IMPLIES
 (AND (NOT (= A B)) (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
  (ALL (E)
   (IMPLIES (IN E (PR!PROCESS-TRACES P)) (IN E (PR!PROCESS-TRACES Q))))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
  (IN B (PR!PROCESS-ALPHABET Q)))
 (NOT
  (AND
   (IMPLIES
    (AND (NOT (TR!IS-EMPTY (TR!TACK A (TR!EMPTY))))
     (= (TR!HEAD (TR!TACK A (TR!EMPTY))) A))
    (NOT (IN (TR!TAIL (TR!TACK A (TR!EMPTY))) (PR!PROCESS-TRACES P))))
   (ALL (E$0)
    (IMPLIES (AND (NOT (TR!IS-EMPTY E$0)) (= (TR!HEAD E$0) A))
     (NOT (IN (TR!TAIL E$0) (PR!PROCESS-TRACES P))))))))
Which simplifies
 when rewriting with EMPTY-IN-TRACES
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL,
TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
PR!IS-PROCESS-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
  (NOT
   (ALL (E)
    (IMPLIES (IN E (PR!PROCESS-TRACES P)) (IN E (PR!PROCESS-TRACES Q)))))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
  (IN B (PR!PROCESS-ALPHABET Q)))
 (NOT
  (ALL (E$1)
   (IMPLIES
    (AND (NOT (TR!IS-EMPTY E$1)) (= (TR!HEAD E$1) A)
     (IN (TR!TAIL E$1) (PR!PROCESS-TRACES P)))
    (AND (= (TR!HEAD E$1) B) (IN (TR!TAIL E$1) (PR!PROCESS-TRACES Q)))))))
Instantiating (= E$1 (TR!TACK A E)) gives ...
(IMPLIES
 (AND (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
  (NOT (IMPLIES (IN E (PR!PROCESS-TRACES P)) (IN E (PR!PROCESS-TRACES Q))))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
  (IN B (PR!PROCESS-ALPHABET Q)))
 (NOT
  (AND
   (IMPLIES
    (AND (NOT (TR!IS-EMPTY (TR!TACK A E))) (= (TR!HEAD (TR!TACK A E)) A)
     (IN (TR!TAIL (TR!TACK A E)) (PR!PROCESS-TRACES P)))
    (AND (= (TR!HEAD (TR!TACK A E)) B)
     (IN (TR!TAIL (TR!TACK A E)) (PR!PROCESS-TRACES Q))))
   (ALL (E$0)
    (IMPLIES
     (AND (NOT (TR!IS-EMPTY E$0)) (= (TR!HEAD E$0) A)
      (IN (TR!TAIL E$0) (PR!PROCESS-TRACES P)))
     (AND (= (TR!HEAD E$0) B) (IN (TR!TAIL E$0) (PR!PROCESS-TRACES Q))))))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL,
PR!IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
  (IN E (PR!PROCESS-TRACES P)) (NOT (IN E (PR!PROCESS-TRACES Q)))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
  (IN B (PR!PROCESS-ALPHABET Q)))
 (IF (IN (TR!TAIL (TR!TACK A E)) (PR!PROCESS-TRACES P))
  (IMPLIES (AND (= A B) (IN (TR!TAIL (TR!TACK A E)) (PR!PROCESS-TRACES Q)))
   (NOT
    (ALL (E$0)
     (IMPLIES
      (AND (NOT (TR!IS-EMPTY E$0)) (= (TR!HEAD E$0) A)
       (IN (TR!TAIL E$0) (PR!PROCESS-TRACES P)))
      (IN (TR!TAIL E$0) (PR!PROCESS-TRACES Q))))))
  (NOT
   (ALL (E$1)
    (IMPLIES
     (AND (NOT (TR!IS-EMPTY E$1)) (= (TR!HEAD E$1) A)
      (IN (TR!TAIL E$1) (PR!PROCESS-TRACES P)))
     (AND (= (TR!HEAD E$1) B) (IN (TR!TAIL E$1) (PR!PROCESS-TRACES Q))))))))
Assuming PR!IN-PROCESS-TRACES with the
instantiations: (= S E) (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (PR!IS-PROCESS P) (IN E (PR!PROCESS-TRACES P)))
   (TR!IS-TRACE-OF E (PR!PROCESS-ALPHABET P)))
  (= (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
  (IN E (PR!PROCESS-TRACES P)) (NOT (IN E (PR!PROCESS-TRACES Q)))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q) (IN A (PR!PROCESS-ALPHABET P))
  (IN B (PR!PROCESS-ALPHABET Q)))
 (IF (IN (TR!TAIL (TR!TACK A E)) (PR!PROCESS-TRACES P))
  (IMPLIES (AND (= A B) (IN (TR!TAIL (TR!TACK A E)) (PR!PROCESS-TRACES Q)))
   (NOT
    (ALL (E$0)
     (IMPLIES
      (AND (NOT (TR!IS-EMPTY E$0)) (= (TR!HEAD E$0) A)
       (IN (TR!TAIL E$0) (PR!PROCESS-TRACES P)))
      (IN (TR!TAIL E$0) (PR!PROCESS-TRACES Q))))))
  (NOT
   (ALL (E$1)
    (IMPLIES
     (AND (NOT (TR!IS-EMPTY E$1)) (= (TR!HEAD E$1) A)
      (IN (TR!TAIL E$1) (PR!PROCESS-TRACES P)))
     (AND (= (TR!HEAD E$1) B) (IN (TR!TAIL E$1) (PR!PROCESS-TRACES Q))))))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PR!PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL,
TR!IS-EMPTY-BOOL, PR!IS-PROCESS-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
IS-PROCESS-PREFIX
Beginning proof of IS-PROCESS-PREFIX ...
(IMPLIES (AND (PR!IS-PROCESS P) (IN A (PR!PROCESS-ALPHABET P)))
 (= (PR!IS-PROCESS (PR!PREFIX A P)) (TRUE)))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION
 with the assumptions PR!PREFIX-IS-PROCESS, PR!IS-PROCESS-BOOL to ...
(TRUE)
FIRST-ACTIONS
FIRST-ACTIONS-STOP
Beginning proof of FIRST-ACTIONS-STOP ...
(= (FIRST-ACTIONS (PR!STOP A)) (NULLSET))
Applying SETRULES!EXTENSIONALITY gives ...
(IF (IN E (FIRST-ACTIONS (PR!STOP A))) (IN E (NULLSET)) (NOT (IN E (NULLSET))))
Which simplifies
 when rewriting with NULLSET.DEFINITION, SETADD.DEFINITION,
SETRULES!UNIT-TO-SETADD, PR!PROCESS-TRACES-STOP, PR!PROCESS-ALPHABET-STOP,
FIRST-ACTIONS.DEFINITION
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PR!IS-PROCESS-STOP to ...
(TRUE)
FIRST-ACTIONS-RUN
Beginning proof of FIRST-ACTIONS-RUN ...
(= (FIRST-ACTIONS (PR!RUN A)) A)
Applying SETRULES!EXTENSIONALITY gives ...
(IF (IN E (FIRST-ACTIONS (PR!RUN A))) (IN E A) (NOT (IN E A)))
Which simplifies
 when rewriting with TR!IS-TRACE-OF-TACK, TR!IS-TRACE-OF-EMPTY,
TR!IN-TRACE-OF, PR!PROCESS-TRACES-RUN, PR!PROCESS-ALPHABET-RUN,
FIRST-ACTIONS.DEFINITION
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!TACK-HEAD-TAIL,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PR!IS-PROCESS-RUN to ...
(TRUE)
FIRST-ACTIONS-PREFIX
Beginning proof of FIRST-ACTIONS-PREFIX ...
(IMPLIES (AND (PR!IS-PROCESS P) (IN A (PR!PROCESS-ALPHABET P)))
 (= (FIRST-ACTIONS (PR!PREFIX A P)) (SETADD A (NULLSET))))
Applying SETRULES!EXTENSIONALITY gives ...
(IMPLIES (AND (PR!IS-PROCESS P) (IN A (PR!PROCESS-ALPHABET P)))
 (ALL (E)
  (IF (IN E (FIRST-ACTIONS (PR!PREFIX A P))) (IN E (SETADD A (NULLSET)))
   (NOT (IN E (SETADD A (NULLSET)))))))
Which simplifies
 when rewriting with NULLSET.DEFINITION, EMPTY-IN-TRACES, IN-MAP-TACK,
SETADD.DEFINITION, SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD, PR!PROCESS-TRACES-PREFIX,
PR!PROCESS-ALPHABET-PREFIX, FIRST-ACTIONS.DEFINITION
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PR!PREFIX-IS-PROCESS, PR!IS-PROCESS-BOOL to ...
(TRUE)
INPUT-CHOICE
TRACE-OF-SUBSET
Beginning proof of TRACE-OF-SUBSET ...
(IMPLIES (SUBSET X Y) (= (SUBSET (TR!TRACE-OF X) (TR!TRACE-OF Y)) (TRUE)))
Invoking (SUBSET (TR!TRACE-OF X) (TR!TRACE-OF Y)) gives ...
(IMPLIES (SUBSET X Y)
 (ALL (E) (IMPLIES (IN E (TR!TRACE-OF X)) (IN E (TR!TRACE-OF Y)))))
Prenexing produces ...
(IMPLIES (AND (SUBSET X Y) (IN E (TR!TRACE-OF X))) (IN E (TR!TRACE-OF Y)))
Which simplifies
 when rewriting with TR!IN-TRACE-OF
 forward chaining using TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE to ...
(IMPLIES (AND (SUBSET X Y) (TR!IS-TRACE-OF E X)) (TR!IS-TRACE-OF E Y))
Inducting using the following scheme ...
 (AND (IMPLIES (TR!IS-EMPTY E) (*P* E X Y))
  (IMPLIES (AND (NOT (TR!IS-EMPTY E)) (*P* (TR!TAIL E) X Y)) (*P* E X Y)))
 produces ...
(AND
 (IMPLIES (TR!IS-EMPTY E)
  (IMPLIES (AND (SUBSET X Y) (TR!IS-TRACE-OF E X)) (TR!IS-TRACE-OF E Y)))
 (IMPLIES
  (AND (NOT (TR!IS-EMPTY E))
   (IMPLIES (AND (SUBSET X Y) (TR!IS-TRACE-OF (TR!TAIL E) X))
    (TR!IS-TRACE-OF (TR!TAIL E) Y)))
  (IMPLIES (AND (SUBSET X Y) (TR!IS-TRACE-OF E X)) (TR!IS-TRACE-OF E Y))))
Which simplifies
 with invocation of TR!IS-TRACE-OF, SUBSET
 when rewriting with TR!IS-TRACE-OF-EMPTY
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-TRACE-OF-IS-TRACE,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, TR!TACK-HEAD-TAIL
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!IS-EMPTY-BOOL to ...
(TRUE)
PREFIX-CLOSED-UNION
Beginning proof of PREFIX-CLOSED-UNION ...
(IMPLIES (AND (PR!PREFIX-CLOSED X) (PR!PREFIX-CLOSED Y))
 (= (PR!PREFIX-CLOSED (UNION X Y)) (TRUE)))
Which simplifies
 with invocation of PR!PREFIX-CLOSED
 when rewriting with UNION.DEFINITION
 forward chaining using TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-BOOL, PR!PREFIX-CLOSED-BOOL to ...
(TRUE)
IS-PROCESS-INPUT-CHOICE
Beginning proof of IS-PROCESS-INPUT-CHOICE ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET)))
 (= (PR!IS-PROCESS (INPUT-CHOICE P Q)) (TRUE)))
Invoking INPUT-CHOICE gives ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET)))
 (PR!IS-PROCESS
  (IF (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET))
   (PR!MAKE-PROCESS (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
    (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q)))
   0)))
Which simplifies
 when rewriting with EMPTY-IN-TRACES, UNION.DEFINITION,
SETRULES!SUBSET-UNION-LEFT, PR!MAKE-PROCESS-IS-PROCESS,
FIRST-ACTIONS.DEFINITION, SETRULES!INTER-NULLSET
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions PR!PREFIX-CLOSED-BOOL, PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
PR!IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (ALL (E)
   (IMPLIES
    (AND (IN E (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (AND
  (SUBSET (PR!PROCESS-TRACES P)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (SUBSET (PR!PROCESS-TRACES Q)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (PR!PREFIX-CLOSED (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q)))))
Assuming IS-PROCESS-FACTS with the instantiations: (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES (PR!IS-PROCESS P)
   (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (ALL (E)
   (IMPLIES
    (AND (IN E (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (AND
  (SUBSET (PR!PROCESS-TRACES P)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (SUBSET (PR!PROCESS-TRACES Q)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (PR!PREFIX-CLOSED (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q)))))
Assuming IS-PROCESS-FACTS with the instantiations: (= P Q) generates ...
(IMPLIES
 (AND
  (IMPLIES (PR!IS-PROCESS Q)
   (AND (SUBSET (PR!PROCESS-TRACES Q) (TR!TRACE-OF (PR!PROCESS-ALPHABET Q)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES Q))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES Q))))
  (IMPLIES (PR!IS-PROCESS P)
   (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (ALL (E)
   (IMPLIES
    (AND (IN E (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (AND
  (SUBSET (PR!PROCESS-TRACES P)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (SUBSET (PR!PROCESS-TRACES Q)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (PR!PREFIX-CLOSED (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q)))))
Assuming TRACE-OF-SUBSET with the
instantiations: (= X (PR!PROCESS-ALPHABET P))
                (= Y
                 (UNION (PR!PROCESS-ALPHABET P)
                  (PR!PROCESS-ALPHABET Q))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (SUBSET (PR!PROCESS-ALPHABET P)
    (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q)))
   (=
    (SUBSET (TR!TRACE-OF (PR!PROCESS-ALPHABET P))
     (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
    (TRUE)))
  (IMPLIES (PR!IS-PROCESS Q)
   (AND (SUBSET (PR!PROCESS-TRACES Q) (TR!TRACE-OF (PR!PROCESS-ALPHABET Q)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES Q))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES Q))))
  (IMPLIES (PR!IS-PROCESS P)
   (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (ALL (E)
   (IMPLIES
    (AND (IN E (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (AND
  (SUBSET (PR!PROCESS-TRACES P)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (SUBSET (PR!PROCESS-TRACES Q)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (PR!PREFIX-CLOSED (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q)))))
Assuming TRACE-OF-SUBSET with the
instantiations: (= X (PR!PROCESS-ALPHABET Q))
                (= Y
                 (UNION (PR!PROCESS-ALPHABET P)
                  (PR!PROCESS-ALPHABET Q))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (SUBSET (PR!PROCESS-ALPHABET Q)
    (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q)))
   (=
    (SUBSET (TR!TRACE-OF (PR!PROCESS-ALPHABET Q))
     (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
    (TRUE)))
  (IMPLIES
   (SUBSET (PR!PROCESS-ALPHABET P)
    (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q)))
   (SUBSET (TR!TRACE-OF (PR!PROCESS-ALPHABET P))
    (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q)))))
  (IMPLIES (PR!IS-PROCESS Q)
   (AND (SUBSET (PR!PROCESS-TRACES Q) (TR!TRACE-OF (PR!PROCESS-ALPHABET Q)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES Q))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES Q))))
  (IMPLIES (PR!IS-PROCESS P)
   (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (ALL (E)
   (IMPLIES
    (AND (IN E (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (AND
  (SUBSET (PR!PROCESS-TRACES P)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (SUBSET (PR!PROCESS-TRACES Q)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (PR!PREFIX-CLOSED (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q)))))
Rearranging gives ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (IMPLIES
   (SUBSET (PR!PROCESS-ALPHABET Q)
    (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q)))
   (=
    (SUBSET (TR!TRACE-OF (PR!PROCESS-ALPHABET Q))
     (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
    (TRUE)))
  (IMPLIES
   (SUBSET (PR!PROCESS-ALPHABET P)
    (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q)))
   (SUBSET (TR!TRACE-OF (PR!PROCESS-ALPHABET P))
    (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q)))))
  (IMPLIES (PR!IS-PROCESS Q)
   (AND (SUBSET (PR!PROCESS-TRACES Q) (TR!TRACE-OF (PR!PROCESS-ALPHABET Q)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES Q))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES Q))))
  (IMPLIES (PR!IS-PROCESS P)
   (AND (SUBSET (PR!PROCESS-TRACES P) (TR!TRACE-OF (PR!PROCESS-ALPHABET P)))
    (IN (TR!EMPTY) (PR!PROCESS-TRACES P))
    (PR!PREFIX-CLOSED (PR!PROCESS-TRACES P))))
  (ALL (E)
   (IMPLIES
    (AND (IN E (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (AND
  (SUBSET (PR!PROCESS-TRACES P)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (SUBSET (PR!PROCESS-TRACES Q)
   (TR!TRACE-OF (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
  (PR!PREFIX-CLOSED (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q)))))
Which simplifies
 when rewriting with PREFIX-CLOSED-UNION, SUBSET.TRANSITIVE, EMPTY-IN-TRACES
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL,
PR!PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
PR!IS-PROCESS-BOOL to ...
(TRUE)
ALPHABET-INPUT-CHOICE
Beginning proof of ALPHABET-INPUT-CHOICE ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET)))
 (= (PR!PROCESS-ALPHABET (INPUT-CHOICE P Q))
  (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
Invoking INPUT-CHOICE gives ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET)))
 (=
  (PR!PROCESS-ALPHABET
   (IF (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET))
    (PR!MAKE-PROCESS (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
     (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q)))
    0))
  (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
Which simplifies
 when rewriting with FIRST-ACTIONS.DEFINITION, SETRULES!INTER-NULLSET
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
PR!IS-PROCESS-BOOL to ...
(TRUE)
TRACES-INPUT-CHOICE
Beginning proof of TRACES-INPUT-CHOICE ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET)))
 (= (PR!PROCESS-TRACES (INPUT-CHOICE P Q))
  (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q))))
Invoking INPUT-CHOICE gives ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET)))
 (=
  (PR!PROCESS-TRACES
   (IF (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET))
    (PR!MAKE-PROCESS (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))
     (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q)))
    0))
  (UNION (PR!PROCESS-TRACES P) (PR!PROCESS-TRACES Q))))
Which simplifies
 when rewriting with FIRST-ACTIONS.DEFINITION, SETRULES!INTER-NULLSET
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
PR!IS-PROCESS-BOOL to ...
(TRUE)
FIRST-ACTIONS-INPUT-CHOICE
Beginning proof of FIRST-ACTIONS-INPUT-CHOICE ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (= (INTER (FIRST-ACTIONS P) (FIRST-ACTIONS Q)) (NULLSET)))
 (= (FIRST-ACTIONS (INPUT-CHOICE P Q))
  (UNION (FIRST-ACTIONS P) (FIRST-ACTIONS Q))))
Which simplifies
 when rewriting with FIRST-ACTIONS.DEFINITION, SETRULES!INTER-NULLSET
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
PR!IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (ALL (E)
   (IMPLIES
    (AND (IN E (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (= (FIRST-ACTIONS (INPUT-CHOICE P Q))
  (UNION (FIRST-ACTIONS P) (FIRST-ACTIONS Q))))
Applying SETRULES!EXTENSIONALITY gives ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (ALL (E)
   (IMPLIES
    (AND (IN E (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (ALL (E$0)
  (IF (IN E$0 (FIRST-ACTIONS (INPUT-CHOICE P Q)))
   (IN E$0 (UNION (FIRST-ACTIONS P) (FIRST-ACTIONS Q)))
   (NOT (IN E$0 (UNION (FIRST-ACTIONS P) (FIRST-ACTIONS Q)))))))
Which simplifies
 when rewriting with TRACES-INPUT-CHOICE, UNION.DEFINITION,
ALPHABET-INPUT-CHOICE, SETRULES!INTER-NULLSET, FIRST-ACTIONS.DEFINITION
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PR!IS-PROCESS-BOOL to
...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (ALL (E)
   (IMPLIES
    (AND (IN E (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (ALL (E$0)
  (IF (IN E$0 (PR!PROCESS-ALPHABET P))
   (IMPLIES
    (AND (NOT (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES P)))
     (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES Q)))
    (IN E$0 (PR!PROCESS-ALPHABET Q)))
   (IMPLIES
    (AND (IN E$0 (PR!PROCESS-ALPHABET Q))
     (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES P)))
    (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
Instantiating (= E E$0) gives ...
(IMPLIES
 (AND (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (IMPLIES
   (AND (IN E (PR!PROCESS-ALPHABET P))
    (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
    (IN E (PR!PROCESS-ALPHABET Q)))
   (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))
  (ALL (E$0)
   (IMPLIES
    (AND (IN E$0 (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E$0 (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (IF (IN E (PR!PROCESS-ALPHABET P))
  (IMPLIES
   (AND (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P)))
    (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q)))
   (IN E (PR!PROCESS-ALPHABET Q)))
  (IMPLIES
   (AND (IN E (PR!PROCESS-ALPHABET Q))
    (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P)))
   (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q)))))
Assuming PR!IN-PROCESS-TRACES with the
instantiations: (= S (TR!TACK E (TR!EMPTY))) (= P Q) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (PR!IS-PROCESS Q) (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q)))
   (TR!IS-TRACE-OF (TR!TACK E (TR!EMPTY)) (PR!PROCESS-ALPHABET Q)))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (IMPLIES
   (AND (IN E (PR!PROCESS-ALPHABET P))
    (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
    (IN E (PR!PROCESS-ALPHABET Q)))
   (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))
  (ALL (E$0)
   (IMPLIES
    (AND (IN E$0 (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E$0 (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (IF (IN E (PR!PROCESS-ALPHABET P))
  (IMPLIES
   (AND (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P)))
    (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q)))
   (IN E (PR!PROCESS-ALPHABET Q)))
  (IMPLIES
   (AND (IN E (PR!PROCESS-ALPHABET Q))
    (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P)))
   (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q)))))
Assuming PR!IN-PROCESS-TRACES with the
instantiations: (= S (TR!TACK E (TR!EMPTY))) (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (PR!IS-PROCESS P) (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P)))
   (TR!IS-TRACE-OF (TR!TACK E (TR!EMPTY)) (PR!PROCESS-ALPHABET P)))
  (IMPLIES
   (AND (PR!IS-PROCESS Q) (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q)))
   (TR!IS-TRACE-OF (TR!TACK E (TR!EMPTY)) (PR!PROCESS-ALPHABET Q)))
  (PR!IS-PROCESS P) (PR!IS-PROCESS Q)
  (IMPLIES
   (AND (IN E (PR!PROCESS-ALPHABET P))
    (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P))
    (IN E (PR!PROCESS-ALPHABET Q)))
   (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q))))
  (ALL (E$0)
   (IMPLIES
    (AND (IN E$0 (PR!PROCESS-ALPHABET P))
     (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES P))
     (IN E$0 (PR!PROCESS-ALPHABET Q)))
    (NOT (IN (TR!TACK E$0 (TR!EMPTY)) (PR!PROCESS-TRACES Q))))))
 (IF (IN E (PR!PROCESS-ALPHABET P))
  (IMPLIES
   (AND (NOT (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P)))
    (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q)))
   (IN E (PR!PROCESS-ALPHABET Q)))
  (IMPLIES
   (AND (IN E (PR!PROCESS-ALPHABET Q))
    (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES P)))
   (IN (TR!TACK E (TR!EMPTY)) (PR!PROCESS-TRACES Q)))))
Which simplifies
 with invocation of TR!IS-TRACE-OF
 when rewriting with TR!IS-TRACE-OF-EMPTY
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!TACK-HEAD-TAIL,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL,
TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
PR!IS-PROCESS-BOOL to ...
(TRUE)
UP
DOWN
P-STEP
TWO-SET
IN-TWO-SET
Beginning proof of IN-TWO-SET ...
(= (IN A (TWO-SET X Y)) (OR (= A X) (= A Y)))
Which simplifies
 with invocation of TWO-SET
 when rewriting with NULLSET.DEFINITION, SETADD.DEFINITION to ...
(TRUE)
IN-TWO-SET-1
Beginning proof of IN-TWO-SET-1 ...
(IN X (TWO-SET X Y))
Which simplifies
 when rewriting with IN-TWO-SET to ...
(TRUE)
IN-TWO-SET-2
Beginning proof of IN-TWO-SET-2 ...
(IN Y (TWO-SET X Y))
Which simplifies
 when rewriting with IN-TWO-SET
 with the assumptions IN-TWO-SET-1 to ...
(TRUE)
P-STEP-RESULT
Beginning proof of P-STEP-RESULT ...
(IMPLIES (AND (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))) (>= N 0))
 (IN (P-STEP P N) (PROCESSES (TWO-SET (UP) (DOWN)))))
Invoking P-STEP gives ...
(IMPLIES (AND (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1))) (>= N 0))
 (IN
  (IF (= N 0) (PR!PREFIX 0 (FN!APPLY P (+ 1 N)))
   (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY P (+ 1 N)))
    (PR!PREFIX 1 (FN!APPLY P (+ -1 N)))))
  (PROCESSES (TWO-SET 0 1))))
Assuming IS-PROCESS-APPLY-PROCESS-CHAIN with the
instantiations: (= F P) (= A (TWO-SET (UP) (DOWN))) (= N (+ 1 N)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (>= (+ 1 N) 0) (IS-CHAIN P (PROCESS-PO (TWO-SET 0 1))))
   (= (PR!IS-PROCESS (FN!APPLY P (+ 1 N))) (TRUE)))
  (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1))) (>= N 0))
 (IN
  (IF (= N 0) (PR!PREFIX 0 (FN!APPLY P (+ 1 N)))
   (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY P (+ 1 N)))
    (PR!PREFIX 1 (FN!APPLY P (+ -1 N)))))
  (PROCESSES (TWO-SET 0 1))))
Which simplifies
 when rewriting with UNION.COMMUTATIVE, SETRULES!UNION-SUBSET-RIGHT,
ALPHABET-INPUT-CHOICE, IS-PROCESS-INPUT-CHOICE, SETRULES!INTER-SUBSET-LEFT,
SUBSET-SETADD, SUBSET.SELF, SETRULES!SETADD-INTER-RIGHT-NONMEMBER,
NULLSET.DEFINITION, SETADD.DEFINITION, FIRST-ACTIONS-PREFIX,
PR!PROCESS-ALPHABET-PREFIX, ALPHABET-APPLY-PROCESS-CHAIN, IN-PROCESSES
 forward chaining using PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO, >=.SAME.TYPE
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, PR!PREFIX-IS-PROCESS, APPLY-IS-PROCESS-NAT,
PROCESS-ALPHABET-APPLY-NAT, PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, IN-TWO-SET-1,
IN-TWO-SET-2 to ...
(IMPLIES
 (AND (>= (+ 1 N) 0) (NOT (IS-CHAIN P (PROCESS-PO (TWO-SET 0 1))))
  (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1))) (>= N 0) (NOT (= N 0)))
 (=
  (UNION (PR!PROCESS-ALPHABET (FN!APPLY P (+ -1 N)))
   (PR!PROCESS-ALPHABET (FN!APPLY P (+ 1 N))))
  (TWO-SET 0 1)))
Assuming UNION.SELF with the
instantiations: (= X (TWO-SET (UP) (DOWN))) generates ...
(IMPLIES
 (AND (= (UNION (TWO-SET 0 1) (TWO-SET 0 1)) (TWO-SET 0 1)) (>= (+ 1 N) 0)
  (NOT (IS-CHAIN P (PROCESS-PO (TWO-SET 0 1))))
  (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1))) (>= N 0) (NOT (= N 0)))
 (=
  (UNION (PR!PROCESS-ALPHABET (FN!APPLY P (+ -1 N)))
   (PR!PROCESS-ALPHABET (FN!APPLY P (+ 1 N))))
  (TWO-SET 0 1)))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO, >=.SAME.TYPE
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, APPLY-IS-PROCESS-NAT,
PROCESS-ALPHABET-APPLY-NAT, PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO,
PROCESS-PO-IS-COMPLETE, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, IN-TWO-SET-1, IN-TWO-SET-2 to ...
(TRUE)
P-STEP-ALPHABET
Beginning proof of P-STEP-ALPHABET ...
(IMPLIES (AND (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))) (>= N 0))
 (= (PR!PROCESS-ALPHABET (P-STEP P N)) (TWO-SET (UP) (DOWN))))
Assuming P-STEP-RESULT with the instantiations: (= P P) (= N N) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))) (>= N 0))
   (IN (P-STEP P N) (PROCESSES (TWO-SET (UP) (DOWN)))))
  (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1))) (>= N 0))
 (= (PR!PROCESS-ALPHABET (P-STEP P N)) (TWO-SET 0 1)))
Which simplifies
 when rewriting with IN-PROCESSES
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions PR!IS-PROCESS-BOOL, IN-TWO-SET-1, IN-TWO-SET-2 to ...
(TRUE)
IS-PROCESS-P-STEP
Beginning proof of IS-PROCESS-P-STEP ...
(IMPLIES (AND (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))) (>= N 0))
 (= (PR!IS-PROCESS (P-STEP P N)) (TRUE)))
Assuming P-STEP-RESULT with the instantiations: (= P P) (= N N) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))) (>= N 0))
   (IN (P-STEP P N) (PROCESSES (TWO-SET (UP) (DOWN)))))
  (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1))) (>= N 0))
 (PR!IS-PROCESS (P-STEP P N)))
Which simplifies
 when rewriting with P-STEP-ALPHABET, IN-PROCESSES
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions PR!IS-PROCESS-BOOL, IN-TWO-SET-1, IN-TWO-SET-2 to ...
(TRUE)
P-STEP-AUX
P-STEP-AUX-IS-FUNCTION
Beginning proof of P-STEP-AUX-IS-FUNCTION ...
(= (FN!IS-FUNCTION (P-STEP-AUX P)) (TRUE))
Which simplifies
 with invocation of P-STEP, REL!IS-RELATION, FN!IS-FUNCTION
 when rewriting with IN-PROCESSES, NAT!IN-NAT, PAIR!IN-CROSS,
P-STEP-AUX.DEFINITION
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PR!IS-PROCESS-BOOL, PAIR!IS-PAIR-BOOL, FN!IS-FUNCTION-BOOL to ...
(TRUE)
DOM-P-STEP-AUX
Beginning proof of DOM-P-STEP-AUX ...
(IMPLIES (IN P (FN!FUN (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))))
 (= (REL!DOM (P-STEP-AUX P)) (NAT!NAT)))
Applying SETRULES!EXTENSIONALITY gives ...
(IMPLIES (IN P (FN!FUN (NAT!NAT) (PROCESSES (TWO-SET 0 1))))
 (ALL (E)
  (IF (IN E (REL!DOM (P-STEP-AUX P))) (IN E (NAT!NAT))
   (NOT (IN E (NAT!NAT))))))
Which simplifies
 when rewriting with P-STEP-ALPHABET, IS-PROCESS-P-STEP, IN-PROCESSES,
NAT!IN-NAT, PAIR!IN-CROSS, P-STEP-AUX.DEFINITION, REL!IN-DOM, IN-FUN
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions PR!IS-PROCESS-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, IN-TWO-SET-1, IN-TWO-SET-2 to ...
(TRUE)
APPLY-P-STEP-AUX
Beginning proof of APPLY-P-STEP-AUX ...
(IMPLIES (AND (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))) (>= N 0))
 (= (FN!APPLY (P-STEP-AUX P) N) (P-STEP P N)))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F (P-STEP-AUX P)) (= X N) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (P-STEP-AUX P)) (IN N (REL!DOM (P-STEP-AUX P))))
   (IN (PAIR!PAIR N (FN!APPLY (P-STEP-AUX P) N)) (P-STEP-AUX P)))
  (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1))) (>= N 0))
 (= (FN!APPLY (P-STEP-AUX P) N) (P-STEP P N)))
Rearranging gives ...
(IMPLIES
 (AND (>= N 0) (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IMPLIES
   (AND (FN!IS-FUNCTION (P-STEP-AUX P)) (IN N (REL!DOM (P-STEP-AUX P))))
   (IN (PAIR!PAIR N (FN!APPLY (P-STEP-AUX P) N)) (P-STEP-AUX P))))
 (= (FN!APPLY (P-STEP-AUX P) N) (P-STEP P N)))
Which simplifies
 when rewriting with IN-PROCESSES, PAIR!IN-CROSS, P-STEP-AUX.DEFINITION,
NAT!IN-NAT, DOM-P-STEP-AUX, IN-FUN, P-STEP-AUX-IS-FUNCTION
 forward chaining using PR!PROCESS-COMPOSITION, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, >=.SAME.TYPE
 with the assumptions PR!IS-PROCESS-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IN-TWO-SET-1,
IN-TWO-SET-2 to ...
(TRUE)
IS-FUN-P-STEP-AUX
Beginning proof of IS-FUN-P-STEP-AUX ...
(IMPLIES (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN))))
 (IS-FUN (P-STEP-AUX P) (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))))
Invoking (IS-FUN (P-STEP-AUX P) (NAT!NAT)
          (PROCESSES (TWO-SET (UP) (DOWN)))) gives
...
(IMPLIES (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
 (AND (FN!IS-FUNCTION (P-STEP-AUX P)) (= (REL!DOM (P-STEP-AUX P)) (NAT!NAT))
  (SUBSET (REL!RAN (P-STEP-AUX P)) (PROCESSES (TWO-SET 0 1)))))
Which simplifies
 with invocation of P-STEP, SUBSET
 when rewriting with IN-PROCESSES, NAT!IN-NAT, PAIR!IN-CROSS,
P-STEP-AUX.DEFINITION, REL!IN-RAN, DOM-P-STEP-AUX, IN-FUN,
P-STEP-AUX-IS-FUNCTION
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions PR!PREFIX-IS-PROCESS, APPLY-IN-NOMINAL-RANGE-NAT,
APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT, PR!IS-PROCESS-BOOL,
PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
FN!IS-FUNCTION-BOOL, IN-TWO-SET-1, IN-TWO-SET-2 to ...
(IMPLIES (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
 (ALL (E A)
  (IMPLIES
   (AND (>= A 0) (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) (TWO-SET 0 1))
    (IF (= A 0) (= E (PR!PREFIX 0 (FN!APPLY P 1)))
     (= E
      (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY P (+ 1 A)))
       (PR!PREFIX 1 (FN!APPLY P (+ -1 A)))))))
   (AND (PR!IS-PROCESS E) (= (PR!PROCESS-ALPHABET E) (TWO-SET 0 1))))))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions PR!PREFIX-IS-PROCESS, APPLY-IN-NOMINAL-RANGE-NAT,
APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT, PR!IS-PROCESS-BOOL,
IN-TWO-SET-1, IN-TWO-SET-2 to ...
(TRUE)
P-STEP-FN
P-STEP-FN-IS-FUNCTION
Beginning proof of P-STEP-FN-IS-FUNCTION ...
(= (FN!IS-FUNCTION (P-STEP-FN)) (TRUE))
Which simplifies
 with invocation of REL!IS-RELATION, FN!IS-FUNCTION
 when rewriting with IN-FUN, PAIR!IN-CROSS, P-STEP-FN.DEFINITION
 forward chaining using IS-FUN-FACTS, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
IS-FUN-P-STEP-AUX, PAIR!IS-PAIR-BOOL, FN!IS-FUNCTION-BOOL to ...
(TRUE)
DOM-P-STEP-FN
Beginning proof of DOM-P-STEP-FN ...
(= (REL!DOM (P-STEP-FN)) (FN!FUN (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))))
Applying SETRULES!EXTENSIONALITY gives ...
(IF (IN E (REL!DOM (P-STEP-FN)))
 (IN E (FN!FUN (NAT!NAT) (PROCESSES (TWO-SET 0 1))))
 (NOT (IN E (FN!FUN (NAT!NAT) (PROCESSES (TWO-SET 0 1))))))
Which simplifies
 when rewriting with IN-FUN, PAIR!IN-CROSS, P-STEP-FN.DEFINITION, REL!IN-DOM
 forward chaining using FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
PAIR!PAIR-COMPOSITION
 with the assumptions IS-FUN-P-STEP-AUX, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
APPLY-P-STEP-FN
Beginning proof of APPLY-P-STEP-FN ...
(IMPLIES (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN))))
 (= (FN!APPLY (P-STEP-FN) P) (P-STEP-AUX P)))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F (P-STEP-FN)) (= X P) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION (P-STEP-FN)) (IN P (REL!DOM (P-STEP-FN))))
   (IN (PAIR!PAIR P (FN!APPLY (P-STEP-FN) P)) (P-STEP-FN)))
  (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1))))
 (= (FN!APPLY (P-STEP-FN) P) (P-STEP-AUX P)))
Rearranging gives ...
(IMPLIES
 (AND (IS-FUN P (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IMPLIES (AND (FN!IS-FUNCTION (P-STEP-FN)) (IN P (REL!DOM (P-STEP-FN))))
   (IN (PAIR!PAIR P (FN!APPLY (P-STEP-FN) P)) (P-STEP-FN))))
 (= (FN!APPLY (P-STEP-FN) P) (P-STEP-AUX P)))
Which simplifies
 when rewriting with PAIR!IN-CROSS, P-STEP-FN.DEFINITION, IN-FUN,
DOM-P-STEP-FN, P-STEP-FN-IS-FUNCTION
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions IS-FUN-P-STEP-AUX, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IN-TWO-SET-1,
IN-TWO-SET-2 to ...
(TRUE)
IS-FUN-P-STEP-FN
Beginning proof of IS-FUN-P-STEP-FN ...
(IS-FUN (P-STEP-FN) (FN!FUN (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN))))
 (FN!FUN (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN)))))
Invoking IS-FUN gives ...
(AND (FN!IS-FUNCTION (P-STEP-FN))
 (= (REL!DOM (P-STEP-FN)) (FN!FUN (NAT!NAT) (PROCESSES (TWO-SET 0 1))))
 (SUBSET (REL!RAN (P-STEP-FN)) (FN!FUN (NAT!NAT) (PROCESSES (TWO-SET 0 1)))))
Which simplifies
 with invocation of SUBSET
 when rewriting with IN-FUN, PAIR!IN-CROSS, P-STEP-FN.DEFINITION, REL!IN-RAN,
DOM-P-STEP-FN, P-STEP-FN-IS-FUNCTION
 forward chaining using IS-FUN-FACTS, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions IS-FUN-P-STEP-AUX, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, IN-TWO-SET-1, IN-TWO-SET-2,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
P-STEP-FN-IS-MONOTONIC
Beginning proof of P-STEP-FN-IS-MONOTONIC ...
(IS-MONOTONIC (P-STEP-FN)
 (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET (UP) (DOWN))))
 (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET (UP) (DOWN)))))
Invoking IS-MONOTONIC gives ...
(AND
 (IS-FUN (P-STEP-FN) (REL!DOM (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
  (REL!DOM (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
 (ALL (X Y)
  (IMPLIES (RELATED X (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))) Y)
   (RELATED (FN!APPLY (P-STEP-FN) X)
    (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
    (FN!APPLY (P-STEP-FN) Y)))))
Which simplifies
 when rewriting with APPLY-P-STEP-FN, IN-FUN, RELATED-BY-FN-ORDER,
DOM-PROCESS-PO, DOM-FN-ORDER
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC, COMPLETE-PO-IS-PO,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions IS-FUN-P-STEP-AUX, FUNCTION-ORDER-COMPLETE,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, IN-TWO-SET-1,
IN-TWO-SET-2, IS-FUN-P-STEP-FN to ...
(IMPLIES
 (AND (IS-FUN X (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IS-FUN Y (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (POINTWISE-RELATED X (PROCESS-PO (TWO-SET 0 1)) Y))
 (POINTWISE-RELATED (P-STEP-AUX X) (PROCESS-PO (TWO-SET 0 1)) (P-STEP-AUX Y)))
Invoking POINTWISE-RELATED gives ...
(IMPLIES
 (AND (IS-FUN X (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IS-FUN Y (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (ALL (X$0)
   (IMPLIES (IN X$0 (REL!DOM X))
    (RELATED (FN!APPLY X X$0) (PROCESS-PO (TWO-SET 0 1)) (FN!APPLY Y X$0)))))
 (ALL (X$1)
  (IMPLIES (IN X$1 (REL!DOM (P-STEP-AUX X)))
   (RELATED (FN!APPLY (P-STEP-AUX X) X$1) (PROCESS-PO (TWO-SET 0 1))
    (FN!APPLY (P-STEP-AUX Y) X$1)))))
Which simplifies
 when rewriting with P-STEP-ALPHABET, IS-PROCESS-P-STEP, APPLY-P-STEP-AUX,
RELATED-BY-PROCESS-PO, NAT!IN-NAT
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC, COMPLETE-PO-IS-PO,
PR!PROCESS-COMPOSITION, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions IS-FUN-P-STEP-AUX, PR!IS-PROCESS-BOOL, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, APPLY-IN-NOMINAL-RANGE-NAT,
APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT, IN-TWO-SET-1,
IN-TWO-SET-2 to ...
(IMPLIES
 (AND (IS-FUN X (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IS-FUN Y (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (ALL (X$0)
   (IMPLIES (>= X$0 0)
    (PR!PROCESS-INCLUDED (FN!APPLY X X$0) (FN!APPLY Y X$0)))))
 (ALL (X$1)
  (IMPLIES (>= X$1 0) (PR!PROCESS-INCLUDED (P-STEP X X$1) (P-STEP Y X$1)))))
Instantiating (= X$0 (+ 1 X$1)) gives ...
(IMPLIES
 (AND (IS-FUN X (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IS-FUN Y (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IMPLIES (>= (+ 1 X$0) 0)
   (PR!PROCESS-INCLUDED (FN!APPLY X (+ 1 X$0)) (FN!APPLY Y (+ 1 X$0))))
  (ALL (X$1)
   (IMPLIES (>= X$1 0)
    (PR!PROCESS-INCLUDED (FN!APPLY X X$1) (FN!APPLY Y X$1))))
  (>= X$0 0))
 (PR!PROCESS-INCLUDED (P-STEP X X$0) (P-STEP Y X$0)))
Invoking P-STEP gives ...
(IMPLIES
 (AND (IS-FUN X (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IS-FUN Y (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IMPLIES (>= (+ 1 X$0) 0)
   (PR!PROCESS-INCLUDED (FN!APPLY X (+ 1 X$0)) (FN!APPLY Y (+ 1 X$0))))
  (ALL (X$1)
   (IMPLIES (>= X$1 0)
    (PR!PROCESS-INCLUDED (FN!APPLY X X$1) (FN!APPLY Y X$1))))
  (>= X$0 0))
 (PR!PROCESS-INCLUDED
  (IF (= X$0 0) (PR!PREFIX 0 (FN!APPLY X (+ 1 X$0)))
   (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY X (+ 1 X$0)))
    (PR!PREFIX 1 (FN!APPLY X (+ -1 X$0)))))
  (IF (= X$0 0) (PR!PREFIX 0 (FN!APPLY Y (+ 1 X$0)))
   (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY Y (+ 1 X$0)))
    (PR!PREFIX 1 (FN!APPLY Y (+ -1 X$0)))))))
Invoking PR!PROCESS-INCLUDED gives ...
(IMPLIES
 (AND (IS-FUN X (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IS-FUN Y (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (IMPLIES (>= (+ 1 X$0) 0)
   (AND
    (= (PR!PROCESS-ALPHABET (FN!APPLY X (+ 1 X$0)))
     (PR!PROCESS-ALPHABET (FN!APPLY Y (+ 1 X$0))))
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY X (+ 1 X$0)))
     (PR!PROCESS-TRACES (FN!APPLY Y (+ 1 X$0))))))
  (ALL (X$1)
   (IMPLIES (>= X$1 0)
    (AND
     (= (PR!PROCESS-ALPHABET (FN!APPLY X X$1))
      (PR!PROCESS-ALPHABET (FN!APPLY Y X$1)))
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY X X$1))
      (PR!PROCESS-TRACES (FN!APPLY Y X$1))))))
  (>= X$0 0))
 (AND
  (=
   (PR!PROCESS-ALPHABET
    (IF (= X$0 0) (PR!PREFIX 0 (FN!APPLY X (+ 1 X$0)))
     (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY X (+ 1 X$0)))
      (PR!PREFIX 1 (FN!APPLY X (+ -1 X$0))))))
   (PR!PROCESS-ALPHABET
    (IF (= X$0 0) (PR!PREFIX 0 (FN!APPLY Y (+ 1 X$0)))
     (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY Y (+ 1 X$0)))
      (PR!PREFIX 1 (FN!APPLY Y (+ -1 X$0)))))))
  (SUBSET
   (PR!PROCESS-TRACES
    (IF (= X$0 0) (PR!PREFIX 0 (FN!APPLY X (+ 1 X$0)))
     (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY X (+ 1 X$0)))
      (PR!PREFIX 1 (FN!APPLY X (+ -1 X$0))))))
   (PR!PROCESS-TRACES
    (IF (= X$0 0) (PR!PREFIX 0 (FN!APPLY Y (+ 1 X$0)))
     (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY Y (+ 1 X$0)))
      (PR!PREFIX 1 (FN!APPLY Y (+ -1 X$0)))))))))
Which simplifies
 when rewriting with SETRULES!SUBSET-UNION-RIGHT, SETRULES!SUBSET-UNION-LEFT,
SUBSET-MAP-TACK, SETRULES!SUBSET-SETADD, SETRULES!SETADD-IDEMPOTENT,
SETRULES!SETADD-UNION-RIGHT, TRACES-INPUT-CHOICE, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD,
PR!PROCESS-TRACES-PREFIX, UNION.COMMUTATIVE, ALPHABET-INPUT-CHOICE,
SETRULES!INTER-SUBSET-LEFT, SUBSET-SETADD, SUBSET.SELF,
SETRULES!SETADD-INTER-RIGHT-NONMEMBER, NULLSET.DEFINITION, SETADD.DEFINITION,
FIRST-ACTIONS-PREFIX, PR!PROCESS-ALPHABET-PREFIX
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PR!PROCESS-COMPOSITION, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
PR!PREFIX-IS-PROCESS, PR!IS-PROCESS-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT, IN-TWO-SET-1, IN-TWO-SET-2
 with the instantiation (= X$1 (+ -1 X$0)) to ...
(TRUE)
CSP-REC-LEMMA
Beginning proof of CSP-REC-LEMMA ...
(= (RELATED F (FN-ORDER D (PROCESS-PO A)) G)
 (AND (IS-FUN F D (PROCESSES A)) (IS-FUN G D (PROCESSES A))
  (ALL (X)
   (IMPLIES (IN X D)
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X))
     (PR!PROCESS-TRACES (FN!APPLY G X)))))))
Splitting on (RELATED F (FN-ORDER D (PROCESS-PO A)) G) generates ...
(IF (RELATED F (FN-ORDER D (PROCESS-PO A)) G)
 (= (RELATED F (FN-ORDER D (PROCESS-PO A)) G)
  (AND (IS-FUN F D (PROCESSES A)) (IS-FUN G D (PROCESSES A))
   (ALL (X)
    (IMPLIES (IN X D)
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X))
      (PR!PROCESS-TRACES (FN!APPLY G X)))))))
 (= (RELATED F (FN-ORDER D (PROCESS-PO A)) G)
  (AND (IS-FUN F D (PROCESSES A)) (IS-FUN G D (PROCESSES A))
   (ALL (X$0)
    (IMPLIES (IN X$0 D)
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$0))
      (PR!PROCESS-TRACES (FN!APPLY G X$0))))))))
Which simplifies
 when rewriting with IN-FUN, DOM-PROCESS-PO, RELATED-BY-FN-ORDER
 forward chaining using PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS, RELATED-DOM-RAN, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE, APPLY-IS-PROCESS,
PROCESS-ALPHABET-APPLY, FUNCTION-ORDER-COMPLETE, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE to ...
(IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IS-FUN G D (PROCESSES A)))
 (IF (POINTWISE-RELATED F (PROCESS-PO A) G)
  (ALL (X)
   (IMPLIES (IN X D)
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X))
     (PR!PROCESS-TRACES (FN!APPLY G X)))))
  (NOT
   (ALL (X$0)
    (IMPLIES (IN X$0 D)
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$0))
      (PR!PROCESS-TRACES (FN!APPLY G X$0))))))))
Invoking POINTWISE-RELATED gives ...
(IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IS-FUN G D (PROCESSES A)))
 (IF
  (ALL (X)
   (IMPLIES (IN X (REL!DOM F))
    (RELATED (FN!APPLY F X) (PROCESS-PO A) (FN!APPLY G X))))
  (ALL (X$0)
   (IMPLIES (IN X$0 D)
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$0))
     (PR!PROCESS-TRACES (FN!APPLY G X$0)))))
  (NOT
   (ALL (X$1)
    (IMPLIES (IN X$1 D)
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$1))
      (PR!PROCESS-TRACES (FN!APPLY G X$1))))))))
Which simplifies
 when rewriting with RELATED-BY-PROCESS-PO
 forward chaining using RELATED-DOM-RAN, IS-PO-BASIC, COMPLETE-PO-IS-PO,
PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions PR!IS-PROCESS-BOOL, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, APPLY-IN-NOMINAL-RANGE,
APPLY-IS-PROCESS, PROCESS-ALPHABET-APPLY to ...
(IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IS-FUN G D (PROCESSES A)))
 (IF
  (ALL (X)
   (IMPLIES (IN X (REL!DOM F))
    (PR!PROCESS-INCLUDED (FN!APPLY F X) (FN!APPLY G X))))
  (ALL (X$0)
   (IMPLIES (IN X$0 D)
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$0))
     (PR!PROCESS-TRACES (FN!APPLY G X$0)))))
  (NOT
   (ALL (X$1)
    (IMPLIES (IN X$1 D)
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$1))
      (PR!PROCESS-TRACES (FN!APPLY G X$1))))))))
Invoking PR!PROCESS-INCLUDED gives ...
(IMPLIES (AND (IS-FUN F D (PROCESSES A)) (IS-FUN G D (PROCESSES A)))
 (IF
  (ALL (X)
   (IMPLIES (IN X (REL!DOM F))
    (AND
     (= (PR!PROCESS-ALPHABET (FN!APPLY F X))
      (PR!PROCESS-ALPHABET (FN!APPLY G X)))
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X))
      (PR!PROCESS-TRACES (FN!APPLY G X))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 D)
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$0))
     (PR!PROCESS-TRACES (FN!APPLY G X$0)))))
  (NOT
   (ALL (X$1)
    (IMPLIES (IN X$1 D)
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$1))
      (PR!PROCESS-TRACES (FN!APPLY G X$1))))))))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE, APPLY-IS-PROCESS,
PROCESS-ALPHABET-APPLY
 with the instantiation (= X X$0) to ...
(IMPLIES
 (AND (IS-FUN F D (PROCESSES A)) (IS-FUN G D (PROCESSES A))
  (NOT
   (ALL (X)
    (IMPLIES (IN X (REL!DOM F))
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X))
      (PR!PROCESS-TRACES (FN!APPLY G X)))))))
 (NOT
  (ALL (X$0)
   (IMPLIES (IN X$0 D)
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$0))
     (PR!PROCESS-TRACES (FN!APPLY G X$0)))))))
Instantiating (= X$0 X) gives ...
(IMPLIES
 (AND (IS-FUN F D (PROCESSES A)) (IS-FUN G D (PROCESSES A))
  (NOT
   (IMPLIES (IN X (REL!DOM F))
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X))
     (PR!PROCESS-TRACES (FN!APPLY G X))))))
 (NOT
  (AND
   (IMPLIES (IN X D)
    (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X))
     (PR!PROCESS-TRACES (FN!APPLY G X))))
   (ALL (X$0)
    (IMPLIES (IN X$0 D)
     (SUBSET (PR!PROCESS-TRACES (FN!APPLY F X$0))
      (PR!PROCESS-TRACES (FN!APPLY G X$0))))))))
Which simplifies
 forward chaining using PR!PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE, APPLY-IS-PROCESS,
PROCESS-ALPHABET-APPLY to ...
(TRUE)
IN-TRACES-PROCESS-CHAIN-LIMIT
Beginning proof of IN-TRACES-PROCESS-CHAIN-LIMIT ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (= (IN T (PR!PROCESS-TRACES (PR!PROCESS-CHAIN-LIMIT F)))
  (SOME (N) (AND (>= N 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N)))))))
Splitting
on (AND (IS-CHAIN F (PROCESS-PO A))
    (IN T (PR!PROCESS-TRACES (PR!PROCESS-CHAIN-LIMIT F)))) generates
...
(IF
 (AND (IS-CHAIN F (PROCESS-PO A))
  (IN T (PR!PROCESS-TRACES (PR!PROCESS-CHAIN-LIMIT F))))
 (IMPLIES (IS-CHAIN F (PROCESS-PO A))
  (= (IN T (PR!PROCESS-TRACES (PR!PROCESS-CHAIN-LIMIT F)))
   (SOME (N) (AND (>= N 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N)))))))
 (IMPLIES (IS-CHAIN F (PROCESS-PO A))
  (= (IN T (PR!PROCESS-TRACES (PR!PROCESS-CHAIN-LIMIT F)))
   (SOME (N$0) (AND (>= N$0 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N$0))))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE to ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (IF (IN T (PR!PROCESS-TRACES (PR!PROCESS-CHAIN-LIMIT F)))
  (= (TRUE)
   (SOME (N) (AND (>= N 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N))))))
  (= (FALSE)
   (SOME (N$0) (AND (>= N$0 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N$0))))))))
Invoking PR!PROCESS-CHAIN-LIMIT gives ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (IF
  (IN T
   (PR!PROCESS-TRACES
    (PR!MAKE-PROCESS (PR!PROCESS-ALPHABET (FN!APPLY F 0))
     (CUP (PR!COLLECT-TRACES F)))))
  (SOME (N) (AND (>= N 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N)))))
  (NOT
   (SOME (N$0) (AND (>= N$0 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N$0))))))))
Which simplifies
 when rewriting with NAT!IN-NAT, FN!IN-RAN-FUNCTION,
PR!COLLECT-TRACES.DEFINITION, CUP.DEFINITION, ALPHABET-APPLY-PROCESS-CHAIN
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions FN!IS-FUNCTION-BOOL, PR!PROCESS-ALPHABET-MAKE-PROCESS,
PR!PROCESS-TRACES-MAKE-PROCESS, APPLY-IN-NOMINAL-RANGE-NAT, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE to ...
(IMPLIES (IS-CHAIN F (PROCESS-PO A))
 (IF (SOME (Y) (AND (IN T (PR!PROCESS-TRACES (FN!APPLY F Y))) (>= Y 0)))
  (SOME (N) (AND (>= N 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N)))))
  (NOT
   (SOME (N$0) (AND (>= N$0 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N$0))))))))
Starting case 2 ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (SOME (Y) (AND (IN T (PR!PROCESS-TRACES (FN!APPLY F Y))) (>= Y 0))))
 (SOME (N) (AND (>= N 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A)) (IN T (PR!PROCESS-TRACES (FN!APPLY F Y)))
  (>= Y 0))
 (SOME (N) (AND (>= N 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N))))))
Instantiating (= N Y) gives ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A)) (IN T (PR!PROCESS-TRACES (FN!APPLY F Y)))
  (>= Y 0) (NOT (AND (>= Y 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F Y))))))
 (SOME (N) (AND (>= N 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT (SOME (Y) (AND (IN T (PR!PROCESS-TRACES (FN!APPLY F Y))) (>= Y 0)))))
 (NOT
  (SOME (N$0) (AND (>= N$0 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N$0)))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT (SOME (Y) (AND (IN T (PR!PROCESS-TRACES (FN!APPLY F Y))) (>= Y 0)))))
 (NOT (AND (>= N 0) (IN T (PR!PROCESS-TRACES (FN!APPLY F N))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE to ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT (SOME (Y) (AND (IN T (PR!PROCESS-TRACES (FN!APPLY F Y))) (>= Y 0))))
  (>= N 0))
 (NOT (IN T (PR!PROCESS-TRACES (FN!APPLY F N)))))
Instantiating (= Y N) gives ...
(IMPLIES
 (AND (IS-CHAIN F (PROCESS-PO A))
  (NOT
   (OR (AND (IN T (PR!PROCESS-TRACES (FN!APPLY F N))) (>= N 0))
    (SOME (Y) (AND (IN T (PR!PROCESS-TRACES (FN!APPLY F Y))) (>= Y 0)))))
  (>= N 0))
 (NOT (IN T (PR!PROCESS-TRACES (FN!APPLY F N)))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
CHAIN-IS-FUN, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
PARAMETERIZED-CSP-RECURSION-CONTINUITY-LEMMA
Beginning proof of PARAMETERIZED-CSP-RECURSION-CONTINUITY-LEMMA ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (ALL (G X T)
   (IMPLIES
    (AND (IS-CHAIN G (FN-ORDER D (PROCESS-PO A))) (IN X D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (LIMIT G (FN-ORDER D (PROCESS-PO A)))) X))))
    (SOME (N)
     (AND (>= N 0)
      (IN T (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G N)) X))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Assuming CONTINUITY-SUBGOAL with the
instantiations: (= F F) (= R (FN-ORDER D (PROCESS-PO A))) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-COMPLETE-PO (FN-ORDER D (PROCESS-PO A)))
    (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
    (ALL (G)
     (IMPLIES (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
      (RELATED (FN!APPLY F (LIMIT G (FN-ORDER D (PROCESS-PO A))))
       (FN-ORDER D (PROCESS-PO A))
       (LIMIT (REL!COMP G F) (FN-ORDER D (PROCESS-PO A)))))))
   (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
  (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (ALL (G$0 X T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (LIMIT G$0 (FN-ORDER D (PROCESS-PO A)))) X))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Which simplifies
 when rewriting with APPLY-POINTWISE-LIMIT, IS-FUN-POINTWISE-LIMIT-2,
DOM-PROCESS-PO, CSP-REC-LEMMA, IS-CHAIN-COMP, FN-ORDER-LIMIT
 forward chaining using >=.SAME.TYPE, CONTINUOUS-IMPLIES-MONOTONIC,
PR!PROCESS-COMPOSITION, RELATED-DOM-RAN, CHAIN-IS-FUN,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-MONOTONIC-FACTS, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, APPLY-IN-NOMINAL-RANGE,
APPLY-IS-PROCESS, PROCESS-ALPHABET-APPLY, IS-FUN-COMPOSITION,
IS-FUNCTION-POINTWISE-LIMIT, IS-FUN-POINTWISE-LIMIT, LIMIT-IN-DOM,
FUNCTION-ORDER-COMPLETE, PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO,
PROCESS-PO-IS-COMPLETE to ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (NOT
   (ALL (G)
    (IMPLIES (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
     (AND
      (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D
       (PROCESSES A))
      (ALL (X)
       (IMPLIES (IN X D)
        (SUBSET
         (PR!PROCESS-TRACES
          (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X))
         (PR!PROCESS-TRACES
          (LIMIT (SECTION (REL!COMP G F) X) (PROCESS-PO A))))))))))
  (ALL (G$0 X$0 T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X$0))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Invoking SUBSET gives ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (NOT
   (ALL (G)
    (IMPLIES (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
     (AND
      (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D
       (PROCESSES A))
      (ALL (X)
       (IMPLIES (IN X D)
        (ALL (E)
         (IMPLIES
          (IN E
           (PR!PROCESS-TRACES
            (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X)))
          (IN E
           (PR!PROCESS-TRACES
            (LIMIT (SECTION (REL!COMP G F) X) (PROCESS-PO A))))))))))))
  (ALL (G$0 X$0 T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X$0))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Prenexing produces ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (NOT
   (IMPLIES (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
    (AND
     (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D
      (PROCESSES A))
     (IMPLIES
      (AND (IN X D)
       (IN E
        (PR!PROCESS-TRACES
         (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X))))
      (IN E
       (PR!PROCESS-TRACES
        (LIMIT (SECTION (REL!COMP G F) X) (PROCESS-PO A))))))))
  (ALL (G$0 X$0 T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X$0))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Which simplifies
 forward chaining using CONTINUOUS-IMPLIES-MONOTONIC, >=.SAME.TYPE,
PR!PROCESS-COMPOSITION, CHAIN-IS-FUN, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS,
IS-MONOTONIC-FACTS, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions APPLY-IN-NOMINAL-RANGE-NAT, IS-FUN-COMPOSITION,
APPLY-IN-NOMINAL-RANGE, APPLY-IS-PROCESS, PROCESS-ALPHABET-APPLY,
IS-FUNCTION-POINTWISE-LIMIT, IS-FUN-POINTWISE-LIMIT, FUNCTION-ORDER-COMPLETE,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE to ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A))))
 (IF
  (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A))
  (IMPLIES
   (AND (IN X D)
    (IN E
     (PR!PROCESS-TRACES
      (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X)))
    (NOT
     (IN E
      (PR!PROCESS-TRACES (LIMIT (SECTION (REL!COMP G F) X) (PROCESS-PO A)))))
    (ALL (G$0 X$0 T)
     (IMPLIES
      (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
       (IN T
        (PR!PROCESS-TRACES
         (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
      (SOME (N)
       (AND (>= N 0)
        (IN T
         (PR!PROCESS-TRACES
          (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X$0))))))))
   (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
  (IMPLIES
   (ALL (G$1 X$1 T$0)
    (IMPLIES
     (AND (IS-CHAIN G$1 (FN-ORDER D (PROCESS-PO A))) (IN X$1 D)
      (IN T$0
       (PR!PROCESS-TRACES
        (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$1 D (PROCESS-PO A))) X$1))))
     (SOME (N$0)
      (AND (>= N$0 0)
       (IN T$0
        (PR!PROCESS-TRACES
         (FN!APPLY (FN!APPLY F (FN!APPLY G$1 N$0)) X$1)))))))
   (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))))
Starting case 2 ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
  (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A))
  (IN X D)
  (IN E
   (PR!PROCESS-TRACES
    (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X)))
  (NOT
   (IN E
    (PR!PROCESS-TRACES (LIMIT (SECTION (REL!COMP G F) X) (PROCESS-PO A)))))
  (ALL (G$0 X$0 T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X$0))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Applying PROCESS-PO-LIMIT gives ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
  (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A))
  (IN X D)
  (IN E
   (PR!PROCESS-TRACES
    (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X)))
  (NOT
   (IN E
    (PR!PROCESS-TRACES
     (IF (IS-CHAIN (SECTION (REL!COMP G F) X) (PROCESS-PO A))
      (PR!PROCESS-CHAIN-LIMIT (SECTION (REL!COMP G F) X))
      (LIMIT (SECTION (REL!COMP G F) X) (PROCESS-PO A))))))
  (ALL (G$0 X$0 T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X$0))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Assuming SECTION-IS-CHAIN with the
instantiations: (= F (REL!COMP G F)) (= X X) (= D D)
                (= R (PROCESS-PO A)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-CHAIN (REL!COMP G F) (FN-ORDER D (PROCESS-PO A))) (IN X D))
   (IS-CHAIN (SECTION (REL!COMP G F) X) (PROCESS-PO A)))
  (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
  (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A))
  (IN X D)
  (IN E
   (PR!PROCESS-TRACES
    (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X)))
  (NOT
   (IN E
    (PR!PROCESS-TRACES
     (IF (IS-CHAIN (SECTION (REL!COMP G F) X) (PROCESS-PO A))
      (PR!PROCESS-CHAIN-LIMIT (SECTION (REL!COMP G F) X))
      (LIMIT (SECTION (REL!COMP G F) X) (PROCESS-PO A))))))
  (ALL (G$0 X$0 T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X$0))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Rearranging gives ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
  (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A))
  (IN X D)
  (IN E
   (PR!PROCESS-TRACES
    (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X)))
  (IMPLIES
   (AND (IS-CHAIN (REL!COMP G F) (FN-ORDER D (PROCESS-PO A))) (IN X D))
   (IS-CHAIN (SECTION (REL!COMP G F) X) (PROCESS-PO A)))
  (NOT
   (IN E
    (PR!PROCESS-TRACES
     (IF (IS-CHAIN (SECTION (REL!COMP G F) X) (PROCESS-PO A))
      (PR!PROCESS-CHAIN-LIMIT (SECTION (REL!COMP G F) X))
      (LIMIT (SECTION (REL!COMP G F) X) (PROCESS-PO A))))))
  (ALL (G$0 X$0 T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X$0))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Instantiating (= G$0 G) (= X$0 X) (= T E) gives ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
  (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A))
  (IN X D)
  (IN E
   (PR!PROCESS-TRACES
    (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X)))
  (IMPLIES
   (AND (IS-CHAIN (REL!COMP G F) (FN-ORDER D (PROCESS-PO A))) (IN X D))
   (IS-CHAIN (SECTION (REL!COMP G F) X) (PROCESS-PO A)))
  (NOT
   (IN E
    (PR!PROCESS-TRACES
     (IF (IS-CHAIN (SECTION (REL!COMP G F) X) (PROCESS-PO A))
      (PR!PROCESS-CHAIN-LIMIT (SECTION (REL!COMP G F) X))
      (LIMIT (SECTION (REL!COMP G F) X) (PROCESS-PO A))))))
  (IMPLIES
   (AND (IS-CHAIN G (FN-ORDER D (PROCESS-PO A))) (IN X D)
    (IN E
     (PR!PROCESS-TRACES
      (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) X))))
   (SOME (N)
    (AND (>= N 0)
     (IN E (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G N)) X))))))
  (ALL (G$0 X$0 T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
    (SOME (N$0)
     (AND (>= N$0 0)
      (IN T
       (PR!PROCESS-TRACES
        (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N$0)) X$0))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Which simplifies
 when rewriting with FN!APPLY-COMP, APPLY-SECTION, NAT!IN-NAT,
IN-TRACES-PROCESS-CHAIN-LIMIT, IS-CHAIN-COMP
 forward chaining using >=.SAME.TYPE, PR!PROCESS-COMPOSITION, CHAIN-IS-FUN,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-MONOTONIC-FACTS, IS-PO-BASIC,
COMPLETE-PO-IS-PO
 with the assumptions FN!IS-FUNCTION-BOOL, APPLY-IN-NOMINAL-RANGE-NAT,
IS-FUN-COMPOSITION, APPLY-IN-NOMINAL-RANGE, APPLY-IS-PROCESS,
PROCESS-ALPHABET-APPLY, IS-FUNCTION-POINTWISE-LIMIT, IS-FUN-POINTWISE-LIMIT,
FUNCTION-ORDER-COMPLETE, PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO,
PROCESS-PO-IS-COMPLETE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
  (NOT
   (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A)))
  (ALL (G$1 X$1 T$0)
   (IMPLIES
    (AND (IS-CHAIN G$1 (FN-ORDER D (PROCESS-PO A))) (IN X$1 D)
     (IN T$0
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$1 D (PROCESS-PO A))) X$1))))
    (SOME (N$0)
     (AND (>= N$0 0)
      (IN T$0
       (PR!PROCESS-TRACES
        (FN!APPLY (FN!APPLY F (FN!APPLY G$1 N$0)) X$1))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Assuming APPLY-IN-NOMINAL-RANGE with the
instantiations: (= F F) (= X (POINTWISE-LIMIT G D (PROCESS-PO A)))
                (= D (FN!FUN D (PROCESSES A)))
                (= R (FN!FUN D (PROCESSES A))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-FUN F (FN!FUN D (PROCESSES A)) (FN!FUN D (PROCESSES A)))
    (IN (POINTWISE-LIMIT G D (PROCESS-PO A)) (FN!FUN D (PROCESSES A))))
   (IN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A)))
    (FN!FUN D (PROCESSES A))))
  (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
  (NOT
   (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A)))
  (ALL (G$0 X T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Rearranging gives ...
(IMPLIES
 (AND (IS-MONOTONIC F (FN-ORDER D (PROCESS-PO A)) (FN-ORDER D (PROCESS-PO A)))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
  (NOT
   (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A)))
  (IMPLIES
   (AND (IS-FUN F (FN!FUN D (PROCESSES A)) (FN!FUN D (PROCESSES A)))
    (IN (POINTWISE-LIMIT G D (PROCESS-PO A)) (FN!FUN D (PROCESSES A))))
   (IN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A)))
    (FN!FUN D (PROCESSES A))))
  (ALL (G$0 X T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Invoking IS-MONOTONIC gives ...
(IMPLIES
 (AND
  (IS-FUN F (REL!DOM (FN-ORDER D (PROCESS-PO A)))
   (REL!DOM (FN-ORDER D (PROCESS-PO A))))
  (ALL (X Y)
   (IMPLIES (RELATED X (FN-ORDER D (PROCESS-PO A)) Y)
    (RELATED (FN!APPLY F X) (FN-ORDER D (PROCESS-PO A)) (FN!APPLY F Y))))
  (IS-CHAIN G (FN-ORDER D (PROCESS-PO A)))
  (NOT
   (IS-FUN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A))) D (PROCESSES A)))
  (IMPLIES
   (AND (IS-FUN F (FN!FUN D (PROCESSES A)) (FN!FUN D (PROCESSES A)))
    (IN (POINTWISE-LIMIT G D (PROCESS-PO A)) (FN!FUN D (PROCESSES A))))
   (IN (FN!APPLY F (POINTWISE-LIMIT G D (PROCESS-PO A)))
    (FN!FUN D (PROCESSES A))))
  (ALL (G$0 X$0 T)
   (IMPLIES
    (AND (IS-CHAIN G$0 (FN-ORDER D (PROCESS-PO A))) (IN X$0 D)
     (IN T
      (PR!PROCESS-TRACES
       (FN!APPLY (FN!APPLY F (POINTWISE-LIMIT G$0 D (PROCESS-PO A))) X$0))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY F (FN!APPLY G$0 N)) X$0))))))))
 (IS-CONTINUOUS F (FN-ORDER D (PROCESS-PO A))))
Which simplifies
 when rewriting with IS-FUN-POINTWISE-LIMIT-2, IN-FUN, CSP-REC-LEMMA,
DOM-PROCESS-PO, DOM-FN-ORDER
 forward chaining using CHAIN-IS-FUN, PR!PROCESS-COMPOSITION, RELATED-DOM-RAN,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS, IS-PO-BASIC, COMPLETE-PO-IS-PO
 with the assumptions IS-FUNCTION-POINTWISE-LIMIT, IS-FUN-POINTWISE-LIMIT,
APPLY-IN-NOMINAL-RANGE, APPLY-IS-PROCESS, PROCESS-ALPHABET-APPLY,
FUNCTION-ORDER-COMPLETE, PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO,
PROCESS-PO-IS-COMPLETE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
P-STEP-FN-IS-CONTINUOUS
Beginning proof of P-STEP-FN-IS-CONTINUOUS ...
(IS-CONTINUOUS (P-STEP-FN)
 (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET (UP) (DOWN)))))
Assuming PARAMETERIZED-CSP-RECURSION-CONTINUITY-LEMMA with the
instantiations: (= F (P-STEP-FN)) (= D (NAT!NAT))
                (= A (TWO-SET (UP) (DOWN))) generates
...
(IF
 (IMPLIES
  (AND
   (IS-MONOTONIC (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
    (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
   (ALL (G X T)
    (IMPLIES
     (AND (IS-CHAIN G (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (IN X (NAT!NAT))
      (IN T
       (PR!PROCESS-TRACES
        (FN!APPLY
         (FN!APPLY (P-STEP-FN)
          (LIMIT G (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
         X))))
     (SOME (N)
      (AND (>= N 0)
       (IN T
        (PR!PROCESS-TRACES
         (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N)) X))))))))
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
 (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
 (TRUE))
Assuming P-STEP-FN-IS-MONOTONIC generates ...
(IF
 (IS-MONOTONIC (P-STEP-FN)
  (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET (UP) (DOWN))))
  (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET (UP) (DOWN)))))
 (IF
  (IMPLIES
   (AND
    (IS-MONOTONIC (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
     (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
    (ALL (G X T)
     (IMPLIES
      (AND (IS-CHAIN G (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
       (IN X (NAT!NAT))
       (IN T
        (PR!PROCESS-TRACES
         (FN!APPLY
          (FN!APPLY (P-STEP-FN)
           (LIMIT G (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
          X))))
      (SOME (N)
       (AND (>= N 0)
        (IN T
         (PR!PROCESS-TRACES
          (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N)) X))))))))
   (IS-CONTINUOUS (P-STEP-FN)
    (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
  (TRUE))
 (TRUE))
Which simplifies
 when rewriting with APPLY-P-STEP-AUX, APPLY-P-STEP-FN,
IS-FUN-POINTWISE-LIMIT-2, DOM-PROCESS-PO, FN-ORDER-LIMIT, NAT!IN-NAT
 forward chaining using CONTINUOUS-IMPLIES-MONOTONIC, PR!PROCESS-COMPOSITION,
>=.SAME.TYPE, CHAIN-IS-FUN, IS-MONOTONIC-FACTS, IS-PO-BASIC,
COMPLETE-PO-IS-PO, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT,
APPLY-IN-NOMINAL-RANGE, APPLY-IN-NOMINAL-RANGE-FUN,
APPLY-IN-NOMINAL-RANGE-NAT, IS-FUNCTION-POINTWISE-LIMIT,
IS-FUN-POINTWISE-LIMIT, LIMIT-IN-DOM, FUNCTION-ORDER-COMPLETE,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, IN-TWO-SET-1,
IN-TWO-SET-2, IS-FUN-P-STEP-FN to ...
(IF
 (IS-MONOTONIC (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
  (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
 (IF
  (ALL (G X T)
   (IMPLIES
    (AND (IS-CHAIN G (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) (>= X 0)
     (IN T
      (PR!PROCESS-TRACES
       (P-STEP (POINTWISE-LIMIT G (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))) X))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES
        (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N)) X)))))))
  (TRUE)
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
 (TRUE))
Applying APPLY-P-STEP-FN gives ...
(IF
 (IS-MONOTONIC (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
  (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
 (IF
  (ALL (G X T)
   (IMPLIES
    (AND (IS-CHAIN G (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) (>= X 0)
     (IN T
      (PR!PROCESS-TRACES
       (P-STEP (POINTWISE-LIMIT G (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))) X))))
    (SOME (N)
     (AND (>= N 0)
      (IN T
       (PR!PROCESS-TRACES
        (FN!APPLY
         (IF (IS-FUN (FN!APPLY G N) (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
          (P-STEP-AUX (FN!APPLY G N)) (FN!APPLY (P-STEP-FN) (FN!APPLY G N)))
         X)))))))
  (TRUE)
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
 (TRUE))
Which simplifies
 when rewriting with APPLY-P-STEP-AUX
 forward chaining using CONTINUOUS-IMPLIES-MONOTONIC, PR!PROCESS-COMPOSITION,
>=.SAME.TYPE, CHAIN-IS-FUN, IS-MONOTONIC-FACTS, IS-PO-BASIC,
COMPLETE-PO-IS-PO, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT,
APPLY-IN-NOMINAL-RANGE, APPLY-IN-NOMINAL-RANGE-FUN, IS-FUN-P-STEP-AUX,
APPLY-IN-NOMINAL-RANGE-NAT, IS-FUNCTION-POINTWISE-LIMIT,
IS-FUN-POINTWISE-LIMIT, FUNCTION-ORDER-COMPLETE, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, IN-TWO-SET-1, IN-TWO-SET-2,
IS-FUN-P-STEP-FN to ...
(IF
 (IS-MONOTONIC (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
  (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
 (IF
  (ALL (G X T)
   (IMPLIES
    (AND (IS-CHAIN G (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) (>= X 0)
     (IN T
      (PR!PROCESS-TRACES
       (P-STEP (POINTWISE-LIMIT G (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))) X))))
    (SOME (N)
     (AND (>= N 0)
      (IF (IS-FUN (FN!APPLY G N) (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
       (IN T (PR!PROCESS-TRACES (P-STEP (FN!APPLY G N) X)))
       (IN T
        (PR!PROCESS-TRACES
         (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N)) X))))))))
  (TRUE)
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
 (TRUE))
Invoking P-STEP gives ...
(IF
 (IS-MONOTONIC (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
  (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
 (IF
  (ALL (G X T)
   (IMPLIES
    (AND (IS-CHAIN G (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) (>= X 0)
     (IN T
      (PR!PROCESS-TRACES
       (IF (= X 0)
        (PR!PREFIX 0
         (FN!APPLY (POINTWISE-LIMIT G (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
          (+ 1 X)))
        (INPUT-CHOICE
         (PR!PREFIX 0
          (FN!APPLY (POINTWISE-LIMIT G (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
           (+ 1 X)))
         (PR!PREFIX 1
          (FN!APPLY (POINTWISE-LIMIT G (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
           (+ -1 X))))))))
    (SOME (N)
     (AND (>= N 0)
      (IF (IS-FUN (FN!APPLY G N) (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
       (IN T
        (PR!PROCESS-TRACES
         (IF (= X 0) (PR!PREFIX 0 (FN!APPLY (FN!APPLY G N) (+ 1 X)))
          (INPUT-CHOICE (PR!PREFIX 0 (FN!APPLY (FN!APPLY G N) (+ 1 X)))
           (PR!PREFIX 1 (FN!APPLY (FN!APPLY G N) (+ -1 X)))))))
       (IN T
        (PR!PROCESS-TRACES
         (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N)) X))))))))
  (TRUE)
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
 (TRUE))
Which simplifies
 when rewriting with UNION.DEFINITION, EMPTY-IN-TRACES, APPLY-SECTION,
IN-TRACES-PROCESS-CHAIN-LIMIT, IN-MAP-TACK, SETRULES!SETADD-IDEMPOTENT,
UNION.COMMUTATIVE, SETRULES!SETADD-UNION-RIGHT, TRACES-INPUT-CHOICE,
SETRULES!INTER-SUBSET-LEFT, SUBSET-SETADD, SUBSET.SELF,
SETRULES!SETADD-INTER-RIGHT-NONMEMBER, NULLSET.DEFINITION, SETADD.DEFINITION,
FIRST-ACTIONS-PREFIX, IS-PROCESS-PREFIX, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD,
PR!PROCESS-TRACES-PREFIX, PROCESS-ALPHABET-LIMIT, LIMIT-IS-PROCESS,
PROCESS-PO-LIMIT, APPLY-POINTWISE-LIMIT, NAT!IN-NAT
 forward chaining using CONTINUOUS-IMPLIES-MONOTONIC,
TR!NOT-IS-TRACE-IS-EMPTY, TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION, >=.SAME.TYPE, CHAIN-IS-FUN,
IS-MONOTONIC-FACTS, IS-PO-BASIC, COMPLETE-PO-IS-PO, FN!FUNCTION-IS-RELATION,
IS-FUN-FACTS
 with the assumptions APPLY-IN-NOMINAL-RANGE, APPLY-IN-NOMINAL-RANGE-FUN,
PR!PREFIX-IS-PROCESS, APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT,
TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!IS-EMPTY-BOOL,
SETRULES!SUBSET-INTER-RELATION-1, SETRULES!SUBSET-INTER-RELATION-2,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PR!IS-PROCESS-BOOL, LIMIT-IN-DOM,
SECTION-IS-CHAIN-NAT, APPLY-IN-NOMINAL-RANGE-NAT, IS-FUNCTION-POINTWISE-LIMIT,
IS-FUN-POINTWISE-LIMIT, FUNCTION-ORDER-COMPLETE, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, IN-TWO-SET-1, IN-TWO-SET-2,
IS-FUN-P-STEP-FN
 with the instantiation (= N X) to ...
(IF
 (IS-MONOTONIC (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
  (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
 (IF
  (ALL (G X)
   (IMPLIES
    (AND (IS-CHAIN G (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
     (>= X 0))
    (IF (= X 0)
     (ALL (T N)
      (IMPLIES
       (AND (NOT (= T (TR!EMPTY))) (NOT (TR!IS-EMPTY T)) (= (TR!HEAD T) 0)
        (>= N 0)
        (IN (TR!TAIL T) (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N) 1))))
       (SOME (N$0)
        (AND (>= N$0 0)
         (IF (IS-FUN (FN!APPLY G N$0) (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
          (IN (TR!TAIL T) (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$0) 1)))
          (IN T
           (PR!PROCESS-TRACES
            (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N$0)) 0))))))))
     (ALL (T$0 N$1 N$2)
      (OR (= T$0 (TR!EMPTY)) (TR!IS-EMPTY T$0)
       (IF (= (TR!HEAD T$0) 1)
        (IMPLIES
         (AND (>= N$1 0)
          (IN (TR!TAIL T$0)
           (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$1) (+ -1 X)))))
         (SOME (N$3)
          (AND (>= N$3 0)
           (IF (IS-FUN (FN!APPLY G N$3) (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
            (IN (TR!TAIL T$0)
             (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$3) (+ -1 X))))
            (IN T$0
             (PR!PROCESS-TRACES
              (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N$3)) X)))))))
        (IMPLIES
         (AND (= (TR!HEAD T$0) 0) (>= N$2 0)
          (IN (TR!TAIL T$0)
           (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$2) (+ 1 X)))))
         (SOME (N$4)
          (AND (>= N$4 0)
           (IF (IS-FUN (FN!APPLY G N$4) (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
            (IN (TR!TAIL T$0)
             (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$4) (+ 1 X))))
            (IN T$0
             (PR!PROCESS-TRACES
              (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N$4)) X)))))))))))))
  (TRUE)
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
 (TRUE))
Invoking IS-CHAIN gives ...
(IF
 (IS-MONOTONIC (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
  (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
 (IF
  (ALL (G X)
   (IMPLIES
    (AND
     (IS-FUN G (NAT!NAT)
      (REL!DOM (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
     (ALL (N)
      (IMPLIES (IN N (NAT!NAT))
       (RELATED (FN!APPLY G N) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))
        (FN!APPLY G (+ 1 N)))))
     (>= X 0))
    (IF (= X 0)
     (ALL (T N$0)
      (IMPLIES
       (AND (NOT (= T (TR!EMPTY))) (NOT (TR!IS-EMPTY T)) (= (TR!HEAD T) 0)
        (>= N$0 0)
        (IN (TR!TAIL T) (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$0) 1))))
       (SOME (N$1)
        (AND (>= N$1 0)
         (IF (IS-FUN (FN!APPLY G N$1) (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
          (IN (TR!TAIL T) (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$1) 1)))
          (IN T
           (PR!PROCESS-TRACES
            (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N$1)) 0))))))))
     (ALL (T$0 N$2 N$3)
      (OR (= T$0 (TR!EMPTY)) (TR!IS-EMPTY T$0)
       (IF (= (TR!HEAD T$0) 1)
        (IMPLIES
         (AND (>= N$2 0)
          (IN (TR!TAIL T$0)
           (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$2) (+ -1 X)))))
         (SOME (N$4)
          (AND (>= N$4 0)
           (IF (IS-FUN (FN!APPLY G N$4) (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
            (IN (TR!TAIL T$0)
             (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$4) (+ -1 X))))
            (IN T$0
             (PR!PROCESS-TRACES
              (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N$4)) X)))))))
        (IMPLIES
         (AND (= (TR!HEAD T$0) 0) (>= N$3 0)
          (IN (TR!TAIL T$0)
           (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$3) (+ 1 X)))))
         (SOME (N$5)
          (AND (>= N$5 0)
           (IF (IS-FUN (FN!APPLY G N$5) (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
            (IN (TR!TAIL T$0)
             (PR!PROCESS-TRACES (FN!APPLY (FN!APPLY G N$5) (+ 1 X))))
            (IN T$0
             (PR!PROCESS-TRACES
              (FN!APPLY (FN!APPLY (P-STEP-FN) (FN!APPLY G N$5)) X)))))))))))))
  (TRUE)
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
 (TRUE))
Which simplifies
 when rewriting with CSP-REC-LEMMA, NAT!IN-NAT, DOM-PROCESS-PO, DOM-FN-ORDER
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!TACK-HEAD-TAIL,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, PR!PROCESS-COMPOSITION,
RELATED-DOM-RAN, >=.SAME.TYPE, IS-MONOTONIC-FACTS, IS-PO-BASIC,
COMPLETE-PO-IS-PO, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!IS-EMPTY-BOOL,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, APPLY-IS-PROCESS-NAT,
PROCESS-ALPHABET-APPLY-NAT, APPLY-IN-NOMINAL-RANGE-NAT,
APPLY-IN-NOMINAL-RANGE-FUN-NAT, FUNCTION-ORDER-COMPLETE, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, IN-TWO-SET-1, IN-TWO-SET-2,
IS-FUN-P-STEP-FN
 with the instantiations (= N$1 N$0) (= N$4 N$2) (= N$5 N$3) to ...
(TRUE)
EXAMPLE-PROCESS
EXAMPLE-PROCESS-1
Beginning proof of EXAMPLE-PROCESS-1 ...
(IS-FUN (EXAMPLE-PROCESS) (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN))))
Assuming FIXPT-IS-FIXEDPOINT with the
instantiations: (= F (P-STEP-FN))
                (= R
                 (FN-ORDER (NAT!NAT)
                  (PROCESS-PO (TWO-SET (UP) (DOWN))))) generates
...
(IF
 (IMPLIES
  (AND (IS-COMPLETE-PO (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
   (HAS-BOTTOM (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
   (IS-CONTINUOUS (P-STEP-FN)
    (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
  (AND
   (IN (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
    (REL!DOM (P-STEP-FN)))
   (=
    (FN!APPLY (P-STEP-FN)
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))))
 (IS-FUN (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
  (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
 (TRUE))
Assuming P-STEP-FN-IS-CONTINUOUS generates ...
(IF
 (IS-CONTINUOUS (P-STEP-FN)
  (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET (UP) (DOWN)))))
 (IF
  (IMPLIES
   (AND (IS-COMPLETE-PO (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
    (HAS-BOTTOM (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
    (IS-CONTINUOUS (P-STEP-FN)
     (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
   (AND
    (IN (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
     (REL!DOM (P-STEP-FN)))
    (=
     (FN!APPLY (P-STEP-FN)
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))))
  (IS-FUN (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
   (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
  (TRUE))
 (TRUE))
Which simplifies
 when rewriting with APPLY-P-STEP-FN, IN-FUN, DOM-P-STEP-FN,
HAS-BOTTOM-FN-ORDER
 forward chaining using IS-MONOTONIC-FACTS, CONTINUOUS-IMPLIES-MONOTONIC,
IS-PO-BASIC, COMPLETE-PO-IS-PO, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions IS-FUN-P-STEP-AUX, FUNCTION-ORDER-COMPLETE,
PROCESS-PO-IS-PO, HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, IN-TWO-SET-1,
IN-TWO-SET-2, IS-FUN-P-STEP-FN to ...
(TRUE)
EXAMPLE-PROCESS-2
Beginning proof of EXAMPLE-PROCESS-2 ...
(IMPLIES (>= N 0)
 (= (FN!APPLY (EXAMPLE-PROCESS) N)
  (IF (= N 0) (PR!PREFIX (UP) (FN!APPLY (EXAMPLE-PROCESS) 1))
   (INPUT-CHOICE (PR!PREFIX (UP) (FN!APPLY (EXAMPLE-PROCESS) (+ 1 N)))
    (PR!PREFIX (DOWN) (FN!APPLY (EXAMPLE-PROCESS) (+ -1 N)))))))
Assuming FIXPT-IS-FIXEDPOINT with the
instantiations: (= F (P-STEP-FN))
                (= R
                 (FN-ORDER (NAT!NAT)
                  (PROCESS-PO (TWO-SET (UP) (DOWN))))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-COMPLETE-PO (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
    (HAS-BOTTOM (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
    (IS-CONTINUOUS (P-STEP-FN)
     (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
   (AND
    (IN (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
     (REL!DOM (P-STEP-FN)))
    (=
     (FN!APPLY (P-STEP-FN)
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))))
  (>= N 0))
 (=
  (FN!APPLY
   (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) N)
  (IF (= N 0)
   (PR!PREFIX 0
    (FN!APPLY
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) 1))
   (INPUT-CHOICE
    (PR!PREFIX 0
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ 1 N)))
    (PR!PREFIX 1
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ -1 N)))))))
Assuming P-STEP-FN-IS-CONTINUOUS generates ...
(IMPLIES
 (AND
  (IS-CONTINUOUS (P-STEP-FN)
   (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET (UP) (DOWN)))))
  (IMPLIES
   (AND (IS-COMPLETE-PO (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
    (HAS-BOTTOM (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
    (IS-CONTINUOUS (P-STEP-FN)
     (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
   (AND
    (IN (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
     (REL!DOM (P-STEP-FN)))
    (=
     (FN!APPLY (P-STEP-FN)
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))))
  (>= N 0))
 (=
  (FN!APPLY
   (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) N)
  (IF (= N 0)
   (PR!PREFIX 0
    (FN!APPLY
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) 1))
   (INPUT-CHOICE
    (PR!PREFIX 0
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ 1 N)))
    (PR!PREFIX 1
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ -1 N)))))))
Which simplifies
 when rewriting with APPLY-P-STEP-FN, IN-FUN, DOM-P-STEP-FN,
HAS-BOTTOM-FN-ORDER
 forward chaining using PR!PROCESS-COMPOSITION, >=.SAME.TYPE,
IS-MONOTONIC-FACTS, CONTINUOUS-IMPLIES-MONOTONIC, IS-PO-BASIC,
COMPLETE-PO-IS-PO, FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions PR!PREFIX-IS-PROCESS, PR!IS-PROCESS-BOOL,
APPLY-IN-NOMINAL-RANGE-NAT, APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT,
IS-FUN-P-STEP-AUX, FUNCTION-ORDER-COMPLETE, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, IN-TWO-SET-1, IN-TWO-SET-2,
IS-FUN-P-STEP-FN, EXAMPLE-PROCESS-1 to ...
(IMPLIES
 (AND
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
  (=
   (P-STEP-AUX
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
   (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
  (>= N 0))
 (IF (= N 0)
  (=
   (FN!APPLY
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) 0)
   (PR!PREFIX 0
    (FN!APPLY
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) 1)))
  (=
   (FN!APPLY
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) N)
   (INPUT-CHOICE
    (PR!PREFIX 0
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ 1 N)))
    (PR!PREFIX 1
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ -1 N)))))))
Assuming APPLY-P-STEP-AUX with the
instantiations: (= P (EXAMPLE-PROCESS)) (= N N) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (IS-FUN
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
     (NAT!NAT) (PROCESSES (TWO-SET (UP) (DOWN))))
    (>= N 0))
   (=
    (FN!APPLY
     (P-STEP-AUX
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
     N)
    (P-STEP
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) N)))
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
  (=
   (P-STEP-AUX
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
   (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
  (>= N 0))
 (IF (= N 0)
  (=
   (FN!APPLY
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) 0)
   (PR!PREFIX 0
    (FN!APPLY
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) 1)))
  (=
   (FN!APPLY
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) N)
   (INPUT-CHOICE
    (PR!PREFIX 0
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ 1 N)))
    (PR!PREFIX 1
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ -1 N)))))))
Invoking P-STEP gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (IS-FUN
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
     (NAT!NAT) (PROCESSES (TWO-SET 0 1)))
    (>= N 0))
   (=
    (FN!APPLY
     (P-STEP-AUX
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
     N)
    (IF (= N 0)
     (PR!PREFIX 0
      (FN!APPLY
       (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
       (+ 1 N)))
     (INPUT-CHOICE
      (PR!PREFIX 0
       (FN!APPLY
        (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
        (+ 1 N)))
      (PR!PREFIX 1
       (FN!APPLY
        (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
        (+ -1 N)))))))
  (IS-CONTINUOUS (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
  (=
   (P-STEP-AUX
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
   (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))))
  (>= N 0))
 (IF (= N 0)
  (=
   (FN!APPLY
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) 0)
   (PR!PREFIX 0
    (FN!APPLY
     (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) 1)))
  (=
   (FN!APPLY
    (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1)))) N)
   (INPUT-CHOICE
    (PR!PREFIX 0
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ 1 N)))
    (PR!PREFIX 1
     (FN!APPLY
      (FIXPT (P-STEP-FN) (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET 0 1))))
      (+ -1 N)))))))
Which simplifies
 forward chaining using IS-MONOTONIC-FACTS, CONTINUOUS-IMPLIES-MONOTONIC,
PR!PROCESS-COMPOSITION, >=.SAME.TYPE, IS-PO-BASIC, COMPLETE-PO-IS-PO,
FN!FUNCTION-IS-RELATION, IS-FUN-FACTS
 with the assumptions PR!PREFIX-IS-PROCESS, PR!IS-PROCESS-BOOL,
APPLY-IN-NOMINAL-RANGE-NAT, APPLY-IS-PROCESS-NAT, PROCESS-ALPHABET-APPLY-NAT,
IS-FUN-P-STEP-AUX, FUNCTION-ORDER-COMPLETE, PROCESS-PO-IS-PO,
HAS-BOTTOM-PROCESS-PO, PROCESS-PO-IS-COMPLETE, IN-TWO-SET-1, IN-TWO-SET-2,
IS-FUN-P-STEP-FN, EXAMPLE-PROCESS-1 to ...
(TRUE)
Done.