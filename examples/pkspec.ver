(load ms)
(load seq)
(load fn)

(function-stub make-state (seen-messages stores history))

(function-stub is-state (s))

(grule make-state-is-state (m st h)
  (is-state (make-state m st h)))

(grule is-state-bool (s)
  (= (type-of (is-state s)) (bool)))

(axiom state-is-constructed (s)
  (implies (is-state s)
           (some (m st h)
             (= s (make-state m st h)))))

(function-stub seen-messages (state))

(function-stub stores (state))

(function-stub history (state))

(grule seen-messages-of-make-state (seen-messages stores history)
  (= (seen-messages (make-state seen-messages stores history))
     seen-messages))

(grule stores-of-make-state (seen-messages stores history)
  (= (stores (make-state seen-messages stores history))
     stores))

(grule history-of-make-state (seen-messages stores history)
  (= (history (make-state seen-messages stores history))
     history))

(function-stub tag-of-event (event))

(function-stub make-send-event (label time message principal))

(function-stub make-receive-event (label time message principal))

(function-stub make-out-of-band-event (label time message sender receiver))

(function-stub make-generate-event (label time message principal))

(function-stub make-construct-event (label time message principal))

(function-stub make-intruder-event (label time message))

(grule tag-of-make-send-event (label time message principal)
  (= (tag-of-event (make-send-event label time message principal)) 0))

(grule tag-of-make-receive-event (label time message principal)
  (= (tag-of-event (make-receive-event label time message principal)) 1))

(grule tag-of-make-out-of-band-event (label time message sender receiver)
  (= (tag-of-event (make-out-of-band-event label time message sender receiver))
     2))

(grule tag-of-make-generate-event (label time message principal)
  (= (tag-of-event (make-generate-event label time message principal)) 3))

(grule tag-of-make-construct-event (label time message principal)
  (= (tag-of-event (make-construct-event label time message principal)) 4))

(grule tag-of-make-intruder-event (label time message)
  (= (tag-of-event (make-intruder-event label time message)) 5))

(function-stub send-events ())

(function-stub receive-events ())

(function-stub out-of-band-events ())

(function-stub generate-events ())

(function-stub construct-events ())

(function-stub intruder-events ())

(axiom send-event-is-constructed (e)
  (implies (in e (send-events))
           (some (l t m p)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in p (ms!principals))
                   (= e (make-send-event l t m p))))))

(axiom receive-event-is-constructed (e)
  (implies (in e (receive-events))
           (some (l t m p)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in p (ms!principals))
                   (= e (make-receive-event l t m p))))))

(axiom out-of-band-event-is-constructed (e)
  (implies (in e (out-of-band-events))
           (some (l t m s r)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in s (ms!principals))
                   (in r (ms!principals))
                   (= e (make-out-of-band-event l t m s r))))))

(axiom generate-event-is-constructed (e)
  (implies (in e (generate-events))
           (some (l t m p)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in p (ms!principals))
                   (= e (make-generate-event l t m p))))))

(axiom construct-event-is-constructed (e)
  (implies (in e (construct-events))
           (some (l t m p)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (in p (ms!principals))
                   (= e (make-construct-event l t m p))))))

(axiom intruder-event-is-constructed (e)
  (implies (in e (intruder-events))
           (some (l t m)
              (and (in l (nat!nat))
                   (in t (nat!nat))
                   (in m (ms!messages))
                   (= e (make-intruder-event l t m))))))

(frule tag-of-send-event (e)
  (implies (in e (send-events))
           (= (tag-of-event e) 0)))

(frule tag-of-receive-event (e)
  (implies (in e (receive-events))
           (= (tag-of-event e) 1)))

(frule tag-of-out-of-band-event (e)
  (implies (in e (out-of-band-events))
           (= (tag-of-event e) 2)))

(frule tag-of-generate-event (e)
  (implies (in e (generate-events))
           (= (tag-of-event e) 3)))

(frule tag-of-construct-event (e)
  (implies (in e (construct-events))
           (= (tag-of-event e) 4)))

(frule tag-of-intruder-event (e)
  (implies (in e (intruder-events))
           (= (tag-of-event e) 5)))

(grule make-send-event-is-send-event (l t m p)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in p (ms!principals)))
           (in (make-send-event l t m p) (send-events))))

(grule make-receive-event-is-receive-event (l t m p)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in p (ms!principals)))
           (in (make-receive-event l t m p) (receive-events))))

(grule make-out-of-band-event-is-out-of-band-event (l t m s r)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in s (ms!principals))
                (in r (ms!principals)))
           (in (make-out-of-band-event l t m s r) (out-of-band-events))))

(grule make-generate-event-is-generate-event (l t m p)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in p (ms!principals)))
           (in (make-generate-event l t m p) (generate-events))))

(grule make-construct-event-is-construct-event (l t m p)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages))
                (in p (ms!principals)))
           (in (make-construct-event l t m p) (construct-events))))

(grule make-intruder-event-is-intruder-event (l t m)
  (implies (and (>= l 0)
                (>= t 0)
                (in m (ms!messages)))
           (in (make-intruder-event l t m) (intruder-events))))

(disabled
  (function events () ()
    (union (send-events)
           (union (receive-events)
                  (union (out-of-band-events)
                         (union (generate-events)
                                (union (construct-events)
                                       (intruder-events))))))))

(frule send-event-is-event (e)
  (implies (in e (send-events))
           (in e (events))))

(frule receive-event-is-event (e)
  (implies (in e (receive-events))
           (in e (events))))

(frule out-of-band-event-is-event (e)
  (implies (in e (out-of-band-events))
           (in e (events))))

(frule generate-event-is-event (e)
  (implies (in e (generate-events))
           (in e (events))))

(frule construct-event-is-event (e)
  (implies (in e (construct-events))
           (in e (events))))

(frule intruder-event-is-event (e)
  (implies (in e (intruder-events))
           (in e (events))))

(function-stub label-of-event (event))

(grule label-of-send-event (l t m p)
  (= (label-of-event (make-send-event l t m p)) l))

(grule label-of-receive-event (l t m p)
  (= (label-of-event (make-receive-event l t m p)) l))

(grule label-of-out-of-band-event (l t m s r)
  (= (label-of-event (make-out-of-band-event l t m s r)) l))

(grule label-of-generate-event (l t m p)
  (= (label-of-event (make-generate-event l t m p)) l))

(grule label-of-construct-event (l t m p)
  (= (label-of-event (make-construct-event l t m p)) l))

(grule label-of-intruder-event (l t m)
  (= (label-of-event (make-intruder-event l t m)) l))

(function-stub time-of-event (event))

(grule time-of-send-event (l t m p)
  (= (time-of-event (make-send-event l t m p)) t))

(grule time-of-receive-event (l t m p)
  (= (time-of-event (make-receive-event l t m p)) t))

(grule time-of-out-of-band-event (l t m s r)
  (= (time-of-event (make-out-of-band-event l t m s r)) t))

(grule time-of-generate-event (l t m p)
  (= (time-of-event (make-generate-event l t m p)) t))

(grule time-of-construct-event (l t m p)
  (= (time-of-event (make-construct-event l t m p)) t))

(grule time-of-intruder-event (l t m)
  (= (time-of-event (make-intruder-event l t m)) t))

(function-stub message-of-event (event))

(grule message-of-send-event (l t m p)
  (= (message-of-event (make-send-event l t m p)) m))

(grule message-of-receive-event (l t m p)
  (= (message-of-event (make-receive-event l t m p)) m))

(grule message-of-out-of-band-event (l t m s r)
  (= (message-of-event (make-out-of-band-event l t m s r)) m))

(grule message-of-generate-event (l t m p)
  (= (message-of-event (make-generate-event l t m p)) m))

(grule message-of-construct-event (l t m p)
  (= (message-of-event (make-construct-event l t m p)) m))

(grule message-of-intruder-event (l t m)
  (= (message-of-event (make-intruder-event l t m)) m))

(function-stub principal1-of-event (event))

(grule principal1-of-send-event (l t m p)
  (= (principal1-of-event (make-send-event l t m p)) p))

(grule principal1-of-receive-event (l t m p)
  (= (principal1-of-event (make-receive-event l t m p)) p))

(grule principal1-of-out-of-band-event (l t m s r)
  (= (principal1-of-event (make-out-of-band-event l t m s r)) s))

(grule principal1-of-generate-event (l t m p)
  (= (principal1-of-event (make-generate-event l t m p)) p))

(grule principal1-of-construct-event (l t m p)
  (= (principal1-of-event (make-construct-event l t m p)) p))

(function-stub principal2-of-event (event))

(grule principal2-of-out-of-band-event (l t m s r)
  (= (principal2-of-event (make-out-of-band-event l t m s r)) r))


(function time-strictly-increases (history) ((measure (seq!length history)))
  (if (seq!emptyp history)
      (true)
      (if (>= (seq!length history) 2)
          (and (time-strictly-increases (seq!tail history))
               (in (time-of-event (seq!head history)) (nat!nat))
               (> (time-of-event (seq!head history))
                  (time-of-event (seq!head (seq!tail history)))))
          (in (time-of-event (seq!head history)) (nat!nat)))))

(function time-constraint (time state) ()
  (and (in time (nat!nat))
       (time-strictly-increases (history state))
       (implies (>= (seq!length (history state)) 1)
                (> time (time-of-event (seq!head (history state)))))))

(frule time-constraint-implies-nat (time state)
  (implies (time-constraint time state)
           (>= time 0)))

(axiom time-of-event-in-constrained-history-nat (event history)
  (implies (and (seq!is-sequence history)
                (seq!is-member event history)
                (time-strictly-increases history))
           (>= (time-of-event event) 0)))


(function all-storage (stores) ()
  (cup (rel!ran stores)))

(function add-to-storage (stores principal messages) ()
  (fn!override 
   stores
   (make-set (pair!pair
              principal (union messages (fn!apply stores principal))))))

(grule add-to-storage-is-function (stores principal message)
  (implies (fn!is-function stores)
           (fn!is-function (add-to-storage stores principal message))))

(rule add-nullset-to-storage (stores principal)
  (implies (and (fn!is-function stores)
		(in principal (rel!dom stores)))
	   (= (add-to-storage stores principal (nullset))
	      stores)))

(function storage-of (principal state) ()
  (fn!apply (stores state) principal))

(function all-messages-in-state (state) ()
  (union (ms!public-keys)
         (union (ms!text-messages)
                (union (ms!principals)
                       (union (seen-messages state)
                              (all-storage (stores state)))))))

(rule all-messages-in-state-definition (state)
  (= (all-messages-in-state state)
     (union (ms!public-keys)
         (union (ms!text-messages)
                (union (ms!principals)
                       (union (seen-messages state)
                              (all-storage (stores state))))))))

;;; Signature

(function sign (message key) ()
  (ms!combine message (ms!encrypt (ms!hash message) key)))

(grule sign-is-in-combine-messages (message key)
  (implies (and (in message (ms!messages))
                (in key (ms!keys)))
           (in (sign message key) (ms!combine-messages))))

(function 3combine (m1 m2 m3) ()
  (ms!combine m1 (ms!combine m2 m3)))

(grule 3combine-is-message (m1 m2 m3)
  (implies (and (in m1 (ms!messages))
                (in m2 (ms!messages))
                (in m3 (ms!messages)))
           (in (3combine m1 m2 m3) (ms!messages))))

(function 4combine (m1 m2 m3 m4) ()
  (ms!combine m1 (ms!combine m2 (ms!combine m3 m4))))

(grule 4combine-is-message (m1 m2 m3 m4)
  (implies (and (in m1 (ms!messages))
                (in m2 (ms!messages))
                (in m3 (ms!messages))
                (in m4 (ms!messages)))
           (in (4combine m1 m2 m3 m4) (ms!messages))))

(function 5combine (m1 m2 m3 m4 m5) ()
  (ms!combine m1 (ms!combine m2 (ms!combine m3 (ms!combine m4 m5)))))

(grule 5combine-is-message (m1 m2 m3 m4 m5)
  (implies (and (in m1 (ms!messages))
                (in m2 (ms!messages))
                (in m3 (ms!messages))
                (in m4 (ms!messages))
                (in m5 (ms!messages)))
           (in (5combine m1 m2 m3 m4 m5) (ms!messages))))

(function 6combine (m1 m2 m3 m4 m5 m6) ()
  (ms!combine
   m1 (ms!combine m2 (ms!combine m3 (ms!combine m4 (ms!combine m5 m6))))))

(grule 6combine-is-message (m1 m2 m3 m4 m5 m6)
  (implies (and (in m1 (ms!messages))
                (in m2 (ms!messages))
                (in m3 (ms!messages))
                (in m4 (ms!messages))
                (in m5 (ms!messages))
                (in m6 (ms!messages)))
           (in (6combine m1 m2 m3 m4 m5 m6) (ms!messages))))

(rule time-strictly-increases-step (event state)
  (implies (and (time-strictly-increases (history state))
                (time-constraint (time-of-event event) state))
           (= (time-strictly-increases
               (seq!tack event (history state)))
              (true))))

(function add-to-state-storage (principal message state) ()
  (make-state (seen-messages state)
              (add-to-storage (stores state) principal message)
              (history state)))

(grule add-to-state-storage-is-state (principal message state)
  (is-state (add-to-state-storage principal message state)))

(rule seen-messages-of-add-to-state-storage (principal message state)
  (= (seen-messages (add-to-state-storage principal message state))
     (seen-messages state)))

(rule stores-of-add-to-state-storage (principal message state)
  (= (stores (add-to-state-storage principal message state))
     (add-to-storage (stores state) principal message)))

(rule history-of-add-to-state-storage (principal message state)
  (= (history (add-to-state-storage principal message state))
     (history state)))

(function add-to-state-history (event state) ()
  (make-state (seen-messages state)
              (stores state)
              (seq!tack event (history state))))

(grule add-to-state-history-is-state (event state)
  (is-state (add-to-state-history event state)))

(rule seen-messages-of-add-to-state-history (event state)
  (= (seen-messages (add-to-state-history event state))
     (seen-messages state)))

(rule stores-of-add-to-state-history (event state)
  (= (stores (add-to-state-history event state))
     (stores state)))

(rule history-of-add-to-state-history (event state)
  (= (history (add-to-state-history event state))
     (seq!tack event (history state))))

(function add-to-state-seen-messages (messages state) ()
  (make-state (union messages (seen-messages state))
              (stores state)
              (history state)))

(grule add-to-state-seen-messages-is-state (message state)
  (is-state (add-to-state-seen-messages message state)))

(rule seen-messages-of-add-to-state-seen-messages (message state)
  (= (seen-messages (add-to-state-seen-messages message state))
     (union message (seen-messages state))))

(rule stores-of-add-to-state-seen-messages (message state)
  (= (stores (add-to-state-seen-messages message state))
     (stores state)))

(rule history-of-add-to-state-seen-messages (message state)
  (= (history (add-to-state-seen-messages message state))
     (history state)))

(function is-good-state (state) ()
  (and (is-state state)
       (subset (seen-messages state) (ms!messages))
       (time-strictly-increases (history state))
       (in (history state) (seq!sequence-of (events)))
       (fn!is-function (stores state))
       (= (rel!dom (stores state)) (ms!principals))
       (subset (rel!ran (stores state)) (powerset (ms!messages)))))

(frule is-good-state-implication (state)
  (implies (is-good-state state)
           (and (is-state state)
                (subset (seen-messages state) (ms!messages))
                (time-strictly-increases (history state))
                (in (history state) (seq!sequence-of (events)))
                (fn!is-function (stores state))
                (= (rel!dom (stores state)) (ms!principals))
                (subset (rel!ran (stores state)) (powerset (ms!messages))))))

(rule is-good-state-add-to-state-storage (principal messages state)
  (implies (and (is-good-state state)
                (in principal (ms!principals))
                (subset messages (ms!messages)))
           (= (is-good-state (add-to-state-storage principal messages state))
              (true))))

(rule is-good-state-add-to-state-history (event state)
  (implies (and (is-good-state state)
                (in event (events))
                (time-constraint (time-of-event event) state))
           (= (is-good-state (add-to-state-history event state))
              (true))))

(rule is-good-state-add-to-state-seen-messages (messages state)
  (implies (and (is-good-state state)
                (subset messages (ms!messages)))
           (= (is-good-state (add-to-state-seen-messages messages state))
              (true))))

;;; Rules about storage-of

(rule storage-of-add-to-state-storage (p1 p2 state m)
  (implies (and (is-good-state state)
                (in p1 (ms!principals))
                (in p2 (ms!principals)))
           (= (storage-of p1 (add-to-state-storage p2 m state))
              (if (= p1 p2)
                  (union m (storage-of p1 state))
                  (storage-of p1 state)))))

(rule storage-of-add-to-state-history (p event state)
  (implies (is-good-state state)
           (= (storage-of p (add-to-state-history event state))
              (storage-of p state))))

(rule storage-of-add-to-state-seen-messages (p m state)
  (implies (is-good-state state)
           (= (storage-of p (add-to-state-seen-messages m state))
              (storage-of p state))))


;;; Good Steps
;;; No-op if minimal precondition not satisfied.
;;; First, define cover functions for known by principal/intruder.

(function known-by-principal (message principal state) ()
  (ms!known-in message
               (union (storage-of principal state)
                      (union (ms!public-keys)
                             (union (ms!text-messages)
                                    (ms!principals))))))

(function forgeable (message state) ()
  (ms!known-in message
               (union (seen-messages state)
                      (union (ms!public-keys)
                             (union (ms!text-messages)
                                    (ms!principals))))))

(function send-step (label time message principal state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in principal (ms!principals))
           (known-by-principal message principal state))
      (add-to-state-seen-messages
       (make-set message)
       (add-to-state-history
        (make-send-event label time message principal)
        state))
      state))

(rule send-step-preserves-good-state (label time message principal state)
  (= (is-good-state (send-step label time message principal state))
     (is-good-state state)))

(function receive-step (label time message principal state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in principal (ms!principals))
           (forgeable message state))
      (add-to-state-storage
       principal
       (make-set message)
       (add-to-state-history
        (make-receive-event label time message principal)
        state))
      state))

(rule receive-step-preserves-good-state (label time message principal state)
  (= (is-good-state (receive-step label time message principal state))
     (is-good-state state)))

(function out-of-band-step (label time message sender receiver state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in sender (ms!principals))
           (in receiver (ms!principals))
           (known-by-principal message sender state))
      (add-to-state-storage
       receiver
       (make-set message)
       (add-to-state-history
        (make-out-of-band-event label time message sender receiver)
        state))
      state))

(rule out-of-band-step-preserves-good-state
    (label time message sender receiver state)
  (= (is-good-state
      (out-of-band-step label time message sender receiver state))
     (is-good-state state)))

(function generate-step (label time message principal state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in message (ms!atomic-messages))
           (ms!is-fresh message (all-messages-in-state state))
           (in principal (ms!principals)))
      (add-to-state-storage
       principal
       (make-set message)
       (add-to-state-history
        (make-generate-event label time message principal)
        state))
      state))

(rule generate-step-preserves-good-state (label time message principal state)
  (= (is-good-state (generate-step label time message principal state))
     (is-good-state state)))

(function construct-step (label time message principal state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in principal (ms!principals))
           (known-by-principal message principal state))
      (add-to-state-history
       (make-construct-event label time message principal)
       state)
      state))

(rule construct-step-preserves-good-state (label time message principal state)
  (= (is-good-state (construct-step label time message principal state))
     (is-good-state state)))

(function intruder-step (label time message state) ()
  (if (and (is-good-state state)
           (time-constraint time state)
           (>= label 0)
           (in message (ms!atomic-messages))
           (ms!is-fresh message (all-messages-in-state state)))
      (add-to-state-seen-messages
       (make-set message)
       (add-to-state-history
        (make-intruder-event label time message)
        state))
      state))

(rule intruder-step-preserves-good-state (label time message state)
  (= (is-good-state (intruder-step label time message state))
     (is-good-state state)))

;;; NEW STUFF !!!


;;; Minimal constraints on good evolution

(function good-step (s0 s1) ()
  (and (is-good-state s0)
       (some (label time message)
         (and (time-constraint time s0)
              (>= label 0)
              (or (some (principal)
                    (and (in principal (ms!principals))
                         (known-by-principal message principal s0)
                         (= s1 (send-step label time message principal s0))))
                  (some (principal)
                    (and (in principal (ms!principals))
                         (forgeable message s0)
                         (= s1 (receive-step
                                label time message principal s0))))
                  (some (sender receiver)
                    (and (in sender (ms!principals))
                         (in receiver (ms!principals))
                         (known-by-principal message sender s0)
                         (= s1 (out-of-band-step
                                label time message sender receiver s0))))
                  (some (principal)
                    (and (in message (ms!atomic-messages))
                         (ms!is-fresh message (all-messages-in-state s0))
                         (in principal (ms!principals))
                         (= s1 (generate-step
                                label time message principal s0))))
                  (some (principal)
                    (and (in principal (ms!principals))
                         (known-by-principal message principal s0)
                         (= s1 (construct-step
                                label time message principal s0))))
                  (and (in message (ms!atomic-messages))
                       (ms!is-fresh message (all-messages-in-state s0))
                       (= s1 (intruder-step label time message s0))))))))

(function is-good-evolution-state (state)
    ((measure (seq!length (history state))))
  (if (seq!emptyp (history state))
      (is-good-state state)
      (some (previous-state)
        (if (= (history previous-state)
               (seq!tail (history state)))
            (and (is-good-evolution-state previous-state)
                 (good-step previous-state state))
            (false)))))

(frule is-good-evolution-state-is-good-state (state)
  (implies (is-good-evolution-state state)
           (is-good-state state)))

(frule good-step-implies-good-states (s0 s1)
  (implies (good-step s0 s1)
           (and (is-good-state s0)
                (is-good-state s1))))

(rule seen-messages-send-step (label time message principal state)
  (= (seen-messages (send-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in principal (ms!principals))
              (known-by-principal message principal state))
         (setadd message (seen-messages state))
         (seen-messages state))))

(rule storage-of-send-step (p label time message principal state)
  (implies (in p (ms!principals))
           (= (storage-of p (send-step label time message principal state))
              (storage-of p state))))

(rule history-of-send-step (label time message principal state)
  (= (history (send-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in principal (ms!principals))
              (known-by-principal message principal state))
         (seq!tack (make-send-event label time message principal)
                   (history state))
         (history state))))

(rule seen-messages-receive-step (label time message principal state)
  (= (seen-messages (receive-step label time message principal state))
     (seen-messages state)))

(rule storage-of-receive-step (p label time message principal state)
  (implies (in p (ms!principals))
           (= (storage-of p (receive-step label time message principal state))
              (if (and (is-good-state state)
                       (time-constraint time state)
                       (>= label 0)
                       (in principal (ms!principals))
                       (forgeable message state)
                       (= p principal))
                  (setadd message (storage-of p state))
                  (storage-of p state)))))

(rule history-of-receive-step (label time message principal state)
  (= (history (receive-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in principal (ms!principals))
              (forgeable message state))
         (seq!tack (make-receive-event label time message principal)
                   (history state))
         (history state))))

(rule seen-messages-out-of-band-step (label time message sender receiver state)
  (= (seen-messages
      (out-of-band-step label time message sender receiver state))
     (seen-messages state)))

(rule storage-of-out-of-band-step (p label time message sender receiver state)
  (implies (in p (ms!principals))
           (= (storage-of
               p (out-of-band-step label time message sender receiver state))
              (if (and (is-good-state state)
                       (time-constraint time state)
                       (>= label 0)
                       (in sender (ms!principals))
                       (in receiver (ms!principals))
                       (known-by-principal message sender state)
                       (= p receiver))
                  (setadd message (storage-of p state))
                  (storage-of p state)))))

(rule history-of-out-of-band-step (label time message sender receiver state)
  (= (history (out-of-band-step label time message sender receiver state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in sender (ms!principals))
              (in receiver (ms!principals))
              (known-by-principal message sender state))
         (seq!tack (make-out-of-band-event label time message sender receiver)
                   (history state))
         (history state))))

(rule seen-messages-generate-step (label time message principal state)
  (= (seen-messages (generate-step label time message principal state))
     (seen-messages state)))

(rule storage-of-generate-step (p label time message principal state)
  (implies (in p (ms!principals))
           (= (storage-of p (generate-step label time message principal state))
              (if (and (is-good-state state)
                       (time-constraint time state)
                       (>= label 0)
                       (in message (ms!atomic-messages))
                       (ms!is-fresh message (all-messages-in-state state))
                       (in principal (ms!principals))
                       (= p principal))
                  (setadd message (storage-of p state))
                  (storage-of p state)))))

(rule history-of-generate-step (label time message principal state)
  (= (history (generate-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in message (ms!atomic-messages))
              (ms!is-fresh message (all-messages-in-state state))
              (in principal (ms!principals)))
         (seq!tack (make-generate-event label time message principal)
                   (history state))
         (history state))))

(rule seen-messages-construct-step (label time message principal state)
  (= (seen-messages (construct-step label time message principal state))
     (seen-messages state)))

(rule storage-of-construct-step (p label time message principal state)
  (= (storage-of p (construct-step label time message principal state))
     (storage-of p state)))

(rule history-of-construct-step (label time message principal state)
  (= (history (construct-step label time message principal state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in principal (ms!principals))
              (known-by-principal message principal state))
         (seq!tack (make-construct-event label time message principal)
                   (history state))
         (history state))))

(rule seen-messages-intruder-step (label time message state)
  (= (seen-messages (intruder-step label time message state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in message (ms!atomic-messages))
              (ms!is-fresh message (all-messages-in-state state)))
         (setadd message (seen-messages state))
         (seen-messages state))))

(rule storage-of-intruder-step (p label time message state)
  (= (storage-of p (intruder-step label time message state))
     (storage-of p state)))

(rule history-of-intruder-step (label time message state)
  (= (history (intruder-step label time message state))
     (if (and (is-good-state state)
              (time-constraint time state)
              (>= label 0)
              (in message (ms!atomic-messages))
              (ms!is-fresh message (all-messages-in-state state)))
         (seq!tack (make-intruder-event label time message)
                   (history state))
         (history state))))

(function is-good-evolution (sequence) ((measure (seq!length sequence)))
  (if (>= (seq!length sequence) 2)
      (and (is-good-evolution (seq!tail sequence))
           (good-step (seq!head (seq!tail sequence))
                      (seq!head sequence)))
      (if (>= (seq!length sequence) 1)
          (and (is-good-state (seq!head sequence))
               (= (history (seq!head sequence)) (seq!empty))
               (= (seq!tail sequence) (seq!empty)))
          (false))))

(grule tail-is-sequence (sequence)
  (implies (and (seq!is-sequence sequence)
                (seq!is-tack sequence))
           (seq!is-sequence (seq!tail sequence))))

(rule history-of-head-of-tail-of-good-evolution (sequence)
  (implies (and (is-good-evolution sequence)
                (>= (seq!length sequence) 2))
           (= (history (seq!head (seq!tail sequence)))
              (seq!tail (history (seq!head sequence))))))

(rule length-of-history-of-good-evolution (sequence)
  (implies (is-good-evolution sequence)
           (= (seq!length (history (seq!head sequence)))
              (- (seq!length sequence) 1))))

(axiom head-of-good-evolution (sequence)
  (implies (is-good-evolution sequence)
           (is-good-evolution-state (seq!head sequence))))

(rule is-good-evolution-tail (sequence)
  (implies (and (>= (seq!length sequence) 2)
                (is-good-evolution sequence))
           (= (is-good-evolution (seq!tail sequence)) (true))))


(function is-initial-evolution-state (state) ()
  (= (history state) (seq!empty)))

(grule non-initial-state-has-non-empty-history (state sequence)
  (implies (and (is-good-evolution sequence)
                (seq!is-member state sequence)
                (not (is-initial-evolution-state state)))
           (>= (seq!length (history state)) 1)))

(axiom history-of-state-is-subsequence (state sequence)
  (implies (and (is-good-evolution sequence)
                (seq!is-member state sequence))
           (some (s)
             (and (seq!is-sequence s)
                  (= (history (seq!head sequence))
                     (seq!join s (history state)))))))


(axiom time-of-event-of-evolution-state (e state)
  (implies (and (is-good-evolution-state state)
                (seq!is-member e (history state)))
           (>= (time-of-event e) 0)))


(axiom seen-messages-monotonic (sequence n1 n2)
  (implies (and (is-good-evolution sequence)
                (>= n2 1)
                (>= n1 n2)
                (>= (seq!length sequence) n1))
           (subset (seen-messages (seq!nth sequence n1))
                   (seen-messages (seq!nth sequence n2)))))

(axiom forgeable-is-monotonic (sequence message n1 n2)
  (implies (and (is-good-evolution sequence)
                (>= n2 1)
                (>= n1 n2)
                (>= (seq!length sequence) n1)
                (forgeable message (seq!nth sequence n1)))
           (forgeable message (seq!nth sequence n2))))

(axiom storage-of-principal-monotonic (sequence principal n1 n2)
  (implies (and (is-good-evolution sequence)
                (in principal (ms!principals))
                (>= n2 1)
                (>= n1 n2)
                (>= (seq!length sequence) n1))
           (subset (storage-of principal (seq!nth sequence n1))
                   (storage-of principal (seq!nth sequence n2)))))

(axiom known-by-is-monotonic (sequence principal message n1 n2)
  (implies (and (is-good-evolution sequence)
                (in principal (ms!principals))
                (>= n2 1)
                (>= n1 n2)
                (>= (seq!length sequence) n1)
                (known-by-principal message principal (seq!nth sequence n1)))
           (known-by-principal message principal (seq!nth sequence n2))))

(axiom sequence-member-can-be-accessed-using-nth (m s)
  (implies (and (seq!is-sequence s) (seq!is-member m s))
           (some (n) (and (>= n 1)
                          (= m (seq!nth s n))
                          (<= n (seq!length s))))))

(axiom member-is-good-evolution-state (sequence state)
  (implies (and (is-good-evolution sequence)
                (seq!is-member state sequence))
           (is-good-evolution-state state)))

(axiom nth-is-member (n sequence)
  (implies (and (seq!is-sequence sequence)
                (>= n 1)
                (<= n (seq!length sequence)))
           (seq!is-member (seq!nth sequence n) sequence)))

(axiom time-of-event-strictly-increases-2 (n1 n2 sequence)
  (implies (and (is-good-evolution sequence)
                (>= n1 1)
                (>= n2 (+ n1 1))
                (<= (+ n2 1) (seq!length sequence)))
           (>= (time-of-event (seq!head (history (seq!nth sequence n1))))
               (+ (time-of-event
                   (seq!head (history (seq!nth sequence n2))))
                  1))))

(axiom last-is-initial (sequence)
  (implies (is-good-evolution sequence)
           (is-initial-evolution-state 
            (seq!nth sequence (seq!length sequence)))))

(axiom subsequent-state-has-history (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= (+ n 1) (seq!length sequence)))
           (>= (seq!length (history (seq!nth sequence n))) 1)))

(axiom initial-state-has-no-history (sequence)
  (implies (is-good-evolution sequence)
           (= (history (seq!nth sequence (seq!length sequence)))
              (seq!empty))))

(axiom no-duplicates-in-good-evolution (n1 n2 sequence)
  (implies (and (is-good-evolution sequence)
                (>= n1 1)
                (>= n2 1)
                (<= n1 (seq!length sequence))
                (<= n2 (seq!length sequence))
                (= (seq!nth sequence n1) (seq!nth sequence n2)))
           (= n1 n2)))

;;; Need some stuff relating event histories and states.

(axiom head-of-good-evolution-not-in-tail (sequence)
  (implies (is-good-evolution sequence)
           (not (seq!is-member (seq!head sequence) (seq!tail sequence)))))

(axiom non-last-is-non-initial (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1)))
           (not (is-initial-evolution-state (seq!nth sequence n)))))

(axiom non-initial-is-non-last (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (seq!length sequence))
                (not (is-initial-evolution-state (seq!nth sequence n))))
           (<= n (- (seq!length sequence) 1))))

(axiom non-initial-state-is-result-of-step (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1)))
           (good-step (seq!nth sequence (+ n 1)) (seq!nth sequence n))))

(axiom send-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n))) (send-events)))
           (and (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal1-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence (+ n 1)))
                (forgeable
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))

(axiom receive-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (receive-events)))
           (and (forgeable
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence (+ n 1)))
                (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal1-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))

(axiom out-of-band-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (out-of-band-events)))
           (and (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal1-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence (+ n 1)))
                (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal2-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))

(axiom generate-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (generate-events)))
           (and (ms!is-fresh
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (all-messages-in-state (seq!nth sequence (+ n 1))))
                (known-by-principal
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (principal1-of-event
                  (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))

(axiom construct-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (construct-events)))
           (known-by-principal
            (message-of-event (seq!head (history (seq!nth sequence n))))
            (principal1-of-event (seq!head (history (seq!nth sequence n))))
            (seq!nth sequence (+ n 1)))))

(axiom intruder-event-theorem (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in (seq!head (history (seq!nth sequence n)))
                    (intruder-events)))
           (and (ms!is-fresh
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (all-messages-in-state (seq!nth sequence (+ n 1))))
                (forgeable
                 (message-of-event (seq!head (history (seq!nth sequence n))))
                 (seq!nth sequence n)))))

;;; New Stuff

(axiom effective-generate-step (s0 s1 label time message principal)
  (implies (and (= s1 (generate-step label time message principal s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (in message (ms!atomic-messages))
                (ms!is-fresh message (all-messages-in-state s0))
                (in principal (ms!principals)))))

(rule forgeable-preserved-by-generate-step (m1 label time m2 principal state)
  (= (forgeable m1 (generate-step label time m2 principal state))
     (forgeable m1 state)))

(rule known-by-principal-monotonic-over-generate-step
    (m1 principal1 label time m2 principal2 state)
  (implies (and (in principal1 (ms!principals))
                (known-by-principal m1 principal1 state))
           (= (known-by-principal
               m1 principal1 (generate-step label time m2 principal2 state))
              (true))))

(rule known-by-principal-generate-step-atomic-case
    (m1 principal1 label time m2 principal2 state)
  (implies (and (in principal1 (ms!principals))
                (in m1 (ms!atomic-messages)))
           (= (known-by-principal
               m1 principal1 (generate-step label time m2 principal2 state))
              (or (known-by-principal m1 principal1 state)
                  (and (= m1 m2)
                       (= principal1 principal2)
                       (not (= (generate-step label time m2 principal2 state)
                               state)))))))

(axiom effective-construct-step (s0 s1 label time message principal)
  (implies (and (= s1 (construct-step label time message principal s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (known-by-principal message principal s0)
                (in principal (ms!principals)))))

(rule forgeable-preserved-by-construct-step (m1 label time m2 principal state)
  (= (forgeable m1 (construct-step label time m2 principal state))
     (forgeable m1 state)))

(rule known-by-principal-preserved-by-construct-step
    (m1 principal1 label time m2 principal2 state)
  (= (known-by-principal
      m1 principal1 (construct-step label time m2 principal2 state))
     (known-by-principal m1 principal1 state)))

(axiom effective-send-step (s0 s1 label time message principal)
  (implies (and (= s1 (send-step label time message principal s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (known-by-principal message principal s0)
                (in principal (ms!principals)))))

(rule forgeable-monotonic-over-send-step (m1 label time m2 principal state)
  (implies (forgeable m1 state)
           (= (forgeable m1 (send-step label time m2 principal state))
              (true))))

(rule known-by-principal-preserved-by-send-step
    (m1 principal1 label time m2 principal2 state)
  (= (known-by-principal
      m1 principal1 (send-step label time m2 principal2 state))
     (known-by-principal m1 principal1 state)))

(axiom effective-receive-step (s0 s1 label time message principal)
  (implies (and (= s1 (receive-step label time message principal s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (forgeable message s0)
                (in principal (ms!principals)))))

(rule forgeable-preserved-by-receive-step (m1 label time m2 principal state)
  (= (forgeable m1 (receive-step label time m2 principal state))
     (forgeable m1 state)))

(rule known-by-principal-monotonic-over-receive-step
    (m1 principal1 label time m2 principal2 state)
  (implies (and (in principal1 (ms!principals))
                (known-by-principal m1 principal1 state))
           (= (known-by-principal
               m1 principal1 (receive-step label time m2 principal2 state))
              (true))))

(rule known-by-principal-receive-step-non-receiver-case
    (m1 principal1 label time m2 principal2 state)
  (implies (and (in principal1 (ms!principals))
                (not (= principal1 principal2)))
           (= (known-by-principal
               m1 principal1 (receive-step label time m2 principal2 state))
              (known-by-principal m1 principal1 state))))

(axiom effective-out-of-band-step (s0 s1 label time message sender receiver)
  (implies
   (and (= s1 (out-of-band-step label time message sender receiver s0))
        (not (= s0 s1)))
   (and (is-good-state s0)
        (time-constraint time s0)
        (>= label 0)
        (in sender (ms!principals))
        (in receiver (ms!principals))
        (known-by-principal message sender s0))))

(rule forgeable-preserved-by-out-of-band-step
    (m1 label time m2 sender receiver state)
  (= (forgeable
      m1 (out-of-band-step label time m2 sender receiver state))
     (forgeable m1 state)))

(rule known-by-principal-monotonic-over-out-of-band-step
    (m1 principal1 label time m2 sender receiver state)
  (implies (and (in principal1 (ms!principals))
                (known-by-principal m1 principal1 state))
           (= (known-by-principal
               m1 principal1
               (out-of-band-step label time m2 sender receiver state))
              (true))))

(rule known-by-principal-out-of-band-step-non-receiver-case
    (m1 principal1 label time m2 sender receiver state)
  (implies (and (in principal1 (ms!principals))
                (not (= principal1 receiver)))
           (= (known-by-principal
               m1 principal1
               (out-of-band-step label time m2 sender receiver state))
              (known-by-principal m1 principal1 state))))

(axiom effective-intruder-step (s0 s1 label time message)
  (implies (and (= s1 (intruder-step label time message s0))
                (not (= s0 s1)))
           (and (is-good-state s0)
                (time-constraint time s0)
                (>= label 0)
                (in message (ms!atomic-messages))
                (ms!is-fresh message (all-messages-in-state s0)))))

(rule forgeable-monotonic-over-intruder-step (m1 label time m2 state)
  (implies (forgeable m1 state)
           (= (forgeable m1 (intruder-step label time m2 state))
              (true))))

(rule known-by-principal-preserved-by-intruder-step
    (m1 principal label time m2 state)
  (= (known-by-principal m1 principal (intruder-step label time m2 state))
     (known-by-principal m1 principal state)))

(rule setadd-member (x s)
  (implies (in x s)
           (= (setadd x s) s)))


(axiom known-by-principal-implies-not-fresh (message principal state)
  (implies (and (is-good-state state)
                (in message (ms!atomic-messages))
                (in principal (ms!principals))
                (known-by-principal message principal state))
           (not (ms!is-fresh message (all-messages-in-state state)))))

(axiom forgeable-implies-not-fresh (message state)
  (implies (and (is-good-state state)
                (in message (ms!atomic-messages))
                (forgeable message state))
           (not (ms!is-fresh message (all-messages-in-state state)))))


;;; Equalities of events, ought to go in st

(rule send-event-equality (l1 l2 t1 t2 m1 m2 p1 p2)
  (= (= (make-send-event l1 t1 m1 p1)
        (make-send-event l2 t2 m2 p2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= p1 p2))))

(rule receive-event-equality (l1 l2 t1 t2 m1 m2 p1 p2)
  (= (= (make-receive-event l1 t1 m1 p1)
        (make-receive-event l2 t2 m2 p2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= p1 p2))))

(rule out-of-band-event-equality (l1 l2 t1 t2 m1 m2 s1 s2 r1 r2)
  (= (= (make-out-of-band-event l1 t1 m1 s1 r1)
        (make-out-of-band-event l2 t2 m2 s2 r2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= s1 s2) (= r1 r2))))

(rule generate-event-equality (l1 l2 t1 t2 m1 m2 p1 p2)
  (= (= (make-generate-event l1 t1 m1 p1)
        (make-generate-event l2 t2 m2 p2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= p1 p2))))

(rule construct-event-equality (l1 l2 t1 t2 m1 m2 p1 p2)
  (= (= (make-construct-event l1 t1 m1 p1)
        (make-construct-event l2 t2 m2 p2))
     (and (= l1 l2) (= t1 t2) (= m1 m2) (= p1 p2))))

(rule intruder-event-equality (l1 l2 t1 t2 m1 m2)
  (= (= (make-intruder-event l1 t1 m1)
        (make-intruder-event l2 t2 m2))
     (and (= l1 l2) (= t1 t2) (= m1 m2))))

(rule 3combine-equality (1m1 1m2 1m3 2m1 2m2 2m3)
  (implies (and (in 1m1 (ms!messages))
                (in 1m2 (ms!messages))
                (in 1m3 (ms!messages))
                (in 2m1 (ms!messages))
                (in 2m2 (ms!messages))
                (in 2m3 (ms!messages)))
           (= (= (3combine 1m1 1m2 1m3) (3combine 2m1 2m2 2m3))
              (and (= 1m1 2m1) (= 1m2 2m2) (= 1m3 2m3)))))

(rule 4combine-equality (1m1 1m2 1m3 1m4 2m1 2m2 2m3 2m4)
  (implies (and (in 1m1 (ms!messages))
                (in 1m2 (ms!messages))
                (in 1m3 (ms!messages))
                (in 1m4 (ms!messages))
                (in 2m1 (ms!messages))
                (in 2m2 (ms!messages))
                (in 2m3 (ms!messages))
                (in 2m4 (ms!messages)))
           (= (= (4combine 1m1 1m2 1m3 1m4) (4combine 2m1 2m2 2m3 2m4))
              (and (= 1m1 2m1) (= 1m2 2m2) (= 1m3 2m3) (= 1m4 2m4)))))

(rule 5combine-equality (1m1 1m2 1m3 1m4 1m5 2m1 2m2 2m3 2m4 2m5)
  (implies (and (in 1m1 (ms!messages))
                (in 1m2 (ms!messages))
                (in 1m3 (ms!messages))
                (in 1m4 (ms!messages))
                (in 1m5 (ms!messages))
                (in 2m1 (ms!messages))
                (in 2m2 (ms!messages))
                (in 2m3 (ms!messages))
                (in 2m4 (ms!messages))
                (in 2m5 (ms!messages)))
           (= (= (5combine 1m1 1m2 1m3 1m4 1m5)
                 (5combine 2m1 2m2 2m3 2m4 2m5))
              (and (= 1m1 2m1) (= 1m2 2m2) (= 1m3 2m3) (= 1m4 2m4)
                   (= 1m5 2m5)))))

(rule 6combine-equality (1m1 1m2 1m3 1m4 1m5 1m6 2m1 2m2 2m3 2m4 2m5 2m6)
  (implies (and (in 1m1 (ms!messages))
                (in 1m2 (ms!messages))
                (in 1m3 (ms!messages))
                (in 1m4 (ms!messages))
                (in 1m5 (ms!messages))
                (in 1m6 (ms!messages))
                (in 2m1 (ms!messages))
                (in 2m2 (ms!messages))
                (in 2m3 (ms!messages))
                (in 2m4 (ms!messages))
                (in 2m5 (ms!messages))
                (in 2m6 (ms!messages)))
           (= (= (6combine 1m1 1m2 1m3 1m4 1m5 1m6)
                 (6combine 2m1 2m2 2m3 2m4 2m5 2m6))
              (and (= 1m1 2m1) (= 1m2 2m2) (= 1m3 2m3)
                   (= 1m4 2m4) (= 1m5 2m5) (= 1m6 2m6)))))

;;; New on Jan. 4th

(rule forgeable-add-to-seen-messages-and-history (m1 m2 event state)
  (implies (is-good-state state)
           (= (forgeable
                m1
                (add-to-state-seen-messages
                  m2 (add-to-state-history event state)))
              (forgeable
                m1 (add-to-state-seen-messages m2 state)))))

(rule known-by-principal-add-to-seen-messages-and-history (m1 m2 p event state)
  (implies (is-good-state state)
           (= (known-by-principal
                m1 p
                (add-to-state-seen-messages
                  m2 (add-to-state-history event state)))
              (known-by-principal
                m1 p (add-to-state-seen-messages m2 state)))))

;;; New on Jan. 7th
(rule storage-of-subset-all-storage (principal state)
  (implies (and (in principal (ms!principals))
                (is-good-state state))
           (= (subset (storage-of principal state)
                      (all-storage (stores state)))
              (true))))

;;; New Jan, 10th

(rule forgeable-add-to-state-history (message event state)
  (= (forgeable message (add-to-state-history event state))
     (forgeable message state)))

(rule known-by-principal-add-to-state-history (message principal event state)
  (= (known-by-principal message principal (add-to-state-history event state))
     (known-by-principal message principal state)))

;;; Inserted Jan 11th

(rule known-by-principal-add-to-state-seen-messages (m m1 p s)
  (= (known-by-principal m p (add-to-state-seen-messages m1 s))
     (known-by-principal m p s)))

(rule forgeable-add-combine (m m1 m2 ms s)
  (implies (and (is-good-state s)
                (in m1 (ms!messages))
                (in m2 (ms!messages))
		(subset ms (ms!messages)))
           (= (forgeable
                m
		(add-to-state-seen-messages (setadd (ms!combine m1 m2) ms) s))
              (forgeable
                m (add-to-state-seen-messages (setadd m1 (setadd m2 ms)) s)))))

(rule forgeable-add-public-key (m ms p s)
  (implies (and (in p (ms!public-keys))
                (is-good-state s))
           (= (forgeable m (add-to-state-seen-messages (setadd p ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))

(rule forgeable-add-text-message (m t ms s)
  (implies (and (in t (ms!text-messages))
                (is-good-state s))
           (= (forgeable m (add-to-state-seen-messages (setadd t ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))

(rule forgeable-add-principal (m p ms s)
  (implies (and (in p (ms!principals))
                (is-good-state s))
           (= (forgeable m (add-to-state-seen-messages (setadd p ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))

(rule forgeable-add-sign (m m1 k ms s)
  (implies (and (in k (ms!keys))
                (in m1 (ms!messages))
		(subset ms (ms!messages))
                (is-good-state s))
           (= (forgeable m (add-to-state-seen-messages (setadd (sign m1 k) ms)
						       s))
              (forgeable
                m (add-to-state-seen-messages
		   (setadd m1 (setadd (ms!encrypt (ms!hash m1) k) ms))
		   s)))))


(rule forgeable-combine (m1 m2 s)
  (= (forgeable (ms!combine m1 m2) s)
     (and (forgeable m1 s) (forgeable m2 s))))

(rule forgeable-add-nonce (m n ms s)
  (implies (and (in n (ms!nonces))
                (in m (ms!atomic-messages)))
           (= (forgeable m (add-to-state-seen-messages (setadd n ms) s))
              (or (= m n)
                  (forgeable m (add-to-state-seen-messages ms s))))))

(rule forgeable-add-hash (m m1 ms s)
  (implies (and (in m (ms!atomic-messages))
                (in m1 (ms!messages)))
           (= (forgeable m (add-to-state-seen-messages (setadd (ms!hash m1) ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))

(rule forgeable-add-encrypt-hash (m m1 k ms s)
  (implies (and (in m (ms!atomic-messages))
                (in m1 (ms!messages))
                (in k (ms!keys)))
           (= (forgeable
                m (add-to-state-seen-messages
                    (setadd (ms!encrypt (ms!hash m1) k) ms) s))
              (forgeable m (add-to-state-seen-messages ms s)))))


(rule forgeable-add-to-state-storage (m m1 p s)
  (= (forgeable m (add-to-state-storage p m1 s))
     (forgeable m s)))

(rule known-by-principal-add-combine (m p m1 m2 ms s)
  (implies (and (is-good-state s)
                (in p (ms!principals))
                (in m1 (ms!messages))
                (in m2 (ms!messages))
		(subset ms (ms!messages)))
           (= (known-by-principal
                m p (add-to-state-storage p (setadd (ms!combine m1 m2) ms) s))
              (known-by-principal
                m p (add-to-state-storage p (setadd m1 (setadd m2 ms)) s)))))

(rule known-by-principal-add-public-key (m p pk ms s)
  (implies (and (in p (ms!principals))
                (in pk (ms!public-keys))
                (is-good-state s))
           (= (known-by-principal
               m p (add-to-state-storage p (setadd pk ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))

(rule known-by-principal-add-text-message (m p t ms s)
  (implies (and (in p (ms!principals))
                (in t (ms!text-messages))
                (is-good-state s))
           (= (known-by-principal m p (add-to-state-storage p (setadd t ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))

(rule known-by-principal-add-principal (m p p1 ms s)
  (implies (and (in p (ms!principals))
                (in p1 (ms!principals))
                (is-good-state s))
           (= (known-by-principal m p (add-to-state-storage p (setadd p1 ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))

(rule known-by-principal-add-sign (m p m1 k ms s)
  (implies (and (in p (ms!principals))
                (in k (ms!keys))
                (in m1 (ms!messages))
		(subset ms (ms!messages))
                (is-good-state s))
           (= (known-by-principal
               m p (add-to-state-storage p (setadd (sign m1 k) ms) s))
              (known-by-principal
                m p (add-to-state-storage
                     p
		     (setadd m1 (setadd (ms!encrypt (ms!hash m1) k) ms))
		     s)))))

(rule known-by-principal-combine (m1 m2 p s)
  (implies (in p (ms!principals))
           (= (known-by-principal (ms!combine m1 m2) p s)
              (and (known-by-principal m1 p s) (known-by-principal m2 p s)))))

(rule known-by-principal-add-nonce (m p n ms s)
  (implies (and (is-good-state s)
                (in p (ms!principals))
                (in n (ms!nonces))
                (in m (ms!atomic-messages)))
           (= (known-by-principal m p (add-to-state-storage p (setadd n ms) s))
              (or (= m n)
                  (known-by-principal m p (add-to-state-storage p ms s))))))

(rule known-by-principal-add-hash (m p m1 ms s)
  (implies (and (is-good-state s)
                (in m (ms!atomic-messages))
                (in p (ms!principals))
                (in m1 (ms!messages)))
           (= (known-by-principal
               m p (add-to-state-storage p (setadd (ms!hash m1) ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))

(rule known-by-principal-add-encrypt-hash (m p m1 k ms s)
  (implies (and (is-good-state s)
                (in m (ms!atomic-messages))
                (in p (ms!principals))
                (in m1 (ms!messages))
                (in k (ms!keys)))
           (= (known-by-principal
                m p (add-to-state-storage p
                     (setadd (ms!encrypt (ms!hash m1) k) ms) s))
              (known-by-principal m p (add-to-state-storage p ms s)))))

;;; Added January 13th.


(disabled
 (rule permute-add-to-storage-add-to-history (p m e state)
   (= (add-to-state-storage
       p m (add-to-state-history e state))
      (add-to-state-history
       e (add-to-state-storage p m state)))))

(rule known-by-principal-add-to-storage-and-history (m1 p1 m2 p2 event state)
  (implies (and (is-good-state state)
                (in p2 (ms!principals))
                (subset m2 (ms!messages)))
           (= (known-by-principal
               m1 p1
               (add-to-state-storage
                p2 m2 (add-to-state-history event state)))
              (known-by-principal
               m1 p1 (add-to-state-storage p2 m2 state)))))

(axiom newly-known-by-generation-not-forgeable (m1 p1 m2 p2 label time state)
  (implies (and (not (known-by-principal m1 p1 state))
                (in m1 (ms!atomic-messages))
                (in p1 (ms!principals))
                (known-by-principal
                 m1 p1 (generate-step label time m2 p2 state)))
           (and (= m1 m2)
                (= p1 p2)
                (not (forgeable m1 state)))))

(axiom is-good-evolution-state-has-good-evolution (state)
  (implies (is-good-evolution-state state)
           (some (sequence)
             (and (is-good-evolution sequence)
                  (= (seq!head sequence) state)))))

(axiom time-of-event-constraint (event state)
  (implies (and (is-good-state state)
                (seq!is-member event (history state)))
           (>= (time-of-event (seq!head (history state)))
               (time-of-event event))))

(axiom forgeable-monotonic-over-step (n sequence message)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (forgeable message (seq!nth sequence (+ n 1))))
           (forgeable message (seq!nth sequence n))))

(axiom known-by-principal-monotonic-over-step (n sequence message principal)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (- (seq!length sequence) 1))
                (in principal (ms!principals))
                (known-by-principal
                 message principal (seq!nth sequence (+ n 1))))
           (known-by-principal message principal (seq!nth sequence n))))

(rule nth-history-head-evolution (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= n (seq!length (history (seq!head sequence)))))
           (= (seq!nth (history (seq!head sequence)) n)
              (seq!head (history (seq!nth sequence n))))))

(axiom send-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (send-events))
                (seq!is-member event (history state)))
           (and (known-by-principal
                 (message-of-event event)
                 (principal1-of-event event)
                 state)
                (forgeable (message-of-event event) state))))

(axiom receive-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (receive-events))
                (seq!is-member event (history state)))
           (and (known-by-principal
                 (message-of-event event)
                 (principal1-of-event event)
                 state)
                (forgeable (message-of-event event) state))))

(axiom out-of-band-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (out-of-band-events))
                (seq!is-member event (history state)))
           (and (known-by-principal
                 (message-of-event event)
                 (principal1-of-event event)
                 state)
                (known-by-principal
                 (message-of-event event)
                 (principal2-of-event event)
                 state))))

(axiom generate-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (generate-events))
                (seq!is-member event (history state)))
           (known-by-principal
            (message-of-event event)
            (principal1-of-event event)
            state)))

(axiom construct-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (construct-events))
                (seq!is-member event (history state)))
           (known-by-principal
            (message-of-event event)
            (principal1-of-event event)
            state)))

(axiom intruder-event-consequence (event state)
  (implies (and (is-good-evolution-state state)
                (in event (intruder-events))
                (seq!is-member event (history state)))
           (forgeable
            (message-of-event event)
            state)))

(axiom send-event-is-from-send-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (send-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message principal)
             (and (is-good-evolution-state state1)
                  (= state (send-step label time message principal state1))
                  (not (= state state1))))))

(axiom receive-event-is-from-receive-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (receive-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message principal)
             (and (is-good-evolution-state state1)
                  (= state (receive-step label time message principal state1))
                  (not (= state state1))))))

(axiom out-of-band-event-is-from-out-of-band-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (out-of-band-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message sender receiver)
             (and (is-good-evolution-state state1)
                  (= state
                     (out-of-band-step
                      label time message sender receiver state1))
                  (not (= state state1))))))

(axiom generate-event-is-from-generate-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (generate-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message principal)
             (and (is-good-evolution-state state1)
                  (= state (generate-step label time message principal state1))
                  (not (= state state1))))))

(axiom construct-event-is-from-construct-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (construct-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message principal)
             (and (is-good-evolution-state state1)
                  (= state
                     (construct-step label time message principal state1))
                  (not (= state state1))))))

(axiom intruder-event-is-from-intruder-step (event state)
  (implies (and (is-good-evolution-state state)
                (in event (intruder-events))
                (seq!is-member event (history state))
                (= (seq!head (history state)) event))
           (some (state1 label time message)
             (and (is-good-evolution-state state1)
                  (= state (intruder-step label time message state1))
                  (not (= state state1))))))


;;; Added February 28, 2000

(rule known-by-principal-add-encrypt (s m p m1 ms k)
  (implies (and (is-good-state s)
                (in m (ms!atomic-messages))
                (in p (ms!principals))
                (in m1 (ms!messages))
                (in k (ms!keys)))
           (= (known-by-principal
               m p (add-to-state-storage p (setadd (ms!encrypt m1 k) ms) s))
              (if (known-by-principal (ms!inverse k) p (add-to-state-storage p ms s))
                  (known-by-principal m p (add-to-state-storage p (setadd m1 ms) s))
                  (known-by-principal m p (add-to-state-storage p ms s))))))

(rule known-by-principal-atomic-add-sign (m p m1 k ms s)
  (implies
   (and (in m (ms!atomic-messages))
        (in p (ms!principals))
        (in k (ms!keys))
        (in m1 (ms!messages))
	(subset ms (ms!messages))
        (is-good-state s))
   (= (known-by-principal m p (add-to-state-storage p (setadd (sign m1 k) ms) s))
      (known-by-principal m p (add-to-state-storage p (setadd m1 ms) s)))))

(rule known-by-principal-monotonic-over-add-to-state-storage (m p m1 s)
  (implies (and (is-good-state s)
                (in p (ms!principals))
                (subset m1 (ms!messages))
                (known-by-principal m p s))
           (= (known-by-principal m p (add-to-state-storage p m1 s))
              (true))))

(rule add-to-state-storage-collects (m1 m2 p s)
   (implies (is-good-state s)
            (= (add-to-state-storage p m1 (add-to-state-storage p m2 s))
               (add-to-state-storage p (union m1 m2) s))))

(axiom in-history-implies-is-head-of-history-of-nth (event sequence)
  (implies (and (is-good-evolution sequence)
                (seq!is-member event (history (seq!head sequence))))
           (some (n)
             (and (>= n 1)
                  (< n (seq!length sequence))
                  (= event (seq!head (history (seq!nth sequence n))))))))

(axiom in-history-implies-is-head-of-history-of-subsequence (event sequence)
  (implies (and (is-good-evolution sequence)
                (seq!is-member event (history (seq!head sequence))))
           (some (s subsequence)
             (and (seq!is-sequence s)
                  (is-good-evolution subsequence)
                  (= sequence (seq!join s subsequence))
                  (= event (seq!head (history (seq!head subsequence))))))))

(axiom fresh-implies-not-known-by-principal (message principal state)
  (implies (and (is-good-state state)
                (in principal (ms!principals))
                (in message (ms!atomic-messages))
                (ms!is-fresh message (all-messages-in-state state)))
           (not (known-by-principal message principal state))))

(axiom fresh-in-all-messages-implies-fresh-in-storage-of-principal
    (message principal state)
  (implies (and (is-good-state state)
                (in principal (ms!principals))
                (in message (ms!atomic-messages))
                (ms!is-fresh message (all-messages-in-state state)))
           (ms!is-fresh message (storage-of principal state))))

(function fresh-outside-principal (message principal state) ()
  (and (ms!is-fresh message
                    (union (ms!public-keys)
                           (union (ms!text-messages)
                                  (union (ms!principals)
                                         (seen-messages state)))))
       (all (p) (implies (and (in p (ms!principals))
                              (not (= p principal)))
                         (ms!is-fresh message (storage-of p state))))))

;;; New, March 2000

(axiom fresh-outside-principal-implies-not-forgeable (message principal state)
  (implies (and (is-good-state state)
                (in principal (ms!principals))
                (in message (ms!atomic-messages))
                (fresh-outside-principal message principal state))
           (not (forgeable message state))))

(axiom known-by-principal-monotonic-join (m p s1 s2)
  (implies (and (in p (ms!principals))
                (is-good-evolution s1)
                (seq!is-sequence s2)
                (is-good-evolution (seq!join s2 s1))
                (known-by-principal m p (seq!head s1)))
           (known-by-principal m p (seq!head (seq!join s2 s1)))))

(axiom forgeable-monotonic-join (m s1 s2)
  (implies (and (is-good-evolution s1)
                (seq!is-sequence s2)
                (is-good-evolution (seq!join s2 s1))
                (forgeable m (seq!head s1)))
           (forgeable m (seq!head (seq!join s2 s1)))))

(axiom forgeable-monotonic-over-good-step (m s0 s1)
  (implies (and (good-step s0 s1)
                (forgeable m s0))
           (forgeable m s1)))

(axiom known-by-principal-monotonic-over-good-step (m p s0 s1)
  (implies (and (good-step s0 s1)
                (in p (ms!principals))
                (known-by-principal m p s0))
           (known-by-principal m p s1)))



;;; ************** NEW


(function is-generated (k s) ()
  (some (l t p1)
    (and (in p1 (ms!principals))
         (seq!is-member
          (make-generate-event l t k p1)
          (history s)))))

(rule in-parts-setadd (m m1 s)
  (implies (not (= s (nullset)))
           (= (in m (ms!parts (setadd m1 s)))
              (or (in m (ms!parts (setadd m1 (nullset))))
                  (in m (ms!parts s))))))

(axiom good-evolution-state-has-good-evolution (state)
  (implies (is-good-evolution-state state)
           (some (s)
             (and (is-good-evolution s)
                  (= (seq!head s) state)))))

(zf-function send-events-containing-encrypt (m k)
  (select (event (send-events))
    (in (ms!encrypt m k)
        (ms!parts (unit (message-of-event event))))))

(axiom earliest-in-sequence-with-property (sequence set)
  (implies (and (seq!is-sequence sequence)
                (some (n)
                  (and (>= n 1)
                       (<= n (seq!length sequence))
                       (in (seq!nth sequence n) set))))
           (some (n1)
             (and (>= n1 1)
                  (<= n1 (seq!length sequence))
                  (in (seq!nth sequence n1) set)
                  (not (some (n2)
                         (and (>= n2 (+ n1 1))
                              (<= n2 (seq!length sequence))
                              (in (seq!nth sequence n2) set))))))))

(zf-function receive-events-containing-encrypt (m k)
  (select (event (receive-events))
    (in (ms!encrypt m k)
        (ms!parts (unit (message-of-event event))))))

(zf-function out-of-band-events-containing-encrypt (m k)
  (select (event (out-of-band-events))
    (in (ms!encrypt m k)
        (ms!parts (unit (message-of-event event))))))

(frule head-is-good-evolution-state (s)
  (implies (is-good-evolution s)
           (is-good-evolution-state (seq!head s))))

(axiom forgeable-encrypted-implies-in-parts (m k s)
  (implies (and (is-good-evolution-state s)
                (in m (ms!messages))
                (in k (ms!keys))
                (not (forgeable k s))
                (forgeable (ms!encrypt m k) s))
           (in (ms!encrypt m k) (ms!parts (seen-messages s)))))

(grule history-is-sequence (s)
  (implies (is-good-evolution-state s)
           (seq!is-sequence (history s))))

(frule known-by-principal-is-message (m p s)
  (implies (known-by-principal m p s)
           (in m (ms!messages))))

(frule forgeable-is-message (m s)
  (implies (forgeable m s)
           (in m (ms!messages))))

(function message-induction (m) ((measure (ms!size m)))
  (if (or (not (in m (ms!messages))) (in m (ms!atomic-messages)))
      (true)
      (all (n) (if (< (ms!size n) (ms!size m)) (message-induction n) (true)))))

(axiom size-proper-part (m1 m2)
  (implies (and (in m1 (ms!messages))
		(in m2 (ms!messages))
		(in m1 (ms!parts (setadd m2 (nullset))))
                (not (= m1 m2)))
	   (>= (ms!size m2) (+ (ms!size m1) 1))))

(rule history-of-nth-of-tail-of-good-evolution-2 (n sequence)
  (implies (and (is-good-evolution sequence)
                (>= n 1)
                (<= (+ n 1) (seq!length sequence)))
           (= (history (seq!nth (seq!tail sequence) n))
              (seq!tail (history (seq!nth sequence n))))))

(disabled
 (rule length-history-nth (n s)
   (implies (and (is-good-evolution s)
                 (>= n 1)
                 (<= n (seq!length s)))
            (= (seq!length (history (seq!nth s n)))
               (- (seq!length s) n)))))

(rule nth-history-nth-evolution (n1 n2 s)
  (implies (and (is-good-evolution s)
                (>= n1 1)
                (<= n1 (seq!length (history (seq!head s))))
                (>= n2 1)
                (<= n2 (seq!length (history (seq!nth s n1)))))
           (= (seq!nth (history (seq!nth s n1)) n2)
              (seq!head (history (seq!nth s (- (+ n1 n2) 1)))))))

(rule head-history-in-events (s)
  (implies (and (is-good-evolution-state s)
                (>= (seq!length (history s)) 1))
           (= (in (seq!head (history s)) (events)) (true))))

(axiom member-history-nth (n1 n2 s e)
  (implies (and (is-good-evolution s)
                (>= n1 1)
                (<= (+ n1 1) (seq!length s))
                (>= n2 1)
                (>= n1 n2)
                (seq!is-member e (history (seq!nth s n1))))
           (seq!is-member e (history (seq!nth s n2)))))

(axiom nth-in-good-evolution (n s)
  (implies (and (is-good-evolution s)
                (>= n 1)
                (<= (+ n 1) (seq!length s)))
           (and (is-good-evolution-state (seq!nth s n))
                (seq!is-tack (history (seq!nth s n)))
                (in (seq!head (history (seq!nth s n))) (events)))))

(axiom all-storage-monotonic (s n1 n2)
  (implies (and (is-good-evolution s)
                (<= 1 n2)
                (<= n2 n1)
                (<= n1 (seq!length s)))
           (subset (all-storage (stores (seq!nth s n1)))
                   (all-storage (stores (seq!nth s n2))))))

(axiom fresh-is-monotonic (k s n1 n2)
  (implies (and (is-good-evolution s)
                (<= 1 n2)
                (<= n2 n1)
                (<= n1 (seq!length s))
                (ms!is-fresh k (all-messages-in-state (seq!nth s n2))))
           (ms!is-fresh k (all-messages-in-state (seq!nth s n1)))))

(axiom is-generated-consequence (s k n)
  (implies (and (is-good-evolution s)
                (is-generated k (seq!head s))
                (<= 1 n)
                (<= n (seq!length s)))
           (or (is-generated k (seq!nth s n))
               (ms!is-fresh k (all-messages-in-state (seq!nth s n))))))

(axiom forgeable-containing-encrypted-implies-in-parts (m k m2 s)
  (implies (and (is-good-evolution-state s)
                (in m (ms!messages))
                (in k (ms!keys))
                (not (forgeable k s))
                (forgeable m2 s)
                (in (ms!encrypt m k) (ms!parts (unit m2))))
           (in (ms!encrypt m k) (ms!parts (seen-messages s)))))

(frule in-send-event (event)
  (implies
   (in event (send-events))
   (and
    (= event
       (make-send-event
        (label-of-event event)
        (time-of-event event)
        (message-of-event event)
        (principal1-of-event event)))
    (>= (label-of-event event) 0)
    (>= (time-of-event event) 0)
    (in (message-of-event event) (ms!messages))
    (in (principal1-of-event event) (ms!principals)))))

(frule in-receive-event (event)
  (implies
   (in event (receive-events))
   (and
    (= event
       (make-receive-event
        (label-of-event event)
        (time-of-event event)
        (message-of-event event)
        (principal1-of-event event)))
    (>= (label-of-event event) 0)
    (>= (time-of-event event) 0)
    (in (message-of-event event) (ms!messages))
    (in (principal1-of-event event) (ms!principals)))))

(frule in-out-of-band-event (event)
  (implies
   (in event (out-of-band-events))
   (and
    (= event
       (make-out-of-band-event
        (label-of-event event)
        (time-of-event event)
        (message-of-event event)
        (principal1-of-event event)
        (principal2-of-event event)))
    (>= (label-of-event event) 0)
    (>= (time-of-event event) 0)
    (in (message-of-event event) (ms!messages))
    (in (principal1-of-event event) (ms!principals))
    (in (principal2-of-event event) (ms!principals)))))

(axiom known-by-principal-containing-encrypted-implies-in-parts (m k p m2 s)
  (implies (and (is-good-evolution-state s)
                (in m (ms!messages))
                (in k (ms!keys))
                (in p (ms!principals))
                (not (known-by-principal k p s))
                (known-by-principal m2 p s)
                (in (ms!encrypt m k) (ms!parts (unit m2))))
           (in (ms!encrypt m k) (ms!parts (storage-of p s)))))

(axiom is-generated-monotonic (s k n1 n2)
  (implies (and (is-good-evolution s)
                (<= 1 n1)
                (<= n1 n2)
                (<= n2 (seq!length s))
                (is-generated k (seq!nth s n2)))
           (is-generated k (seq!nth s n1))))

(axiom encrypted-message-theorem (m k s)
  (implies
   (and (is-good-evolution s)
        (in m (ms!messages))
        (in k (ms!keys))
        ;; (forgeable (ms!encrypt m k) (seq!head s))
        (in (ms!encrypt m k)
            (ms!parts (seen-messages (seq!head s))))
        (not (forgeable k (seq!head s)))
        (is-generated k (seq!head s)))
   (or (some (n2 l2 t2 m2 p2)
         (and (>= n2 1)
              (< n2 (seq!length s))
              (in m2 (ms!messages))
              (in p2 (ms!principals))
              (= (seq!nth (history (seq!head s)) n2)
                 (make-send-event l2 t2 m2 p2))
              (known-by-principal k p2 (seq!nth s (+ n2 1)))
              (not (in (ms!encrypt m k)
                       (ms!parts (seen-messages (seq!nth s (+ n2 1))))))
              (in (ms!encrypt m k) (ms!parts (setadd m2 (nullset))))))
       (some (n3 l3 t3 m3 p3 p4)
         (and (>= n3 1)
              (< n3 (seq!length s))
              (in m3 (ms!messages))
              (in p3 (ms!principals))
              (in p4 (ms!principals))
              (= (seq!nth (history (seq!head s)) n3)
                 (make-out-of-band-event l3 t3 m3 p3 p4))
              (known-by-principal k p3 (seq!nth s (+ n3 1)))
              ;(not (in (ms!encrypt m k)
              ;         (ms!parts (storage-of p4 (seq!nth s (+ n3 1))))))
              (in (ms!encrypt m k)
                  (ms!parts (setadd m3 (nullset)))))))))


;;; Added March 2001

(rule in-parts-add-known-by-principal (k m p s)
  (implies
   (and
    (is-good-evolution-state s)
    (in p (ms!principals))
    (known-by-principal m p s)
    (in k (ms!atomic-messages))
    (not (in k (ms!principals)))
    (not (in k (ms!text-messages)))
    (not (in k (ms!public-keys))))
   (= (in k (ms!parts
             (setadd m (union (ms!principals)
                              (union (ms!text-messages)
                                     (union (ms!public-keys)
                                            (storage-of p s)))))))
      (in k (ms!parts (storage-of p s))))))

(axiom in-parts-seen-implies-in-parts-forgeable (k state)
  (implies (and (is-good-state state)
                (in k (ms!atomic-messages))
                (in k (ms!parts (seen-messages state))))
           (some (message)
             (and (forgeable message state)
                  (in k (ms!parts (unit message)))))))

(rule send-step-is-good-step (label time message principal state)
  (implies (not (= state (send-step label time message principal state)))
           (= (good-step
               state (send-step label time message principal state))
              (true))))

(rule receive-step-is-good-step (label time message principal state)
  (implies (not (= state (receive-step label time message principal state)))
           (= (good-step
               state (receive-step label time message principal state))
              (true))))

(rule out-of-band-step-is-good-step (label time message sender receiver state)
  (implies (not (= state
                   (out-of-band-step
                    label time message sender receiver state)))
           (= (good-step
               state (out-of-band-step
                      label time message sender receiver state))
              (true))))

(rule generate-step-is-good-step (label time message principal state)
  (implies (not (= state
                   (generate-step label time message principal state)))
           (= (good-step
               state (generate-step label time message principal state))
              (true))))

(rule construct-step-is-good-step (label time message principal state)
  (implies (not (= state
                   (construct-step label time message principal state)))
           (= (good-step
               state (construct-step label time message principal state))
              (true))))

(rule intruder-step-is-good-step (label time message state)
  (implies (not (= state (intruder-step label time message state)))
           (= (good-step
               state (intruder-step label time message state))
              (true))))
