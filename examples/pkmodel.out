
Reading "/home/sentot/zk/version1/ZK/examples/pkmodel.ver"
Warning RULE-LOOPS for MS!IN-PARTS-SETADD:
 The rule MS!IN-PARTS-SETADD loops upon itself.
Warning RULE-LOOPS for MS!IN-PARTS-ADD-KNOWN-IN:
 The rule MS!IN-PARTS-ADD-KNOWN-IN loops upon itself.
Warning RULE-LOOPS for SEQ!EXTENSIONALITY:
 The rule SEQ!EXTENSIONALITY loops upon itself.
Warning RULE-LOOPS for FN!FUNCTION-EXTENSIONALITY:
 The rule FN!FUNCTION-EXTENSIONALITY loops upon itself.
MAKE-STATE
IS-STATE
MAKE-STATE-IS-STATE
Beginning proof of MAKE-STATE-IS-STATE ...
(IS-STATE (MAKE-STATE M ST H))
Which simplifies
 with invocation of IS-STATE to ...
(TRUE)
IS-STATE-BOOL
Beginning proof of IS-STATE-BOOL ...
(= (TYPE-OF (IS-STATE S)) (BOOL))
Which simplifies
 with invocation of IS-STATE
 with the assumptions MAKE-STATE-IS-STATE to ...
(TRUE)
STATE-IS-CONSTRUCTED
Beginning proof of STATE-IS-CONSTRUCTED ...
(IMPLIES (IS-STATE S) (SOME (M ST H) (= S (MAKE-STATE M ST H))))
Which simplifies
 with invocation of IS-STATE
 with the assumptions MAKE-STATE-IS-STATE, IS-STATE-BOOL to ...
(TRUE)
SEEN-MESSAGES
STORES
HISTORY
SEEN-MESSAGES-OF-MAKE-STATE
Beginning proof of SEEN-MESSAGES-OF-MAKE-STATE ...
(= (SEEN-MESSAGES (MAKE-STATE SEEN-MESSAGES STORES HISTORY)) SEEN-MESSAGES)
Which simplifies
 with invocation of SEEN-MESSAGES, MAKE-STATE
 forward chaining using TUPLE!3TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-3TUPLE-3TUPLE, TUPLE!P1-3TUPLE,
TUPLE!P2-3TUPLE, TUPLE!P3-3TUPLE, MAKE-STATE-IS-STATE to ...
(TRUE)
STORES-OF-MAKE-STATE
Beginning proof of STORES-OF-MAKE-STATE ...
(= (STORES (MAKE-STATE SEEN-MESSAGES STORES HISTORY)) STORES)
Which simplifies
 with invocation of STORES, MAKE-STATE
 forward chaining using TUPLE!3TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-3TUPLE-3TUPLE, TUPLE!P1-3TUPLE,
TUPLE!P2-3TUPLE, TUPLE!P3-3TUPLE, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE to ...
(TRUE)
HISTORY-OF-MAKE-STATE
Beginning proof of HISTORY-OF-MAKE-STATE ...
(= (HISTORY (MAKE-STATE SEEN-MESSAGES STORES HISTORY)) HISTORY)
Which simplifies
 with invocation of HISTORY, MAKE-STATE
 forward chaining using TUPLE!3TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-3TUPLE-3TUPLE, TUPLE!P1-3TUPLE,
TUPLE!P2-3TUPLE, TUPLE!P3-3TUPLE, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE, STORES-OF-MAKE-STATE to ...
(TRUE)
TAG-OF-EVENT
MAKE-SEND-EVENT
MAKE-RECEIVE-EVENT
MAKE-OUT-OF-BAND-EVENT
MAKE-GENERATE-EVENT
MAKE-CONSTRUCT-EVENT
MAKE-INTRUDER-EVENT
TAG-OF-MAKE-SEND-EVENT
Beginning proof of TAG-OF-MAKE-SEND-EVENT ...
(= (TAG-OF-EVENT (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)) 0)
Which simplifies
 with invocation of TAG-OF-EVENT, MAKE-SEND-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE to ...
(TRUE)
TAG-OF-MAKE-RECEIVE-EVENT
Beginning proof of TAG-OF-MAKE-RECEIVE-EVENT ...
(= (TAG-OF-EVENT (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)) 1)
Which simplifies
 with invocation of TAG-OF-EVENT, MAKE-RECEIVE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE to ...
(TRUE)
TAG-OF-MAKE-OUT-OF-BAND-EVENT
Beginning proof of TAG-OF-MAKE-OUT-OF-BAND-EVENT ...
(= (TAG-OF-EVENT (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER))
 2)
Which simplifies
 with invocation of TAG-OF-EVENT, MAKE-OUT-OF-BAND-EVENT
 forward chaining using TUPLE!6TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-6TUPLE-6TUPLE, TUPLE!P1-6TUPLE,
TUPLE!P2-6TUPLE, TUPLE!P3-6TUPLE, TUPLE!P4-6TUPLE, TUPLE!P5-6TUPLE,
TUPLE!P6-6TUPLE to ...
(TRUE)
TAG-OF-MAKE-GENERATE-EVENT
Beginning proof of TAG-OF-MAKE-GENERATE-EVENT ...
(= (TAG-OF-EVENT (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)) 3)
Which simplifies
 with invocation of TAG-OF-EVENT, MAKE-GENERATE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE to ...
(TRUE)
TAG-OF-MAKE-CONSTRUCT-EVENT
Beginning proof of TAG-OF-MAKE-CONSTRUCT-EVENT ...
(= (TAG-OF-EVENT (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)) 4)
Which simplifies
 with invocation of TAG-OF-EVENT, MAKE-CONSTRUCT-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE to ...
(TRUE)
TAG-OF-MAKE-INTRUDER-EVENT
Beginning proof of TAG-OF-MAKE-INTRUDER-EVENT ...
(= (TAG-OF-EVENT (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)) 5)
Which simplifies
 with invocation of TAG-OF-EVENT, MAKE-INTRUDER-EVENT
 forward chaining using TUPLE!4TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-4TUPLE-4TUPLE, TUPLE!P1-4TUPLE,
TUPLE!P2-4TUPLE, TUPLE!P3-4TUPLE, TUPLE!P4-4TUPLE to ...
(TRUE)
SEND-EVENTS
RECEIVE-EVENTS
OUT-OF-BAND-EVENTS
GENERATE-EVENTS
CONSTRUCT-EVENTS
INTRUDER-EVENTS
SEND-EVENT-IS-CONSTRUCTED
Beginning proof of SEND-EVENT-IS-CONSTRUCTED ...
(IMPLIES (IN E (SEND-EVENTS))
 (SOME (L T M P)
  (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (= E (MAKE-SEND-EVENT L T M P)))))
Which simplifies
 when rewriting with NAT!IN-NAT, SEND-EVENTS.DEFINITION
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (SOME (L T M P)
  (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
   (= E (MAKE-SEND-EVENT L T M P))))
 (SOME (L$0)
  (AND (>= L$0 0)
   (SOME (T$0)
    (AND (>= T$0 0)
     (SOME (M$0)
      (AND (IN M$0 (MS!MESSAGES))
       (SOME (P$0)
        (AND (IN P$0 (MS!PRINCIPALS))
         (= E (MAKE-SEND-EVENT L$0 T$0 M$0 P$0)))))))))))
Instantiating (= L$0 L) (= T$0 T) (= M$0 M) (= P$0 P) gives ...
(IMPLIES
 (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-SEND-EVENT L T M P))
  (NOT
   (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
    (= E (MAKE-SEND-EVENT L T M P)))))
 (SOME (L$0 T$0 M$0 P$0)
  (AND (>= L$0 0) (>= T$0 0) (IN M$0 (MS!MESSAGES)) (IN P$0 (MS!PRINCIPALS))
   (= E (MAKE-SEND-EVENT L$0 T$0 M$0 P$0)))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
RECEIVE-EVENT-IS-CONSTRUCTED
Beginning proof of RECEIVE-EVENT-IS-CONSTRUCTED ...
(IMPLIES (IN E (RECEIVE-EVENTS))
 (SOME (L T M P)
  (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (= E (MAKE-RECEIVE-EVENT L T M P)))))
Which simplifies
 when rewriting with NAT!IN-NAT, RECEIVE-EVENTS.DEFINITION
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (SOME (L T M P)
  (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
   (= E (MAKE-RECEIVE-EVENT L T M P))))
 (SOME (L$0)
  (AND (>= L$0 0)
   (SOME (T$0)
    (AND (>= T$0 0)
     (SOME (M$0)
      (AND (IN M$0 (MS!MESSAGES))
       (SOME (P$0)
        (AND (IN P$0 (MS!PRINCIPALS))
         (= E (MAKE-RECEIVE-EVENT L$0 T$0 M$0 P$0)))))))))))
Instantiating (= L$0 L) (= T$0 T) (= M$0 M) (= P$0 P) gives ...
(IMPLIES
 (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-RECEIVE-EVENT L T M P))
  (NOT
   (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
    (= E (MAKE-RECEIVE-EVENT L T M P)))))
 (SOME (L$0 T$0 M$0 P$0)
  (AND (>= L$0 0) (>= T$0 0) (IN M$0 (MS!MESSAGES)) (IN P$0 (MS!PRINCIPALS))
   (= E (MAKE-RECEIVE-EVENT L$0 T$0 M$0 P$0)))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
OUT-OF-BAND-EVENT-IS-CONSTRUCTED
Beginning proof of OUT-OF-BAND-EVENT-IS-CONSTRUCTED ...
(IMPLIES (IN E (OUT-OF-BAND-EVENTS))
 (SOME (L T M S R)
  (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
   (IN S (MS!PRINCIPALS)) (IN R (MS!PRINCIPALS))
   (= E (MAKE-OUT-OF-BAND-EVENT L T M S R)))))
Which simplifies
 when rewriting with NAT!IN-NAT, OUT-OF-BAND-EVENTS.DEFINITION
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (SOME (L T M S R)
  (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN S (MS!PRINCIPALS))
   (IN R (MS!PRINCIPALS)) (= E (MAKE-OUT-OF-BAND-EVENT L T M S R))))
 (SOME (L$0)
  (AND (>= L$0 0)
   (SOME (T$0)
    (AND (>= T$0 0)
     (SOME (M$0)
      (AND (IN M$0 (MS!MESSAGES))
       (SOME (S$0)
        (AND (IN S$0 (MS!PRINCIPALS))
         (SOME (R$0)
          (AND (IN R$0 (MS!PRINCIPALS))
           (= E (MAKE-OUT-OF-BAND-EVENT L$0 T$0 M$0 S$0 R$0)))))))))))))
Instantiating (= L$0 L) (= T$0 T) (= M$0 M) (= S$0 S) (= R$0 R) gives ...
(IMPLIES
 (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN S (MS!PRINCIPALS))
  (IN R (MS!PRINCIPALS)) (= E (MAKE-OUT-OF-BAND-EVENT L T M S R))
  (NOT
   (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN S (MS!PRINCIPALS))
    (IN R (MS!PRINCIPALS)) (= E (MAKE-OUT-OF-BAND-EVENT L T M S R)))))
 (SOME (L$0 T$0 M$0 S$0 R$0)
  (AND (>= L$0 0) (>= T$0 0) (IN M$0 (MS!MESSAGES)) (IN S$0 (MS!PRINCIPALS))
   (IN R$0 (MS!PRINCIPALS))
   (= E (MAKE-OUT-OF-BAND-EVENT L$0 T$0 M$0 S$0 R$0)))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
GENERATE-EVENT-IS-CONSTRUCTED
Beginning proof of GENERATE-EVENT-IS-CONSTRUCTED ...
(IMPLIES (IN E (GENERATE-EVENTS))
 (SOME (L T M P)
  (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (= E (MAKE-GENERATE-EVENT L T M P)))))
Which simplifies
 when rewriting with NAT!IN-NAT, GENERATE-EVENTS.DEFINITION
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (SOME (L T M P)
  (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
   (= E (MAKE-GENERATE-EVENT L T M P))))
 (SOME (L$0)
  (AND (>= L$0 0)
   (SOME (T$0)
    (AND (>= T$0 0)
     (SOME (M$0)
      (AND (IN M$0 (MS!MESSAGES))
       (SOME (P$0)
        (AND (IN P$0 (MS!PRINCIPALS))
         (= E (MAKE-GENERATE-EVENT L$0 T$0 M$0 P$0)))))))))))
Instantiating (= L$0 L) (= T$0 T) (= M$0 M) (= P$0 P) gives ...
(IMPLIES
 (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-GENERATE-EVENT L T M P))
  (NOT
   (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
    (= E (MAKE-GENERATE-EVENT L T M P)))))
 (SOME (L$0 T$0 M$0 P$0)
  (AND (>= L$0 0) (>= T$0 0) (IN M$0 (MS!MESSAGES)) (IN P$0 (MS!PRINCIPALS))
   (= E (MAKE-GENERATE-EVENT L$0 T$0 M$0 P$0)))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
CONSTRUCT-EVENT-IS-CONSTRUCTED
Beginning proof of CONSTRUCT-EVENT-IS-CONSTRUCTED ...
(IMPLIES (IN E (CONSTRUCT-EVENTS))
 (SOME (L T M P)
  (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (= E (MAKE-CONSTRUCT-EVENT L T M P)))))
Which simplifies
 when rewriting with NAT!IN-NAT, CONSTRUCT-EVENTS.DEFINITION
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (SOME (L T M P)
  (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
   (= E (MAKE-CONSTRUCT-EVENT L T M P))))
 (SOME (L$0)
  (AND (>= L$0 0)
   (SOME (T$0)
    (AND (>= T$0 0)
     (SOME (M$0)
      (AND (IN M$0 (MS!MESSAGES))
       (SOME (P$0)
        (AND (IN P$0 (MS!PRINCIPALS))
         (= E (MAKE-CONSTRUCT-EVENT L$0 T$0 M$0 P$0)))))))))))
Instantiating (= L$0 L) (= T$0 T) (= M$0 M) (= P$0 P) gives ...
(IMPLIES
 (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-CONSTRUCT-EVENT L T M P))
  (NOT
   (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
    (= E (MAKE-CONSTRUCT-EVENT L T M P)))))
 (SOME (L$0 T$0 M$0 P$0)
  (AND (>= L$0 0) (>= T$0 0) (IN M$0 (MS!MESSAGES)) (IN P$0 (MS!PRINCIPALS))
   (= E (MAKE-CONSTRUCT-EVENT L$0 T$0 M$0 P$0)))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
INTRUDER-EVENT-IS-CONSTRUCTED
Beginning proof of INTRUDER-EVENT-IS-CONSTRUCTED ...
(IMPLIES (IN E (INTRUDER-EVENTS))
 (SOME (L T M)
  (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
   (= E (MAKE-INTRUDER-EVENT L T M)))))
Which simplifies
 when rewriting with NAT!IN-NAT, INTRUDER-EVENTS.DEFINITION
 forward chaining using >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-INTRUDER-EVENT,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (SOME (L T M)
  (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES))
   (= E (MAKE-INTRUDER-EVENT L T M))))
 (SOME (L$0)
  (AND (>= L$0 0)
   (SOME (T$0)
    (AND (>= T$0 0)
     (SOME (M$0)
      (AND (IN M$0 (MS!MESSAGES))
       (= E (MAKE-INTRUDER-EVENT L$0 T$0 M$0)))))))))
Instantiating (= L$0 L) (= T$0 T) (= M$0 M) gives ...
(IMPLIES
 (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (= E (MAKE-INTRUDER-EVENT L T M))
  (NOT
   (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES))
    (= E (MAKE-INTRUDER-EVENT L T M)))))
 (SOME (L$0 T$0 M$0)
  (AND (>= L$0 0) (>= T$0 0) (IN M$0 (MS!MESSAGES))
   (= E (MAKE-INTRUDER-EVENT L$0 T$0 M$0)))))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-INTRUDER-EVENT,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
TAG-OF-SEND-EVENT
Beginning proof of TAG-OF-SEND-EVENT ...
(IMPLIES (IN E (SEND-EVENTS)) (= (TAG-OF-EVENT E) 0))
Assuming SEND-EVENT-IS-CONSTRUCTED with the instantiations: (= E E) generates
...
(IMPLIES
 (AND
  (IMPLIES (IN E (SEND-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= E (MAKE-SEND-EVENT L T M P)))))
  (IN E (SEND-EVENTS)))
 (= (TAG-OF-EVENT E) 0))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN E (SEND-EVENTS))
  (SOME (L)
   (AND (IN L (NAT!NAT))
    (SOME (T)
     (AND (IN T (NAT!NAT))
      (SOME (M)
       (AND (IN M (MS!MESSAGES))
        (SOME (P)
         (AND (IN P (MS!PRINCIPALS)) (= E (MAKE-SEND-EVENT L T M P)))))))))))
 (= (TAG-OF-EVENT E) 0))
Prenexing produces ...
(IMPLIES
 (AND (IN E (SEND-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (= E (MAKE-SEND-EVENT L T M P)))
 (= (TAG-OF-EVENT E) 0))
Substituting (= E (MAKE-SEND-EVENT L T M P)) produces ...
(IMPLIES
 (AND (IN E (SEND-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (= E (MAKE-SEND-EVENT L T M P)))
 (= (TAG-OF-EVENT (MAKE-SEND-EVENT L T M P)) 0))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
TAG-OF-RECEIVE-EVENT
Beginning proof of TAG-OF-RECEIVE-EVENT ...
(IMPLIES (IN E (RECEIVE-EVENTS)) (= (TAG-OF-EVENT E) 1))
Assuming RECEIVE-EVENT-IS-CONSTRUCTED with the
instantiations: (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN E (RECEIVE-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= E (MAKE-RECEIVE-EVENT L T M P)))))
  (IN E (RECEIVE-EVENTS)))
 (= (TAG-OF-EVENT E) 1))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN E (RECEIVE-EVENTS))
  (SOME (L)
   (AND (IN L (NAT!NAT))
    (SOME (T)
     (AND (IN T (NAT!NAT))
      (SOME (M)
       (AND (IN M (MS!MESSAGES))
        (SOME (P)
         (AND (IN P (MS!PRINCIPALS))
          (= E (MAKE-RECEIVE-EVENT L T M P)))))))))))
 (= (TAG-OF-EVENT E) 1))
Prenexing produces ...
(IMPLIES
 (AND (IN E (RECEIVE-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-RECEIVE-EVENT L T M P)))
 (= (TAG-OF-EVENT E) 1))
Substituting (= E (MAKE-RECEIVE-EVENT L T M P)) produces ...
(IMPLIES
 (AND (IN E (RECEIVE-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-RECEIVE-EVENT L T M P)))
 (= (TAG-OF-EVENT (MAKE-RECEIVE-EVENT L T M P)) 1))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
TAG-OF-OUT-OF-BAND-EVENT
Beginning proof of TAG-OF-OUT-OF-BAND-EVENT ...
(IMPLIES (IN E (OUT-OF-BAND-EVENTS)) (= (TAG-OF-EVENT E) 2))
Assuming OUT-OF-BAND-EVENT-IS-CONSTRUCTED with the
instantiations: (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN E (OUT-OF-BAND-EVENTS))
   (SOME (L T M S R)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN S (MS!PRINCIPALS)) (IN R (MS!PRINCIPALS))
     (= E (MAKE-OUT-OF-BAND-EVENT L T M S R)))))
  (IN E (OUT-OF-BAND-EVENTS)))
 (= (TAG-OF-EVENT E) 2))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN E (OUT-OF-BAND-EVENTS))
  (SOME (L)
   (AND (IN L (NAT!NAT))
    (SOME (T)
     (AND (IN T (NAT!NAT))
      (SOME (M)
       (AND (IN M (MS!MESSAGES))
        (SOME (S)
         (AND (IN S (MS!PRINCIPALS))
          (SOME (R)
           (AND (IN R (MS!PRINCIPALS))
            (= E (MAKE-OUT-OF-BAND-EVENT L T M S R)))))))))))))
 (= (TAG-OF-EVENT E) 2))
Prenexing produces ...
(IMPLIES
 (AND (IN E (OUT-OF-BAND-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN S (MS!PRINCIPALS)) (IN R (MS!PRINCIPALS))
  (= E (MAKE-OUT-OF-BAND-EVENT L T M S R)))
 (= (TAG-OF-EVENT E) 2))
Substituting (= E (MAKE-OUT-OF-BAND-EVENT L T M S R)) produces ...
(IMPLIES
 (AND (IN E (OUT-OF-BAND-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN S (MS!PRINCIPALS)) (IN R (MS!PRINCIPALS))
  (= E (MAKE-OUT-OF-BAND-EVENT L T M S R)))
 (= (TAG-OF-EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)) 2))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
TAG-OF-GENERATE-EVENT
Beginning proof of TAG-OF-GENERATE-EVENT ...
(IMPLIES (IN E (GENERATE-EVENTS)) (= (TAG-OF-EVENT E) 3))
Assuming GENERATE-EVENT-IS-CONSTRUCTED with the
instantiations: (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN E (GENERATE-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= E (MAKE-GENERATE-EVENT L T M P)))))
  (IN E (GENERATE-EVENTS)))
 (= (TAG-OF-EVENT E) 3))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN E (GENERATE-EVENTS))
  (SOME (L)
   (AND (IN L (NAT!NAT))
    (SOME (T)
     (AND (IN T (NAT!NAT))
      (SOME (M)
       (AND (IN M (MS!MESSAGES))
        (SOME (P)
         (AND (IN P (MS!PRINCIPALS))
          (= E (MAKE-GENERATE-EVENT L T M P)))))))))))
 (= (TAG-OF-EVENT E) 3))
Prenexing produces ...
(IMPLIES
 (AND (IN E (GENERATE-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-GENERATE-EVENT L T M P)))
 (= (TAG-OF-EVENT E) 3))
Substituting (= E (MAKE-GENERATE-EVENT L T M P)) produces ...
(IMPLIES
 (AND (IN E (GENERATE-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-GENERATE-EVENT L T M P)))
 (= (TAG-OF-EVENT (MAKE-GENERATE-EVENT L T M P)) 3))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
TAG-OF-CONSTRUCT-EVENT
Beginning proof of TAG-OF-CONSTRUCT-EVENT ...
(IMPLIES (IN E (CONSTRUCT-EVENTS)) (= (TAG-OF-EVENT E) 4))
Assuming CONSTRUCT-EVENT-IS-CONSTRUCTED with the
instantiations: (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN E (CONSTRUCT-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= E (MAKE-CONSTRUCT-EVENT L T M P)))))
  (IN E (CONSTRUCT-EVENTS)))
 (= (TAG-OF-EVENT E) 4))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN E (CONSTRUCT-EVENTS))
  (SOME (L)
   (AND (IN L (NAT!NAT))
    (SOME (T)
     (AND (IN T (NAT!NAT))
      (SOME (M)
       (AND (IN M (MS!MESSAGES))
        (SOME (P)
         (AND (IN P (MS!PRINCIPALS))
          (= E (MAKE-CONSTRUCT-EVENT L T M P)))))))))))
 (= (TAG-OF-EVENT E) 4))
Prenexing produces ...
(IMPLIES
 (AND (IN E (CONSTRUCT-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-CONSTRUCT-EVENT L T M P)))
 (= (TAG-OF-EVENT E) 4))
Substituting (= E (MAKE-CONSTRUCT-EVENT L T M P)) produces ...
(IMPLIES
 (AND (IN E (CONSTRUCT-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= E (MAKE-CONSTRUCT-EVENT L T M P)))
 (= (TAG-OF-EVENT (MAKE-CONSTRUCT-EVENT L T M P)) 4))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
TAG-OF-INTRUDER-EVENT
Beginning proof of TAG-OF-INTRUDER-EVENT ...
(IMPLIES (IN E (INTRUDER-EVENTS)) (= (TAG-OF-EVENT E) 5))
Assuming INTRUDER-EVENT-IS-CONSTRUCTED with the
instantiations: (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN E (INTRUDER-EVENTS))
   (SOME (L T M)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (= E (MAKE-INTRUDER-EVENT L T M)))))
  (IN E (INTRUDER-EVENTS)))
 (= (TAG-OF-EVENT E) 5))
Which simplifies
 with the assumptions TAG-OF-MAKE-INTRUDER-EVENT,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN E (INTRUDER-EVENTS))
  (SOME (L)
   (AND (IN L (NAT!NAT))
    (SOME (T)
     (AND (IN T (NAT!NAT))
      (SOME (M)
       (AND (IN M (MS!MESSAGES)) (= E (MAKE-INTRUDER-EVENT L T M)))))))))
 (= (TAG-OF-EVENT E) 5))
Prenexing produces ...
(IMPLIES
 (AND (IN E (INTRUDER-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (= E (MAKE-INTRUDER-EVENT L T M)))
 (= (TAG-OF-EVENT E) 5))
Substituting (= E (MAKE-INTRUDER-EVENT L T M)) produces ...
(IMPLIES
 (AND (IN E (INTRUDER-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (= E (MAKE-INTRUDER-EVENT L T M)))
 (= (TAG-OF-EVENT (MAKE-INTRUDER-EVENT L T M)) 5))
Which simplifies
 with the assumptions TAG-OF-MAKE-INTRUDER-EVENT,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
MAKE-SEND-EVENT-IS-SEND-EVENT
Beginning proof of MAKE-SEND-EVENT-IS-SEND-EVENT ...
(IMPLIES (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)))
 (IN (MAKE-SEND-EVENT L T M P) (SEND-EVENTS)))
Which simplifies
 when rewriting with NAT!IN-NAT, SEND-EVENTS.DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT
Beginning proof of MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT ...
(IMPLIES (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)))
 (IN (MAKE-RECEIVE-EVENT L T M P) (RECEIVE-EVENTS)))
Which simplifies
 when rewriting with NAT!IN-NAT, RECEIVE-EVENTS.DEFINITION
 forward chaining using TAG-OF-RECEIVE-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT
Beginning proof of MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT ...
(IMPLIES
 (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN S (MS!PRINCIPALS))
  (IN R (MS!PRINCIPALS)))
 (IN (MAKE-OUT-OF-BAND-EVENT L T M S R) (OUT-OF-BAND-EVENTS)))
Which simplifies
 when rewriting with NAT!IN-NAT, OUT-OF-BAND-EVENTS.DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT
Beginning proof of MAKE-GENERATE-EVENT-IS-GENERATE-EVENT ...
(IMPLIES (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)))
 (IN (MAKE-GENERATE-EVENT L T M P) (GENERATE-EVENTS)))
Which simplifies
 when rewriting with NAT!IN-NAT, GENERATE-EVENTS.DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
MAKE-CONSTRUCT-EVENT-IS-CONSTRUCT-EVENT
Beginning proof of MAKE-CONSTRUCT-EVENT-IS-CONSTRUCT-EVENT ...
(IMPLIES (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)))
 (IN (MAKE-CONSTRUCT-EVENT L T M P) (CONSTRUCT-EVENTS)))
Which simplifies
 when rewriting with NAT!IN-NAT, CONSTRUCT-EVENTS.DEFINITION
 forward chaining using TAG-OF-CONSTRUCT-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT
Beginning proof of MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT ...
(IMPLIES (AND (>= L 0) (>= T 0) (IN M (MS!MESSAGES)))
 (IN (MAKE-INTRUDER-EVENT L T M) (INTRUDER-EVENTS)))
Which simplifies
 when rewriting with NAT!IN-NAT, INTRUDER-EVENTS.DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-INTRUDER-EVENT,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
EVENTS
SEND-EVENT-IS-EVENT
Beginning proof of SEND-EVENT-IS-EVENT ...
(IMPLIES (IN E (SEND-EVENTS)) (IN E (EVENTS)))
Invoking EVENTS gives ...
(IMPLIES (IN E (SEND-EVENTS))
 (IN E
  (UNION (SEND-EVENTS)
   (UNION (RECEIVE-EVENTS)
    (UNION (OUT-OF-BAND-EVENTS)
     (UNION (GENERATE-EVENTS)
      (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS))))))))
Which simplifies
 when rewriting with UNION.DEFINITION
 forward chaining using TAG-OF-SEND-EVENT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
RECEIVE-EVENT-IS-EVENT
Beginning proof of RECEIVE-EVENT-IS-EVENT ...
(IMPLIES (IN E (RECEIVE-EVENTS)) (IN E (EVENTS)))
Invoking EVENTS gives ...
(IMPLIES (IN E (RECEIVE-EVENTS))
 (IN E
  (UNION (SEND-EVENTS)
   (UNION (RECEIVE-EVENTS)
    (UNION (OUT-OF-BAND-EVENTS)
     (UNION (GENERATE-EVENTS)
      (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS))))))))
Which simplifies
 when rewriting with UNION.DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
OUT-OF-BAND-EVENT-IS-EVENT
Beginning proof of OUT-OF-BAND-EVENT-IS-EVENT ...
(IMPLIES (IN E (OUT-OF-BAND-EVENTS)) (IN E (EVENTS)))
Invoking EVENTS gives ...
(IMPLIES (IN E (OUT-OF-BAND-EVENTS))
 (IN E
  (UNION (SEND-EVENTS)
   (UNION (RECEIVE-EVENTS)
    (UNION (OUT-OF-BAND-EVENTS)
     (UNION (GENERATE-EVENTS)
      (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS))))))))
Which simplifies
 when rewriting with UNION.DEFINITION
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, TAG-OF-OUT-OF-BAND-EVENT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
GENERATE-EVENT-IS-EVENT
Beginning proof of GENERATE-EVENT-IS-EVENT ...
(IMPLIES (IN E (GENERATE-EVENTS)) (IN E (EVENTS)))
Invoking EVENTS gives ...
(IMPLIES (IN E (GENERATE-EVENTS))
 (IN E
  (UNION (SEND-EVENTS)
   (UNION (RECEIVE-EVENTS)
    (UNION (OUT-OF-BAND-EVENTS)
     (UNION (GENERATE-EVENTS)
      (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS))))))))
Which simplifies
 when rewriting with UNION.DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, TAG-OF-GENERATE-EVENT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
CONSTRUCT-EVENT-IS-EVENT
Beginning proof of CONSTRUCT-EVENT-IS-EVENT ...
(IMPLIES (IN E (CONSTRUCT-EVENTS)) (IN E (EVENTS)))
Invoking EVENTS gives ...
(IMPLIES (IN E (CONSTRUCT-EVENTS))
 (IN E
  (UNION (SEND-EVENTS)
   (UNION (RECEIVE-EVENTS)
    (UNION (OUT-OF-BAND-EVENTS)
     (UNION (GENERATE-EVENTS)
      (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS))))))))
Which simplifies
 when rewriting with UNION.DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, TAG-OF-RECEIVE-EVENT,
RECEIVE-EVENT-IS-EVENT, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
TAG-OF-CONSTRUCT-EVENT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
INTRUDER-EVENT-IS-EVENT
Beginning proof of INTRUDER-EVENT-IS-EVENT ...
(IMPLIES (IN E (INTRUDER-EVENTS)) (IN E (EVENTS)))
Invoking EVENTS gives ...
(IMPLIES (IN E (INTRUDER-EVENTS))
 (IN E
  (UNION (SEND-EVENTS)
   (UNION (RECEIVE-EVENTS)
    (UNION (OUT-OF-BAND-EVENTS)
     (UNION (GENERATE-EVENTS)
      (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS))))))))
Which simplifies
 when rewriting with UNION.DEFINITION
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, TAG-OF-INTRUDER-EVENT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
LABEL-OF-EVENT
LABEL-OF-SEND-EVENT
Beginning proof of LABEL-OF-SEND-EVENT ...
(= (LABEL-OF-EVENT (MAKE-SEND-EVENT L T M P)) L)
Which simplifies
 with invocation of LABEL-OF-EVENT, MAKE-SEND-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-SEND-EVENT to ...
(TRUE)
LABEL-OF-RECEIVE-EVENT
Beginning proof of LABEL-OF-RECEIVE-EVENT ...
(= (LABEL-OF-EVENT (MAKE-RECEIVE-EVENT L T M P)) L)
Which simplifies
 with invocation of LABEL-OF-EVENT, MAKE-RECEIVE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-RECEIVE-EVENT to ...
(TRUE)
LABEL-OF-OUT-OF-BAND-EVENT
Beginning proof of LABEL-OF-OUT-OF-BAND-EVENT ...
(= (LABEL-OF-EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)) L)
Which simplifies
 with invocation of LABEL-OF-EVENT, MAKE-OUT-OF-BAND-EVENT
 forward chaining using TUPLE!6TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-6TUPLE-6TUPLE, TUPLE!P1-6TUPLE,
TUPLE!P2-6TUPLE, TUPLE!P3-6TUPLE, TUPLE!P4-6TUPLE, TUPLE!P5-6TUPLE,
TUPLE!P6-6TUPLE, TAG-OF-MAKE-OUT-OF-BAND-EVENT to ...
(TRUE)
LABEL-OF-GENERATE-EVENT
Beginning proof of LABEL-OF-GENERATE-EVENT ...
(= (LABEL-OF-EVENT (MAKE-GENERATE-EVENT L T M P)) L)
Which simplifies
 with invocation of LABEL-OF-EVENT, MAKE-GENERATE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-GENERATE-EVENT to ...
(TRUE)
LABEL-OF-CONSTRUCT-EVENT
Beginning proof of LABEL-OF-CONSTRUCT-EVENT ...
(= (LABEL-OF-EVENT (MAKE-CONSTRUCT-EVENT L T M P)) L)
Which simplifies
 with invocation of LABEL-OF-EVENT, MAKE-CONSTRUCT-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-CONSTRUCT-EVENT to ...
(TRUE)
LABEL-OF-INTRUDER-EVENT
Beginning proof of LABEL-OF-INTRUDER-EVENT ...
(= (LABEL-OF-EVENT (MAKE-INTRUDER-EVENT L T M)) L)
Which simplifies
 with invocation of LABEL-OF-EVENT, MAKE-INTRUDER-EVENT
 forward chaining using TUPLE!4TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-4TUPLE-4TUPLE, TUPLE!P1-4TUPLE,
TUPLE!P2-4TUPLE, TUPLE!P3-4TUPLE, TUPLE!P4-4TUPLE,
TAG-OF-MAKE-INTRUDER-EVENT to ...
(TRUE)
TIME-OF-EVENT
TIME-OF-SEND-EVENT
Beginning proof of TIME-OF-SEND-EVENT ...
(= (TIME-OF-EVENT (MAKE-SEND-EVENT L T M P)) T)
Which simplifies
 with invocation of TIME-OF-EVENT, MAKE-SEND-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT to ...
(TRUE)
TIME-OF-RECEIVE-EVENT
Beginning proof of TIME-OF-RECEIVE-EVENT ...
(= (TIME-OF-EVENT (MAKE-RECEIVE-EVENT L T M P)) T)
Which simplifies
 with invocation of TIME-OF-EVENT, MAKE-RECEIVE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT to ...
(TRUE)
TIME-OF-OUT-OF-BAND-EVENT
Beginning proof of TIME-OF-OUT-OF-BAND-EVENT ...
(= (TIME-OF-EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)) T)
Which simplifies
 with invocation of TIME-OF-EVENT, MAKE-OUT-OF-BAND-EVENT
 forward chaining using TUPLE!6TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-6TUPLE-6TUPLE, TUPLE!P1-6TUPLE,
TUPLE!P2-6TUPLE, TUPLE!P3-6TUPLE, TUPLE!P4-6TUPLE, TUPLE!P5-6TUPLE,
TUPLE!P6-6TUPLE, TAG-OF-MAKE-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT to
...
(TRUE)
TIME-OF-GENERATE-EVENT
Beginning proof of TIME-OF-GENERATE-EVENT ...
(= (TIME-OF-EVENT (MAKE-GENERATE-EVENT L T M P)) T)
Which simplifies
 with invocation of TIME-OF-EVENT, MAKE-GENERATE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT to ...
(TRUE)
TIME-OF-CONSTRUCT-EVENT
Beginning proof of TIME-OF-CONSTRUCT-EVENT ...
(= (TIME-OF-EVENT (MAKE-CONSTRUCT-EVENT L T M P)) T)
Which simplifies
 with invocation of TIME-OF-EVENT, MAKE-CONSTRUCT-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT to ...
(TRUE)
TIME-OF-INTRUDER-EVENT
Beginning proof of TIME-OF-INTRUDER-EVENT ...
(= (TIME-OF-EVENT (MAKE-INTRUDER-EVENT L T M)) T)
Which simplifies
 with invocation of TIME-OF-EVENT, MAKE-INTRUDER-EVENT
 forward chaining using TUPLE!4TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-4TUPLE-4TUPLE, TUPLE!P1-4TUPLE,
TUPLE!P2-4TUPLE, TUPLE!P3-4TUPLE, TUPLE!P4-4TUPLE, TAG-OF-MAKE-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT to ...
(TRUE)
MESSAGE-OF-EVENT
MESSAGE-OF-SEND-EVENT
Beginning proof of MESSAGE-OF-SEND-EVENT ...
(= (MESSAGE-OF-EVENT (MAKE-SEND-EVENT L T M P)) M)
Which simplifies
 with invocation of MESSAGE-OF-EVENT, MAKE-SEND-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT to ...
(TRUE)
MESSAGE-OF-RECEIVE-EVENT
Beginning proof of MESSAGE-OF-RECEIVE-EVENT ...
(= (MESSAGE-OF-EVENT (MAKE-RECEIVE-EVENT L T M P)) M)
Which simplifies
 with invocation of MESSAGE-OF-EVENT, MAKE-RECEIVE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT to ...
(TRUE)
MESSAGE-OF-OUT-OF-BAND-EVENT
Beginning proof of MESSAGE-OF-OUT-OF-BAND-EVENT ...
(= (MESSAGE-OF-EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)) M)
Which simplifies
 with invocation of MESSAGE-OF-EVENT, MAKE-OUT-OF-BAND-EVENT
 forward chaining using TUPLE!6TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-6TUPLE-6TUPLE, TUPLE!P1-6TUPLE,
TUPLE!P2-6TUPLE, TUPLE!P3-6TUPLE, TUPLE!P4-6TUPLE, TUPLE!P5-6TUPLE,
TUPLE!P6-6TUPLE, TAG-OF-MAKE-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT to ...
(TRUE)
MESSAGE-OF-GENERATE-EVENT
Beginning proof of MESSAGE-OF-GENERATE-EVENT ...
(= (MESSAGE-OF-EVENT (MAKE-GENERATE-EVENT L T M P)) M)
Which simplifies
 with invocation of MESSAGE-OF-EVENT, MAKE-GENERATE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT to
...
(TRUE)
MESSAGE-OF-CONSTRUCT-EVENT
Beginning proof of MESSAGE-OF-CONSTRUCT-EVENT ...
(= (MESSAGE-OF-EVENT (MAKE-CONSTRUCT-EVENT L T M P)) M)
Which simplifies
 with invocation of MESSAGE-OF-EVENT, MAKE-CONSTRUCT-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT to ...
(TRUE)
MESSAGE-OF-INTRUDER-EVENT
Beginning proof of MESSAGE-OF-INTRUDER-EVENT ...
(= (MESSAGE-OF-EVENT (MAKE-INTRUDER-EVENT L T M)) M)
Which simplifies
 with invocation of MESSAGE-OF-EVENT, MAKE-INTRUDER-EVENT
 forward chaining using TUPLE!4TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-4TUPLE-4TUPLE, TUPLE!P1-4TUPLE,
TUPLE!P2-4TUPLE, TUPLE!P3-4TUPLE, TUPLE!P4-4TUPLE, TAG-OF-MAKE-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT, TIME-OF-INTRUDER-EVENT to ...
(TRUE)
PRINCIPAL1-OF-EVENT
PRINCIPAL1-OF-SEND-EVENT
Beginning proof of PRINCIPAL1-OF-SEND-EVENT ...
(= (PRINCIPAL1-OF-EVENT (MAKE-SEND-EVENT L T M P)) P)
Which simplifies
 with invocation of PRINCIPAL1-OF-EVENT, MAKE-SEND-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT to ...
(TRUE)
PRINCIPAL1-OF-RECEIVE-EVENT
Beginning proof of PRINCIPAL1-OF-RECEIVE-EVENT ...
(= (PRINCIPAL1-OF-EVENT (MAKE-RECEIVE-EVENT L T M P)) P)
Which simplifies
 with invocation of PRINCIPAL1-OF-EVENT, MAKE-RECEIVE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT to ...
(TRUE)
PRINCIPAL1-OF-OUT-OF-BAND-EVENT
Beginning proof of PRINCIPAL1-OF-OUT-OF-BAND-EVENT ...
(= (PRINCIPAL1-OF-EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)) S)
Which simplifies
 with invocation of PRINCIPAL1-OF-EVENT, MAKE-OUT-OF-BAND-EVENT
 forward chaining using TUPLE!6TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-6TUPLE-6TUPLE, TUPLE!P1-6TUPLE,
TUPLE!P2-6TUPLE, TUPLE!P3-6TUPLE, TUPLE!P4-6TUPLE, TUPLE!P5-6TUPLE,
TUPLE!P6-6TUPLE, TAG-OF-MAKE-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT to ...
(TRUE)
PRINCIPAL1-OF-GENERATE-EVENT
Beginning proof of PRINCIPAL1-OF-GENERATE-EVENT ...
(= (PRINCIPAL1-OF-EVENT (MAKE-GENERATE-EVENT L T M P)) P)
Which simplifies
 with invocation of PRINCIPAL1-OF-EVENT, MAKE-GENERATE-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT to ...
(TRUE)
PRINCIPAL1-OF-CONSTRUCT-EVENT
Beginning proof of PRINCIPAL1-OF-CONSTRUCT-EVENT ...
(= (PRINCIPAL1-OF-EVENT (MAKE-CONSTRUCT-EVENT L T M P)) P)
Which simplifies
 with invocation of PRINCIPAL1-OF-EVENT, MAKE-CONSTRUCT-EVENT
 forward chaining using TUPLE!5TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-5TUPLE-5TUPLE, TUPLE!P1-5TUPLE,
TUPLE!P2-5TUPLE, TUPLE!P3-5TUPLE, TUPLE!P4-5TUPLE, TUPLE!P5-5TUPLE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT to ...
(TRUE)
PRINCIPAL2-OF-EVENT
PRINCIPAL2-OF-OUT-OF-BAND-EVENT
Beginning proof of PRINCIPAL2-OF-OUT-OF-BAND-EVENT ...
(= (PRINCIPAL2-OF-EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)) R)
Which simplifies
 with invocation of PRINCIPAL2-OF-EVENT, MAKE-OUT-OF-BAND-EVENT
 forward chaining using TUPLE!6TUPLE-COMPOSITION
 with the assumptions TUPLE!IS-6TUPLE-6TUPLE, TUPLE!P1-6TUPLE,
TUPLE!P2-6TUPLE, TUPLE!P3-6TUPLE, TUPLE!P4-6TUPLE, TUPLE!P5-6TUPLE,
TUPLE!P6-6TUPLE, TAG-OF-MAKE-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT to ...
(TRUE)
TIME-STRICTLY-INCREASES
Beginning proof of TIME-STRICTLY-INCREASES ...
(IF (SEQ!EMPTYP HISTORY) (TRUE)
 (IF (>= (SEQ!LENGTH HISTORY) 2)
  (M< (SEQ!LENGTH (SEQ!TAIL HISTORY)) (SEQ!LENGTH HISTORY)) (TRUE)))
Which simplifies
 with invocation of SEQ!LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE, SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
TIME-CONSTRAINT
TIME-CONSTRAINT-IMPLIES-NAT
Beginning proof of TIME-CONSTRAINT-IMPLIES-NAT ...
(IMPLIES (TIME-CONSTRAINT TIME STATE) (>= TIME 0))
Which simplifies
 with invocation of TIME-CONSTRAINT
 when rewriting with NAT!IN-NAT
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
TIME-OF-EVENT-IN-CONSTRAINED-HISTORY-NAT
Beginning proof of TIME-OF-EVENT-IN-CONSTRAINED-HISTORY-NAT ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE HISTORY) (SEQ!IS-MEMBER EVENT HISTORY)
  (TIME-STRICTLY-INCREASES HISTORY))
 (>= (TIME-OF-EVENT EVENT) 0))
Inducting using the following scheme ...
 (AND (IMPLIES (SEQ!EMPTYP HISTORY) (*P* EVENT HISTORY))
  (IMPLIES
   (AND (NOT (SEQ!EMPTYP HISTORY)) (>= (SEQ!LENGTH HISTORY) 2)
    (*P* EVENT (SEQ!TAIL HISTORY)))
   (*P* EVENT HISTORY))
  (IMPLIES (AND (NOT (SEQ!EMPTYP HISTORY)) (NOT (>= (SEQ!LENGTH HISTORY) 2)))
   (*P* EVENT HISTORY)))
 produces ...
(AND
 (IMPLIES (SEQ!EMPTYP HISTORY)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE HISTORY) (SEQ!IS-MEMBER EVENT HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT EVENT) 0)))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP HISTORY)) (>= (SEQ!LENGTH HISTORY) 2)
   (IMPLIES
    (AND (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
     (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
     (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY)))
    (>= (TIME-OF-EVENT EVENT) 0)))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE HISTORY) (SEQ!IS-MEMBER EVENT HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT EVENT) 0)))
 (IMPLIES (AND (NOT (SEQ!EMPTYP HISTORY)) (NOT (>= (SEQ!LENGTH HISTORY) 2)))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE HISTORY) (SEQ!IS-MEMBER EVENT HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT EVENT) 0))))
Which simplifies
 with invocation of SEQ!IS-SEQUENCE, TIME-STRICTLY-INCREASES, SEQ!LENGTH,
SEQ!IS-MEMBER
 when rewriting with NAT!IN-NAT, SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES (AND (SEQ!IS-TACK HISTORY) (SEQ!IS-SEQUENCE HISTORY))
 (IF (>= (SEQ!LENGTH HISTORY) 2)
  (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
   (IMPLIES (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (OR (>= (TIME-OF-EVENT EVENT) 0)
      (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 2)
      (NOT (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)))
     (IMPLIES
      (AND (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 2))
       (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
      (>= (TIME-OF-EVENT EVENT) 0))))
   (IMPLIES
    (AND (NOT (= EVENT (SEQ!HEAD HISTORY)))
     (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY)))
    (IF (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 2)
     (IMPLIES
      (AND (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
       (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
        (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))))))
      (>= (TIME-OF-EVENT EVENT) 0))
     (IMPLIES (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
      (>= (TIME-OF-EVENT EVENT) 0)))))
  (IMPLIES
   (AND (SEQ!IS-MEMBER EVENT HISTORY)
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
   (>= (TIME-OF-EVENT EVENT) 0))))
Invoking (SEQ!LENGTH HISTORY) gives ...
(IMPLIES (AND (SEQ!IS-TACK HISTORY) (SEQ!IS-SEQUENCE HISTORY))
 (IF (>= (IF (SEQ!IS-TACK HISTORY) (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 0) 2)
  (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
   (IMPLIES (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (OR (>= (TIME-OF-EVENT EVENT) 0)
      (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 2)
      (NOT (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)))
     (IMPLIES
      (AND (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 2))
       (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
      (>= (TIME-OF-EVENT EVENT) 0))))
   (IMPLIES
    (AND (NOT (= EVENT (SEQ!HEAD HISTORY)))
     (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
     (IF (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 2)
      (AND (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
       (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
        (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))))))
      (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)))
    (>= (TIME-OF-EVENT EVENT) 0)))
  (IMPLIES
   (AND (SEQ!IS-MEMBER EVENT HISTORY)
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
   (>= (TIME-OF-EVENT EVENT) 0))))
Which simplifies
 with invocation of SEQ!IS-MEMBER
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES (AND (SEQ!IS-TACK HISTORY) (SEQ!IS-SEQUENCE HISTORY))
 (IF (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 2)
  (IMPLIES
   (AND (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY)))
    (NOT (= EVENT (SEQ!HEAD HISTORY)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
     (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))))))
   (>= (TIME-OF-EVENT EVENT) 0))
  (IMPLIES
   (AND (NOT (= EVENT (SEQ!HEAD HISTORY)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
   (>= (TIME-OF-EVENT EVENT) 0))))
Invoking (SEQ!LENGTH (SEQ!TAIL HISTORY)) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK HISTORY) (SEQ!IS-SEQUENCE HISTORY)
  (IF
   (>=
    (+ 1
     (IF (SEQ!IS-TACK (SEQ!TAIL HISTORY))
      (+ 1 (SEQ!LENGTH (SEQ!TAIL (SEQ!TAIL HISTORY)))) 0))
    2)
   (AND (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY)))
    (NOT (= EVENT (SEQ!HEAD HISTORY)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
     (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))))))
   (AND (NOT (= EVENT (SEQ!HEAD HISTORY)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))))
 (>= (TIME-OF-EVENT EVENT) 0))
Which simplifies
 with invocation of SEQ!IS-MEMBER
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-TACK HISTORY) (SEQ!IS-SEQUENCE HISTORY)
  (SEQ!IS-TACK (SEQ!TAIL HISTORY)) (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY)))
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))))))
 (>= (TIME-OF-EVENT EVENT) 0))
Invoking (SEQ!IS-SEQUENCE HISTORY) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK HISTORY)
  (IF (SEQ!IS-TACK HISTORY) (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
   (= HISTORY (SEQ!EMPTY)))
  (SEQ!IS-TACK (SEQ!TAIL HISTORY)) (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY)))
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))))))
 (>= (TIME-OF-EVENT EVENT) 0))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
ALL-STORAGE
ADD-TO-STORAGE
ADD-TO-STORAGE-IS-FUNCTION
Beginning proof of ADD-TO-STORAGE-IS-FUNCTION ...
(IMPLIES (FN!IS-FUNCTION STORES)
 (FN!IS-FUNCTION (ADD-TO-STORAGE STORES PRINCIPAL MESSAGE)))
Which simplifies
 with invocation of ADD-TO-STORAGE
 when rewriting with FN!IS-FUNCTION-OVERRIDE, NULLSET.DEFINITION,
REL!DOM-NULLSET, FN!IS-FUNCTION-NULLSET, FN!IS-FUNCTION-SETADD
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FN!IS-FUNCTION-BOOL to ...
(TRUE)
ADD-NULLSET-TO-STORAGE
Beginning proof of ADD-NULLSET-TO-STORAGE ...
(IMPLIES (AND (FN!IS-FUNCTION STORES) (IN PRINCIPAL (REL!DOM STORES)))
 (= (ADD-TO-STORAGE STORES PRINCIPAL (NULLSET)) STORES))
Applying FN!FUNCTION-EXTENSIONALITY gives ...
(IMPLIES (AND (FN!IS-FUNCTION STORES) (IN PRINCIPAL (REL!DOM STORES)))
 (IF
  (AND (FN!IS-FUNCTION (ADD-TO-STORAGE STORES PRINCIPAL (NULLSET)))
   (FN!IS-FUNCTION STORES))
  (AND
   (= (REL!DOM (ADD-TO-STORAGE STORES PRINCIPAL (NULLSET))) (REL!DOM STORES))
   (ALL (X)
    (IMPLIES (IN X (REL!DOM (ADD-TO-STORAGE STORES PRINCIPAL (NULLSET))))
     (= (FN!APPLY (ADD-TO-STORAGE STORES PRINCIPAL (NULLSET)) X)
      (FN!APPLY STORES X)))))
  (= (ADD-TO-STORAGE STORES PRINCIPAL (NULLSET)) STORES)))
Which simplifies
 with invocation of ADD-TO-STORAGE
 when rewriting with FN!APPLY-SETADD, SETADD.DEFINITION, FN!APPLY-OVERRIDE,
SETRULES!UNION-SUBSET-LEFT, SETRULES!SUBSET-SETADD, REL!DOM-SETADD,
FN!DOM-OVERRIDE, FN!IS-FUNCTION-OVERRIDE, NULLSET.DEFINITION, REL!DOM-NULLSET,
FN!IS-FUNCTION-NULLSET, FN!IS-FUNCTION-SETADD, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STORAGE-IS-FUNCTION,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
STORAGE-OF
ALL-MESSAGES-IN-STATE
ALL-MESSAGES-IN-STATE-DEFINITION
Beginning proof of ALL-MESSAGES-IN-STATE-DEFINITION ...
(= (ALL-MESSAGES-IN-STATE STATE)
 (UNION (MS!PUBLIC-KEYS)
  (UNION (MS!TEXT-MESSAGES)
   (UNION (MS!PRINCIPALS)
    (UNION (SEEN-MESSAGES STATE) (ALL-STORAGE (STORES STATE)))))))
Invoking ALL-MESSAGES-IN-STATE gives ...
(=
 (UNION (MS!PUBLIC-KEYS)
  (UNION (MS!TEXT-MESSAGES)
   (UNION (MS!PRINCIPALS)
    (UNION (SEEN-MESSAGES STATE) (ALL-STORAGE (STORES STATE))))))
 (UNION (MS!PUBLIC-KEYS)
  (UNION (MS!TEXT-MESSAGES)
   (UNION (MS!PRINCIPALS)
    (UNION (SEEN-MESSAGES STATE) (ALL-STORAGE (STORES STATE)))))))
Which simplifies
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY to ...
(TRUE)
SIGN
SIGN-IS-IN-COMBINE-MESSAGES
Beginning proof of SIGN-IS-IN-COMBINE-MESSAGES ...
(IMPLIES (AND (IN MESSAGE (MS!MESSAGES)) (IN KEY (MS!KEYS)))
 (IN (SIGN MESSAGE KEY) (MS!COMBINE-MESSAGES)))
Which simplifies
 with invocation of SIGN
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES
 with the assumptions MS!SET-OF-COMBINE-MESSAGES-NOT-EMPTY, MS!TAG-OF-COMBINE,
MS!CB1-COMBINE, MS!CB2-COMBINE, MS!COMBINE-IN-COMBINE-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
3COMBINE
3COMBINE-IS-MESSAGE
Beginning proof of 3COMBINE-IS-MESSAGE ...
(IMPLIES
 (AND (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES)) (IN M3 (MS!MESSAGES)))
 (IN (3COMBINE M1 M2 M3) (MS!MESSAGES)))
Which simplifies
 with invocation of 3COMBINE
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
4COMBINE
4COMBINE-IS-MESSAGE
Beginning proof of 4COMBINE-IS-MESSAGE ...
(IMPLIES
 (AND (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES)) (IN M3 (MS!MESSAGES))
  (IN M4 (MS!MESSAGES)))
 (IN (4COMBINE M1 M2 M3 M4) (MS!MESSAGES)))
Which simplifies
 with invocation of 4COMBINE
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
5COMBINE
5COMBINE-IS-MESSAGE
Beginning proof of 5COMBINE-IS-MESSAGE ...
(IMPLIES
 (AND (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES)) (IN M3 (MS!MESSAGES))
  (IN M4 (MS!MESSAGES)) (IN M5 (MS!MESSAGES)))
 (IN (5COMBINE M1 M2 M3 M4 M5) (MS!MESSAGES)))
Which simplifies
 with invocation of 5COMBINE
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
6COMBINE
6COMBINE-IS-MESSAGE
Beginning proof of 6COMBINE-IS-MESSAGE ...
(IMPLIES
 (AND (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES)) (IN M3 (MS!MESSAGES))
  (IN M4 (MS!MESSAGES)) (IN M5 (MS!MESSAGES)) (IN M6 (MS!MESSAGES)))
 (IN (6COMBINE M1 M2 M3 M4 M5 M6) (MS!MESSAGES)))
Which simplifies
 with invocation of 6COMBINE
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
TIME-STRICTLY-INCREASES-STEP
Beginning proof of TIME-STRICTLY-INCREASES-STEP ...
(IMPLIES
 (AND (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (TIME-CONSTRAINT (TIME-OF-EVENT EVENT) STATE))
 (= (TIME-STRICTLY-INCREASES (SEQ!TACK EVENT (HISTORY STATE))) (TRUE)))
Which simplifies
 with invocation of TIME-STRICTLY-INCREASES, SEQ!IS-SEQUENCE, TIME-CONSTRAINT
 when rewriting with SEQ!LENGTH-TACK, SEQ!EMPTYP-DEFINITION, NAT!IN-NAT
 forward chaining using SEQ!TACK-HEAD-TAIL, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK,
SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
ADD-TO-STATE-STORAGE
ADD-TO-STATE-STORAGE-IS-STATE
Beginning proof of ADD-TO-STATE-STORAGE-IS-STATE ...
(IS-STATE (ADD-TO-STATE-STORAGE PRINCIPAL MESSAGE STATE))
Which simplifies
 with invocation of ADD-TO-STORAGE, ADD-TO-STATE-STORAGE
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions IS-STATE-BOOL, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE, STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE,
PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
SEEN-MESSAGES-OF-ADD-TO-STATE-STORAGE
Beginning proof of SEEN-MESSAGES-OF-ADD-TO-STATE-STORAGE ...
(= (SEEN-MESSAGES (ADD-TO-STATE-STORAGE PRINCIPAL MESSAGE STATE))
 (SEEN-MESSAGES STATE))
Which simplifies
 with invocation of ADD-TO-STORAGE, ADD-TO-STATE-STORAGE
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FN!IS-FUNCTION-BOOL,
ADD-TO-STATE-STORAGE-IS-STATE to ...
(TRUE)
STORES-OF-ADD-TO-STATE-STORAGE
Beginning proof of STORES-OF-ADD-TO-STATE-STORAGE ...
(= (STORES (ADD-TO-STATE-STORAGE PRINCIPAL MESSAGE STATE))
 (ADD-TO-STORAGE (STORES STATE) PRINCIPAL MESSAGE))
Which simplifies
 with invocation of ADD-TO-STORAGE, ADD-TO-STATE-STORAGE
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FN!IS-FUNCTION-BOOL,
ADD-TO-STATE-STORAGE-IS-STATE to ...
(TRUE)
HISTORY-OF-ADD-TO-STATE-STORAGE
Beginning proof of HISTORY-OF-ADD-TO-STATE-STORAGE ...
(= (HISTORY (ADD-TO-STATE-STORAGE PRINCIPAL MESSAGE STATE)) (HISTORY STATE))
Which simplifies
 with invocation of ADD-TO-STORAGE, ADD-TO-STATE-STORAGE
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FN!IS-FUNCTION-BOOL,
ADD-TO-STATE-STORAGE-IS-STATE to ...
(TRUE)
ADD-TO-STATE-HISTORY
ADD-TO-STATE-HISTORY-IS-STATE
Beginning proof of ADD-TO-STATE-HISTORY-IS-STATE ...
(IS-STATE (ADD-TO-STATE-HISTORY EVENT STATE))
Which simplifies
 with invocation of ADD-TO-STATE-HISTORY
 forward chaining using SEQ!TACK-HEAD-TAIL
 with the assumptions IS-STATE-BOOL, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE, STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK to ...
(TRUE)
SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY
Beginning proof of SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY ...
(= (SEEN-MESSAGES (ADD-TO-STATE-HISTORY EVENT STATE)) (SEEN-MESSAGES STATE))
Which simplifies
 with invocation of ADD-TO-STATE-HISTORY
 forward chaining using SEQ!TACK-HEAD-TAIL
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK,
SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-HISTORY-IS-STATE to ...
(TRUE)
STORES-OF-ADD-TO-STATE-HISTORY
Beginning proof of STORES-OF-ADD-TO-STATE-HISTORY ...
(= (STORES (ADD-TO-STATE-HISTORY EVENT STATE)) (STORES STATE))
Which simplifies
 with invocation of ADD-TO-STATE-HISTORY
 forward chaining using SEQ!TACK-HEAD-TAIL
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK,
SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-HISTORY-IS-STATE to ...
(TRUE)
HISTORY-OF-ADD-TO-STATE-HISTORY
Beginning proof of HISTORY-OF-ADD-TO-STATE-HISTORY ...
(= (HISTORY (ADD-TO-STATE-HISTORY EVENT STATE))
 (SEQ!TACK EVENT (HISTORY STATE)))
Which simplifies
 with invocation of ADD-TO-STATE-HISTORY
 forward chaining using SEQ!TACK-HEAD-TAIL
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK,
SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-HISTORY-IS-STATE to ...
(TRUE)
ADD-TO-STATE-SEEN-MESSAGES
ADD-TO-STATE-SEEN-MESSAGES-IS-STATE
Beginning proof of ADD-TO-STATE-SEEN-MESSAGES-IS-STATE ...
(IS-STATE (ADD-TO-STATE-SEEN-MESSAGES MESSAGE STATE))
Which simplifies
 with invocation of ADD-TO-STATE-SEEN-MESSAGES
 with the assumptions IS-STATE-BOOL, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE, STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
Beginning proof of SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES ...
(= (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES MESSAGE STATE))
 (UNION MESSAGE (SEEN-MESSAGES STATE)))
Which simplifies
 with invocation of ADD-TO-STATE-SEEN-MESSAGES
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE to ...
(TRUE)
STORES-OF-ADD-TO-STATE-SEEN-MESSAGES
Beginning proof of STORES-OF-ADD-TO-STATE-SEEN-MESSAGES ...
(= (STORES (ADD-TO-STATE-SEEN-MESSAGES MESSAGE STATE)) (STORES STATE))
Which simplifies
 with invocation of ADD-TO-STATE-SEEN-MESSAGES
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE to ...
(TRUE)
HISTORY-OF-ADD-TO-STATE-SEEN-MESSAGES
Beginning proof of HISTORY-OF-ADD-TO-STATE-SEEN-MESSAGES ...
(= (HISTORY (ADD-TO-STATE-SEEN-MESSAGES MESSAGE STATE)) (HISTORY STATE))
Which simplifies
 with invocation of ADD-TO-STATE-SEEN-MESSAGES
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE to ...
(TRUE)
IS-GOOD-STATE
IS-GOOD-STATE-IMPLICATION
Beginning proof of IS-GOOD-STATE-IMPLICATION ...
(IMPLIES (IS-GOOD-STATE STATE)
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES))))
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
SETADD-MEMBER
Beginning proof of SETADD-MEMBER ...
(IMPLIES (IN X S) (= (SETADD X S) S))
Which simplifies
 when rewriting with SETRULES!SETADD-MEMBER to ...
(TRUE)
IS-GOOD-STATE-ADD-TO-STATE-STORAGE
Beginning proof of IS-GOOD-STATE-ADD-TO-STATE-STORAGE ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (SUBSET MESSAGES (MS!MESSAGES)))
 (= (IS-GOOD-STATE (ADD-TO-STATE-STORAGE PRINCIPAL MESSAGES STATE)) (TRUE)))
Which simplifies
 with invocation of ADD-TO-STORAGE, ADD-TO-STATE-STORAGE, IS-GOOD-STATE
 when rewriting with SETRULES!UNION-SUBSET-LEFT, SUBSET.NULLSET.LEFT,
SETRULES!SUBSET-SETADD, REL!DOM-SETADD, FN!DOM-OVERRIDE,
FN!IS-FUNCTION-OVERRIDE, NULLSET.DEFINITION, REL!DOM-NULLSET,
FN!IS-FUNCTION-NULLSET, FN!IS-FUNCTION-SETADD, SEQ!IN-SEQUENCE-OF
 forward chaining using PAIR!PAIR-COMPOSITION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions PAIR!IS-PAIR-BOOL, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE, STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE,
PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
ADD-TO-STORAGE-IS-FUNCTION, ADD-TO-STATE-STORAGE-IS-STATE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN PRINCIPAL (MS!PRINCIPALS)) (SUBSET MESSAGES (MS!MESSAGES)))
 (SUBSET
  (REL!RAN
   (FN!OVERRIDE (STORES STATE)
    (SETADD
     (PAIR!PAIR PRINCIPAL
      (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
     (NULLSET))))
  (POWERSET (MS!MESSAGES))))
Assuming FN!RAN-OVERRIDE with the
instantiations: (= F (STORES STATE))
                (= G
                 (SETADD
                  (PAIR!PAIR PRINCIPAL
                   (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
                  (NULLSET))) generates
...
(IMPLIES
 (AND
  (SUBSET
   (REL!RAN
    (FN!OVERRIDE (STORES STATE)
     (SETADD
      (PAIR!PAIR PRINCIPAL
       (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
      (NULLSET))))
   (UNION (REL!RAN (STORES STATE))
    (REL!RAN
     (SETADD
      (PAIR!PAIR PRINCIPAL
       (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
      (NULLSET)))))
  (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN PRINCIPAL (MS!PRINCIPALS)) (SUBSET MESSAGES (MS!MESSAGES)))
 (SUBSET
  (REL!RAN
   (FN!OVERRIDE (STORES STATE)
    (SETADD
     (PAIR!PAIR PRINCIPAL
      (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
     (NULLSET))))
  (POWERSET (MS!MESSAGES))))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-LEFT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-RIGHT, REL!RAN-NULLSET, REL!RAN-SETADD
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION, PAIR!PAIR-COMPOSITION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(IMPLIES
 (AND
  (SUBSET
   (REL!RAN
    (FN!OVERRIDE (STORES STATE)
     (SETADD
      (PAIR!PAIR PRINCIPAL
       (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
      (NULLSET))))
   (SETADD (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL))
    (REL!RAN (STORES STATE))))
  (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN PRINCIPAL (MS!PRINCIPALS)) (SUBSET MESSAGES (MS!MESSAGES)))
 (SUBSET
  (REL!RAN
   (FN!OVERRIDE (STORES STATE)
    (SETADD
     (PAIR!PAIR PRINCIPAL
      (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
     (NULLSET))))
  (POWERSET (MS!MESSAGES))))
Assuming FN!APPLY-IN-RAN with the
instantiations: (= F (STORES STATE)) (= X PRINCIPAL) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (STORES STATE))
    (IN PRINCIPAL (REL!DOM (STORES STATE))))
   (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
  (SUBSET
   (REL!RAN
    (FN!OVERRIDE (STORES STATE)
     (SETADD
      (PAIR!PAIR PRINCIPAL
       (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
      (NULLSET))))
   (SETADD (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL))
    (REL!RAN (STORES STATE))))
  (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN PRINCIPAL (MS!PRINCIPALS)) (SUBSET MESSAGES (MS!MESSAGES)))
 (SUBSET
  (REL!RAN
   (FN!OVERRIDE (STORES STATE)
    (SETADD
     (PAIR!PAIR PRINCIPAL
      (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
     (NULLSET))))
  (POWERSET (MS!MESSAGES))))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION (STORES STATE)) (IN PRINCIPAL (REL!DOM (STORES STATE)))
  (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))
  (SUBSET
   (REL!RAN
    (FN!OVERRIDE (STORES STATE)
     (SETADD
      (PAIR!PAIR PRINCIPAL
       (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
      (NULLSET))))
   (SETADD (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL))
    (REL!RAN (STORES STATE))))
  (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (SUBSET MESSAGES (MS!MESSAGES)))
 (SUBSET
  (REL!RAN
   (FN!OVERRIDE (STORES STATE)
    (SETADD
     (PAIR!PAIR PRINCIPAL
      (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
     (NULLSET))))
  (POWERSET (MS!MESSAGES))))
Invoking FN!OVERRIDE gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION (STORES STATE)) (IN PRINCIPAL (REL!DOM (STORES STATE)))
  (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))
  (SUBSET
   (REL!RAN
    (UNION
     (REL!DOM-REMOVE
      (REL!DOM
       (SETADD
        (PAIR!PAIR PRINCIPAL
         (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
        (NULLSET)))
      (STORES STATE))
     (SETADD
      (PAIR!PAIR PRINCIPAL
       (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
      (NULLSET))))
   (SETADD (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL))
    (REL!RAN (STORES STATE))))
  (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (SUBSET MESSAGES (MS!MESSAGES)))
 (SUBSET
  (REL!RAN
   (UNION
    (REL!DOM-REMOVE
     (REL!DOM
      (SETADD
       (PAIR!PAIR PRINCIPAL
        (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
       (NULLSET)))
     (STORES STATE))
    (SETADD
     (PAIR!PAIR PRINCIPAL
      (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))
     (NULLSET))))
  (POWERSET (MS!MESSAGES))))
Which simplifies
 when rewriting with SUBSET.TRANSITIVE, SETRULES!SUBSET-UNION-LEFT,
POWERSET.DEFINITION, SETADD.DEFINITION, SETRULES!SUBSET-SETADD,
REL!RAN-SETADD, SETRULES!UNION-SUBSET-LEFT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-RIGHT, REL!DOM-NULLSET, REL!DOM-SETADD
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION (STORES STATE)) (IN PRINCIPAL (REL!DOM (STORES STATE)))
  (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))
  (SUBSET
   (REL!RAN (REL!DOM-REMOVE (SETADD PRINCIPAL (NULLSET)) (STORES STATE)))
   (SETADD (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL))
    (REL!RAN (STORES STATE))))
  (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (SUBSET MESSAGES (MS!MESSAGES)))
 (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL) (MS!MESSAGES)))
Invoking SUBSET gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION (STORES STATE)) (IN PRINCIPAL (REL!DOM (STORES STATE)))
  (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))
  (ALL (E)
   (IMPLIES
    (IN E
     (REL!RAN (REL!DOM-REMOVE (SETADD PRINCIPAL (NULLSET)) (STORES STATE))))
    (IN E
     (SETADD (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL))
      (REL!RAN (STORES STATE))))))
  (IS-STATE STATE)
  (ALL (E$0) (IMPLIES (IN E$0 (SEEN-MESSAGES STATE)) (IN E$0 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (E$1)
   (IMPLIES (IN E$1 (SEQ!MEMBERS (HISTORY STATE))) (IN E$1 (EVENTS))))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (ALL (E$2)
   (IMPLIES (IN E$2 (REL!RAN (STORES STATE)))
    (IN E$2 (POWERSET (MS!MESSAGES)))))
  (ALL (E$3) (IMPLIES (IN E$3 MESSAGES) (IN E$3 (MS!MESSAGES)))))
 (ALL (E$4)
  (IMPLIES (IN E$4 (FN!APPLY (STORES STATE) PRINCIPAL))
   (IN E$4 (MS!MESSAGES)))))
Prenexing produces ...
(IMPLIES
 (AND (FN!IS-FUNCTION (STORES STATE)) (IN PRINCIPAL (REL!DOM (STORES STATE)))
  (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))
  (ALL (E$0)
   (IMPLIES
    (IN E$0
     (REL!RAN (REL!DOM-REMOVE (SETADD PRINCIPAL (NULLSET)) (STORES STATE))))
    (IN E$0
     (SETADD (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL))
      (REL!RAN (STORES STATE))))))
  (IS-STATE STATE)
  (ALL (E$1) (IMPLIES (IN E$1 (SEEN-MESSAGES STATE)) (IN E$1 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (E$2)
   (IMPLIES (IN E$2 (SEQ!MEMBERS (HISTORY STATE))) (IN E$2 (EVENTS))))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (ALL (E$3)
   (IMPLIES (IN E$3 (REL!RAN (STORES STATE)))
    (IN E$3 (POWERSET (MS!MESSAGES)))))
  (ALL (E$4) (IMPLIES (IN E$4 MESSAGES) (IN E$4 (MS!MESSAGES))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL)))
 (IN E (MS!MESSAGES)))
Instantiating (= E$3 (FN!APPLY (STORES STATE) PRINCIPAL)) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION (STORES STATE)) (IN PRINCIPAL (REL!DOM (STORES STATE)))
  (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))
  (ALL (E$0)
   (IMPLIES
    (IN E$0
     (REL!RAN (REL!DOM-REMOVE (SETADD PRINCIPAL (NULLSET)) (STORES STATE))))
    (IN E$0
     (SETADD (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL))
      (REL!RAN (STORES STATE))))))
  (IS-STATE STATE)
  (ALL (E$1) (IMPLIES (IN E$1 (SEEN-MESSAGES STATE)) (IN E$1 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (E$2)
   (IMPLIES (IN E$2 (SEQ!MEMBERS (HISTORY STATE))) (IN E$2 (EVENTS))))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (IMPLIES (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))
   (IN (FN!APPLY (STORES STATE) PRINCIPAL) (POWERSET (MS!MESSAGES))))
  (ALL (E$3)
   (IMPLIES (IN E$3 (REL!RAN (STORES STATE)))
    (IN E$3 (POWERSET (MS!MESSAGES)))))
  (ALL (E$4) (IMPLIES (IN E$4 MESSAGES) (IN E$4 (MS!MESSAGES))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL)))
 (IN E (MS!MESSAGES)))
Which simplifies
 when rewriting with POWERSET.DEFINITION, SEQ!IN-MEMBERS, SETADD.DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION (STORES STATE)) (IN PRINCIPAL (REL!DOM (STORES STATE)))
  (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))
  (ALL (E$0)
   (IMPLIES
    (AND
     (IN E$0
      (REL!RAN (REL!DOM-REMOVE (SETADD PRINCIPAL (NULLSET)) (STORES STATE))))
     (NOT (= E$0 (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))))
    (IN E$0 (REL!RAN (STORES STATE)))))
  (IS-STATE STATE)
  (ALL (E$1) (IMPLIES (IN E$1 (SEEN-MESSAGES STATE)) (IN E$1 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (E$2) (IMPLIES (SEQ!IS-MEMBER E$2 (HISTORY STATE)) (IN E$2 (EVENTS))))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL) (MS!MESSAGES))
  (ALL (E$3)
   (IMPLIES (IN E$3 (REL!RAN (STORES STATE))) (SUBSET E$3 (MS!MESSAGES))))
  (ALL (E$4) (IMPLIES (IN E$4 MESSAGES) (IN E$4 (MS!MESSAGES))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL)))
 (IN E (MS!MESSAGES)))
Invoking SUBSET gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION (STORES STATE)) (IN PRINCIPAL (REL!DOM (STORES STATE)))
  (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))
  (ALL (E$0)
   (IMPLIES
    (AND
     (IN E$0
      (REL!RAN (REL!DOM-REMOVE (SETADD PRINCIPAL (NULLSET)) (STORES STATE))))
     (NOT (= E$0 (UNION MESSAGES (FN!APPLY (STORES STATE) PRINCIPAL)))))
    (IN E$0 (REL!RAN (STORES STATE)))))
  (IS-STATE STATE)
  (ALL (E$1) (IMPLIES (IN E$1 (SEEN-MESSAGES STATE)) (IN E$1 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (E$2) (IMPLIES (SEQ!IS-MEMBER E$2 (HISTORY STATE)) (IN E$2 (EVENTS))))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (ALL (E$3)
   (IMPLIES (IN E$3 (FN!APPLY (STORES STATE) PRINCIPAL))
    (IN E$3 (MS!MESSAGES))))
  (ALL (E$4)
   (IMPLIES (IN E$4 (REL!RAN (STORES STATE)))
    (ALL (E$5) (IMPLIES (IN E$5 E$4) (IN E$5 (MS!MESSAGES))))))
  (ALL (E$6) (IMPLIES (IN E$6 MESSAGES) (IN E$6 (MS!MESSAGES))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL)))
 (IN E (MS!MESSAGES)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FN!IS-FUNCTION-BOOL
 with the instantiation (= E$3 E) to ...
(TRUE)
IS-GOOD-STATE-ADD-TO-STATE-HISTORY
Beginning proof of IS-GOOD-STATE-ADD-TO-STATE-HISTORY ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN EVENT (EVENTS))
  (TIME-CONSTRAINT (TIME-OF-EVENT EVENT) STATE))
 (= (IS-GOOD-STATE (ADD-TO-STATE-HISTORY EVENT STATE)) (TRUE)))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (EVENTS)) (TIME-CONSTRAINT (TIME-OF-EVENT EVENT) STATE))
 (AND (IS-STATE (ADD-TO-STATE-HISTORY EVENT STATE))
  (SUBSET (SEEN-MESSAGES (ADD-TO-STATE-HISTORY EVENT STATE)) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (ADD-TO-STATE-HISTORY EVENT STATE)))
  (IN (HISTORY (ADD-TO-STATE-HISTORY EVENT STATE)) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES (ADD-TO-STATE-HISTORY EVENT STATE)))
  (= (REL!DOM (STORES (ADD-TO-STATE-HISTORY EVENT STATE))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (ADD-TO-STATE-HISTORY EVENT STATE)))
   (POWERSET (MS!MESSAGES)))))
Which simplifies
 when rewriting with STORES-OF-ADD-TO-STATE-HISTORY, SETRULES!SUBSET-SETADD,
SEQ!MEMBERS-TACK, TIME-STRICTLY-INCREASES-STEP,
HISTORY-OF-ADD-TO-STATE-HISTORY, SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEQ!IN-SEQUENCE-OF
 forward chaining using SEQ!TACK-HEAD-TAIL, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-HISTORY-IS-STATE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
IS-GOOD-STATE-ADD-TO-STATE-SEEN-MESSAGES
Beginning proof of IS-GOOD-STATE-ADD-TO-STATE-SEEN-MESSAGES ...
(IMPLIES (AND (IS-GOOD-STATE STATE) (SUBSET MESSAGES (MS!MESSAGES)))
 (= (IS-GOOD-STATE (ADD-TO-STATE-SEEN-MESSAGES MESSAGES STATE)) (TRUE)))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (SUBSET MESSAGES (MS!MESSAGES)))
 (AND (IS-STATE (ADD-TO-STATE-SEEN-MESSAGES MESSAGES STATE))
  (SUBSET (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES MESSAGES STATE))
   (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES
   (HISTORY (ADD-TO-STATE-SEEN-MESSAGES MESSAGES STATE)))
  (IN (HISTORY (ADD-TO-STATE-SEEN-MESSAGES MESSAGES STATE))
   (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES (ADD-TO-STATE-SEEN-MESSAGES MESSAGES STATE)))
  (= (REL!DOM (STORES (ADD-TO-STATE-SEEN-MESSAGES MESSAGES STATE)))
   (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (ADD-TO-STATE-SEEN-MESSAGES MESSAGES STATE)))
   (POWERSET (MS!MESSAGES)))))
Which simplifies
 when rewriting with STORES-OF-ADD-TO-STATE-SEEN-MESSAGES,
HISTORY-OF-ADD-TO-STATE-SEEN-MESSAGES, SETRULES!SUBSET-UNION-LEFT,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES, SEQ!IN-SEQUENCE-OF
 forward chaining using FN!FUNCTION-IS-RELATION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
ADD-NULLSET-TO-STATE-STORAGE
Beginning proof of ADD-NULLSET-TO-STATE-STORAGE ...
(IMPLIES (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS)))
 (= (ADD-TO-STATE-STORAGE PRINCIPAL (NULLSET) STATE) STATE))
Which simplifies
 with invocation of ADD-TO-STATE-STORAGE, SUBSET, IS-GOOD-STATE
 when rewriting with ADD-NULLSET-TO-STORAGE, POWERSET.DEFINITION,
SEQ!IN-MEMBERS, SEQ!IN-SEQUENCE-OF
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, ADD-TO-STORAGE-IS-FUNCTION,
ADD-TO-STATE-STORAGE-IS-STATE, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
FN!IS-FUNCTION-BOOL, MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE STATE)
  (ALL (E) (IMPLIES (IN E (SEEN-MESSAGES STATE)) (IN E (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (E$0) (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY STATE)) (IN E$0 (EVENTS))))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (ALL (E$1)
   (IMPLIES (IN E$1 (REL!RAN (STORES STATE)))
    (ALL (E$2) (IMPLIES (IN E$2 E$1) (IN E$2 (MS!MESSAGES))))))
  (IN PRINCIPAL (MS!PRINCIPALS)))
 (= (MAKE-STATE (SEEN-MESSAGES STATE) (STORES STATE) (HISTORY STATE)) STATE))
Invoking IS-STATE gives ...
(IMPLIES
 (AND (SOME (M ST H) (= STATE (MAKE-STATE M ST H)))
  (ALL (E) (IMPLIES (IN E (SEEN-MESSAGES STATE)) (IN E (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (E$0) (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY STATE)) (IN E$0 (EVENTS))))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (ALL (E$1)
   (IMPLIES (IN E$1 (REL!RAN (STORES STATE)))
    (ALL (E$2) (IMPLIES (IN E$2 E$1) (IN E$2 (MS!MESSAGES))))))
  (IN PRINCIPAL (MS!PRINCIPALS)))
 (= (MAKE-STATE (SEEN-MESSAGES STATE) (STORES STATE) (HISTORY STATE)) STATE))
Prenexing produces ...
(IMPLIES
 (AND (= STATE (MAKE-STATE M ST H))
  (ALL (E) (IMPLIES (IN E (SEEN-MESSAGES STATE)) (IN E (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (E$0) (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY STATE)) (IN E$0 (EVENTS))))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (ALL (E$1)
   (IMPLIES (IN E$1 (REL!RAN (STORES STATE)))
    (ALL (E$2) (IMPLIES (IN E$2 E$1) (IN E$2 (MS!MESSAGES))))))
  (IN PRINCIPAL (MS!PRINCIPALS)))
 (= (MAKE-STATE (SEEN-MESSAGES STATE) (STORES STATE) (HISTORY STATE)) STATE))
Substituting (= STATE (MAKE-STATE M ST H)) produces ...
(IMPLIES
 (AND (= STATE (MAKE-STATE M ST H))
  (ALL (E)
   (IMPLIES (IN E (SEEN-MESSAGES (MAKE-STATE M ST H))) (IN E (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY (MAKE-STATE M ST H)))
  (SEQ!IS-SEQUENCE (HISTORY (MAKE-STATE M ST H)))
  (ALL (E$0)
   (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY (MAKE-STATE M ST H)))
    (IN E$0 (EVENTS))))
  (FN!IS-FUNCTION (STORES (MAKE-STATE M ST H)))
  (= (REL!DOM (STORES (MAKE-STATE M ST H))) (MS!PRINCIPALS))
  (ALL (E$1)
   (IMPLIES (IN E$1 (REL!RAN (STORES (MAKE-STATE M ST H))))
    (ALL (E$2) (IMPLIES (IN E$2 E$1) (IN E$2 (MS!MESSAGES))))))
  (IN PRINCIPAL (MS!PRINCIPALS)))
 (=
  (MAKE-STATE (SEEN-MESSAGES (MAKE-STATE M ST H)) (STORES (MAKE-STATE M ST H))
   (HISTORY (MAKE-STATE M ST H)))
  (MAKE-STATE M ST H)))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE, STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE to ...
(TRUE)
STORAGE-OF-ADD-TO-STATE-STORAGE
Beginning proof of STORAGE-OF-ADD-TO-STATE-STORAGE ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN P1 (MS!PRINCIPALS)) (IN P2 (MS!PRINCIPALS)))
 (= (STORAGE-OF P1 (ADD-TO-STATE-STORAGE P2 M STATE))
  (IF (= P1 P2) (UNION M (STORAGE-OF P1 STATE)) (STORAGE-OF P1 STATE))))
Which simplifies
 with invocation of STORAGE-OF, ADD-TO-STORAGE, ADD-TO-STATE-STORAGE, SUBSET,
IS-GOOD-STATE
 when rewriting with FN!APPLY-SETADD, SETADD.DEFINITION, REL!DOM-SETADD,
FN!APPLY-OVERRIDE, NULLSET.DEFINITION, REL!DOM-NULLSET,
FN!IS-FUNCTION-NULLSET, FN!IS-FUNCTION-SETADD, POWERSET.DEFINITION,
SEQ!IN-MEMBERS, SEQ!IN-SEQUENCE-OF
 forward chaining using PAIR!PAIR-COMPOSITION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions PAIR!IS-PAIR-BOOL, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE, STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE,
PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
ADD-TO-STORAGE-IS-FUNCTION, ADD-TO-STATE-STORAGE-IS-STATE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
STORAGE-OF-ADD-TO-STATE-HISTORY
Beginning proof of STORAGE-OF-ADD-TO-STATE-HISTORY ...
(IMPLIES (IS-GOOD-STATE STATE)
 (= (STORAGE-OF P (ADD-TO-STATE-HISTORY EVENT STATE)) (STORAGE-OF P STATE)))
Which simplifies
 with invocation of STORAGE-OF, ADD-TO-STATE-HISTORY, SUBSET, IS-GOOD-STATE
 when rewriting with POWERSET.DEFINITION, SEQ!IN-MEMBERS, SEQ!IN-SEQUENCE-OF
 forward chaining using SEQ!TACK-HEAD-TAIL, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK,
SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-HISTORY-IS-STATE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
STORAGE-OF-ADD-TO-STATE-SEEN-MESSAGES
Beginning proof of STORAGE-OF-ADD-TO-STATE-SEEN-MESSAGES ...
(IMPLIES (IS-GOOD-STATE STATE)
 (= (STORAGE-OF P (ADD-TO-STATE-SEEN-MESSAGES M STATE)) (STORAGE-OF P STATE)))
Which simplifies
 with invocation of STORAGE-OF, ADD-TO-STATE-SEEN-MESSAGES, SUBSET,
IS-GOOD-STATE
 when rewriting with POWERSET.DEFINITION, SEQ!IN-MEMBERS, SEQ!IN-SEQUENCE-OF
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
KNOWN-BY-PRINCIPAL
FORGEABLE
SEND-STEP
SEND-STEP-PRESERVES-GOOD-STATE
Beginning proof of SEND-STEP-PRESERVES-GOOD-STATE ...
(= (IS-GOOD-STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (IS-GOOD-STATE STATE))
Splitting on (IS-GOOD-STATE STATE) generates ...
(IF (IS-GOOD-STATE STATE)
 (= (IS-GOOD-STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IS-GOOD-STATE STATE))
 (= (IS-GOOD-STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IS-GOOD-STATE STATE)))
Invoking SEND-STEP gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (MS!KNOWN-IN MESSAGE
      (UNION (STORAGE-OF PRINCIPAL STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (MS!KNOWN-IN MESSAGE
      (UNION (STORAGE-OF PRINCIPAL STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE)))
Which simplifies
 when rewriting with IS-GOOD-STATE-ADD-TO-STATE-SEEN-MESSAGES,
SUBSET.NULLSET.LEFT, SETRULES!SUBSET-SETADD,
IS-GOOD-STATE-ADD-TO-STATE-HISTORY, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT,
MAKE-SEND-EVENT-IS-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
RECEIVE-STEP
RECEIVE-STEP-PRESERVES-GOOD-STATE
Beginning proof of RECEIVE-STEP-PRESERVES-GOOD-STATE ...
(= (IS-GOOD-STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (IS-GOOD-STATE STATE))
Splitting on (IS-GOOD-STATE STATE) generates ...
(IF (IS-GOOD-STATE STATE)
 (= (IS-GOOD-STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IS-GOOD-STATE STATE))
 (= (IS-GOOD-STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IS-GOOD-STATE STATE)))
Invoking RECEIVE-STEP gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE)))
Invoking FORGEABLE gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (MS!KNOWN-IN MESSAGE
      (UNION (SEEN-MESSAGES STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (MS!KNOWN-IN MESSAGE
      (UNION (SEEN-MESSAGES STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE)))
Which simplifies
 when rewriting with IS-GOOD-STATE-ADD-TO-STATE-STORAGE, SUBSET.NULLSET.LEFT,
SETRULES!SUBSET-SETADD, IS-GOOD-STATE-ADD-TO-STATE-HISTORY, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
OUT-OF-BAND-STEP
OUT-OF-BAND-STEP-PRESERVES-GOOD-STATE
Beginning proof of OUT-OF-BAND-STEP-PRESERVES-GOOD-STATE ...
(= (IS-GOOD-STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))
 (IS-GOOD-STATE STATE))
Splitting on (IS-GOOD-STATE STATE) generates ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))
  (IS-GOOD-STATE STATE)))
Invoking OUT-OF-BAND-STEP gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
    STATE))
  (IS-GOOD-STATE STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (MS!KNOWN-IN MESSAGE
      (UNION (STORAGE-OF SENDER STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (MS!KNOWN-IN MESSAGE
      (UNION (STORAGE-OF SENDER STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
    STATE))
  (IS-GOOD-STATE STATE)))
Which simplifies
 when rewriting with IS-GOOD-STATE-ADD-TO-STATE-STORAGE, SUBSET.NULLSET.LEFT,
SETRULES!SUBSET-SETADD, IS-GOOD-STATE-ADD-TO-STATE-HISTORY, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
GENERATE-STEP
GENERATE-STEP-PRESERVES-GOOD-STATE
Beginning proof of GENERATE-STEP-PRESERVES-GOOD-STATE ...
(= (IS-GOOD-STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (IS-GOOD-STATE STATE))
Splitting on (IS-GOOD-STATE STATE) generates ...
(IF (IS-GOOD-STATE STATE)
 (= (IS-GOOD-STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IS-GOOD-STATE STATE))
 (= (IS-GOOD-STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IS-GOOD-STATE STATE)))
Invoking GENERATE-STEP gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
     (IN PRINCIPAL (MS!PRINCIPALS)))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
     (IN PRINCIPAL (MS!PRINCIPALS)))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IS-GOOD-STATE STATE)))
Which simplifies
 when rewriting with IS-GOOD-STATE-ADD-TO-STATE-STORAGE, SUBSET.NULLSET.LEFT,
SETRULES!SUBSET-SETADD, IS-GOOD-STATE-ADD-TO-STATE-HISTORY,
MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
CONSTRUCT-STEP
CONSTRUCT-STEP-PRESERVES-GOOD-STATE
Beginning proof of CONSTRUCT-STEP-PRESERVES-GOOD-STATE ...
(= (IS-GOOD-STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (IS-GOOD-STATE STATE))
Splitting on (IS-GOOD-STATE STATE) generates ...
(IF (IS-GOOD-STATE STATE)
 (= (IS-GOOD-STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IS-GOOD-STATE STATE))
 (= (IS-GOOD-STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IS-GOOD-STATE STATE)))
Invoking CONSTRUCT-STEP gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
    (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE)
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
    (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE)
    STATE))
  (IS-GOOD-STATE STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (MS!KNOWN-IN MESSAGE
      (UNION (STORAGE-OF PRINCIPAL STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
    (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE)
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (MS!KNOWN-IN MESSAGE
      (UNION (STORAGE-OF PRINCIPAL STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
    (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE)
    STATE))
  (IS-GOOD-STATE STATE)))
Which simplifies
 when rewriting with IS-GOOD-STATE-ADD-TO-STATE-HISTORY, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, MAKE-CONSTRUCT-EVENT-IS-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
INTRUDER-STEP
INTRUDER-STEP-PRESERVES-GOOD-STATE
Beginning proof of INTRUDER-STEP-PRESERVES-GOOD-STATE ...
(= (IS-GOOD-STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE))
 (IS-GOOD-STATE STATE))
Splitting on (IS-GOOD-STATE STATE) generates ...
(IF (IS-GOOD-STATE STATE)
 (= (IS-GOOD-STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE))
  (IS-GOOD-STATE STATE))
 (= (IS-GOOD-STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE))
  (IS-GOOD-STATE STATE)))
Invoking INTRUDER-STEP gives ...
(IF (IS-GOOD-STATE STATE)
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) STATE))
    STATE))
  (IS-GOOD-STATE STATE))
 (=
  (IS-GOOD-STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) STATE))
    STATE))
  (IS-GOOD-STATE STATE)))
Which simplifies
 when rewriting with IS-GOOD-STATE-ADD-TO-STATE-SEEN-MESSAGES,
SUBSET.NULLSET.LEFT, SETRULES!SUBSET-SETADD,
IS-GOOD-STATE-ADD-TO-STATE-HISTORY, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
GOOD-STEP
IS-GOOD-EVOLUTION-STATE
Beginning proof of IS-GOOD-EVOLUTION-STATE ...
(IF (SEQ!EMPTYP (HISTORY STATE)) (TRUE)
 (ALL (PREVIOUS-STATE)
  (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (M< (SEQ!LENGTH (HISTORY PREVIOUS-STATE)) (SEQ!LENGTH (HISTORY STATE)))
   (TRUE))))
Which simplifies
 with invocation of SEQ!LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE, SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
Beginning proof of IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE ...
(IMPLIES (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-STATE STATE))
Inducting using the following scheme ...
 (AND (IMPLIES (SEQ!EMPTYP (HISTORY STATE)) (*P* STATE))
  (IMPLIES
   (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
    (ALL (PREVIOUS-STATE)
     (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
      (*P* PREVIOUS-STATE) (TRUE))))
   (*P* STATE)))
 produces ...
(AND
 (IMPLIES (SEQ!EMPTYP (HISTORY STATE))
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-STATE STATE)))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
   (ALL (PREVIOUS-STATE)
    (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IMPLIES (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (IS-GOOD-STATE PREVIOUS-STATE))
     (TRUE))))
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-STATE STATE))))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(AND
 (IMPLIES
  (AND (SEQ!EMPTYP (HISTORY STATE))
   (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
    (SOME (PREVIOUS-STATE)
     (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (GOOD-STEP PREVIOUS-STATE STATE)))))
  (IS-GOOD-STATE STATE))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
   (ALL (PREVIOUS-STATE$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
     (IS-GOOD-STATE PREVIOUS-STATE$0)))
   (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
    (SOME (PREVIOUS-STATE$1)
     (AND (= (HISTORY PREVIOUS-STATE$1) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$1)
      (GOOD-STEP PREVIOUS-STATE$1 STATE)))))
  (IS-GOOD-STATE STATE)))
Which simplifies
 when rewriting with SEQ!EMPTYP-DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
    (IS-GOOD-STATE PREVIOUS-STATE)))
  (SOME (PREVIOUS-STATE$0)
   (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (GOOD-STEP PREVIOUS-STATE$0 STATE))))
 (IS-GOOD-STATE STATE))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (IS-GOOD-STATE PREVIOUS-STATE$0)))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE))
 (IS-GOOD-STATE STATE))
Instantiating (= PREVIOUS-STATE$0 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
   (IS-GOOD-STATE PREVIOUS-STATE))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (IS-GOOD-STATE PREVIOUS-STATE$0)))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE))
 (IS-GOOD-STATE STATE))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (IS-GOOD-STATE PREVIOUS-STATE$0)))
  (GOOD-STEP PREVIOUS-STATE STATE))
 (IS-GOOD-STATE STATE))
Invoking (GOOD-STEP PREVIOUS-STATE STATE) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (IS-GOOD-STATE PREVIOUS-STATE$0)))
  (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= STATE
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= STATE
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= STATE
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= STATE
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))))))
 (IS-GOOD-STATE STATE))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (IS-GOOD-STATE PREVIOUS-STATE$0)))
  (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= STATE
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))))
 (IS-GOOD-STATE STATE))
The conjunctive normal form ...
(AND
 (OR (NOT (SEQ!IS-TACK (HISTORY STATE)))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT
   (ALL (PREVIOUS-STATE$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
     (IS-GOOD-STATE PREVIOUS-STATE$0))))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (IS-GOOD-STATE STATE))
 (OR (NOT (SEQ!IS-TACK (HISTORY STATE)))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT
   (ALL (PREVIOUS-STATE$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
     (IS-GOOD-STATE PREVIOUS-STATE$0))))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (IS-GOOD-STATE STATE))
 (OR (NOT (SEQ!IS-TACK (HISTORY STATE)))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT
   (ALL (PREVIOUS-STATE$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
     (IS-GOOD-STATE PREVIOUS-STATE$0))))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IS-GOOD-STATE STATE))
 (OR (NOT (SEQ!IS-TACK (HISTORY STATE)))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT
   (ALL (PREVIOUS-STATE$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
     (IS-GOOD-STATE PREVIOUS-STATE$0))))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (IS-GOOD-STATE STATE))
 (OR (NOT (SEQ!IS-TACK (HISTORY STATE)))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT
   (ALL (PREVIOUS-STATE$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
     (IS-GOOD-STATE PREVIOUS-STATE$0))))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (IS-GOOD-STATE STATE))
 (OR (NOT (SEQ!IS-TACK (HISTORY STATE)))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT
   (ALL (PREVIOUS-STATE$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
     (IS-GOOD-STATE PREVIOUS-STATE$0))))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (IS-GOOD-STATE STATE)))
Substituting (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= STATE
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= STATE
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= STATE
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= STATE
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (ALL (PREVIOUS-STATE$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
     (IS-GOOD-STATE PREVIOUS-STATE$0)))
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (IS-GOOD-STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
 (IMPLIES
  (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (ALL (PREVIOUS-STATE$1)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$1) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$1))
     (IS-GOOD-STATE PREVIOUS-STATE$1)))
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (IS-GOOD-STATE
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
 (IMPLIES
  (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (ALL (PREVIOUS-STATE$2)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$2) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$2))
     (IS-GOOD-STATE PREVIOUS-STATE$2)))
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IS-GOOD-STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
 (IMPLIES
  (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (ALL (PREVIOUS-STATE$3)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$3) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$3))
     (IS-GOOD-STATE PREVIOUS-STATE$3)))
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (IS-GOOD-STATE
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
 (IMPLIES
  (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (ALL (PREVIOUS-STATE$4)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$4) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$4))
     (IS-GOOD-STATE PREVIOUS-STATE$4)))
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (IS-GOOD-STATE
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
 (IMPLIES
  (AND (SEQ!IS-TACK (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (ALL (PREVIOUS-STATE$5)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$5) (SEQ!TAIL (HISTORY STATE)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$5))
     (IS-GOOD-STATE PREVIOUS-STATE$5)))
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (IS-GOOD-STATE
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
Which simplifies
 when rewriting with OUT-OF-BAND-STEP-PRESERVES-GOOD-STATE,
CONSTRUCT-STEP-PRESERVES-GOOD-STATE, RECEIVE-STEP-PRESERVES-GOOD-STATE,
SEND-STEP-PRESERVES-GOOD-STATE, GENERATE-STEP-PRESERVES-GOOD-STATE,
INTRUDER-STEP-PRESERVES-GOOD-STATE, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
GOOD-STEP-IMPLIES-GOOD-STATES
Beginning proof of GOOD-STEP-IMPLIES-GOOD-STATES ...
(IMPLIES (GOOD-STEP S0 S1) (AND (IS-GOOD-STATE S0) (IS-GOOD-STATE S1)))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S0)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0)
       (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0)
       (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)
       (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0)
       (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
      (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0)))))))
 (AND (IS-GOOD-STATE S0) (IS-GOOD-STATE S1)))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0)
    (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0)
    (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)
    (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0)
    (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
    (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0)))))
 (AND (IS-GOOD-STATE S0) (IS-GOOD-STATE S1)))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0)))
  (NOT (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0))) (IS-GOOD-STATE S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
  (IS-GOOD-STATE S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0))
  (NOT (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0))) (IS-GOOD-STATE S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE S0))
  (NOT (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
  (IS-GOOD-STATE S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0))
  (NOT (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
  (IS-GOOD-STATE S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0))
  (NOT (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0)))
  (IS-GOOD-STATE S1)))
Substituting (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0))
             (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0))
             (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0))
             (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0))
             (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0))
             (= S1
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               S0)) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
   (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0)))
  (IS-GOOD-STATE (INTRUDER-STEP LABEL TIME MESSAGE S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
  (IS-GOOD-STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0)
   (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)))
  (IS-GOOD-STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0)
   (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
  (IS-GOOD-STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0)
   (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
  (IS-GOOD-STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)
   (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0)))
  (IS-GOOD-STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0))))
Which simplifies
 when rewriting with OUT-OF-BAND-STEP-PRESERVES-GOOD-STATE,
CONSTRUCT-STEP-PRESERVES-GOOD-STATE, RECEIVE-STEP-PRESERVES-GOOD-STATE,
SEND-STEP-PRESERVES-GOOD-STATE, GENERATE-STEP-PRESERVES-GOOD-STATE,
INTRUDER-STEP-PRESERVES-GOOD-STATE, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
SEEN-MESSAGES-SEND-STEP
Beginning proof of SEEN-MESSAGES-SEND-STEP ...
(= (SEEN-MESSAGES (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
  (SETADD MESSAGE (SEEN-MESSAGES STATE)) (SEEN-MESSAGES STATE)))
Invoking SEND-STEP gives ...
(=
 (SEEN-MESSAGES
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE))
   STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
  (SETADD MESSAGE (SEEN-MESSAGES STATE)) (SEEN-MESSAGES STATE)))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
STORAGE-OF-SEND-STEP
Beginning proof of STORAGE-OF-SEND-STEP ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (= (STORAGE-OF P (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (STORAGE-OF P STATE)))
Invoking SEND-STEP gives ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (=
  (STORAGE-OF P
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (STORAGE-OF P STATE)))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
 (=
  (STORAGE-OF P
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE)))
  (STORAGE-OF P STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (=
  (STORAGE-OF P
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE)))
  (STORAGE-OF P STATE)))
Which simplifies
 when rewriting with STORAGE-OF-ADD-TO-STATE-HISTORY,
STORAGE-OF-ADD-TO-STATE-SEEN-MESSAGES, IS-GOOD-STATE-ADD-TO-STATE-HISTORY,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT,
MAKE-SEND-EVENT-IS-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
HISTORY-OF-SEND-STEP
Beginning proof of HISTORY-OF-SEND-STEP ...
(= (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
  (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) (HISTORY STATE))
  (HISTORY STATE)))
Invoking SEND-STEP gives ...
(=
 (HISTORY
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE))
   STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
  (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) (HISTORY STATE))
  (HISTORY STATE)))
Which simplifies
 when rewriting with HISTORY-OF-ADD-TO-STATE-HISTORY,
HISTORY-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using SEQ!TACK-HEAD-TAIL, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
SEEN-MESSAGES-RECEIVE-STEP
Beginning proof of SEEN-MESSAGES-RECEIVE-STEP ...
(= (SEEN-MESSAGES (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (SEEN-MESSAGES STATE))
Invoking RECEIVE-STEP gives ...
(=
 (SEEN-MESSAGES
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
   (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE))
   STATE))
 (SEEN-MESSAGES STATE))
Which simplifies
 when rewriting with SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEEN-MESSAGES-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
STORAGE-OF-RECEIVE-STEP
Beginning proof of STORAGE-OF-RECEIVE-STEP ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (= (STORAGE-OF P (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE) (= P PRINCIPAL))
   (SETADD MESSAGE (STORAGE-OF P STATE)) (STORAGE-OF P STATE))))
Invoking RECEIVE-STEP gives ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (=
  (STORAGE-OF P
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE) (= P PRINCIPAL))
   (SETADD MESSAGE (STORAGE-OF P STATE)) (STORAGE-OF P STATE))))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (FORGEABLE MESSAGE STATE))
 (IF (= P PRINCIPAL)
  (=
   (STORAGE-OF P
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE)))
   (SETADD MESSAGE (STORAGE-OF P STATE)))
  (=
   (STORAGE-OF P
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE)))
   (STORAGE-OF P STATE))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (IF (= P PRINCIPAL)
  (=
   (STORAGE-OF P
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE)))
   (SETADD MESSAGE (STORAGE-OF P STATE)))
  (=
   (STORAGE-OF P
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE)))
   (STORAGE-OF P STATE))))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, STORAGE-OF-ADD-TO-STATE-HISTORY,
STORAGE-OF-ADD-TO-STATE-STORAGE, IS-GOOD-STATE-ADD-TO-STATE-HISTORY,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
HISTORY-OF-RECEIVE-STEP
Beginning proof of HISTORY-OF-RECEIVE-STEP ...
(= (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
  (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) (HISTORY STATE))
  (HISTORY STATE)))
Invoking RECEIVE-STEP gives ...
(=
 (HISTORY
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
   (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE))
   STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
  (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) (HISTORY STATE))
  (HISTORY STATE)))
Which simplifies
 when rewriting with HISTORY-OF-ADD-TO-STATE-HISTORY,
HISTORY-OF-ADD-TO-STATE-STORAGE
 forward chaining using SEQ!TACK-HEAD-TAIL, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
SEEN-MESSAGES-OUT-OF-BAND-STEP
Beginning proof of SEEN-MESSAGES-OUT-OF-BAND-STEP ...
(= (SEEN-MESSAGES (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))
 (SEEN-MESSAGES STATE))
Invoking OUT-OF-BAND-STEP gives ...
(=
 (SEEN-MESSAGES
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
   STATE))
 (SEEN-MESSAGES STATE))
Which simplifies
 when rewriting with SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEEN-MESSAGES-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
STORAGE-OF-OUT-OF-BAND-STEP
Beginning proof of STORAGE-OF-OUT-OF-BAND-STEP ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (= (STORAGE-OF P (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE) (= P RECEIVER))
   (SETADD MESSAGE (STORAGE-OF P STATE)) (STORAGE-OF P STATE))))
Invoking OUT-OF-BAND-STEP gives ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (=
  (STORAGE-OF P
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
    STATE))
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE) (= P RECEIVER))
   (SETADD MESSAGE (STORAGE-OF P STATE)) (STORAGE-OF P STATE))))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN SENDER (MS!PRINCIPALS))
  (IN RECEIVER (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
 (IF (= P RECEIVER)
  (=
   (STORAGE-OF P
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE)))
   (SETADD MESSAGE (STORAGE-OF P STATE)))
  (=
   (STORAGE-OF P
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE)))
   (STORAGE-OF P STATE))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN SENDER (MS!PRINCIPALS))
  (IN RECEIVER (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF SENDER STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (IF (= P RECEIVER)
  (=
   (STORAGE-OF P
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE)))
   (SETADD MESSAGE (STORAGE-OF P STATE)))
  (=
   (STORAGE-OF P
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE)))
   (STORAGE-OF P STATE))))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, STORAGE-OF-ADD-TO-STATE-HISTORY,
STORAGE-OF-ADD-TO-STATE-STORAGE, IS-GOOD-STATE-ADD-TO-STATE-HISTORY,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
HISTORY-OF-OUT-OF-BAND-STEP
Beginning proof of HISTORY-OF-OUT-OF-BAND-STEP ...
(= (HISTORY (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
  (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
   (HISTORY STATE))
  (HISTORY STATE)))
Invoking OUT-OF-BAND-STEP gives ...
(=
 (HISTORY
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
   STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
  (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
   (HISTORY STATE))
  (HISTORY STATE)))
Which simplifies
 when rewriting with HISTORY-OF-ADD-TO-STATE-HISTORY,
HISTORY-OF-ADD-TO-STATE-STORAGE
 forward chaining using SEQ!TACK-HEAD-TAIL, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
SEEN-MESSAGES-GENERATE-STEP
Beginning proof of SEEN-MESSAGES-GENERATE-STEP ...
(= (SEEN-MESSAGES (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (SEEN-MESSAGES STATE))
Invoking GENERATE-STEP gives ...
(=
 (SEEN-MESSAGES
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
    (IN PRINCIPAL (MS!PRINCIPALS)))
   (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE))
   STATE))
 (SEEN-MESSAGES STATE))
Which simplifies
 when rewriting with SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEEN-MESSAGES-OF-ADD-TO-STATE-STORAGE, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
STORAGE-OF-GENERATE-STEP
Beginning proof of STORAGE-OF-GENERATE-STEP ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (= (STORAGE-OF P (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
    (IN PRINCIPAL (MS!PRINCIPALS)) (= P PRINCIPAL))
   (SETADD MESSAGE (STORAGE-OF P STATE)) (STORAGE-OF P STATE))))
Invoking GENERATE-STEP gives ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (=
  (STORAGE-OF P
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
     (IN PRINCIPAL (MS!PRINCIPALS)))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE))
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
    (IN PRINCIPAL (MS!PRINCIPALS)) (= P PRINCIPAL))
   (SETADD MESSAGE (STORAGE-OF P STATE)) (STORAGE-OF P STATE))))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, STORAGE-OF-ADD-TO-STATE-HISTORY,
STORAGE-OF-ADD-TO-STATE-STORAGE, IS-GOOD-STATE-ADD-TO-STATE-HISTORY,
MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
HISTORY-OF-GENERATE-STEP
Beginning proof of HISTORY-OF-GENERATE-STEP ...
(= (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
   (IN PRINCIPAL (MS!PRINCIPALS)))
  (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
   (HISTORY STATE))
  (HISTORY STATE)))
Invoking GENERATE-STEP gives ...
(=
 (HISTORY
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
    (IN PRINCIPAL (MS!PRINCIPALS)))
   (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE))
   STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
   (IN PRINCIPAL (MS!PRINCIPALS)))
  (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
   (HISTORY STATE))
  (HISTORY STATE)))
Which simplifies
 when rewriting with HISTORY-OF-ADD-TO-STATE-HISTORY,
HISTORY-OF-ADD-TO-STATE-STORAGE, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using SEQ!TACK-HEAD-TAIL, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
SEEN-MESSAGES-CONSTRUCT-STEP
Beginning proof of SEEN-MESSAGES-CONSTRUCT-STEP ...
(= (SEEN-MESSAGES (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (SEEN-MESSAGES STATE))
Invoking CONSTRUCT-STEP gives ...
(=
 (SEEN-MESSAGES
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
    STATE)
   STATE))
 (SEEN-MESSAGES STATE))
Which simplifies
 when rewriting with SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
STORAGE-OF-CONSTRUCT-STEP
Beginning proof of STORAGE-OF-CONSTRUCT-STEP ...
(= (STORAGE-OF P (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (STORAGE-OF P STATE))
Invoking CONSTRUCT-STEP gives ...
(=
 (STORAGE-OF P
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
    STATE)
   STATE))
 (STORAGE-OF P STATE))
Which simplifies
 when rewriting with STORAGE-OF-ADD-TO-STATE-HISTORY
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
HISTORY-OF-CONSTRUCT-STEP
Beginning proof of HISTORY-OF-CONSTRUCT-STEP ...
(= (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
  (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
   (HISTORY STATE))
  (HISTORY STATE)))
Invoking CONSTRUCT-STEP gives ...
(=
 (HISTORY
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
    STATE)
   STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
  (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
   (HISTORY STATE))
  (HISTORY STATE)))
Which simplifies
 when rewriting with HISTORY-OF-ADD-TO-STATE-HISTORY
 forward chaining using SEQ!TACK-HEAD-TAIL, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
SEEN-MESSAGES-INTRUDER-STEP
Beginning proof of SEEN-MESSAGES-INTRUDER-STEP ...
(= (SEEN-MESSAGES (INTRUDER-STEP LABEL TIME MESSAGE STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
  (SETADD MESSAGE (SEEN-MESSAGES STATE)) (SEEN-MESSAGES STATE)))
Invoking INTRUDER-STEP gives ...
(=
 (SEEN-MESSAGES
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) STATE))
   STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
  (SETADD MESSAGE (SEEN-MESSAGES STATE)) (SEEN-MESSAGES STATE)))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
STORAGE-OF-INTRUDER-STEP
Beginning proof of STORAGE-OF-INTRUDER-STEP ...
(= (STORAGE-OF P (INTRUDER-STEP LABEL TIME MESSAGE STATE))
 (STORAGE-OF P STATE))
Invoking INTRUDER-STEP gives ...
(=
 (STORAGE-OF P
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) STATE))
   STATE))
 (STORAGE-OF P STATE))
Which simplifies
 when rewriting with STORAGE-OF-ADD-TO-STATE-HISTORY,
STORAGE-OF-ADD-TO-STATE-SEEN-MESSAGES, IS-GOOD-STATE-ADD-TO-STATE-HISTORY,
MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
HISTORY-OF-INTRUDER-STEP
Beginning proof of HISTORY-OF-INTRUDER-STEP ...
(= (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
  (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) (HISTORY STATE))
  (HISTORY STATE)))
Invoking INTRUDER-STEP gives ...
(=
 (HISTORY
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) STATE))
   STATE))
 (IF
  (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
  (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) (HISTORY STATE))
  (HISTORY STATE)))
Which simplifies
 when rewriting with HISTORY-OF-ADD-TO-STATE-HISTORY,
HISTORY-OF-ADD-TO-STATE-SEEN-MESSAGES, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
IS-GOOD-EVOLUTION
Beginning proof of IS-GOOD-EVOLUTION ...
(IF (>= (SEQ!LENGTH SEQUENCE) 2)
 (M< (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (SEQ!LENGTH SEQUENCE)) (TRUE))
Which simplifies
 with invocation of SEQ!LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SUCC.INT, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
TAIL-IS-SEQUENCE
Beginning proof of TAIL-IS-SEQUENCE ...
(IMPLIES (AND (SEQ!IS-SEQUENCE SEQUENCE) (SEQ!IS-TACK SEQUENCE))
 (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE)))
Invoking (SEQ!IS-SEQUENCE SEQUENCE) gives ...
(IMPLIES
 (AND
  (IF (SEQ!IS-TACK SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
   (= SEQUENCE (SEQ!EMPTY)))
  (SEQ!IS-TACK SEQUENCE))
 (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE)))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION
Beginning proof of HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION ...
(IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
 (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (SEQ!TAIL SEQUENCE)))
   (*P* SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
     (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
     (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
   (>= (SEQ!LENGTH SEQUENCE) 2))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
   (>= (SEQ!LENGTH SEQUENCE) 2))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (IMPLIES
   (AND
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
     (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
  (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
   (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
 (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
   (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!HEAD SEQUENCE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE
       (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (= (SEQ!HEAD SEQUENCE)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))))
 (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
   (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!HEAD SEQUENCE)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (= (SEQ!HEAD SEQUENCE)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
Substituting (= (SEQ!HEAD SEQUENCE)
              (INTRUDER-STEP LABEL TIME MESSAGE
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
 (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!HEAD SEQUENCE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE
       (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (= (SEQ!HEAD SEQUENCE)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))))
 (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!HEAD SEQUENCE)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (= (SEQ!HEAD SEQUENCE)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
Substituting (= (SEQ!HEAD SEQUENCE)
              (INTRUDER-STEP LABEL TIME MESSAGE
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
Beginning proof of LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION ...
(IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
 (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) (- (SEQ!LENGTH SEQUENCE) 1)))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (SEQ!TAIL SEQUENCE)))
   (*P* SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1))))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE)))
    (- (SEQ!LENGTH SEQUENCE) 1))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE)))
    (- (SEQ!LENGTH SEQUENCE) 1)))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
  (IS-GOOD-EVOLUTION SEQUENCE))
 (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) (- (SEQ!LENGTH SEQUENCE) 1)))
Rearranging gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1))))
 (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) (- (SEQ!LENGTH SEQUENCE) 1)))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE))
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE)))
    (+ -1 (SEQ!LENGTH SEQUENCE))))
  (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 (SEQ!LENGTH SEQUENCE)))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE)))
    (+ -1 (SEQ!LENGTH SEQUENCE))))
  (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 (SEQ!LENGTH SEQUENCE)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 (SEQ!LENGTH SEQUENCE))))
Invoking (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (=
  (IF (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
   (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))) 0)
  (+ -1 (SEQ!LENGTH SEQUENCE))))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (AND (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (+ -1 (SEQ!LENGTH SEQUENCE)))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (AND (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (+ -1
    (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (AND (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!HEAD SEQUENCE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE
       (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (= (SEQ!HEAD SEQUENCE)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
  (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (AND (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!HEAD SEQUENCE)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (= (SEQ!HEAD SEQUENCE)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (AND (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
The conjunctive normal form ...
(AND
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (OR (NOT (SEQ!IS-TACK SEQUENCE))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (= (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
Substituting (= (SEQ!HEAD SEQUENCE)
              (INTRUDER-STEP LABEL TIME MESSAGE
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(AND
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK
   (HISTORY
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK
   (HISTORY
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK
   (HISTORY
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK
   (HISTORY
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK
   (HISTORY
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (SEQ!IS-TACK
   (HISTORY
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (=
   (+ 1
    (SEQ!LENGTH
     (SEQ!TAIL
      (HISTORY
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (=
   (+ 1
    (SEQ!LENGTH
     (SEQ!TAIL
      (HISTORY
       (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
        (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (=
   (+ 1
    (SEQ!LENGTH
     (SEQ!TAIL
      (HISTORY
       (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
        (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (=
   (+ 1
    (SEQ!LENGTH
     (SEQ!TAIL
      (HISTORY
       (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
        (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (=
   (+ 1
    (SEQ!LENGTH
     (SEQ!TAIL
      (HISTORY
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
        (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
 (IMPLIES
  (AND (SEQ!IS-TACK SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (=
   (+ 1
    (SEQ!LENGTH
     (SEQ!TAIL
      (HISTORY
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
        (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE))
 (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) (- (SEQ!LENGTH SEQUENCE) 1)))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
 (= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) (- (SEQ!LENGTH SEQUENCE) 1)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
HEAD-OF-GOOD-EVOLUTION
Beginning proof of HEAD-OF-GOOD-EVOLUTION ...
(IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
 (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (SEQ!TAIL SEQUENCE)))
   (*P* SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IF (>= (SEQ!LENGTH SEQUENCE) 2)
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
   (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))))
Invoking (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)) gives ...
(IF (>= (SEQ!LENGTH SEQUENCE) 2)
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
  (IF (SEQ!EMPTYP (HISTORY (SEQ!HEAD SEQUENCE)))
   (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE (SEQ!HEAD SEQUENCE))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
   (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))
  (IF (SEQ!EMPTYP (HISTORY (SEQ!HEAD SEQUENCE)))
   (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
   (SOME (PREVIOUS-STATE$0)
    (AND
     (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (GOOD-STEP PREVIOUS-STATE$0 (SEQ!HEAD SEQUENCE)))))))
Which simplifies
 when rewriting with SEQ!EMPTYP-DEFINITION
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
TAIL-IS-SEQUENCE, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (PREVIOUS-STATE)
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (GOOD-STEP PREVIOUS-STATE (SEQ!HEAD SEQUENCE)))))
Instantiating (= PREVIOUS-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT
   (AND
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
     (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))))
 (SOME (PREVIOUS-STATE)
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (GOOD-STEP PREVIOUS-STATE (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAIL-IS-SEQUENCE, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
 (SOME (PREVIOUS-STATE)
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (GOOD-STEP PREVIOUS-STATE (SEQ!HEAD SEQUENCE)))))
Applying HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT
   (=
    (IF (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
     (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
 (SOME (PREVIOUS-STATE)
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (GOOD-STEP PREVIOUS-STATE (SEQ!HEAD SEQUENCE)))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT
   (=
    (IF
     (AND
      (IF (>= (SEQ!LENGTH SEQUENCE) 2)
       (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
        (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
       (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
        (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
        (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
      (>= (SEQ!LENGTH SEQUENCE) 2))
     (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
 (SOME (PREVIOUS-STATE)
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (GOOD-STEP PREVIOUS-STATE (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAIL-IS-SEQUENCE, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
IS-GOOD-EVOLUTION-TAIL
Beginning proof of IS-GOOD-EVOLUTION-TAIL ...
(IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE))
 (= (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (TRUE)))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
 (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
IS-INITIAL-EVOLUTION-STATE
HEAD-OF-EVOLUTION-IN-EVOLUTION
Beginning proof of HEAD-OF-EVOLUTION-IN-EVOLUTION ...
(IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
 (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) SEQUENCE))
Invoking IS-GOOD-EVOLUTION gives ...
(IMPLIES
 (IF (>= (SEQ!LENGTH SEQUENCE) 2)
  (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
  (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
   (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
 (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) SEQUENCE))
Invoking SEQ!IS-MEMBER gives ...
(IMPLIES
 (IF (>= (SEQ!LENGTH SEQUENCE) 2)
  (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
  (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
   (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
 (AND (SEQ!IS-TACK SEQUENCE)
  (OR (= (SEQ!HEAD SEQUENCE) (SEQ!HEAD SEQUENCE))
   (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
GOOD-EVOLUTION-IS-SEQUENCE
Beginning proof of GOOD-EVOLUTION-IS-SEQUENCE ...
(IMPLIES (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE SEQUENCE))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (SEQ!TAIL SEQUENCE)))
   (*P* SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE SEQUENCE)))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE SEQUENCE))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE)) (IS-GOOD-EVOLUTION SEQUENCE))
   (SEQ!IS-SEQUENCE SEQUENCE))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE SEQUENCE)))
 (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE SEQUENCE)))
Starting case 2 ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE)) (IS-GOOD-EVOLUTION SEQUENCE))
   (SEQ!IS-SEQUENCE SEQUENCE))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE SEQUENCE))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE)) (IS-GOOD-EVOLUTION SEQUENCE))
 (SEQ!IS-SEQUENCE SEQUENCE))
Invoking (SEQ!IS-SEQUENCE SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE)) (IS-GOOD-EVOLUTION SEQUENCE))
 (IF (SEQ!IS-TACK SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (= SEQUENCE (SEQ!EMPTY))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (IS-GOOD-EVOLUTION SEQUENCE))
 (SEQ!IS-SEQUENCE SEQUENCE))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
 (SEQ!IS-SEQUENCE SEQUENCE))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE))
 (SEQ!IS-SEQUENCE SEQUENCE))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
 (SEQ!IS-SEQUENCE SEQUENCE))
Invoking (SEQ!IS-SEQUENCE SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
 (IF (SEQ!IS-TACK SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (= SEQUENCE (SEQ!EMPTY))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
STATE-IS-GOOD-EVOLUTION-STATE
Beginning proof of STATE-IS-GOOD-EVOLUTION-STATE ...
(IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (IS-GOOD-EVOLUTION-STATE STATE))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (SEQ!TAIL SEQUENCE) STATE))
   (*P* SEQUENCE STATE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* SEQUENCE STATE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
    (IS-GOOD-EVOLUTION-STATE STATE)))
  (IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
   (IS-GOOD-EVOLUTION-STATE STATE)))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
   (IS-GOOD-EVOLUTION-STATE STATE))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
   (IS-GOOD-EVOLUTION-STATE STATE))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (IS-GOOD-EVOLUTION-STATE STATE))
Rearranging gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
   (IS-GOOD-EVOLUTION-STATE STATE)))
 (IS-GOOD-EVOLUTION-STATE STATE))
Which simplifies
 when rewriting with IS-GOOD-EVOLUTION-TAIL
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))))
 (IS-GOOD-EVOLUTION-STATE STATE))
Invoking (SEQ!IS-MEMBER STATE SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-TACK SEQUENCE)
  (OR (= STATE (SEQ!HEAD SEQUENCE)) (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (NOT (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))))
 (IS-GOOD-EVOLUTION-STATE STATE))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE))
 (IS-GOOD-EVOLUTION-STATE STATE))
Invoking (SEQ!IS-MEMBER STATE SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-TACK SEQUENCE)
  (OR (= STATE (SEQ!HEAD SEQUENCE))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))))
 (IS-GOOD-EVOLUTION-STATE STATE))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions TAIL-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-TACK SEQUENCE) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
 (IS-GOOD-EVOLUTION-STATE STATE))
Splitting on (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) generates ...
(IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
   (SEQ!IS-TACK SEQUENCE) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (IS-GOOD-EVOLUTION-STATE STATE))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
   (SEQ!IS-TACK SEQUENCE) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (IS-GOOD-EVOLUTION-STATE STATE)))
Starting case 1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-TACK SEQUENCE) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
 (IS-GOOD-EVOLUTION-STATE STATE))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)
  (NOT
   (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
    2))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-TACK SEQUENCE)
  (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
 (IS-GOOD-EVOLUTION-STATE STATE))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
>=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-TACK SEQUENCE) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
 (IS-GOOD-EVOLUTION-STATE STATE))
Invoking (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-TACK SEQUENCE) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-TACK (SEQ!TAIL SEQUENCE))
  (OR (= STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL (SEQ!TAIL SEQUENCE)))))
 (IS-GOOD-EVOLUTION-STATE STATE))
Invoking (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) gives ...
(IMPLIES
 (AND
  (NOT
   (>=
    (IF (SEQ!IS-TACK (SEQ!TAIL SEQUENCE))
     (+ 1 (SEQ!LENGTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)))) 0)
    1))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-TACK SEQUENCE) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-TACK (SEQ!TAIL SEQUENCE))
  (OR (= STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL (SEQ!TAIL SEQUENCE)))))
 (IS-GOOD-EVOLUTION-STATE STATE))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAIL-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
NON-INITIAL-STATE-HAS-NON-EMPTY-HISTORY
Beginning proof of NON-INITIAL-STATE-HAS-NON-EMPTY-HISTORY ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (IS-INITIAL-EVOLUTION-STATE STATE)))
 (>= (SEQ!LENGTH (HISTORY STATE)) 1))
Invoking IS-INITIAL-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
 (>= (SEQ!LENGTH (HISTORY STATE)) 1))
Invoking (SEQ!LENGTH (HISTORY STATE)) gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
 (>=
  (IF (SEQ!IS-TACK (HISTORY STATE))
   (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
  1))
Which simplifies
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK,
SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
 (SEQ!IS-TACK (HISTORY STATE)))
Splitting on (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS))) generates ...
(IF (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
  (SEQ!IS-TACK (HISTORY STATE)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
  (SEQ!IS-TACK (HISTORY STATE))))
Starting case 2 ...
(IMPLIES
 (AND (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
 (SEQ!IS-TACK (HISTORY STATE)))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS))))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
 (SEQ!IS-TACK (HISTORY STATE)))
Splitting on (IS-GOOD-EVOLUTION-STATE STATE) generates ...
(IF (IS-GOOD-EVOLUTION-STATE STATE)
 (IMPLIES
  (AND (NOT (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS))))
   (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
  (SEQ!IS-TACK (HISTORY STATE)))
 (IMPLIES
  (AND (NOT (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS))))
   (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
  (SEQ!IS-TACK (HISTORY STATE))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY to ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION-STATE STATE))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE))
 (SEQ!IS-TACK (HISTORY STATE)))
Splitting
on (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)) generates
...
(IF (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (IMPLIES
  (AND (NOT (IS-GOOD-EVOLUTION-STATE STATE))
   (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION SEQUENCE)
   (SEQ!IS-MEMBER STATE SEQUENCE))
  (SEQ!IS-TACK (HISTORY STATE)))
 (IMPLIES
  (AND (NOT (IS-GOOD-EVOLUTION-STATE STATE))
   (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION SEQUENCE)
   (SEQ!IS-MEMBER STATE SEQUENCE))
  (SEQ!IS-TACK (HISTORY STATE))))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION-STATE STATE))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE))
 (SEQ!IS-TACK (HISTORY STATE)))
Assuming STATE-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= STATE STATE) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
   (IS-GOOD-EVOLUTION-STATE STATE))
  (NOT (IS-GOOD-EVOLUTION-STATE STATE))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE))
 (SEQ!IS-TACK (HISTORY STATE)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
IS-TACK-EQUIV-NON-ZERO-LENGTH
Beginning proof of IS-TACK-EQUIV-NON-ZERO-LENGTH ...
(= (SEQ!IS-TACK SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1))
Splitting on (>= (SEQ!LENGTH SEQUENCE) 1) generates ...
(IF (>= (SEQ!LENGTH SEQUENCE) 1)
 (= (SEQ!IS-TACK SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1))
 (= (SEQ!IS-TACK SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1)))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(OR (>= (SEQ!LENGTH SEQUENCE) 1) (= (SEQ!IS-TACK SEQUENCE) (FALSE)))
Invoking SEQ!LENGTH gives ...
(OR
 (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
 (= (SEQ!IS-TACK SEQUENCE) (FALSE)))
Which simplifies
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
HISTORY-OF-STATE-IS-SUBSEQUENCE
Beginning proof of HISTORY-OF-STATE-IS-SUBSEQUENCE ...
(IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (SEQ!TAIL SEQUENCE) STATE))
   (*P* SEQUENCE STATE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* SEQUENCE STATE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
    (SOME (S)
     (AND (SEQ!IS-SEQUENCE S)
      (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (SEQ!JOIN S (HISTORY STATE)))))))
  (IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
   (SOME (S)
    (AND (SEQ!IS-SEQUENCE S)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE)))))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
   (SOME (S)
    (AND (SEQ!IS-SEQUENCE S)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))))
The conjunctive normal form ...
(AND
 (OR (>= (SEQ!LENGTH SEQUENCE) 2) (NOT (IS-GOOD-EVOLUTION SEQUENCE))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (SOME (S)
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
 (OR
  (NOT
   (SOME (S)
    (AND (SEQ!IS-SEQUENCE S)
     (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
      (SEQ!JOIN S (HISTORY STATE))))))
  (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (SOME (S)
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
 (OR (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (SOME (S)
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
 (OR (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))
  (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (SOME (S)
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE)))))))
Starting case 4 ...
(OR (>= (SEQ!LENGTH SEQUENCE) 2) (NOT (IS-GOOD-EVOLUTION SEQUENCE))
 (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Instantiating (= S (SEQ!EMPTY)) gives ...
(OR (>= (SEQ!LENGTH SEQUENCE) 2) (NOT (IS-GOOD-EVOLUTION SEQUENCE))
 (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
 (AND (SEQ!IS-SEQUENCE (SEQ!EMPTY))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN (SEQ!EMPTY) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 when rewriting with SEQ!JOIN-EMPTY-LEFT
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (= (SEQ!EMPTY) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Invoking (SEQ!IS-MEMBER STATE SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-TACK SEQUENCE)
  (OR (= STATE (SEQ!HEAD SEQUENCE)) (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (NOT (= (SEQ!EMPTY) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER STATE (SEQ!EMPTY)) (NOT (= (SEQ!EMPTY) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Invoking SEQ!IS-MEMBER gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-TACK (SEQ!EMPTY))
  (OR (= STATE (SEQ!HEAD (SEQ!EMPTY)))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL (SEQ!EMPTY))))
  (NOT (= (SEQ!EMPTY) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 3 ...
(OR
 (NOT
  (SOME (S)
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
     (SEQ!JOIN S (HISTORY STATE))))))
 (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND
  (SOME (S)
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
     (SEQ!JOIN S (HISTORY STATE)))))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
Instantiating (= S$0
               (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))) S)) gives
...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (AND
    (SEQ!IS-SEQUENCE (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))) S))
    (= (HISTORY (SEQ!HEAD SEQUENCE))
     (SEQ!JOIN (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))) S)
      (HISTORY STATE))))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
Which simplifies
 when rewriting with SEQ!JOIN-TACK
 forward chaining using SEQ!TACK-HEAD-TAIL, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (= (HISTORY (SEQ!HEAD SEQUENCE))
    (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
     (SEQ!JOIN S (HISTORY STATE))))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
Substituting (= (SEQ!JOIN S (HISTORY STATE))
              (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (= (HISTORY (SEQ!HEAD SEQUENCE))
    (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
Splitting on (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE))) generates ...
(IF (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (= (HISTORY (SEQ!HEAD SEQUENCE))
     (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (= (HISTORY (SEQ!HEAD SEQUENCE))
     (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$1)
   (AND (SEQ!IS-SEQUENCE S$1)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$1 (HISTORY STATE)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IF (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (= (HISTORY (SEQ!HEAD SEQUENCE))
     (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (= (HISTORY (SEQ!HEAD SEQUENCE))
     (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$1)
   (AND (SEQ!IS-SEQUENCE S$1)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$1 (HISTORY STATE)))))))
Splitting on (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) generates ...
(IF (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
 (IF (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$0)
    (AND (SEQ!IS-SEQUENCE S$0)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$1)
    (AND (SEQ!IS-SEQUENCE S$1)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$1 (HISTORY STATE)))))))
 (IF (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$2)
    (AND (SEQ!IS-SEQUENCE S$2)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$2 (HISTORY STATE))))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$3)
    (AND (SEQ!IS-SEQUENCE S$3)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$3 (HISTORY STATE))))))))
Starting case 3.2 ...
(IMPLIES (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
 (IF (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$0)
    (AND (SEQ!IS-SEQUENCE S$0)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$1)
    (AND (SEQ!IS-SEQUENCE S$1)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$1 (HISTORY STATE))))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
 (IF (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$0)
    (AND (SEQ!IS-SEQUENCE S$0)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$1)
    (AND (SEQ!IS-SEQUENCE S$1)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$1 (HISTORY STATE))))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, SEQ!TACK-HEAD-TAIL,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (= (HISTORY (SEQ!HEAD SEQUENCE))
    (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!HEAD SEQUENCE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE
       (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (= (SEQ!HEAD SEQUENCE)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (= (HISTORY (SEQ!HEAD SEQUENCE))
    (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!HEAD SEQUENCE)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (= (SEQ!HEAD SEQUENCE)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (= (HISTORY (SEQ!HEAD SEQUENCE))
    (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE)))))))
Substituting (= (SEQ!HEAD SEQUENCE)
              (INTRUDER-STEP LABEL TIME MESSAGE
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (=
     (HISTORY
      (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$0 (HISTORY STATE))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$1)
   (AND (SEQ!IS-SEQUENCE S$1)
    (=
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$1 (HISTORY STATE))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$2)
   (AND (SEQ!IS-SEQUENCE S$2)
    (=
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$2 (HISTORY STATE))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$3)
   (AND (SEQ!IS-SEQUENCE S$3)
    (=
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$3 (HISTORY STATE))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$4)
   (AND (SEQ!IS-SEQUENCE S$4)
    (=
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$4 (HISTORY STATE))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1) (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$5)
   (AND (SEQ!IS-SEQUENCE S$5)
    (=
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$5 (HISTORY STATE)))))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 3.1 ...
(IMPLIES (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
 (IF (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$2)
    (AND (SEQ!IS-SEQUENCE S$2)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$2 (HISTORY STATE))))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$3)
    (AND (SEQ!IS-SEQUENCE S$3)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$3 (HISTORY STATE))))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
 (IF (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$0)
    (AND (SEQ!IS-SEQUENCE S$0)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S)
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$1)
    (AND (SEQ!IS-SEQUENCE S$1)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$1 (HISTORY STATE))))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, SEQ!TACK-HEAD-TAIL,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
 (IF (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
    (SEQ!IS-MEMBER STATE SEQUENCE)
    (NOT
     (= (HISTORY (SEQ!HEAD SEQUENCE))
      (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
       (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
   (SOME (S$0)
    (AND (SEQ!IS-SEQUENCE S$0)
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER STATE SEQUENCE))
   (SOME (S$1)
    (AND (SEQ!IS-SEQUENCE S$1)
     (= (SEQ!EMPTY) (SEQ!JOIN S$1 (HISTORY STATE))))))))
Starting case 3.1.2 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (= (HISTORY (SEQ!HEAD SEQUENCE))
    (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!HEAD SEQUENCE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE
       (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (= (SEQ!HEAD SEQUENCE)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (= (HISTORY (SEQ!HEAD SEQUENCE))
    (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
Prenexing produces ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!HEAD SEQUENCE)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (= (SEQ!HEAD SEQUENCE)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (= (HISTORY (SEQ!HEAD SEQUENCE))
    (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
The conjunctive normal form ...
(AND
 (OR (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE))))))
 (OR (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1)
  (NOT (SEQ!IS-SEQUENCE S))
  (NOT
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE))
   (SEQ!TACK (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))
    (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S$0 (HISTORY STATE)))))))
Substituting (= (SEQ!HEAD SEQUENCE)
              (INTRUDER-STEP LABEL TIME MESSAGE
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(AND
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
   (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (=
     (HISTORY
      (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$0 (HISTORY STATE))))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
   (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$1)
   (AND (SEQ!IS-SEQUENCE S$1)
    (=
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$1 (HISTORY STATE))))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
   (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$2)
   (AND (SEQ!IS-SEQUENCE S$2)
    (=
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$2 (HISTORY STATE))))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
   (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$3)
   (AND (SEQ!IS-SEQUENCE S$3)
    (=
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$3 (HISTORY STATE))))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
   (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$4)
   (AND (SEQ!IS-SEQUENCE S$4)
    (=
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$4 (HISTORY STATE))))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
   (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER STATE SEQUENCE)
   (NOT
    (=
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!TACK
      (SEQ!HEAD
       (HISTORY
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
  (SOME (S$5)
   (AND (SEQ!IS-SEQUENCE S$5)
    (=
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
     (SEQ!JOIN S$5 (HISTORY STATE)))))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 3.1.1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S$1)
  (AND (SEQ!IS-SEQUENCE S$1) (= (SEQ!EMPTY) (SEQ!JOIN S$1 (HISTORY STATE))))))
Invoking SEQ!IS-MEMBER gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-TACK SEQUENCE)
  (OR (= STATE (SEQ!HEAD SEQUENCE))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0) (= (SEQ!EMPTY) (SEQ!JOIN S$0 (HISTORY STATE))))))
Which simplifies
 when rewriting with SEQ!JOIN-EMPTY-RIGHT
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE
 with the instantiation (= S$0 (SEQ!EMPTY)) to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER STATE (SEQ!EMPTY)))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0) (= (SEQ!EMPTY) (SEQ!JOIN S$0 (HISTORY STATE))))))
Invoking SEQ!IS-MEMBER gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 1))
  (SEQ!IS-SEQUENCE S)
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (SEQ!JOIN S (HISTORY STATE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-TACK (SEQ!EMPTY))
  (OR (= STATE (SEQ!HEAD (SEQ!EMPTY)))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL (SEQ!EMPTY)))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0) (= (SEQ!EMPTY) (SEQ!JOIN S$0 (HISTORY STATE))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2 ...
(OR (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (IS-GOOD-EVOLUTION SEQUENCE))
 (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY to ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Instantiating (= S (SEQ!EMPTY)) gives ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT
   (AND (SEQ!IS-SEQUENCE (SEQ!EMPTY))
    (= (SEQ!EMPTY) (SEQ!JOIN (SEQ!EMPTY) (HISTORY STATE))))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 when rewriting with SEQ!JOIN-EMPTY-LEFT
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY to ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (= (SEQ!EMPTY) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Invoking (SEQ!IS-MEMBER STATE SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-TACK SEQUENCE)
  (OR (= STATE (SEQ!HEAD SEQUENCE)) (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (NOT (= (SEQ!EMPTY) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY to ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER STATE (SEQ!EMPTY)) (NOT (= (SEQ!EMPTY) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Invoking SEQ!IS-MEMBER gives ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-TACK (SEQ!EMPTY))
  (OR (= STATE (SEQ!HEAD (SEQ!EMPTY)))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL (SEQ!EMPTY))))
  (NOT (= (SEQ!EMPTY) (HISTORY STATE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S) (= (SEQ!EMPTY) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY to ...
(TRUE)
Starting case 1 ...
(OR (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))
 (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (NOT (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Invoking (SEQ!IS-MEMBER STATE SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-TACK SEQUENCE)
  (OR (= STATE (SEQ!HEAD SEQUENCE))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (NOT (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1)
  (= STATE (SEQ!HEAD SEQUENCE)))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Instantiating (= S (SEQ!EMPTY)) gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1)
  (= STATE (SEQ!HEAD SEQUENCE))
  (NOT
   (AND (SEQ!IS-SEQUENCE (SEQ!EMPTY))
    (= (HISTORY (SEQ!HEAD SEQUENCE))
     (SEQ!JOIN (SEQ!EMPTY) (HISTORY STATE))))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!JOIN S (HISTORY STATE))))))
Which simplifies
 when rewriting with SEQ!JOIN-EMPTY-LEFT
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
TIME-OF-EVENT-STRICTLY-INCREASES
Beginning proof of TIME-OF-EVENT-STRICTLY-INCREASES ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (>= (SEQ!LENGTH (HISTORY STATE)) 2))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) 1)))
Splitting on (IS-GOOD-STATE STATE) generates ...
(IF (IS-GOOD-STATE STATE)
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE STATE) (>= (SEQ!LENGTH (HISTORY STATE)) 2))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) 1)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE STATE) (>= (SEQ!LENGTH (HISTORY STATE)) 2))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) 1))))
Starting case 2 ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (SEQ!LENGTH (HISTORY STATE)) 2))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) 1)))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE) (>= (SEQ!LENGTH (HISTORY STATE)) 2))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) 1)))
Invoking TIME-STRICTLY-INCREASES gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (OR (SEQ!EMPTYP (HISTORY STATE))
   (IF (>= (SEQ!LENGTH (HISTORY STATE)) 2)
    (AND (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
     (IN (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (NAT!NAT))
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
      (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
    (IN (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (NAT!NAT))))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE) (>= (SEQ!LENGTH (HISTORY STATE)) 2))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) 1)))
Rearranging gives ...
(IMPLIES
 (AND (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (>= (SEQ!LENGTH (HISTORY STATE)) 2) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (OR (SEQ!EMPTYP (HISTORY STATE))
   (IF (>= (SEQ!LENGTH (HISTORY STATE)) 2)
    (AND
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
      (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))))
     (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
     (IN (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (NAT!NAT)))
    (IN (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (NAT!NAT)))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) 1)))
Which simplifies
 when rewriting with NAT!IN-NAT, SEQ!EMPTYP-DEFINITION, SEQ!IN-SEQUENCE-OF
 forward chaining using SEQ!NOT-IS-TACK-FACTS, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (>= (SEQ!LENGTH (HISTORY STATE)) 2) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))))
  (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
Assuming TIME-OF-EVENT-IN-CONSTRAINED-HISTORY-NAT with the
instantiations: (= EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))
                (= HISTORY (HISTORY STATE)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
    (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))) (HISTORY STATE))
    (TIME-STRICTLY-INCREASES (HISTORY STATE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) 0))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (>= (SEQ!LENGTH (HISTORY STATE)) 2) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))))
  (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
Which simplifies
 when rewriting with SUCC.INT.RULE
 forward chaining using IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions SUCC.INT, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
  (NOT (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))) (HISTORY STATE)))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (>= (SEQ!LENGTH (HISTORY STATE)) 2) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))))
  (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
Invoking (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))
          (HISTORY STATE)) gives
...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
  (NOT
   (AND (SEQ!IS-TACK (HISTORY STATE))
    (OR (= (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))) (SEQ!HEAD (HISTORY STATE)))
     (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))
      (SEQ!TAIL (HISTORY STATE))))))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (>= (SEQ!LENGTH (HISTORY STATE)) 2) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))))
  (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION, >=.SAME.TYPE,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, MS!SET-OF-MESSAGES-NOT-EMPTY,
IS-STATE-BOOL, MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (NOT (= (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))) (SEQ!HEAD (HISTORY STATE))))
  (NOT
   (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))
    (SEQ!TAIL (HISTORY STATE))))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (>= (SEQ!LENGTH (HISTORY STATE)) 2) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))))
  (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
Invoking (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))
          (SEQ!TAIL (HISTORY STATE))) gives
...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (NOT (= (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))) (SEQ!HEAD (HISTORY STATE))))
  (NOT
   (AND (SEQ!IS-TACK (SEQ!TAIL (HISTORY STATE)))
    (OR
     (= (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))
      (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))
     (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))
      (SEQ!TAIL (SEQ!TAIL (HISTORY STATE)))))))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (>= (SEQ!LENGTH (HISTORY STATE)) 2) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))))
  (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL, MS!SET-OF-MESSAGES-NOT-EMPTY,
IS-STATE-BOOL, MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (NOT (= (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))) (SEQ!HEAD (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))) 1))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (>= (SEQ!LENGTH (HISTORY STATE)) 2) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))))
  (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
Invoking (SEQ!LENGTH (HISTORY STATE)) gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
  (>=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   1)
  (NOT (= (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))) (SEQ!HEAD (HISTORY STATE))))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))) 1))
  (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (>=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   2)
  (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE))))))
  (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (IS-GOOD-STATE STATE)) (IS-GOOD-EVOLUTION-STATE STATE)
  (>= (SEQ!LENGTH (HISTORY STATE)) 2))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
  (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))) 1)))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION to ...
(TRUE)
Completing all cases produces ...
(TRUE)
TIME-OF-EVENT-OF-EVOLUTION-STATE
Beginning proof of TIME-OF-EVENT-OF-EVOLUTION-STATE ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (SEQ!IS-MEMBER E (HISTORY STATE)))
 (>= (TIME-OF-EVENT E) 0))
Inducting using the following scheme ...
 (AND (IMPLIES (SEQ!EMPTYP (HISTORY STATE)) (*P* E STATE))
  (IMPLIES
   (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
    (ALL (PREVIOUS-STATE)
     (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
      (*P* E PREVIOUS-STATE) (TRUE))))
   (*P* E STATE)))
 produces ...
(AND
 (IMPLIES (SEQ!EMPTYP (HISTORY STATE))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE STATE) (SEQ!IS-MEMBER E (HISTORY STATE)))
   (>= (TIME-OF-EVENT E) 0)))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
   (ALL (PREVIOUS-STATE)
    (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
       (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
      (>= (TIME-OF-EVENT E) 0))
     (TRUE))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE STATE) (SEQ!IS-MEMBER E (HISTORY STATE)))
   (>= (TIME-OF-EVENT E) 0))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-EVOLUTION-STATE STATE)
  (SEQ!IS-MEMBER E (HISTORY STATE)))
 (>= (TIME-OF-EVENT E) 0))
Which simplifies
 with invocation of SEQ!IS-MEMBER, SEQ!MEMBERS, SEQ!IS-SEQUENCE,
IS-GOOD-EVOLUTION-STATE, TIME-STRICTLY-INCREASES, SUBSET, IS-GOOD-STATE
 when rewriting with POWERSET.DEFINITION, SUBSET.NULLSET.LEFT,
SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
  (ALL (PREVIOUS-STATE)
   (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
     (>= (TIME-OF-EVENT E) 0))
    (TRUE)))
  (IS-GOOD-EVOLUTION-STATE STATE) (SEQ!IS-MEMBER E (HISTORY STATE)))
 (>= (TIME-OF-EVENT E) 0))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
    (>= (TIME-OF-EVENT E) 0)))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE$0)
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (GOOD-STEP PREVIOUS-STATE$0 STATE))))
  (SEQ!IS-MEMBER E (HISTORY STATE)))
 (>= (TIME-OF-EVENT E) 0))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
    (>= (TIME-OF-EVENT E) 0)))
  (SOME (PREVIOUS-STATE$0)
   (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (GOOD-STEP PREVIOUS-STATE$0 STATE)))
  (SEQ!IS-MEMBER E (HISTORY STATE)))
 (>= (TIME-OF-EVENT E) 0))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE$0)))
    (>= (TIME-OF-EVENT E) 0)))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (SEQ!IS-MEMBER E (HISTORY STATE)))
 (>= (TIME-OF-EVENT E) 0))
Instantiating (= PREVIOUS-STATE$0 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
   (>= (TIME-OF-EVENT E) 0))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE$0)))
    (>= (TIME-OF-EVENT E) 0)))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (SEQ!IS-MEMBER E (HISTORY STATE)))
 (>= (TIME-OF-EVENT E) 0))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
  (GOOD-STEP PREVIOUS-STATE STATE) (SEQ!IS-MEMBER E (HISTORY STATE)))
 (>= (TIME-OF-EVENT E) 0))
Invoking (SEQ!IS-MEMBER E (HISTORY STATE)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
  (GOOD-STEP PREVIOUS-STATE STATE) (SEQ!IS-TACK (HISTORY STATE))
  (OR (= E (SEQ!HEAD (HISTORY STATE)))
   (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY STATE)))))
 (>= (TIME-OF-EVENT E) 0))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
  (GOOD-STEP PREVIOUS-STATE STATE) (= E (SEQ!HEAD (HISTORY STATE))))
 (>= (TIME-OF-EVENT E) 0))
Splitting on (IS-GOOD-STATE STATE) generates ...
(IF (IS-GOOD-STATE STATE)
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
   (GOOD-STEP PREVIOUS-STATE STATE) (= E (SEQ!HEAD (HISTORY STATE))))
  (>= (TIME-OF-EVENT E) 0))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
   (GOOD-STEP PREVIOUS-STATE STATE) (= E (SEQ!HEAD (HISTORY STATE))))
  (>= (TIME-OF-EVENT E) 0)))
Starting case 1.2 ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
  (GOOD-STEP PREVIOUS-STATE STATE) (= E (SEQ!HEAD (HISTORY STATE))))
 (>= (TIME-OF-EVENT E) 0))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
  (GOOD-STEP PREVIOUS-STATE STATE) (= E (SEQ!HEAD (HISTORY STATE))))
 (>= (TIME-OF-EVENT E) 0))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
  (GOOD-STEP PREVIOUS-STATE STATE) (= E (SEQ!HEAD (HISTORY STATE))))
 (>= (TIME-OF-EVENT E) 0))
Invoking TIME-STRICTLY-INCREASES gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (OR (SEQ!EMPTYP (HISTORY STATE))
   (IF (>= (SEQ!LENGTH (HISTORY STATE)) 2)
    (AND (TIME-STRICTLY-INCREASES (SEQ!TAIL (HISTORY STATE)))
     (IN (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (NAT!NAT))
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE)))
      (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY STATE)))))))
    (IN (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (NAT!NAT))))
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
  (GOOD-STEP PREVIOUS-STATE STATE) (= E (SEQ!HEAD (HISTORY STATE))))
 (>= (TIME-OF-EVENT E) 0))
Which simplifies
 when rewriting with NAT!IN-NAT, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK, MS!SET-OF-MESSAGES-NOT-EMPTY,
IS-STATE-BOOL to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (NOT (IS-GOOD-STATE STATE)) (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (NOT (SEQ!IS-MEMBER E (HISTORY PREVIOUS-STATE)))
  (GOOD-STEP PREVIOUS-STATE STATE) (= E (SEQ!HEAD (HISTORY STATE))))
 (>= (TIME-OF-EVENT E) 0))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
MEMBER-IS-GOOD-EVOLUTION-STATE
Beginning proof of MEMBER-IS-GOOD-EVOLUTION-STATE ...
(IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (IS-GOOD-EVOLUTION-STATE STATE))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (SEQ!TAIL SEQUENCE) STATE))
   (*P* SEQUENCE STATE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* SEQUENCE STATE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
    (IS-GOOD-EVOLUTION-STATE STATE)))
  (IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
   (IS-GOOD-EVOLUTION-STATE STATE)))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
   (IS-GOOD-EVOLUTION-STATE STATE))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
   (IS-GOOD-EVOLUTION-STATE STATE))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-MEMBER STATE SEQUENCE))
 (IS-GOOD-EVOLUTION-STATE STATE))
Rearranging gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
   (IS-GOOD-EVOLUTION-STATE STATE)))
 (IS-GOOD-EVOLUTION-STATE STATE))
Which simplifies
 when rewriting with IS-GOOD-EVOLUTION-TAIL
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE)
  (NOT (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))))
 (IS-GOOD-EVOLUTION-STATE STATE))
Invoking (SEQ!IS-MEMBER STATE SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-TACK SEQUENCE)
  (OR (= STATE (SEQ!HEAD SEQUENCE)) (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE)))
  (NOT (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))))
 (IS-GOOD-EVOLUTION-STATE STATE))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER STATE SEQUENCE))
 (IS-GOOD-EVOLUTION-STATE STATE))
Invoking IS-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (SEQ!IS-MEMBER STATE SEQUENCE))
 (IS-GOOD-EVOLUTION-STATE STATE))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
>=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER STATE SEQUENCE))
 (IS-GOOD-EVOLUTION-STATE STATE))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER STATE SEQUENCE))
 (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
  (SOME (PREVIOUS-STATE)
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (GOOD-STEP PREVIOUS-STATE STATE)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
>=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER STATE SEQUENCE))
 (IF (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (IF (SEQ!IS-SEQUENCE (HISTORY STATE))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE)))
   (IS-GOOD-STATE STATE))
  (IS-GOOD-STATE STATE)))
Invoking (SEQ!IS-MEMBER STATE SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-TACK SEQUENCE)
  (OR (= STATE (SEQ!HEAD SEQUENCE))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL SEQUENCE))))
 (IF (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (IF (SEQ!IS-SEQUENCE (HISTORY STATE))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE)))
   (IS-GOOD-STATE STATE))
  (IS-GOOD-STATE STATE)))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER STATE (SEQ!EMPTY)))
 (IF (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (IF (SEQ!IS-SEQUENCE (HISTORY STATE))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE)))
   (IS-GOOD-STATE STATE))
  (IS-GOOD-STATE STATE)))
Invoking (SEQ!IS-MEMBER STATE (SEQ!EMPTY)) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (NOT (= STATE (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-TACK (SEQ!EMPTY))
  (OR (= STATE (SEQ!HEAD (SEQ!EMPTY)))
   (SEQ!IS-MEMBER STATE (SEQ!TAIL (SEQ!EMPTY)))))
 (IF (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (IF (SEQ!IS-SEQUENCE (HISTORY STATE))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE)))
   (IS-GOOD-STATE STATE))
  (IS-GOOD-STATE STATE)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
SPECIAL-INDUCTION
Beginning proof of SPECIAL-INDUCTION ...
(IF (>= (SEQ!LENGTH SEQUENCE) 1)
 (AND (M< (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (SEQ!LENGTH SEQUENCE))
  (M< (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (SEQ!LENGTH SEQUENCE))
  (M< (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (SEQ!LENGTH SEQUENCE)))
 (TRUE))
Which simplifies
 with invocation of SEQ!LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SUCC.INT, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
TIME-OF-EVENT-STRICTLY-INCREASES-2
Beginning proof of TIME-OF-EVENT-STRICTLY-INCREASES-2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 (+ N1 1))
  (<= (+ N2 1) (SEQ!LENGTH SEQUENCE)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
  (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))) 1)))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (*P* (- N1 1) N2 (SEQ!TAIL SEQUENCE))
    (*P* N1 (- N2 1) (SEQ!TAIL SEQUENCE))
    (*P* (- N1 1) (- N2 1) (SEQ!TAIL SEQUENCE)))
   (*P* N1 N2 SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 1)) (*P* N1 N2 SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N1 1) 1)
     (>= N2 (+ (- N1 1) 1)) (<= (+ N2 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
    (>=
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))))
     (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))
      1)))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N1 1)
     (>= (- N2 1) (+ N1 1))
     (<= (+ (- N2 1) 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
    (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))))
     (+
      (TIME-OF-EVENT
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
      1)))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N1 1) 1)
     (>= (- N2 1) (+ (- N1 1) 1))
     (<= (+ (- N2 1) 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
    (>=
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))))
     (+
      (TIME-OF-EVENT
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
      1))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 (+ N1 1))
    (<= (+ N2 1) (SEQ!LENGTH SEQUENCE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))) 1))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 (+ N1 1))
    (<= (+ N2 1) (SEQ!LENGTH SEQUENCE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))) 1)))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N1 1) 1)
    (>= N2 (+ (- N1 1) 1)) (<= (+ N2 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (>=
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))
     1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N1 1)
    (>= (- N2 1) (+ N1 1))
    (<= (+ (- N2 1) 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))))
    (+
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
     1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N1 1) 1)
    (>= (- N2 1) (+ (- N1 1) 1))
    (<= (+ (- N2 1) 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (>=
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))))
    (+
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
     1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 (+ N1 1))
  (<= (+ N2 1) (SEQ!LENGTH SEQUENCE)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
  (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))) 1)))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ N1 1))
  (IS-GOOD-EVOLUTION SEQUENCE) (<= (+ N2 1) (SEQ!LENGTH SEQUENCE))
  (IMPLIES
   (AND (>= (- N1 1) 1) (>= N2 (+ (- N1 1) 1))
    (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (<= (+ N2 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (>=
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))
     1)))
  (IMPLIES
   (AND (>= N1 1) (>= (- N2 1) (+ N1 1))
    (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (<= (+ (- N2 1) 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))))
    (+
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
     1)))
  (IMPLIES
   (AND (>= (- N1 1) 1) (>= (- N2 1) (+ (- N1 1) 1))
    (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (<= (+ (- N2 1) 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (>=
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))))
    (+
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
     1))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
  (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))) 1)))
Which simplifies
 when rewriting with IS-GOOD-EVOLUTION-TAIL
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N2)))
 (IF (>= (+ -1 N1) 1)
  (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N2))
   (IMPLIES
    (>=
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
     (+ 1
      (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))))
    (IF (>= (+ -1 N2) (+ 1 N1))
     (IMPLIES
      (AND
       (>=
        (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
       (>=
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
      (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
       (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
     (IMPLIES
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
       (+ 1
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
      (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
       (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))))
   (IF (>= (+ -1 N2) (+ 1 N1))
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
     (IMPLIES
      (AND
       (>=
        (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
       (>=
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
      (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
       (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
      (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
     (IMPLIES
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
       (+ 1
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
      (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
       (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
      (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))))
  (IF (>= (+ -1 N2) 2)
   (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
      (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
    (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
     (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
    (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))))
Invoking (SEQ!NTH SEQUENCE N1) gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N2)))
 (IF (>= (+ -1 N1) 1)
  (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N2))
   (IMPLIES
    (AND
     (>=
      (TIME-OF-EVENT
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
      (+ 1
       (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))))
     (IF (>= (+ -1 N2) (+ 1 N1))
      (AND
       (>=
        (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
       (>=
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
       (+ 1
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))))
    (>=
     (TIME-OF-EVENT
      (SEQ!HEAD
       (HISTORY
        (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
         (SEQ!HEAD SEQUENCE)))))
     (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
   (IF (>= (+ -1 N2) (+ 1 N1))
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
     (IMPLIES
      (AND
       (>=
        (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
       (>=
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD
         (HISTORY
          (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
           (SEQ!HEAD SEQUENCE)))))
       (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
     (>=
      (TIME-OF-EVENT
       (SEQ!HEAD
        (HISTORY
         (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
          (SEQ!HEAD SEQUENCE)))))
      (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
     (IMPLIES
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
       (+ 1
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD
         (HISTORY
          (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
           (SEQ!HEAD SEQUENCE)))))
       (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
     (>=
      (TIME-OF-EVENT
       (SEQ!HEAD
        (HISTORY
         (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
          (SEQ!HEAD SEQUENCE)))))
      (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))))
  (IF (>= (+ -1 N2) 2)
   (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
      (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
    (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
     (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
    (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))))
Invoking (SEQ!NTH SEQUENCE N2) gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N2)))
 (IF (>= (+ -1 N1) 1)
  (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N2))
   (IMPLIES
    (AND
     (>=
      (TIME-OF-EVENT
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
      (+ 1
       (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))))
     (IF (>= (+ -1 N2) (+ 1 N1))
      (AND
       (>=
        (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
       (>=
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
       (+ 1
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))))
    (>=
     (TIME-OF-EVENT
      (SEQ!HEAD
       (HISTORY
        (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
         (SEQ!HEAD SEQUENCE)))))
     (+ 1
      (TIME-OF-EVENT
       (SEQ!HEAD
        (HISTORY
         (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
          (SEQ!HEAD SEQUENCE))))))))
   (IF (>= (+ -1 N2) (+ 1 N1))
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
     (IMPLIES
      (AND
       (>=
        (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
       (>=
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
        (+ 1
         (TIME-OF-EVENT
          (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD
         (HISTORY
          (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
           (SEQ!HEAD SEQUENCE)))))
       (+ 1
        (TIME-OF-EVENT
         (SEQ!HEAD
          (HISTORY
           (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
            (SEQ!HEAD SEQUENCE))))))))
     (>=
      (TIME-OF-EVENT
       (SEQ!HEAD
        (HISTORY
         (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
          (SEQ!HEAD SEQUENCE)))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD
         (HISTORY
          (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
           (SEQ!HEAD SEQUENCE))))))))
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
     (IMPLIES
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
       (+ 1
        (TIME-OF-EVENT
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
      (>=
       (TIME-OF-EVENT
        (SEQ!HEAD
         (HISTORY
          (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
           (SEQ!HEAD SEQUENCE)))))
       (+ 1
        (TIME-OF-EVENT
         (SEQ!HEAD
          (HISTORY
           (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
            (SEQ!HEAD SEQUENCE))))))))
     (>=
      (TIME-OF-EVENT
       (SEQ!HEAD
        (HISTORY
         (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
          (SEQ!HEAD SEQUENCE)))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD
         (HISTORY
          (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
           (SEQ!HEAD SEQUENCE))))))))))
  (IF (>= (+ -1 N2) 2)
   (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD
         (HISTORY
          (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
           (SEQ!HEAD SEQUENCE))))))))
    (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
     (+ 1
      (TIME-OF-EVENT
       (SEQ!HEAD
        (HISTORY
         (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
          (SEQ!HEAD SEQUENCE))))))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
    (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N2)))
 (IF (>= (+ -1 N1) 1)
  (OR (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N2))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
   (>=
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
    (+ 1
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
  (IF (>= (+ -1 N2) 2)
   (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
    (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
     (+ 1
      (TIME-OF-EVENT
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
    (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND (>= N1 1)
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
  (>= N2 (+ 1 N1)) (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
   (+ 1 N2)))
 (IF (>= (+ -1 N1) 1)
  (OR (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N2))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
   (>=
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))))
    (+ 1
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
  (IF (>= (+ -1 N2) 2)
   (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N2)
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
     (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
      (+ 1
       (TIME-OF-EVENT
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
    (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
     (+ 1
      (TIME-OF-EVENT
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
    (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
>=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (NOT (>= (+ -1 N1) 1)))
 (IF (>= (+ -1 N2) 2)
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
    (+ 1
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
    (+ 1
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2))))))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (NOT (>= (+ -1 N1) 1))
  (>= (+ -1 N2) 2)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (NOT (>= (+ -1 N1) 1))
  (>= (+ -1 N2) 2)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
 (>=
  (TIME-OF-EVENT
   (SEQ!HEAD
    (HISTORY
     (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1))
      (SEQ!HEAD SEQUENCE)))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (NOT (>= (+ -1 N1) 1))
  (>= (+ -1 N2) 2)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Assuming TIME-OF-EVENT-STRICTLY-INCREASES with the
instantiations: (= STATE (SEQ!HEAD SEQUENCE)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))
    (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 2))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
     1)))
  (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (NOT (>= (+ -1 N1) 1))
  (>= (+ -1 N2) 2)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (>= (+ -1 N2) 2)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (+ -1 N1) 1))
  (IMPLIES
   (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 2)
    (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
     1))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (>= (+ -1 N2) 2)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (+ -1 N1) 1)))
 (IF (>= (+ -1 (SEQ!LENGTH SEQUENCE)) 2)
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (+ 1
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND (>= N1 1)
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
  (>= N2 (+ 1 N1)) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2))
  (>= (+ -1 N2) 2)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (+ -1 N1) 1)))
 (IF
  (>=
   (+ -1 (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
   2)
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (+ 1
     (TIME-OF-EVENT
      (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
>=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (>= (+ -1 N2) 2)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (+ -1 N1) 1))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Invoking (SEQ!NTH (SEQ!TAIL SEQUENCE) 1) gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (>= (+ -1 N2) 2)
  (>=
   (TIME-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- 1 1))
       (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (+ -1 N1) 1))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (>= (+ -1 N2) 2)
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (+ -1 N1) 1))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Applying HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (>= (+ -1 N2) 2)
  (>=
   (TIME-OF-EVENT
    (SEQ!HEAD
     (IF (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
      (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))
      (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (+ -1 N1) 1))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (>= (+ -1 N2) 2)
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (NOT (>= (+ -1 N1) 1))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND (>= N1 1)
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
  (>= N2 (+ 1 N1)) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2))
  (>= (+ -1 N2) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT
   (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
    2))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (+ 1
    (TIME-OF-EVENT
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (NOT (>= (+ -1 N1) 1))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
>=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (+ -1 N2) 2)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))
Splitting on (= N1 1) generates ...
(IF (= N1 1)
 (IMPLIES
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
   (IS-GOOD-EVOLUTION SEQUENCE)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (NOT (>= (+ -1 N1) 1))
   (NOT (>= (+ -1 N2) 2)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))
 (IMPLIES
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 (+ 1 N1))
   (IS-GOOD-EVOLUTION SEQUENCE)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (NOT (>= (+ -1 N1) 1))
   (NOT (>= (+ -1 N2) 2)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 2)
  (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2)) (NOT (>= (+ -1 N2) 2)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))
Splitting on (= N2 2) generates ...
(IF (= N2 2)
 (IMPLIES
  (AND (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 2)
   (IS-GOOD-EVOLUTION SEQUENCE)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2))
   (NOT (>= (+ -1 N2) 2)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))
 (IMPLIES
  (AND (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (>= N2 2)
   (IS-GOOD-EVOLUTION SEQUENCE)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N2))
   (NOT (>= (+ -1 N2) 2)))
  (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
   (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 2) (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 3))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 2)))))))
Invoking SEQ!NTH gives ...
(IMPLIES
 (AND (= N2 2) (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 3))
 (>=
  (TIME-OF-EVENT
   (SEQ!HEAD
    (HISTORY
     (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1))
      (SEQ!HEAD SEQUENCE)))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (IF (>= 2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 2 1))
       (SEQ!HEAD SEQUENCE))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 2) (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 3))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))))))
Invoking SEQ!NTH gives ...
(IMPLIES
 (AND (= N2 2) (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 3))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1
   (TIME-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- 1 1))
       (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 2) (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 3))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
Assuming TIME-OF-EVENT-STRICTLY-INCREASES with the
instantiations: (= STATE (SEQ!HEAD SEQUENCE)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))
    (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 2))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
     1)))
  (= N2 2) (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 3))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
Rearranging gives ...
(IMPLIES
 (AND (= N2 2) (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 3) (IS-GOOD-EVOLUTION SEQUENCE)
  (IMPLIES
   (AND (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) 2)
    (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
     1))))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
Which simplifies
 when rewriting with HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION,
LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 2) (= N1 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 3) (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) 2)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND (= N2 2) (= N1 1)
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 3) (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT
   (>=
    (+ -1
     (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
    2)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (+ 1 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 1)) (IS-GOOD-EVOLUTION SEQUENCE)
  (>= N1 1) (>= N2 (+ N1 1)) (<= (+ N2 1) (SEQ!LENGTH SEQUENCE)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
  (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))) 1)))
Invoking IS-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (>= N1 1) (>= N2 (+ N1 1)) (>= (SEQ!LENGTH SEQUENCE) (+ N2 1)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
  (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))) 1)))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
SEEN-MESSAGES-MONOTONIC
Beginning proof of SEEN-MESSAGES-MONOTONIC ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
  (>= (SEQ!LENGTH SEQUENCE) N1))
 (SUBSET (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
  (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (*P* (- N1 1) N2 (SEQ!TAIL SEQUENCE))
    (*P* N1 (- N2 1) (SEQ!TAIL SEQUENCE))
    (*P* (- N1 1) (- N2 1) (SEQ!TAIL SEQUENCE)))
   (*P* N1 N2 SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 1)) (*P* N1 N2 SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N2 1) (>= (- N1 1) N2)
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N2 1) 1)
     (>= N1 (- N2 1)) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N2 1) 1)
     (>= (- N1 1) (- N2 1)) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
    (>= (SEQ!LENGTH SEQUENCE) N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2)))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
    (>= (SEQ!LENGTH SEQUENCE) N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))))))
Invoking (SEQ!NTH SEQUENCE N1) gives ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N2 1) (>= (- N1 1) N2)
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N2 1) 1)
     (>= N1 (- N2 1)) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N2 1) 1)
     (>= (- N1 1) (- N2 1)) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
   (>= (SEQ!LENGTH SEQUENCE) N1))
  (SUBSET
   (SEEN-MESSAGES
    (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE)))
   (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 1)) (IS-GOOD-EVOLUTION SEQUENCE)
   (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1))
  (SUBSET
   (SEEN-MESSAGES
    (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE)))
   (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2)))))
Invoking (SEQ!NTH SEQUENCE N2) gives ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N2 1) (>= (- N1 1) N2)
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N2 1) 1)
     (>= N1 (- N2 1)) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N2 1) 1)
     (>= (- N1 1) (- N2 1)) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
   (>= (SEQ!LENGTH SEQUENCE) N1))
  (SUBSET
   (SEEN-MESSAGES
    (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE)))
   (SEEN-MESSAGES
    (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
     (SEQ!HEAD SEQUENCE)))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 1)) (IS-GOOD-EVOLUTION SEQUENCE)
   (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1))
  (SUBSET
   (SEEN-MESSAGES
    (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE)))
   (SEEN-MESSAGES
    (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
     (SEQ!HEAD SEQUENCE))))))
Which simplifies
 when rewriting with SUBSET.SELF
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 1)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES (>= N2 1)
   (IF (>= (+ -1 N1) N2)
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
     (IMPLIES
      (AND
       (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
       (NOT (>= (+ -1 N2) 1)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1)
       (>= (SEQ!LENGTH SEQUENCE) N1))
      (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
       (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 N2)
       (>= (SEQ!LENGTH SEQUENCE) N1))
      (IF (>= N2 2)
       (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
       (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))))
    (IMPLIES
     (AND (>= (+ -1 N2) 1) (>= N1 (+ -1 N2))
      (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1)) (>= (+ -1 N1) (+ -1 N2))
      (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
      (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1))
     (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
      (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
    (>= (SEQ!LENGTH SEQUENCE) N1) (>= N1 2))
   (IF (>= N2 2)
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!HEAD SEQUENCE)))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES (>= N2 1)
   (IF (>= (+ -1 N1) N2)
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
     (IMPLIES
      (AND
       (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
       (NOT (>= (+ -1 N2) 1)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1)
       (>=
        (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
        N1))
      (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
       (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 N2)
       (>=
        (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
        N1))
      (IF (>= N2 2)
       (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
       (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))))
    (IMPLIES
     (AND (>= (+ -1 N2) 1) (>= N1 (+ -1 N2))
      (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1)) (>= (+ -1 N1) (+ -1 N2))
      (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
      (IS-GOOD-EVOLUTION SEQUENCE)
      (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
       N1))
     (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
      (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
    (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     N1)
    (>= N1 2))
   (IF (>= N2 2)
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!HEAD SEQUENCE)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 1)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND (>= N2 1) (>= (+ -1 N1) N2)
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
    (NOT (>= (+ -1 N2) 1)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
    (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N1) (>= N1 2))
   (IF (>= N2 2)
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!HEAD SEQUENCE)))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 1)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND (>= N2 1) (>= (+ -1 N1) N2)
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
    (NOT (>= (+ -1 N2) 1))
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (>= N1 1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (>= N2 1) (>= N1 N2) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N1)
    (>= N1 2))
   (IF (>= N2 2)
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (SEEN-MESSAGES (SEQ!HEAD SEQUENCE)))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (>= N2 1) (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
  (NOT (>= (+ -1 N2) 1)))
 (IF (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
    (>= N1 1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (>= N1 1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!EMPTY) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (>= N2 1) (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
  (NOT (>= (+ -1 N2) 1)) (>= (SEQ!LENGTH SEQUENCE) 2)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
 (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
Splitting on (= N2 1) generates ...
(IF (= N2 1)
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (>= N2 1) (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
   (NOT (>= (+ -1 N2) 1)) (>= (SEQ!LENGTH SEQUENCE) 2)
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (>= N2 1) (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
   (NOT (>= (+ -1 N2) 1)) (>= (SEQ!LENGTH SEQUENCE) 2)
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
  (>= (SEQ!LENGTH SEQUENCE) 2)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
 (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
Invoking (SEQ!NTH (SEQ!TAIL SEQUENCE) 1) gives ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- 1 1))
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (>= (SEQ!LENGTH SEQUENCE) 2)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
 (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (>= (SEQ!LENGTH SEQUENCE) 2)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
 (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!HEAD SEQUENCE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE
       (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (= (SEQ!HEAD SEQUENCE)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
  (>= N1 1))
 (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
Prenexing produces ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!HEAD SEQUENCE)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (= (SEQ!HEAD SEQUENCE)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (>= N1 1))
 (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
The conjunctive normal form ...
(AND
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!HEAD SEQUENCE)))))
Substituting (= (SEQ!HEAD SEQUENCE)
              (INTRUDER-STEP LABEL TIME MESSAGE
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(AND
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N1) 1)
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (SEEN-MESSAGES (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
Which simplifies
 when rewriting with SEEN-MESSAGES-OUT-OF-BAND-STEP,
SEEN-MESSAGES-CONSTRUCT-STEP, SEEN-MESSAGES-RECEIVE-STEP,
SEEN-MESSAGES-SEND-STEP, SEEN-MESSAGES-GENERATE-STEP, MS!SUBSET-SETADD,
SEEN-MESSAGES-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (>= N2 1) (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
  (NOT (>= (+ -1 N2) 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (>= N1 1))
 (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!EMPTY) (+ -1 N1)))
  (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N2 1) (>= (+ -1 N1) N2)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
  (NOT (>= (+ -1 N2) 1))
  (NOT
   (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
    2))
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (>= N1 1))
 (SUBSET (SEEN-MESSAGES (SEQ!NTH (SEQ!EMPTY) (+ -1 N1)))
  (SEEN-MESSAGES (SEQ!HEAD SEQUENCE))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
FORGEABLE-IS-MONOTONIC
Beginning proof of FORGEABLE-IS-MONOTONIC ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
  (>= (SEQ!LENGTH SEQUENCE) N1) (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N1)))
 (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N2)))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
  (>= (SEQ!LENGTH SEQUENCE) N1)
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Assuming SEEN-MESSAGES-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE) (= N1 N1) (= N2 N2) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
    (>= (SEQ!LENGTH SEQUENCE) N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
  (>= (SEQ!LENGTH SEQUENCE) N1)
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
  (>= (SEQ!LENGTH SEQUENCE) N1)
  (SUBSET (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
   (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2)))
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Assuming MS!KNOWN-IN-SUBSET with the
instantiations: (= C MESSAGE)
                (= S1
                 (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
                  (UNION (MS!PUBLIC-KEYS)
                   (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
                (= S2
                 (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
                  (UNION (MS!PUBLIC-KEYS)
                   (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (MS!KNOWN-IN MESSAGE
     (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
    (SUBSET
     (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))
     (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
   (MS!KNOWN-IN MESSAGE
    (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 N2)
  (>= (SEQ!LENGTH SEQUENCE) N1)
  (SUBSET (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
   (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2)))
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1)
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SUBSET (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
   (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2)))
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IMPLIES
   (AND
    (MS!KNOWN-IN MESSAGE
     (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
    (SUBSET
     (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N1))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))
     (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
   (MS!KNOWN-IN MESSAGE
    (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with SETRULES!SUBSET-UNION-RIGHT, SETRULES!SUBSET-UNION-LEFT,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
STORAGE-OF-PRINCIPAL-MONOTONIC
Beginning proof of STORAGE-OF-PRINCIPAL-MONOTONIC ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
  (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1))
 (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
  (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 1)
    (*P* (- N1 1) N2 PRINCIPAL (SEQ!TAIL SEQUENCE))
    (*P* N1 (- N2 1) PRINCIPAL (SEQ!TAIL SEQUENCE))
    (*P* (- N1 1) (- N2 1) PRINCIPAL (SEQ!TAIL SEQUENCE)))
   (*P* N1 N2 PRINCIPAL SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 1)) (*P* N1 N2 PRINCIPAL SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (- N1 1) N2)
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (IN PRINCIPAL (MS!PRINCIPALS)) (>= (- N2 1) 1) (>= N1 (- N2 1))
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (IN PRINCIPAL (MS!PRINCIPALS)) (>= (- N2 1) 1) (>= (- N1 1) (- N2 1))
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
    (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
    (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2)))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
    (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
    (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))))))
Invoking (SEQ!NTH SEQUENCE N1) gives ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (- N1 1) N2)
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (IN PRINCIPAL (MS!PRINCIPALS)) (>= (- N2 1) 1) (>= N1 (- N2 1))
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (IN PRINCIPAL (MS!PRINCIPALS)) (>= (- N2 1) 1) (>= (- N1 1) (- N2 1))
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
   (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1))
  (SUBSET
   (STORAGE-OF PRINCIPAL
    (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE)))
   (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 1)) (IS-GOOD-EVOLUTION SEQUENCE)
   (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= N1 N2)
   (>= (SEQ!LENGTH SEQUENCE) N1))
  (SUBSET
   (STORAGE-OF PRINCIPAL
    (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE)))
   (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2)))))
Invoking (SEQ!NTH SEQUENCE N2) gives ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (- N1 1) N2)
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (IN PRINCIPAL (MS!PRINCIPALS)) (>= (- N2 1) 1) (>= N1 (- N2 1))
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N1))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (IN PRINCIPAL (MS!PRINCIPALS)) (>= (- N2 1) 1) (>= (- N1 1) (- N2 1))
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N1 1)))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))))
   (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
   (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1))
  (SUBSET
   (STORAGE-OF PRINCIPAL
    (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE)))
   (STORAGE-OF PRINCIPAL
    (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
     (SEQ!HEAD SEQUENCE)))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 1)) (IS-GOOD-EVOLUTION SEQUENCE)
   (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= N1 N2)
   (>= (SEQ!LENGTH SEQUENCE) N1))
  (SUBSET
   (STORAGE-OF PRINCIPAL
    (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE)))
   (STORAGE-OF PRINCIPAL
    (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))
     (SEQ!HEAD SEQUENCE))))))
Which simplifies
 when rewriting with SUBSET.SELF
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 1)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1))
   (IF (>= (+ -1 N1) N2)
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
     (IMPLIES
      (AND
       (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
       (NOT (>= (+ -1 N2) 1)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1)
       (>= (SEQ!LENGTH SEQUENCE) N1))
      (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
       (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 N2)
       (>= (SEQ!LENGTH SEQUENCE) N1))
      (IF (>= N2 2)
       (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
       (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))))
    (IMPLIES
     (AND (>= (+ -1 N2) 1) (>= N1 (+ -1 N2))
      (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1)) (>= (+ -1 N1) (+ -1 N2))
      (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
      (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1))
     (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
      (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
    (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1) (>= N1 2))
   (IF (>= N2 2)
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE)))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1))
   (IF (>= (+ -1 N1) N2)
    (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
     (IMPLIES
      (AND
       (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
       (NOT (>= (+ -1 N2) 1)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1)
       (>=
        (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
        N1))
      (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
       (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 N2)
       (>=
        (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
        N1))
      (IF (>= N2 2)
       (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
       (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
        (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))))
    (IMPLIES
     (AND (>= (+ -1 N2) 1) (>= N1 (+ -1 N2))
      (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N1)) (>= (+ -1 N1) (+ -1 N2))
      (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
      (IS-GOOD-EVOLUTION SEQUENCE)
      (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
       N1))
     (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
      (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
    (>= N1 N2)
    (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     N1)
    (>= N1 2))
   (IF (>= N2 2)
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 1)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (+ -1 N1) N2)
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
    (NOT (>= (+ -1 N2) 1)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
    (>= N1 N2) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N1) (>= N1 2))
   (IF (>= N2 2)
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE)))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 1)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (+ -1 N1) N2)
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
    (NOT (>= (+ -1 N2) 1))
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (>= N1 1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= N1 N2)
    (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N1) (>= N1 2))
   (IF (>= N2 2)
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2))))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
     (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE)))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (+ -1 N1) N2)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
  (NOT (>= (+ -1 N2) 1)))
 (IF (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
    (>= N1 1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (>= N1 1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!EMPTY) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (+ -1 N1) N2)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
  (NOT (>= (+ -1 N2) 1)) (>= (SEQ!LENGTH SEQUENCE) 2)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
 (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
Splitting on (= N2 1) generates ...
(IF (= N2 1)
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (+ -1 N1) N2)
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
   (NOT (>= (+ -1 N2) 1)) (>= (SEQ!LENGTH SEQUENCE) 2)
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (+ -1 N1) N2)
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
   (NOT (>= (+ -1 N2) 1)) (>= (SEQ!LENGTH SEQUENCE) 2)
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
  (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
  (>= (SEQ!LENGTH SEQUENCE) 2)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
 (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
Invoking (SEQ!NTH (SEQ!TAIL SEQUENCE) 1) gives ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
  (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- 1 1))
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (>= (SEQ!LENGTH SEQUENCE) 2)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
 (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
  (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (>= (SEQ!LENGTH SEQUENCE) 2)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N1 1))
 (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
  (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$2)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (= (SEQ!HEAD SEQUENCE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$3)
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$3 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$3
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE
       (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (= (SEQ!HEAD SEQUENCE)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))))
  (>= N1 1))
 (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
Prenexing produces ...
(IMPLIES
 (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
  (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (= (SEQ!HEAD SEQUENCE)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$3 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$3
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (= (SEQ!HEAD SEQUENCE)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (>= N1 1))
 (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
  (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
The conjunctive normal form ...
(AND
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$3 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$3 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$3
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
 (OR (NOT (= N2 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS))) (NOT (>= (+ -1 N1) 1))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1)))
  (NOT
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE)))))
Substituting (= (SEQ!HEAD SEQUENCE)
              (INTRUDER-STEP LABEL TIME MESSAGE
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$3
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(AND
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
   (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
   (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
   (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
   (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
   (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$3 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$3 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$3
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$3
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
 (IMPLIES
  (AND (= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
   (>= (+ -1 N1) 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
    (STORAGE-OF PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (>= N1 1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
Which simplifies
 when rewriting with STORAGE-OF-OUT-OF-BAND-STEP, STORAGE-OF-CONSTRUCT-STEP,
STORAGE-OF-RECEIVE-STEP, STORAGE-OF-SEND-STEP, MS!SUBSET-SETADD,
STORAGE-OF-GENERATE-STEP, STORAGE-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= (+ -1 N1) N2)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
  (NOT (>= (+ -1 N2) 1)) (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (>= N1 1))
 (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!EMPTY) (+ -1 N1)))
  (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (IN PRINCIPAL (MS!PRINCIPALS))
  (>= N2 1) (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1)))
   (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!TAIL SEQUENCE) N2)))
  (NOT (>= (+ -1 N2) 1))
  (NOT
   (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
    2))
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (>= N1 1))
 (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH (SEQ!EMPTY) (+ -1 N1)))
  (STORAGE-OF PRINCIPAL (SEQ!HEAD SEQUENCE))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
KNOWN-BY-IS-MONOTONIC
Beginning proof of KNOWN-BY-IS-MONOTONIC ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
  (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1)
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N1)))
 (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N2)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
  (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1)
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Assuming STORAGE-OF-PRINCIPAL-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE) (= PRINCIPAL PRINCIPAL) (= N1 N1)
                (= N2 N2) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
    (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1))
   (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
    (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))))
  (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
  (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1)
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
  (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1)
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
   (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2)))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Assuming MS!KNOWN-IN-SUBSET with the
instantiations: (= C MESSAGE)
                (= S1
                 (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
                  (UNION (MS!PUBLIC-KEYS)
                   (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
                (= S2
                 (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
                  (UNION (MS!PUBLIC-KEYS)
                   (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (MS!KNOWN-IN MESSAGE
     (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
    (SUBSET
     (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))
     (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
   (MS!KNOWN-IN MESSAGE
    (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
  (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
  (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1)
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
   (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2)))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH SEQUENCE) N1)
  (IS-GOOD-EVOLUTION SEQUENCE) (IN PRINCIPAL (MS!PRINCIPALS))
  (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
   (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2)))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IMPLIES
   (AND
    (MS!KNOWN-IN MESSAGE
     (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
    (SUBSET
     (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N1))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))
     (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
   (MS!KNOWN-IN MESSAGE
    (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE N2))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with SETRULES!SUBSET-UNION-RIGHT, SETRULES!SUBSET-UNION-LEFT,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH
Beginning proof of SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH ...
(IMPLIES (AND (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S))
 (SOME (N) (AND (>= N 1) (= M (SEQ!NTH S N)) (<= N (SEQ!LENGTH S)))))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (SEQ!IS-TACK S) (*P* M (SEQ!TAIL S))) (*P* M S))
  (IMPLIES (NOT (SEQ!IS-TACK S)) (*P* M S)))
 produces ...
(AND
 (IMPLIES
  (AND (SEQ!IS-TACK S)
   (IMPLIES
    (AND (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)))
    (SOME (N)
     (AND (>= N 1) (= M (SEQ!NTH (SEQ!TAIL S) N))
      (<= N (SEQ!LENGTH (SEQ!TAIL S)))))))
  (IMPLIES (AND (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S))
   (SOME (N) (AND (>= N 1) (= M (SEQ!NTH S N)) (<= N (SEQ!LENGTH S))))))
 (IMPLIES (NOT (SEQ!IS-TACK S))
  (IMPLIES (AND (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S))
   (SOME (N) (AND (>= N 1) (= M (SEQ!NTH S N)) (<= N (SEQ!LENGTH S)))))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!IS-TACK S)
  (IMPLIES (AND (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)))
   (SOME (N)
    (AND (>= N 1) (= M (SEQ!NTH (SEQ!TAIL S) N))
     (<= N (SEQ!LENGTH (SEQ!TAIL S))))))
  (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S))
 (SOME (N) (AND (>= N 1) (= M (SEQ!NTH S N)) (<= N (SEQ!LENGTH S)))))
Prenexing produces ...
(IMPLIES
 (SOME (N)
  (AND (SEQ!IS-TACK S)
   (IMPLIES
    (AND (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)))
    (AND (>= N 1) (= M (SEQ!NTH (SEQ!TAIL S) N))
     (>= (SEQ!LENGTH (SEQ!TAIL S)) N)))
   (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S)))
 (SOME (N$0) (AND (>= N$0 1) (= M (SEQ!NTH S N$0)) (>= (SEQ!LENGTH S) N$0))))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-TACK S)
  (IMPLIES (AND (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)))
   (AND (>= N 1) (= M (SEQ!NTH (SEQ!TAIL S) N))
    (>= (SEQ!LENGTH (SEQ!TAIL S)) N)))
  (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S))
 (SOME (N$0) (AND (>= N$0 1) (= M (SEQ!NTH S N$0)) (>= (SEQ!LENGTH S) N$0))))
Rearranging gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S)
  (IMPLIES (AND (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)))
   (AND (>= N 1) (= M (SEQ!NTH (SEQ!TAIL S) N))
    (>= (SEQ!LENGTH (SEQ!TAIL S)) N))))
 (SOME (N$0) (AND (>= N$0 1) (= M (SEQ!NTH S N$0)) (>= (SEQ!LENGTH S) N$0))))
Invoking (SEQ!LENGTH S) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S)
  (IMPLIES (AND (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)))
   (AND (>= N 1) (= M (SEQ!NTH (SEQ!TAIL S) N))
    (>= (SEQ!LENGTH (SEQ!TAIL S)) N))))
 (SOME (N$0)
  (AND (>= N$0 1) (= M (SEQ!NTH S N$0))
   (>= (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0) N$0))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S))
 (IF (SEQ!IS-SEQUENCE (SEQ!TAIL S))
  (IF (SEQ!IS-MEMBER M (SEQ!TAIL S))
   (IMPLIES
    (AND (>= N 1) (= M (SEQ!NTH (SEQ!TAIL S) N))
     (>= (SEQ!LENGTH (SEQ!TAIL S)) N))
    (SOME (N$0)
     (AND (>= N$0 1) (= M (SEQ!NTH S N$0))
      (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$0))))
   (SOME (N$1)
    (AND (>= N$1 1) (= M (SEQ!NTH S N$1))
     (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$1))))
  (SOME (N$2)
   (AND (>= N$2 1) (= M (SEQ!NTH S N$2))
    (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$2)))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S)
  (SEQ!IS-SEQUENCE (SEQ!TAIL S)))
 (IF (SEQ!IS-MEMBER M (SEQ!TAIL S))
  (IMPLIES
   (AND (>= N 1) (= M (SEQ!NTH (SEQ!TAIL S) N))
    (>= (SEQ!LENGTH (SEQ!TAIL S)) N))
   (SOME (N$0)
    (AND (>= N$0 1) (= M (SEQ!NTH S N$0))
     (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$0))))
  (SOME (N$1)
   (AND (>= N$1 1) (= M (SEQ!NTH S N$1))
    (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$1)))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S)
  (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)) (>= N 1)
  (= M (SEQ!NTH (SEQ!TAIL S) N)) (>= (SEQ!LENGTH (SEQ!TAIL S)) N))
 (SOME (N$0)
  (AND (>= N$0 1) (= M (SEQ!NTH S N$0))
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$0))))
Instantiating (= N$0 (+ N 1)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S)
  (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)) (>= N 1)
  (= M (SEQ!NTH (SEQ!TAIL S) N)) (>= (SEQ!LENGTH (SEQ!TAIL S)) N)
  (NOT
   (AND (>= (+ N 1) 1) (= M (SEQ!NTH S (+ N 1)))
    (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) (+ N 1)))))
 (SOME (N$0)
  (AND (>= N$0 1) (= M (SEQ!NTH S N$0))
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$0))))
Invoking (SEQ!NTH S (+ N 1)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S)
  (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)) (>= N 1)
  (= M (SEQ!NTH (SEQ!TAIL S) N)) (>= (SEQ!LENGTH (SEQ!TAIL S)) N)
  (NOT
   (AND (>= (+ N 1) 1)
    (= M
     (IF (>= (+ N 1) 2) (SEQ!NTH (SEQ!TAIL S) (- (+ N 1) 1)) (SEQ!HEAD S)))
    (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) (+ N 1)))))
 (SOME (N$0)
  (AND (>= N$0 1) (= M (SEQ!NTH S N$0))
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$0))))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S)
  (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (NOT (SEQ!IS-MEMBER M (SEQ!TAIL S))))
 (SOME (N$1)
  (AND (>= N$1 1) (= M (SEQ!NTH S N$1))
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$1))))
Invoking (SEQ!IS-MEMBER M S) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (SEQ!IS-TACK S)
  (OR (= M (SEQ!HEAD S)) (SEQ!IS-MEMBER M (SEQ!TAIL S)))
  (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (NOT (SEQ!IS-MEMBER M (SEQ!TAIL S))))
 (SOME (N)
  (AND (>= N 1) (= M (SEQ!NTH S N)) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (= M (SEQ!HEAD S))
  (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (NOT (SEQ!IS-MEMBER M (SEQ!TAIL S))))
 (SOME (N)
  (AND (>= N 1) (= M (SEQ!NTH S N)) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N))))
Instantiating (= N 1) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (= M (SEQ!HEAD S))
  (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (NOT (SEQ!IS-MEMBER M (SEQ!TAIL S)))
  (NOT
   (AND (>= 1 1) (= M (SEQ!NTH S 1)) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 1))))
 (SOME (N)
  (AND (>= N 1) (= M (SEQ!NTH S N)) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (= M (SEQ!HEAD S))
  (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (NOT (SEQ!IS-MEMBER M (SEQ!TAIL S)))
  (NOT
   (AND (>= 1 1)
    (= M (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S)))
    (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 1))))
 (SOME (N)
  (AND (>= N 1) (= M (SEQ!NTH S N)) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N))))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S)
  (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL S))))
 (SOME (N$2)
  (AND (>= N$2 1) (= M (SEQ!NTH S N$2))
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N$2))))
Invoking (SEQ!IS-SEQUENCE S) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S) 1)
  (IF (SEQ!IS-TACK S) (SEQ!IS-SEQUENCE (SEQ!TAIL S)) (= S (SEQ!EMPTY)))
  (SEQ!IS-MEMBER M S) (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL S))))
 (SOME (N)
  (AND (>= N 1) (= M (SEQ!NTH S N)) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (NOT (SEQ!IS-TACK S)) (SEQ!IS-SEQUENCE S) (SEQ!IS-MEMBER M S))
 (SOME (N) (AND (>= N 1) (= M (SEQ!NTH S N)) (<= N (SEQ!LENGTH S)))))
Invoking (SEQ!IS-MEMBER M S) gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-TACK S)) (SEQ!IS-SEQUENCE S) (SEQ!IS-TACK S)
  (OR (= M (SEQ!HEAD S)) (SEQ!IS-MEMBER M (SEQ!TAIL S))))
 (SOME (N) (AND (>= N 1) (= M (SEQ!NTH S N)) (>= (SEQ!LENGTH S) N))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
NTH-IS-MEMBER
Beginning proof of NTH-IS-MEMBER ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1) (<= N (SEQ!LENGTH SEQUENCE)))
 (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= N 2) (*P* (- N 1) (SEQ!TAIL SEQUENCE))) (*P* N SEQUENCE))
  (IMPLIES (NOT (>= N 2)) (*P* N SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= N 2)
   (IMPLIES
    (AND (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
     (<= (- N 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
    (SEQ!IS-MEMBER (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))
     (SEQ!TAIL SEQUENCE))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1) (<= N (SEQ!LENGTH SEQUENCE)))
   (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE)))
 (IMPLIES (NOT (>= N 2))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1) (<= N (SEQ!LENGTH SEQUENCE)))
   (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))))
Starting case 2 ...
(IMPLIES
 (AND (>= N 2)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (<= (- N 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!TAIL SEQUENCE)))
  (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1) (<= N (SEQ!LENGTH SEQUENCE)))
 (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
Rearranging gives ...
(IMPLIES
 (AND (>= N 2) (>= N 1) (SEQ!IS-SEQUENCE SEQUENCE)
  (<= N (SEQ!LENGTH SEQUENCE))
  (IMPLIES
   (AND (>= (- N 1) 1) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
    (<= (- N 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-MEMBER (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!TAIL SEQUENCE))))
 (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND (>= N 2) (>= N 1) (SEQ!IS-SEQUENCE SEQUENCE)
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) N)
  (IMPLIES
   (AND (>= (- N 1) 1) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N 1)))
   (SEQ!IS-MEMBER (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!TAIL SEQUENCE))))
 (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= N 2) (SEQ!IS-SEQUENCE SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N))
 (IF (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (SEQ!IS-MEMBER (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)) (SEQ!TAIL SEQUENCE))
   (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE)))
Starting case 2.2 ...
(IMPLIES
 (AND (>= N 2) (SEQ!IS-SEQUENCE SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
  (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)) (SEQ!TAIL SEQUENCE)))
 (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
Invoking (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE) gives ...
(IMPLIES
 (AND (>= N 2) (SEQ!IS-SEQUENCE SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
  (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)) (SEQ!TAIL SEQUENCE)))
 (AND (SEQ!IS-TACK SEQUENCE)
  (OR (= (SEQ!NTH SEQUENCE N) (SEQ!HEAD SEQUENCE))
   (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) (SEQ!TAIL SEQUENCE)))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 2) (SEQ!IS-SEQUENCE SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
  (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)) (SEQ!TAIL SEQUENCE))
  (NOT (= (SEQ!NTH SEQUENCE N) (SEQ!HEAD SEQUENCE))))
 (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) (SEQ!TAIL SEQUENCE)))
Invoking (SEQ!NTH SEQUENCE N) gives ...
(IMPLIES
 (AND (>= N 2) (SEQ!IS-SEQUENCE SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
  (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)) (SEQ!TAIL SEQUENCE))
  (NOT
   (= (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!HEAD SEQUENCE))
    (SEQ!HEAD SEQUENCE))))
 (SEQ!IS-MEMBER
  (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!HEAD SEQUENCE))
  (SEQ!TAIL SEQUENCE)))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= N 2) (SEQ!IS-SEQUENCE SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
  (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))))
 (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
Invoking (SEQ!IS-SEQUENCE SEQUENCE) gives ...
(IMPLIES
 (AND (>= N 2)
  (IF (SEQ!IS-TACK SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
   (= SEQUENCE (SEQ!EMPTY)))
  (>= (SEQ!LENGTH SEQUENCE) 1) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
  (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))))
 (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= N 2)) (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1)
  (<= N (SEQ!LENGTH SEQUENCE)))
 (SEQ!IS-MEMBER (SEQ!NTH SEQUENCE N) SEQUENCE))
Invoking (SEQ!NTH SEQUENCE N) gives ...
(IMPLIES
 (AND (NOT (>= N 2)) (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1)
  (>= (SEQ!LENGTH SEQUENCE) N))
 (SEQ!IS-MEMBER
  (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!HEAD SEQUENCE))
  SEQUENCE))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= N 2)) (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1)
  (>= (SEQ!LENGTH SEQUENCE) 1))
 (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) SEQUENCE))
Invoking (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= N 2)) (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1)
  (>= (SEQ!LENGTH SEQUENCE) 1))
 (AND (SEQ!IS-TACK SEQUENCE)
  (OR (= (SEQ!HEAD SEQUENCE) (SEQ!HEAD SEQUENCE))
   (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
LAST-IS-INITIAL
Beginning proof of LAST-IS-INITIAL ...
(IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
 (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (SEQ!TAIL SEQUENCE)))
   (*P* SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (IS-INITIAL-EVOLUTION-STATE
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-INITIAL-EVOLUTION-STATE
    (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE))
 (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))
Rearranging gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (IS-INITIAL-EVOLUTION-STATE
    (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))))
 (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))
Which simplifies
 when rewriting with IS-GOOD-EVOLUTION-TAIL
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (IS-INITIAL-EVOLUTION-STATE
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))
Invoking (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION SEQUENCE)
  (IS-INITIAL-EVOLUTION-STATE
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (IS-INITIAL-EVOLUTION-STATE
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (- (SEQ!LENGTH SEQUENCE) 1))
   (SEQ!HEAD SEQUENCE))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IS-INITIAL-EVOLUTION-STATE
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))
 (IS-INITIAL-EVOLUTION-STATE
  (IF
   (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
   (SEQ!NTH (SEQ!TAIL SEQUENCE)
    (- (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     1))
   (SEQ!HEAD SEQUENCE))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE))
 (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))
Invoking IS-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
 (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))
 (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE 1)))
Invoking IS-INITIAL-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))
 (= (HISTORY (SEQ!NTH SEQUENCE 1)) (SEQ!EMPTY)))
Invoking SEQ!NTH gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))
 (=
  (HISTORY
   (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE)))
  (SEQ!EMPTY)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
SUBSEQUENT-STATE-HAS-HISTORY
Beginning proof of SUBSEQUENT-STATE-HAS-HISTORY ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= (+ N 1) (SEQ!LENGTH SEQUENCE)))
 (>= (SEQ!LENGTH (HISTORY (SEQ!NTH SEQUENCE N))) 1))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (- N 1) (SEQ!TAIL SEQUENCE))
    (*P* N (SEQ!TAIL SEQUENCE)))
   (*P* N SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* N SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
     (<= (+ (- N 1) 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))) 1))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
     (<= (+ N 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))) 1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= (+ N 1) (SEQ!LENGTH SEQUENCE)))
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH SEQUENCE N))) 1)))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= (+ N 1) (SEQ!LENGTH SEQUENCE)))
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH SEQUENCE N))) 1))))
Invoking (SEQ!NTH SEQUENCE N) gives ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ (- N 1) 1)))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))) 1))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
     (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ N 1)))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))) 1))
   (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ N 1)))
  (>=
   (SEQ!LENGTH
    (HISTORY
     (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!HEAD SEQUENCE))))
   1))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
   (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ N 1)))
  (>=
   (SEQ!LENGTH
    (HISTORY
     (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!HEAD SEQUENCE))))
   1)))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND (>= (+ -1 N) 1) (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (ORD N)))
    (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N)))
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))) 1))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ 1 N)) (>= N 2))
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))) 1))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (AND (>= (+ -1 N) 1) (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (ORD N)))
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N)))
   (AND
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N)) (>= N 2))))
 (>= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))) 1))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
  (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (AND (>= (+ -1 N) 1) (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (ORD N)))
    (IF
     (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
      2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND
      (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
       1)
      (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (>= N 1)
    (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     (+ 1 N)))
   (AND
    (IF
     (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
      2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND
      (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
       1)
      (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (>= N 1)
    (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     (+ 1 N))
    (>= N 2))))
 (>= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))) 1))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
INITIAL-STATE-HAS-NO-HISTORY
Beginning proof of INITIAL-STATE-HAS-NO-HISTORY ...
(IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
 (= (HISTORY (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))) (SEQ!EMPTY)))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (SEQ!TAIL SEQUENCE)))
   (*P* SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (=
     (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
     (SEQ!EMPTY))))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (= (HISTORY (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))) (SEQ!EMPTY))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (= (HISTORY (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))) (SEQ!EMPTY)))))
Invoking (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)) gives ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (=
     (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
     (SEQ!EMPTY)))
   (IS-GOOD-EVOLUTION SEQUENCE))
  (=
   (HISTORY
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (- (SEQ!LENGTH SEQUENCE) 1))
     (SEQ!HEAD SEQUENCE)))
   (SEQ!EMPTY)))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE))
  (=
   (HISTORY
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (- (SEQ!LENGTH SEQUENCE) 1))
     (SEQ!HEAD SEQUENCE)))
   (SEQ!EMPTY))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IF (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND
    (=
     (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
     (SEQ!EMPTY))
    (IS-GOOD-EVOLUTION SEQUENCE))
   (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 (SEQ!LENGTH SEQUENCE))))
    (SEQ!EMPTY)))
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 (SEQ!LENGTH SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IF (>= (SEQ!LENGTH SEQUENCE) 2)
 (IMPLIES
  (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (AND
    (=
     (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
     (SEQ!EMPTY))
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
  (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 (SEQ!LENGTH SEQUENCE))))
   (SEQ!EMPTY)))
 (IMPLIES
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IF
 (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
 (IMPLIES
  (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (AND
    (=
     (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
     (SEQ!EMPTY))
    (IF
     (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
      2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND
      (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
       1)
      (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
   (IF
    (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND
     (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
      1)
     (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
  (=
   (HISTORY
    (SEQ!NTH (SEQ!TAIL SEQUENCE)
     (+ -1
      (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))))
   (SEQ!EMPTY)))
 (IMPLIES
  (IF
   (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND
    (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     1)
    (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
SPECIAL-INDUCTION2
Beginning proof of SPECIAL-INDUCTION2 ...
(IF (AND (>= (SEQ!LENGTH SEQUENCE) 1) (>= N1 2) (>= N2 2))
 (M< (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (SEQ!LENGTH SEQUENCE)) (TRUE))
Which simplifies
 with invocation of SEQ!LENGTH
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SUCC.INT, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
NO-DUPLICATES-IN-GOOD-EVOLUTION
Beginning proof of NO-DUPLICATES-IN-GOOD-EVOLUTION ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 1)
  (<= N1 (SEQ!LENGTH SEQUENCE)) (<= N2 (SEQ!LENGTH SEQUENCE))
  (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)))
 (= N1 N2))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (>= N1 2) (>= N2 2)
    (*P* (- N1 1) (- N2 1) (SEQ!TAIL SEQUENCE)))
   (*P* N1 N2 SEQUENCE))
  (IMPLIES (NOT (AND (>= (SEQ!LENGTH SEQUENCE) 1) (>= N1 2) (>= N2 2)))
   (*P* N1 N2 SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1) (>= N1 2) (>= N2 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N1 1) 1)
     (>= (- N2 1) 1) (<= (- N1 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
     (<= (- N2 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
     (= (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
      (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))))
    (= (- N1 1) (- N2 1))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 1)
    (<= N1 (SEQ!LENGTH SEQUENCE)) (<= N2 (SEQ!LENGTH SEQUENCE))
    (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)))
   (= N1 N2)))
 (IMPLIES (NOT (AND (>= (SEQ!LENGTH SEQUENCE) 1) (>= N1 2) (>= N2 2)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 1)
    (<= N1 (SEQ!LENGTH SEQUENCE)) (<= N2 (SEQ!LENGTH SEQUENCE))
    (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)))
   (= N1 N2))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1) (>= N1 2) (>= N2 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N1 1) 1)
    (>= (- N2 1) 1) (<= (- N1 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
    (<= (- N2 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
    (= (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1))))
   (= (- N1 1) (- N2 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 1)
  (<= N1 (SEQ!LENGTH SEQUENCE)) (<= N2 (SEQ!LENGTH SEQUENCE))
  (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)))
 (= N1 N2))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 2) (>= N2 2) (>= N1 1) (>= N2 1) (>= (SEQ!LENGTH SEQUENCE) 1)
  (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (<= N1 (SEQ!LENGTH SEQUENCE)) (<= N2 (SEQ!LENGTH SEQUENCE))
  (IMPLIES
   (AND (>= (- N1 1) 1) (>= (- N2 1) 1)
    (= (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)))
    (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (<= (- N1 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
    (<= (- N2 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))
   (= (- N1 1) (- N2 1))))
 (= N1 N2))
Which simplifies
 when rewriting with IS-GOOD-EVOLUTION-TAIL
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 2) (>= N2 2) (>= (SEQ!LENGTH SEQUENCE) 1)
  (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (SEQ!LENGTH SEQUENCE) N1) (>= (SEQ!LENGTH SEQUENCE) N2))
 (AND
  (= (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1))
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))
  (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N2)) (= N1 N2))))
Invoking (SEQ!NTH SEQUENCE N1) gives ...
(IMPLIES
 (AND (>= N1 2) (>= N2 2) (>= (SEQ!LENGTH SEQUENCE) 1)
  (= (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE))
   (SEQ!NTH SEQUENCE N2))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1)
  (>= (SEQ!LENGTH SEQUENCE) N2))
 (AND
  (= (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1))
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))
  (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N2)) (= N1 N2))))
Invoking (SEQ!NTH SEQUENCE N2) gives ...
(IMPLIES
 (AND (>= N1 2) (>= N2 2) (>= (SEQ!LENGTH SEQUENCE) 1)
  (= (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE))
   (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)) (SEQ!HEAD SEQUENCE)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1)
  (>= (SEQ!LENGTH SEQUENCE) N2))
 (AND
  (= (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1))
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))
  (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N2)) (= N1 N2))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND (>= N1 2) (>= N2 2)
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
  (= (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N1 1)) (SEQ!HEAD SEQUENCE))
   (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N2 1)) (SEQ!HEAD SEQUENCE)))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) N1)
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
   N2))
 (AND
  (= (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N1))
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N2)))
  (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N1))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N2)) (= N1 N2))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
>=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (AND (>= (SEQ!LENGTH SEQUENCE) 1) (>= N1 2) (>= N2 2)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 1)
  (<= N1 (SEQ!LENGTH SEQUENCE)) (<= N2 (SEQ!LENGTH SEQUENCE))
  (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)))
 (= N1 N2))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (IS-GOOD-EVOLUTION SEQUENCE) (<= N1 (SEQ!LENGTH SEQUENCE))
  (<= N2 (SEQ!LENGTH SEQUENCE))
  (NOT (AND (>= N1 2) (>= N2 2) (>= (SEQ!LENGTH SEQUENCE) 1))))
 (= N1 N2))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1)
  (>= (SEQ!LENGTH SEQUENCE) N2))
 (IF (>= N1 2) (>= N2 2) (= 1 N2)))
Starting case 1.2 ...
(IMPLIES
 (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1)
  (>= (SEQ!LENGTH SEQUENCE) N2) (>= N1 2))
 (>= N2 2))
Splitting on (>= N2 N1) generates ...
(IF (>= N2 N1)
 (IMPLIES
  (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
   (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1)
   (>= (SEQ!LENGTH SEQUENCE) N2) (>= N1 2))
  (>= N2 2))
 (IMPLIES
  (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
   (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1)
   (>= (SEQ!LENGTH SEQUENCE) N2) (>= N1 2))
  (>= N2 2)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= N2 N1)) (>= N1 1) (>= N2 1)
  (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (SEQ!LENGTH SEQUENCE) N1))
 (>= N2 2))
Assuming TIME-OF-EVENT-STRICTLY-INCREASES-2 with the
instantiations: (= N1 N2) (= N2 N1) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1) (>= N1 (+ N2 1))
    (<= (+ N1 1) (SEQ!LENGTH SEQUENCE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1)))) 1)))
  (NOT (>= N2 N1)) (>= N1 1) (>= N2 1)
  (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (SEQ!LENGTH SEQUENCE) N1))
 (>= N2 2))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (NOT (>= N2 N1)) (IS-GOOD-EVOLUTION SEQUENCE)
  (IMPLIES
   (AND (>= N2 1) (>= N1 (+ N2 1)) (IS-GOOD-EVOLUTION SEQUENCE)
    (<= (+ N1 1) (SEQ!LENGTH SEQUENCE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1)))) 1))))
 (>= N2 2))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (NOT (>= N2 N1)) (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N1))))
 (>= N2 2))
Assuming LAST-IS-INITIAL with the
instantiations: (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))
  (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (NOT (>= N2 N1)) (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N1))))
 (>= N2 2))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE)
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)))
  (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (NOT (>= N2 N1))
  (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N1))))
 (>= N2 2))
Assuming SUBSEQUENT-STATE-HAS-HISTORY with the
instantiations: (= N N2) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1)
    (<= (+ N2 1) (SEQ!LENGTH SEQUENCE)))
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH SEQUENCE N2))) 1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)))
  (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (NOT (>= N2 N1))
  (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N1))))
 (>= N2 2))
Assuming INITIAL-STATE-HAS-NO-HISTORY with the
instantiations: (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (= (HISTORY (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))) (SEQ!EMPTY)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N2 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N2 1)))
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH SEQUENCE N2))) 1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)))
  (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (NOT (>= N2 N1))
  (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N1))))
 (>= N2 2))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1)
  (>= (SEQ!LENGTH SEQUENCE) N2) (NOT (>= N1 2)))
 (= 1 N2))
Splitting on (>= N1 N2) generates ...
(IF (>= N1 N2)
 (IMPLIES
  (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
   (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1)
   (>= (SEQ!LENGTH SEQUENCE) N2) (NOT (>= N1 2)))
  (= 1 N2))
 (IMPLIES
  (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
   (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) N1)
   (>= (SEQ!LENGTH SEQUENCE) N2) (NOT (>= N1 2)))
  (= 1 N2)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= N1 N2)) (>= N1 1) (>= N2 1)
  (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (SEQ!LENGTH SEQUENCE) N1) (>= (SEQ!LENGTH SEQUENCE) N2))
 (>= N1 2))
Assuming TIME-OF-EVENT-STRICTLY-INCREASES-2 with the
instantiations: (= N1 N1) (= N2 N2) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1) (>= N2 (+ N1 1))
    (<= (+ N2 1) (SEQ!LENGTH SEQUENCE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))) 1)))
  (NOT (>= N1 N2)) (>= N1 1) (>= N2 1)
  (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (>= (SEQ!LENGTH SEQUENCE) N1) (>= (SEQ!LENGTH SEQUENCE) N2))
 (>= N1 2))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (>= (SEQ!LENGTH SEQUENCE) N2) (NOT (>= N1 N2))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IMPLIES
   (AND (>= N1 1) (>= N2 (+ N1 1)) (IS-GOOD-EVOLUTION SEQUENCE)
    (<= (+ N2 1) (SEQ!LENGTH SEQUENCE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N1))))
    (+ (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N2)))) 1))))
 (>= N1 2))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (>= (SEQ!LENGTH SEQUENCE) N2) (NOT (>= N1 N2))
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N2))))
 (>= N1 2))
Assuming LAST-IS-INITIAL with the
instantiations: (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))
  (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (>= (SEQ!LENGTH SEQUENCE) N2) (NOT (>= N1 N2))
  (IS-GOOD-EVOLUTION SEQUENCE) (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N2))))
 (>= N1 2))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE)
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)))
  (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (>= (SEQ!LENGTH SEQUENCE) N2) (NOT (>= N1 N2))
  (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N2))))
 (>= N1 2))
Assuming SUBSEQUENT-STATE-HAS-HISTORY with the
instantiations: (= N N1) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1)
    (<= (+ N1 1) (SEQ!LENGTH SEQUENCE)))
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH SEQUENCE N1))) 1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)))
  (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (>= (SEQ!LENGTH SEQUENCE) N2) (NOT (>= N1 N2))
  (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N2))))
 (>= N1 2))
Assuming INITIAL-STATE-HAS-NO-HISTORY with the
instantiations: (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (= (HISTORY (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))) (SEQ!EMPTY)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N1 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N1 1)))
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH SEQUENCE N1))) 1))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE)))
  (>= N1 1) (>= N2 1) (= (SEQ!NTH SEQUENCE N1) (SEQ!NTH SEQUENCE N2))
  (>= (SEQ!LENGTH SEQUENCE) N1) (>= (SEQ!LENGTH SEQUENCE) N2) (NOT (>= N1 N2))
  (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N2))))
 (>= N1 2))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
HEAD-OF-GOOD-EVOLUTION-NOT-IN-TAIL
Beginning proof of HEAD-OF-GOOD-EVOLUTION-NOT-IN-TAIL ...
(IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
 (NOT (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M (SEQ!HEAD SEQUENCE)) (= S (SEQ!TAIL SEQUENCE)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
    (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))
   (SOME (N)
    (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
     (<= N (SEQ!LENGTH (SEQ!TAIL SEQUENCE))))))
  (IS-GOOD-EVOLUTION SEQUENCE))
 (NOT (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
    (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))
   (SOME (N)
    (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
     (<= N (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))))))
 (NOT (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
 (IF (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (IMPLIES (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
   (NOT
    (SOME (N)
     (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
      (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))))
  (NOT (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))))
Starting case 2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))
 (NOT
  (SOME (N)
   (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))
 (NOT
  (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
   (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)) (>= N 1)
  (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N)))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Assuming NO-DUPLICATES-IN-GOOD-EVOLUTION with the
instantiations: (= N1 1) (= N2 (+ N 1)) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= 1 1) (>= (+ N 1) 1)
    (<= 1 (SEQ!LENGTH SEQUENCE)) (<= (+ N 1) (SEQ!LENGTH SEQUENCE))
    (= (SEQ!NTH SEQUENCE 1) (SEQ!NTH SEQUENCE (+ N 1))))
   (= 1 (+ N 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)) (>= N 1)
  (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N)))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND (>= 1 1) (>= (+ N 1) 1)
    (= (SEQ!NTH SEQUENCE 1) (SEQ!NTH SEQUENCE (+ N 1)))
    (IS-GOOD-EVOLUTION SEQUENCE) (<= 1 (SEQ!LENGTH SEQUENCE))
    (<= (+ N 1) (SEQ!LENGTH SEQUENCE)))
   (= 1 (+ N 1))))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))
 (IF (= (SEQ!NTH SEQUENCE 1) (SEQ!NTH SEQUENCE (+ 1 N)))
  (IF (>= (SEQ!LENGTH SEQUENCE) 1)
   (OR (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
    (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
   (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (= (SEQ!NTH SEQUENCE 1) (SEQ!NTH SEQUENCE (+ 1 N))))
 (IF (>= (SEQ!LENGTH SEQUENCE) 1)
  (OR (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
   (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (= (SEQ!NTH SEQUENCE 1) (SEQ!NTH SEQUENCE (+ 1 N)))
  (>= (SEQ!LENGTH SEQUENCE) 1) (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (= (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (>= (SEQ!LENGTH SEQUENCE) 1) (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (= (SEQ!HEAD SEQUENCE) (SEQ!NTH SEQUENCE (+ 1 N)))
  (>= (SEQ!LENGTH SEQUENCE) 1) (NOT (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (= (SEQ!HEAD SEQUENCE) (SEQ!NTH SEQUENCE (+ 1 N)))
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
  (NOT
   (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
    (+ 1 N))))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, TAIL-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (= (SEQ!NTH SEQUENCE 1) (SEQ!NTH SEQUENCE (+ 1 N)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 1)))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Invoking IS-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (= (SEQ!NTH SEQUENCE 1) (SEQ!NTH SEQUENCE (+ 1 N)))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 1)))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (NOT (= (SEQ!NTH SEQUENCE 1) (SEQ!NTH SEQUENCE (+ 1 N)))))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (NOT
   (= (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (NOT (= (SEQ!HEAD SEQUENCE) (SEQ!NTH SEQUENCE (+ 1 N)))))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Invoking (SEQ!NTH SEQUENCE (+ 1 N)) gives ...
(IMPLIES
 (AND (>= N 1) (= (SEQ!HEAD SEQUENCE) (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (IF (>= (+ 1 N) 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- (+ 1 N) 1))
     (SEQ!HEAD SEQUENCE)))))
 (NOT (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK to
...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))))
 (NOT (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))))
Invoking IS-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL SEQUENCE))))
 (NOT (SEQ!IS-MEMBER (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
NON-LAST-IS-NON-INITIAL
Beginning proof of NON-LAST-IS-NON-INITIAL ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
 (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (- N 1) (SEQ!TAIL SEQUENCE))
    (*P* N (SEQ!TAIL SEQUENCE)))
   (*P* N SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* N SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
     (<= (- N 1) (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
     (<= N (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N)))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (<= (- N 1) (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (<= N (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
 (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) (- N 1)))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) N))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
 (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
Invoking (SEQ!NTH SEQUENCE N) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) (- N 1)))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) N))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
 (NOT
  (IS-INITIAL-EVOLUTION-STATE
   (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (>= (+ -1 N) 1)
  (IMPLIES
   (AND (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N 1)
    (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
  (IMPLIES (>= N 1)
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
    (IMPLIES
     (AND (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))))
    (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (>= (+ -1 N) 1)
  (IMPLIES
   (AND (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)) (>= N 1)
    (>=
     (+ -1
      (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
     N))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
  (IMPLIES
   (AND (>= N 1)
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
     (AND (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1))
 (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (IMPLIES
   (AND (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))))
  (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))))))
Invoking (IS-INITIAL-EVOLUTION-STATE (SEQ!HEAD SEQUENCE)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (AND (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
 (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1))
 (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (IMPLIES
   (AND (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
  (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
   (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
 (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!HEAD SEQUENCE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE
       (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (= (SEQ!HEAD SEQUENCE)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))))
 (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!HEAD SEQUENCE)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (= (SEQ!HEAD SEQUENCE)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
  (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY)))))
Substituting (= (SEQ!HEAD SEQUENCE)
              (INTRUDER-STEP LABEL TIME MESSAGE
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY)))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!NOT-IS-TACK-FACTS, SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
TAG-OF-MAKE-INTRUDER-EVENT, MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT, TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
 (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!HEAD SEQUENCE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
       (= (SEQ!HEAD SEQUENCE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE
       (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (= (SEQ!HEAD SEQUENCE)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))))
 (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
  (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!HEAD SEQUENCE)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (= (SEQ!HEAD SEQUENCE)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE
     (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (= (SEQ!HEAD SEQUENCE)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))))
 (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))))
 (OR (NOT (>= (SEQ!LENGTH SEQUENCE) 1))
  (NOT (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (>= (+ -1 N) 1) (NOT (>= N 1))
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (NOT (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (NOT
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY)))))
Substituting (= (SEQ!HEAD SEQUENCE)
              (INTRUDER-STEP LABEL TIME MESSAGE
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
             (= (SEQ!HEAD SEQUENCE)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (= (SEQ!HEAD SEQUENCE)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE
    (ALL-MESSAGES-IN-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!HEAD SEQUENCE)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 1)
   (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
   (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
   (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1))
   (IS-GOOD-STATE (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (TIME-CONSTRAINT TIME (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (= (SEQ!HEAD SEQUENCE)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (NOT
   (=
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (SEQ!EMPTY)))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!NOT-IS-TACK-FACTS, SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
TAG-OF-MAKE-INTRUDER-EVENT, MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT, TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
 (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
NON-INITIAL-IS-NON-LAST
Beginning proof of NON-INITIAL-IS-NON-LAST ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (SEQ!LENGTH SEQUENCE))
  (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
 (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (- N 1) (SEQ!TAIL SEQUENCE))
    (*P* N (SEQ!TAIL SEQUENCE)))
   (*P* N SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* N SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
     (<= (- N 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
     (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))))
    (<= (- N 1) (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
     (<= N (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
     (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
    (<= N (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (SEQ!LENGTH SEQUENCE))
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
   (<= N (- (SEQ!LENGTH SEQUENCE) 1))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (SEQ!LENGTH SEQUENCE))
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
   (<= N (- (SEQ!LENGTH SEQUENCE) 1)))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (<= (- N 1) (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))))
   (<= (- N 1) (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (<= N (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
   (<= N (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (SEQ!LENGTH SEQUENCE))
  (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
 (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N 1))
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))))
   (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) (- N 1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
   (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) N))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
  (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
 (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
Invoking (SEQ!NTH SEQUENCE N) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (- N 1))
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)))))
   (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) (- N 1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N)
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
   (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) N))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
  (NOT
   (IS-INITIAL-EVOLUTION-STATE
    (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!HEAD SEQUENCE)))))
 (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (>= (+ -1 N) 1))
 (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N))
  (IMPLIES
   (AND
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))
    (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N)) (>= N 1))
   (IF (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
    (IMPLIES
     (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
      (>= (SEQ!LENGTH SEQUENCE) N))
     (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
    (IMPLIES
     (AND (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
      (>= (SEQ!LENGTH SEQUENCE) N))
     (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))))
  (IMPLIES
   (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
    (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N) 1))
 (IF (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ -1 N))
  (IMPLIES
   (AND
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))
    (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N)) (>= N 1)
    (IF (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
     (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
      (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
       N))
     (AND (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
      (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
       N))))
   (>=
    (+ -1
     (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
    N))
  (IMPLIES
   (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
    (>= N 1)
    (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     N)
    (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
   (>=
    (+ -1
     (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
    N))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= N (SEQ!LENGTH SEQUENCE))
  (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
 (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
Assuming LAST-IS-INITIAL with the
instantiations: (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
   (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE (SEQ!LENGTH SEQUENCE))))
  (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (SEQ!LENGTH SEQUENCE) N)
  (NOT (IS-INITIAL-EVOLUTION-STATE (SEQ!NTH SEQUENCE N))))
 (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
NON-INITIAL-STATE-IS-RESULT-OF-STEP
Beginning proof of NON-INITIAL-STATE-IS-RESULT-OF-STEP ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
 (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (- N 1) (SEQ!TAIL SEQUENCE))
    (*P* N (SEQ!TAIL SEQUENCE)))
   (*P* N SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* N SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
     (<= (- N 1) (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
    (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ (- N 1) 1))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
     (<= N (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
    (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ N 1))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (<= (- N 1) (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
   (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ (- N 1) 1))
    (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (<= N (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
   (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ N 1))
    (SEQ!NTH (SEQ!TAIL SEQUENCE) N)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
 (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) (- N 1)))
   (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ (- N 1) 1))
    (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) N))
   (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ N 1))
    (SEQ!NTH (SEQ!TAIL SEQUENCE) N)))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
 (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
Invoking (SEQ!NTH SEQUENCE N) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) (- N 1)))
   (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ (- N 1) 1))
    (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) N))
   (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ N 1))
    (SEQ!NTH (SEQ!TAIL SEQUENCE) N)))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
 (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1))
  (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (>= (+ -1 N) 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
   (IMPLIES
    (AND
     (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (ORD N))
      (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))
     (>= N 1))
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
     (IMPLIES
      (AND
       (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ 1 N))
        (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
       (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
       (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
      (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N))
       (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))
     (IMPLIES
      (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
       (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
      (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N))
       (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))))
   (IMPLIES
    (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
    (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
  (IMPLIES (>= N 1)
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
    (IMPLIES
     (AND
      (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) 2)
       (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (GOOD-STEP (SEQ!NTH SEQUENCE 2) (SEQ!HEAD SEQUENCE)))
    (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (GOOD-STEP (SEQ!NTH SEQUENCE 2) (SEQ!HEAD SEQUENCE)))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (>= (+ -1 N) 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
   (IMPLIES
    (AND
     (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (ORD N))
      (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))
     (>= N 1)
     (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
      (AND
       (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ 1 N))
        (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
       (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
       (>=
        (+ -1
         (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
        N))
      (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
       (>=
        (+ -1
         (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
        N))))
    (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))
   (IMPLIES
    (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (>= N 1)
     (>=
      (+ -1
       (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
      N))
    (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
  (IMPLIES
   (AND (>= N 1)
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
     (AND
      (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) 2)
       (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
   (GOOD-STEP (SEQ!NTH SEQUENCE 2) (SEQ!HEAD SEQUENCE)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (>= (+ -1 N) 1)
  (IMPLIES
   (AND (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
    (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (ORD N))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))
    (>= N 1))
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
    (IMPLIES
     (AND
      (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ 1 N))
       (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N))
      (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))
    (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N))
      (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))))
  (IMPLIES (>= N 1)
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
    (IMPLIES
     (AND
      (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) 2)
       (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (GOOD-STEP (SEQ!NTH SEQUENCE 2) (SEQ!HEAD SEQUENCE)))
    (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (GOOD-STEP (SEQ!NTH SEQUENCE 2) (SEQ!HEAD SEQUENCE)))))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N) 1)
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
  (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (ORD N))
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))
  (>= N 1))
 (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
  (IMPLIES
   (AND
    (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ 1 N))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N))
    (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))
  (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N))
    (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))))
Invoking (SEQ!NTH SEQUENCE (+ 1 N)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N) 1)
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
  (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (ORD N))
   (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))
  (>= N 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
   (AND
    (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ 1 N))
     (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
 (GOOD-STEP
  (IF (>= (+ 1 N) 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- (+ 1 N) 1))
   (SEQ!HEAD SEQUENCE))
  (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1))
 (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (IMPLIES
   (AND
    (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) 2)
     (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!NTH SEQUENCE 2) (SEQ!HEAD SEQUENCE)))
  (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
   (GOOD-STEP (SEQ!NTH SEQUENCE 2) (SEQ!HEAD SEQUENCE)))))
Invoking (SEQ!NTH SEQUENCE 2) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (AND
    (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) 2)
     (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
 (GOOD-STEP
  (IF (>= 2 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 2 1)) (SEQ!HEAD SEQUENCE))
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1))
 (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (IMPLIES
   (AND
    (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) 2)
     (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) 1) (SEQ!HEAD SEQUENCE)))
  (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
   (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) 1) (SEQ!HEAD SEQUENCE)))))
Invoking (SEQ!NTH (SEQ!TAIL SEQUENCE) 1) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (AND
    (GOOD-STEP (SEQ!NTH (SEQ!TAIL SEQUENCE) 2)
     (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- 1 1))
      (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
 (GOOD-STEP
  (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- 1 1))
   (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
 (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
SEND-EVENT-THEOREM
Beginning proof of SEND-EVENT-THEOREM ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ N 1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Assuming NON-INITIAL-STATE-IS-RESULT-OF-STEP with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ N 1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N)) (SEQ!NTH SEQUENCE N))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!NTH SEQUENCE N)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
      (= (SEQ!NTH SEQUENCE N)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!NTH SEQUENCE N)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (= (SEQ!NTH SEQUENCE N)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Substituting (= (SEQ!NTH SEQUENCE N)
              (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!NTH SEQUENCE (+ 1 N)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Trivially rewrites using HISTORY-OF-OUT-OF-BAND-STEP,
HISTORY-OF-CONSTRUCT-STEP, HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP,
HISTORY-OF-GENERATE-STEP, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION to ...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (SEND-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Which simplifies
 when rewriting with MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!IS-FRESH-ATOMIC, MS!PRINCIPAL-ATOMIC
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, SEQ!TACK-HEAD-TAIL,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
  (= (SEQ!NTH SEQUENCE N)
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) (SEND-EVENTS)))
 (FORGEABLE MESSAGE
  (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
  (= (SEQ!NTH SEQUENCE N)
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) (SEND-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (SEEN-MESSAGES
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Applying SEEN-MESSAGES-SEND-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
  (= (SEQ!NTH SEQUENCE N)
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) (SEND-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (IF
    (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
     (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
    (SETADD MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (= (SEQ!NTH SEQUENCE N)
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) (SEND-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (IF
    (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
     (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (MS!KNOWN-IN MESSAGE
      (UNION (STORAGE-OF PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
    (SETADD MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with MS!A7, SETADD.DEFINITION, SETRULES!SETADD-UNION-LEFT,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
RECEIVE-EVENT-THEOREM
Beginning proof of RECEIVE-EVENT-THEOREM ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
 (AND
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ N 1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Assuming NON-INITIAL-STATE-IS-RESULT-OF-STEP with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
 (AND
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ N 1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N)) (SEQ!NTH SEQUENCE N))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
 (AND
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!NTH SEQUENCE N)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
      (= (SEQ!NTH SEQUENCE N)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
 (AND
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!NTH SEQUENCE N)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (= (SEQ!NTH SEQUENCE N)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
 (AND
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Substituting (= (SEQ!NTH SEQUENCE N)
              (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!NTH SEQUENCE (+ 1 N)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Trivially rewrites using HISTORY-OF-OUT-OF-BAND-STEP,
HISTORY-OF-CONSTRUCT-STEP, HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP,
HISTORY-OF-GENERATE-STEP, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION to ...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (RECEIVE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Which simplifies
 when rewriting with MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!IS-FRESH-ATOMIC, MS!PRINCIPAL-ATOMIC
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, SEQ!TACK-HEAD-TAIL,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
  (= (SEQ!NTH SEQUENCE N)
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0) (RECEIVE-EVENTS)))
 (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0
  (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
  (= (SEQ!NTH SEQUENCE N)
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0) (RECEIVE-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (STORAGE-OF PRINCIPAL$0
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Applying STORAGE-OF-RECEIVE-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
  (= (SEQ!NTH SEQUENCE N)
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0) (RECEIVE-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (IF (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (IF
     (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
      (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
      (IN PRINCIPAL$0 (MS!PRINCIPALS))
      (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
      (= PRINCIPAL$0 PRINCIPAL$0))
     (SETADD MESSAGE (STORAGE-OF PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
     (STORAGE-OF PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
    (STORAGE-OF PRINCIPAL$0
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with SETRULES!SETADD-UNION-LEFT, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, TAG-OF-RECEIVE-EVENT,
RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
  (= (SEQ!NTH SEQUENCE N)
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0) (RECEIVE-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (SETADD MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS)
      (STORAGE-OF PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (= (SEQ!NTH SEQUENCE N)
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0) (RECEIVE-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (SETADD MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS)
      (STORAGE-OF PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))))))
Which simplifies
 when rewriting with MS!A7, SETADD.DEFINITION, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
OUT-OF-BAND-EVENT-THEOREM
Beginning proof of OUT-OF-BAND-EVENT-THEOREM ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ N 1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Assuming NON-INITIAL-STATE-IS-RESULT-OF-STEP with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ N 1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N)) (SEQ!NTH SEQUENCE N))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!NTH SEQUENCE N)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
      (= (SEQ!NTH SEQUENCE N)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!NTH SEQUENCE N)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (= (SEQ!NTH SEQUENCE N)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Substituting (= (SEQ!NTH SEQUENCE N)
              (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!NTH SEQUENCE (+ 1 N)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Trivially rewrites using HISTORY-OF-OUT-OF-BAND-STEP,
HISTORY-OF-CONSTRUCT-STEP, HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP,
HISTORY-OF-GENERATE-STEP, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION to ...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (OUT-OF-BAND-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL2-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Which simplifies
 when rewriting with MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!IS-FRESH-ATOMIC, MS!PRINCIPAL-ATOMIC
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, SEQ!TACK-HEAD-TAIL,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
  (= (SEQ!NTH SEQUENCE N)
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
   (OUT-OF-BAND-EVENTS)))
 (KNOWN-BY-PRINCIPAL MESSAGE RECEIVER
  (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
   (SEQ!NTH SEQUENCE (+ 1 N)))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (= (SEQ!NTH SEQUENCE N)
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
   (OUT-OF-BAND-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (STORAGE-OF RECEIVER
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Applying STORAGE-OF-OUT-OF-BAND-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (= (SEQ!NTH SEQUENCE N)
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
   (OUT-OF-BAND-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (IF (IN RECEIVER (MS!PRINCIPALS))
    (IF
     (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
      (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
      (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
      (= RECEIVER RECEIVER))
     (SETADD MESSAGE (STORAGE-OF RECEIVER (SEQ!NTH SEQUENCE (+ 1 N))))
     (STORAGE-OF RECEIVER (SEQ!NTH SEQUENCE (+ 1 N))))
    (STORAGE-OF RECEIVER
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (= (SEQ!NTH SEQUENCE N)
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))
  (IN (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
   (OUT-OF-BAND-EVENTS)))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (IF (IN RECEIVER (MS!PRINCIPALS))
    (IF
     (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
      (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
      (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
      (MS!KNOWN-IN MESSAGE
       (UNION (STORAGE-OF SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
        (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
      (= RECEIVER RECEIVER))
     (SETADD MESSAGE (STORAGE-OF RECEIVER (SEQ!NTH SEQUENCE (+ 1 N))))
     (STORAGE-OF RECEIVER (SEQ!NTH SEQUENCE (+ 1 N))))
    (STORAGE-OF RECEIVER
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with MS!A7, SETADD.DEFINITION, SETRULES!SETADD-UNION-LEFT,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
GENERATE-EVENT-THEOREM
Beginning proof of GENERATE-EVENT-THEOREM ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ N 1))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Assuming NON-INITIAL-STATE-IS-RESULT-OF-STEP with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ N 1))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Which simplifies
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N)) (SEQ!NTH SEQUENCE N))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!NTH SEQUENCE N)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
      (= (SEQ!NTH SEQUENCE N)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!NTH SEQUENCE N)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (= (SEQ!NTH SEQUENCE N)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Substituting (= (SEQ!NTH SEQUENCE N)
              (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!NTH SEQUENCE (+ 1 N)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Trivially rewrites using HISTORY-OF-OUT-OF-BAND-STEP,
HISTORY-OF-CONSTRUCT-STEP, HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP,
HISTORY-OF-GENERATE-STEP, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION to ...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Which simplifies
 when rewriting with MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!IS-FRESH-ATOMIC, MS!PRINCIPAL-ATOMIC
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= (SEQ!NTH SEQUENCE N)
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$1
  (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= (SEQ!NTH SEQUENCE N)
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (STORAGE-OF PRINCIPAL$1
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Applying STORAGE-OF-GENERATE-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= (SEQ!NTH SEQUENCE N)
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (IF (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (IF
     (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
      (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
      (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
      (IN PRINCIPAL$1 (MS!PRINCIPALS)) (= PRINCIPAL$1 PRINCIPAL$1))
     (SETADD MESSAGE (STORAGE-OF PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
     (STORAGE-OF PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
    (STORAGE-OF PRINCIPAL$1
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with MS!B5, SETADD.DEFINITION, MS!D2-RULE,
SETRULES!SETADD-UNION-LEFT, UNION.COMMUTATIVE, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
CONSTRUCT-EVENT-THEOREM
Beginning proof of CONSTRUCT-EVENT-THEOREM ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL
  (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (SEQ!NTH SEQUENCE (+ N 1))))
Assuming NON-INITIAL-STATE-IS-RESULT-OF-STEP with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL
  (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (SEQ!NTH SEQUENCE (+ N 1))))
Which simplifies
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N)) (SEQ!NTH SEQUENCE N))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL
  (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (SEQ!NTH SEQUENCE (+ 1 N))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!NTH SEQUENCE N)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
      (= (SEQ!NTH SEQUENCE N)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL
  (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (SEQ!NTH SEQUENCE (+ 1 N))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!NTH SEQUENCE N)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (= (SEQ!NTH SEQUENCE N)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL
  (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (SEQ!NTH SEQUENCE (+ 1 N))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))))
Substituting (= (SEQ!NTH SEQUENCE N)
              (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!NTH SEQUENCE (+ 1 N)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N)))))
Trivially rewrites using HISTORY-OF-OUT-OF-BAND-STEP,
HISTORY-OF-CONSTRUCT-STEP, HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP,
HISTORY-OF-GENERATE-STEP, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION to ...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (PRINCIPAL1-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEQ!NTH SEQUENCE (+ 1 N)))))
Which simplifies
 when rewriting with MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!IS-FRESH-ATOMIC, MS!PRINCIPAL-ATOMIC
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT, SEQ!TACK-HEAD-TAIL,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
INTRUDER-EVENT-THEOREM
Beginning proof of INTRUDER-EVENT-THEOREM ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ N 1))))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Assuming NON-INITIAL-STATE-IS-RESULT-OF-STEP with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ N 1))))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Which simplifies
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N)) (SEQ!NTH SEQUENCE N))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE
        (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!NTH SEQUENCE N)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
      (= (SEQ!NTH SEQUENCE N)
       (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!NTH SEQUENCE N)
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (= (SEQ!NTH SEQUENCE N)
     (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
 (AND
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))))
Substituting (= (SEQ!NTH SEQUENCE N)
              (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               (SEQ!NTH SEQUENCE (+ 1 N)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (MS!IS-FRESH
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
       (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Trivially rewrites using HISTORY-OF-OUT-OF-BAND-STEP,
HISTORY-OF-CONSTRUCT-STEP, HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP,
HISTORY-OF-GENERATE-STEP, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION to ...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
       (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN MESSAGE (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
        (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
        (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
        (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
        (MS!IS-FRESH MESSAGE
         (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
        (IN PRINCIPAL$1 (MS!PRINCIPALS)))
       (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$0 (MS!PRINCIPALS))
        (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN PRINCIPAL$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (AND
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PRINCIPALS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!TEXT-MESSAGES))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (MS!PUBLIC-KEYS))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH
    (MESSAGE-OF-EVENT
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
        (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
        (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
       (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
        (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
    (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SEQ!TACK (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS)))
      (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (SEND-STEP LABEL TIME MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
    (INTRUDER-EVENTS)))
  (FORGEABLE
   (MESSAGE-OF-EVENT
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
       (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))
      (HISTORY (SEQ!NTH SEQUENCE (+ 1 N))))))
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Which simplifies
 when rewriting with MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!IS-FRESH-ATOMIC, MS!PRINCIPAL-ATOMIC
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
  (= (SEQ!NTH SEQUENCE N)
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (FORGEABLE MESSAGE
  (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
  (= (SEQ!NTH SEQUENCE N)
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (MS!KNOWN-IN MESSAGE
  (UNION
   (SEEN-MESSAGES
    (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Trivially rewrites using UNION.COMMUTATIVE, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION,
SEEN-MESSAGES-INTRUDER-STEP to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
  (= (SEQ!NTH SEQUENCE N)
   (INTRUDER-STEP LABEL TIME MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
 (MS!KNOWN-IN MESSAGE
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS)
     (IF
      (AND (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
       (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
       (IN MESSAGE (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE (MS!PRINCIPALS))
       (MS!IS-FRESH MESSAGE (MS!TEXT-MESSAGES))
       (MS!IS-FRESH MESSAGE (MS!PUBLIC-KEYS))
       (MS!IS-FRESH MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
       (MS!IS-FRESH MESSAGE
        (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N))))))
      (SETADD MESSAGE (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
      (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N)))))))))
Which simplifies
 when rewriting with MS!B5, SETADD.DEFINITION, MS!D2-RULE,
SETRULES!SETADD-UNION-RIGHT, MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!IS-FRESH-ATOMIC, MS!PRINCIPAL-ATOMIC
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
EFFECTIVE-GENERATE-STEP
Beginning proof of EFFECTIVE-GENERATE-STEP ...
(IMPLIES
 (AND (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL S0)) (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
  (IN PRINCIPAL (MS!PRINCIPALS))))
Invoking GENERATE-STEP gives ...
(IMPLIES
 (AND
  (= S1
   (IF
    (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
     (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
     (IN PRINCIPAL (MS!PRINCIPALS)))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      S0))
    S0))
  (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
  (IN PRINCIPAL (MS!PRINCIPALS))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
FORGEABLE-PRESERVED-BY-GENERATE-STEP
Beginning proof of FORGEABLE-PRESERVED-BY-GENERATE-STEP ...
(= (FORGEABLE M1 (GENERATE-STEP LABEL TIME M2 PRINCIPAL STATE))
 (FORGEABLE M1 STATE))
Invoking GENERATE-STEP gives ...
(=
 (FORGEABLE M1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN M2 (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH M2 (ALL-MESSAGES-IN-STATE STATE))
    (IN PRINCIPAL (MS!PRINCIPALS)))
   (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL)
     STATE))
   STATE))
 (FORGEABLE M1 STATE))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (IN PRINCIPAL (MS!PRINCIPALS)))
 (=
  (FORGEABLE M1
   (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL)
     STATE)))
  (FORGEABLE M1 STATE)))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (IN PRINCIPAL (MS!PRINCIPALS)))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (SEEN-MESSAGES
     (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL)
       STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE,
SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY, SEEN-MESSAGES-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GENERATE-STEP
Beginning proof of KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GENERATE-STEP ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
  (TRUE)))
Invoking GENERATE-STEP gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN M2 (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH M2 (ALL-MESSAGES-IN-STATE STATE))
    (IN PRINCIPAL2 (MS!PRINCIPALS)))
   (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2)
     STATE))
   STATE)))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (IN PRINCIPAL2 (MS!PRINCIPALS)))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
  (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
   (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2)
    STATE))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL1 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (IN PRINCIPAL2 (MS!PRINCIPALS)))
 (MS!KNOWN-IN M1
  (UNION
   (STORAGE-OF PRINCIPAL1
    (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2)
      STATE)))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with MS!KNOWN-IN-OF-SETADD, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT,
STORAGE-OF-ADD-TO-STATE-HISTORY, STORAGE-OF-ADD-TO-STATE-STORAGE,
IS-GOOD-STATE-ADD-TO-STATE-HISTORY, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
FRESH-IN-STORAGE-OF-PRINCIPAL
Beginning proof of FRESH-IN-STORAGE-OF-PRINCIPAL ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES STATE))))
 (= (MS!IS-FRESH MESSAGE (STORAGE-OF PRINCIPAL STATE)) (TRUE)))
Invoking ALL-STORAGE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE)))))
 (MS!IS-FRESH MESSAGE (STORAGE-OF PRINCIPAL STATE)))
Invoking STORAGE-OF gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE)))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Assuming MS!IS-FRESH-SUBSET with the
instantiations: (= K MESSAGE) (= S1 (CUP (REL!RAN (STORES STATE))))
                (= S2 (FN!APPLY (STORES STATE) PRINCIPAL)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
    (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL)
     (CUP (REL!RAN (STORES STATE)))))
   (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE)))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
  (IMPLIES
   (AND (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
    (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL)
     (CUP (REL!RAN (STORES STATE)))))
   (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
  (NOT
   (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL)
    (CUP (REL!RAN (STORES STATE))))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Invoking SUBSET gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
  (NOT
   (ALL (E)
    (IMPLIES (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
     (IN E (CUP (REL!RAN (STORES STATE))))))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Which simplifies
 when rewriting with CUP.DEFINITION
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
  (NOT
   (ALL (E)
    (IMPLIES (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
     (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
  (NOT
   (IMPLIES (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
    (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE))))))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Instantiating (= Y (FN!APPLY (STORES STATE) PRINCIPAL)) gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT
   (OR
    (AND (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
     (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
    (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE))))))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
  (NOT (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Assuming FN!APPLY-IN-RAN with the
instantiations: (= F (STORES STATE)) (= X PRINCIPAL) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (STORES STATE))
    (IN PRINCIPAL (REL!DOM (STORES STATE))))
   (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
  (NOT (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))
 (MS!IS-FRESH MESSAGE (FN!APPLY (STORES STATE) PRINCIPAL)))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-STATE-IMPLICATION,
FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL to
...
(TRUE)
KNOWN-BY-PRINCIPAL-GENERATE-STEP-ATOMIC-CASE
Beginning proof of KNOWN-BY-PRINCIPAL-GENERATE-STEP-ATOMIC-CASE ...
(IMPLIES (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (IN M1 (MS!ATOMIC-MESSAGES)))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
  (OR (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)
   (AND (= M1 M2) (= PRINCIPAL1 PRINCIPAL2)
    (NOT (= (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE) STATE))))))
Which simplifies
 when rewriting with KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GENERATE-STEP
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (IN M1 (MS!ATOMIC-MESSAGES))
  (NOT (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)))
 (IF (= M1 M2)
  (IF (= PRINCIPAL1 PRINCIPAL2)
   (IF (= (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE) STATE)
    (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
    (=
     (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
      (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
     (TRUE)))
   (=
    (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
     (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
    (FALSE)))
  (=
   (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
    (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
   (FALSE))))
Starting case 2 ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (IN M1 (MS!ATOMIC-MESSAGES))
  (NOT (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)) (= M1 M2))
 (IF (= PRINCIPAL1 PRINCIPAL2)
  (IF (= (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE) STATE)
   (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
   (=
    (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
     (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
    (TRUE)))
  (=
   (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
    (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
   (FALSE))))
Invoking GENERATE-STEP gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (IN M1 (MS!ATOMIC-MESSAGES))
  (NOT (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)) (= M1 M2))
 (IF (= PRINCIPAL1 PRINCIPAL2)
  (IF
   (=
    (IF
     (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
      (IN M2 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH M2 (ALL-MESSAGES-IN-STATE STATE))
      (IN PRINCIPAL2 (MS!PRINCIPALS)))
     (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2)
       STATE))
     STATE)
    STATE)
   (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
   (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
    (IF
     (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
      (IN M2 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH M2 (ALL-MESSAGES-IN-STATE STATE))
      (IN PRINCIPAL2 (MS!PRINCIPALS)))
     (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2)
       STATE))
     STATE)))
  (=
   (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
    (IF
     (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
      (IN M2 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH M2 (ALL-MESSAGES-IN-STATE STATE))
      (IN PRINCIPAL2 (MS!PRINCIPALS)))
     (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2)
       STATE))
     STATE))
   (FALSE))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (IN M1 (MS!ATOMIC-MESSAGES))
  (NOT (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)) (= M1 M2))
 (IF (= PRINCIPAL1 PRINCIPAL2)
  (IF (IS-GOOD-STATE STATE)
   (IF (TIME-CONSTRAINT TIME STATE)
    (IF (>= LABEL 0)
     (IF (IN M2 (MS!PRINCIPALS))
      (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
      (IF (IN M2 (MS!TEXT-MESSAGES))
       (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
       (IF (IN M2 (MS!PUBLIC-KEYS))
        (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
        (IF (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
         (IF (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
          (IF
           (=
            (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
             (ADD-TO-STATE-HISTORY
              (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2) STATE))
            STATE)
           (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
           (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
            (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
             (ADD-TO-STATE-HISTORY
              (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2) STATE))))
          (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE)))
         (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))))))
     (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE)))
    (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE)))
   (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE)))
  (IF (IS-GOOD-STATE STATE)
   (IF (TIME-CONSTRAINT TIME STATE)
    (IF (>= LABEL 0)
     (IF (IN M2 (MS!PRINCIPALS))
      (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
      (IF (IN M2 (MS!TEXT-MESSAGES))
       (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
       (IF (IN M2 (MS!PUBLIC-KEYS))
        (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))
        (IF (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
         (IF (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
          (IF (IN PRINCIPAL2 (MS!PRINCIPALS))
           (=
            (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
             (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
              (ADD-TO-STATE-HISTORY
               (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2) STATE)))
            (FALSE))
           (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE)))
          (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE)))
         (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE))))))
     (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE)))
    (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE)))
   (= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE) (FALSE)))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (IN M1 (MS!ATOMIC-MESSAGES))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (STORAGE-OF PRINCIPAL1 STATE)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
  (= M1 M2))
 (IF (= PRINCIPAL1 PRINCIPAL2)
  (IF (IS-GOOD-STATE STATE)
   (IF (TIME-CONSTRAINT TIME STATE)
    (IF (>= LABEL 0)
     (IF (IN M2 (MS!PRINCIPALS))
      (=
       (MS!KNOWN-IN M1
        (UNION (STORAGE-OF PRINCIPAL1 STATE)
         (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
       (FALSE))
      (IF (IN M2 (MS!TEXT-MESSAGES))
       (=
        (MS!KNOWN-IN M1
         (UNION (STORAGE-OF PRINCIPAL1 STATE)
          (UNION (MS!PUBLIC-KEYS)
           (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
        (FALSE))
       (IF (IN M2 (MS!PUBLIC-KEYS))
        (=
         (MS!KNOWN-IN M1
          (UNION (STORAGE-OF PRINCIPAL1 STATE)
           (UNION (MS!PUBLIC-KEYS)
            (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
         (FALSE))
        (IF (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
         (IF (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
          (IF
           (=
            (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
             (ADD-TO-STATE-HISTORY
              (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2) STATE))
            STATE)
           (=
            (MS!KNOWN-IN M1
             (UNION (STORAGE-OF PRINCIPAL1 STATE)
              (UNION (MS!PUBLIC-KEYS)
               (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
            (FALSE))
           (MS!KNOWN-IN M1
            (UNION
             (STORAGE-OF PRINCIPAL1
              (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
               (ADD-TO-STATE-HISTORY
                (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2) STATE)))
             (UNION (MS!PUBLIC-KEYS)
              (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
          (=
           (MS!KNOWN-IN M1
            (UNION (STORAGE-OF PRINCIPAL1 STATE)
             (UNION (MS!PUBLIC-KEYS)
              (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
           (FALSE)))
         (=
          (MS!KNOWN-IN M1
           (UNION (STORAGE-OF PRINCIPAL1 STATE)
            (UNION (MS!PUBLIC-KEYS)
             (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
          (FALSE))))))
     (=
      (MS!KNOWN-IN M1
       (UNION (STORAGE-OF PRINCIPAL1 STATE)
        (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
      (FALSE)))
    (=
     (MS!KNOWN-IN M1
      (UNION (STORAGE-OF PRINCIPAL1 STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
     (FALSE)))
   (=
    (MS!KNOWN-IN M1
     (UNION (STORAGE-OF PRINCIPAL1 STATE)
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
    (FALSE)))
  (IF (IS-GOOD-STATE STATE)
   (IF (TIME-CONSTRAINT TIME STATE)
    (IF (>= LABEL 0)
     (IF (IN M2 (MS!PRINCIPALS))
      (=
       (MS!KNOWN-IN M1
        (UNION (STORAGE-OF PRINCIPAL1 STATE)
         (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
       (FALSE))
      (IF (IN M2 (MS!TEXT-MESSAGES))
       (=
        (MS!KNOWN-IN M1
         (UNION (STORAGE-OF PRINCIPAL1 STATE)
          (UNION (MS!PUBLIC-KEYS)
           (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
        (FALSE))
       (IF (IN M2 (MS!PUBLIC-KEYS))
        (=
         (MS!KNOWN-IN M1
          (UNION (STORAGE-OF PRINCIPAL1 STATE)
           (UNION (MS!PUBLIC-KEYS)
            (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
         (FALSE))
        (IF (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
         (IF (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
          (IF (IN PRINCIPAL2 (MS!PRINCIPALS))
           (=
            (MS!KNOWN-IN M1
             (UNION
              (STORAGE-OF PRINCIPAL1
               (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
                (ADD-TO-STATE-HISTORY
                 (MAKE-GENERATE-EVENT LABEL TIME M2 PRINCIPAL2) STATE)))
              (UNION (MS!PUBLIC-KEYS)
               (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
            (FALSE))
           (=
            (MS!KNOWN-IN M1
             (UNION (STORAGE-OF PRINCIPAL1 STATE)
              (UNION (MS!PUBLIC-KEYS)
               (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
            (FALSE)))
          (=
           (MS!KNOWN-IN M1
            (UNION (STORAGE-OF PRINCIPAL1 STATE)
             (UNION (MS!PUBLIC-KEYS)
              (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
           (FALSE)))
         (=
          (MS!KNOWN-IN M1
           (UNION (STORAGE-OF PRINCIPAL1 STATE)
            (UNION (MS!PUBLIC-KEYS)
             (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
          (FALSE))))))
     (=
      (MS!KNOWN-IN M1
       (UNION (STORAGE-OF PRINCIPAL1 STATE)
        (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
      (FALSE)))
    (=
     (MS!KNOWN-IN M1
      (UNION (STORAGE-OF PRINCIPAL1 STATE)
       (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
     (FALSE)))
   (=
    (MS!KNOWN-IN M1
     (UNION (STORAGE-OF PRINCIPAL1 STATE)
      (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
    (FALSE)))))
Which simplifies
 when rewriting with MS!B5, SETADD.DEFINITION, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT,
STORAGE-OF-ADD-TO-STATE-HISTORY, STORAGE-OF-ADD-TO-STATE-STORAGE,
IS-GOOD-STATE-ADD-TO-STATE-HISTORY, MS!D2-RULE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!COMP-OF-IN-MESSAGES,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (IN M1 (MS!ATOMIC-MESSAGES))
  (NOT (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)) (NOT (= M1 M2)))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
  (FALSE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (IN M1 (MS!ATOMIC-MESSAGES))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (STORAGE-OF PRINCIPAL1 STATE)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
  (NOT (= M1 M2)))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF PRINCIPAL1 (GENERATE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (FALSE)))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD-FRESH, FRESH-IN-STORAGE-OF-PRINCIPAL,
SETRULES!SETADD-UNION-LEFT, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
ALL-MESSAGES-IN-STATE-DEFINITION, STORAGE-OF-GENERATE-STEP, MS!D2-RULE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Completing all cases produces ...
(TRUE)
EFFECTIVE-CONSTRUCT-STEP
Beginning proof of EFFECTIVE-CONSTRUCT-STEP ...
(IMPLIES
 (AND (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL S0)) (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0) (IN PRINCIPAL (MS!PRINCIPALS))))
Invoking CONSTRUCT-STEP gives ...
(IMPLIES
 (AND
  (= S1
   (IF
    (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0))
    (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
     S0)
    S0))
  (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0) (IN PRINCIPAL (MS!PRINCIPALS))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
FORGEABLE-PRESERVED-BY-CONSTRUCT-STEP
Beginning proof of FORGEABLE-PRESERVED-BY-CONSTRUCT-STEP ...
(= (FORGEABLE M1 (CONSTRUCT-STEP LABEL TIME M2 PRINCIPAL STATE))
 (FORGEABLE M1 STATE))
Invoking CONSTRUCT-STEP gives ...
(=
 (FORGEABLE M1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M2 PRINCIPAL STATE))
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME M2 PRINCIPAL) STATE)
   STATE))
 (FORGEABLE M1 STATE))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M2 PRINCIPAL STATE))
 (=
  (FORGEABLE M1
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME M2 PRINCIPAL)
    STATE))
  (FORGEABLE M1 STATE)))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M2 PRINCIPAL STATE))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (SEEN-MESSAGES
     (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME M2 PRINCIPAL)
      STATE))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE,
SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-PRESERVED-BY-CONSTRUCT-STEP
Beginning proof of KNOWN-BY-PRINCIPAL-PRESERVED-BY-CONSTRUCT-STEP ...
(=
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
  (CONSTRUCT-STEP LABEL TIME M2 PRINCIPAL2 STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
Invoking CONSTRUCT-STEP gives ...
(=
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL2 (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M2 PRINCIPAL2 STATE))
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME M2 PRINCIPAL2)
    STATE)
   STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M2 PRINCIPAL2 STATE))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME M2 PRINCIPAL2)
    STATE))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS))
  (MS!KNOWN-IN M2
   (UNION (STORAGE-OF PRINCIPAL2 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF PRINCIPAL1
     (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME M2 PRINCIPAL2)
      STATE))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL1 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with STORAGE-OF-ADD-TO-STATE-HISTORY, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, MAKE-CONSTRUCT-EVENT-IS-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
EFFECTIVE-SEND-STEP
Beginning proof of EFFECTIVE-SEND-STEP ...
(IMPLIES
 (AND (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)) (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0) (IN PRINCIPAL (MS!PRINCIPALS))))
Invoking SEND-STEP gives ...
(IMPLIES
 (AND
  (= S1
   (IF
    (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) S0))
    S0))
  (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0) (IN PRINCIPAL (MS!PRINCIPALS))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
FORGEABLE-MONOTONIC-OVER-SEND-STEP
Beginning proof of FORGEABLE-MONOTONIC-OVER-SEND-STEP ...
(IMPLIES (FORGEABLE M1 STATE)
 (= (FORGEABLE M1 (SEND-STEP LABEL TIME M2 PRINCIPAL STATE)) (TRUE)))
Invoking SEND-STEP gives ...
(IMPLIES (FORGEABLE M1 STATE)
 (FORGEABLE M1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M2 PRINCIPAL STATE))
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME M2 PRINCIPAL) STATE))
   STATE)))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (FORGEABLE M1 STATE) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M2 PRINCIPAL STATE))
 (FORGEABLE M1
  (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
   (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME M2 PRINCIPAL) STATE))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND
  (MS!KNOWN-IN M1
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M2 PRINCIPAL STATE))
 (MS!KNOWN-IN M1
  (UNION
   (SEEN-MESSAGES
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME M2 PRINCIPAL) STATE)))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with MS!KNOWN-IN-OF-SETADD, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT,
SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!KNOWN-IN-IN-MESSAGES,
MS!D1
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-PRESERVED-BY-SEND-STEP
Beginning proof of KNOWN-BY-PRINCIPAL-PRESERVED-BY-SEND-STEP ...
(=
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 (SEND-STEP LABEL TIME M2 PRINCIPAL2 STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
Invoking SEND-STEP gives ...
(=
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL2 (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M2 PRINCIPAL2 STATE))
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME M2 PRINCIPAL2) STATE))
   STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M2 PRINCIPAL2 STATE))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME M2 PRINCIPAL2) STATE)))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS))
  (MS!KNOWN-IN M2
   (UNION (STORAGE-OF PRINCIPAL2 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF PRINCIPAL1
     (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME M2 PRINCIPAL2)
       STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL1 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with STORAGE-OF-ADD-TO-STATE-HISTORY,
STORAGE-OF-ADD-TO-STATE-SEEN-MESSAGES, IS-GOOD-STATE-ADD-TO-STATE-HISTORY,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT,
MAKE-SEND-EVENT-IS-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
EFFECTIVE-RECEIVE-STEP
Beginning proof of EFFECTIVE-RECEIVE-STEP ...
(IMPLIES
 (AND (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL S0)) (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (FORGEABLE MESSAGE S0) (IN PRINCIPAL (MS!PRINCIPALS))))
Invoking RECEIVE-STEP gives ...
(IMPLIES
 (AND
  (= S1
   (IF
    (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      S0))
    S0))
  (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (FORGEABLE MESSAGE S0) (IN PRINCIPAL (MS!PRINCIPALS))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
FORGEABLE-PRESERVED-BY-RECEIVE-STEP
Beginning proof of FORGEABLE-PRESERVED-BY-RECEIVE-STEP ...
(= (FORGEABLE M1 (RECEIVE-STEP LABEL TIME M2 PRINCIPAL STATE))
 (FORGEABLE M1 STATE))
Invoking RECEIVE-STEP gives ...
(=
 (FORGEABLE M1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE M2 STATE))
   (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL) STATE))
   STATE))
 (FORGEABLE M1 STATE))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE M2 STATE))
 (=
  (FORGEABLE M1
   (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL)
     STATE)))
  (FORGEABLE M1 STATE)))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!KNOWN-IN M2
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (SEEN-MESSAGES
     (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL)
       STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEEN-MESSAGES-OF-ADD-TO-STATE-STORAGE, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-RECEIVE-STEP
Beginning proof of KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-RECEIVE-STEP ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (RECEIVE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
  (TRUE)))
Invoking RECEIVE-STEP gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN PRINCIPAL2 (MS!PRINCIPALS)) (FORGEABLE M2 STATE))
   (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL2)
     STATE))
   STATE)))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS)) (FORGEABLE M2 STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
  (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
   (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL2)
    STATE))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL1 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS)) (FORGEABLE M2 STATE))
 (MS!KNOWN-IN M1
  (UNION
   (STORAGE-OF PRINCIPAL1
    (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL2)
      STATE)))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL1 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS))
  (MS!KNOWN-IN M2
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN M1
  (UNION
   (STORAGE-OF PRINCIPAL1
    (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL2)
      STATE)))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with MS!KNOWN-IN-OF-SETADD, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT,
STORAGE-OF-ADD-TO-STATE-HISTORY, STORAGE-OF-ADD-TO-STATE-STORAGE,
IS-GOOD-STATE-ADD-TO-STATE-HISTORY, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-RECEIVE-STEP-NON-RECEIVER-CASE
Beginning proof of KNOWN-BY-PRINCIPAL-RECEIVE-STEP-NON-RECEIVER-CASE ...
(IMPLIES (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (NOT (= PRINCIPAL1 PRINCIPAL2)))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (RECEIVE-STEP LABEL TIME M2 PRINCIPAL2 STATE))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)))
Invoking RECEIVE-STEP gives ...
(IMPLIES (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (NOT (= PRINCIPAL1 PRINCIPAL2)))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL2 (MS!PRINCIPALS)) (FORGEABLE M2 STATE))
    (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL2)
      STATE))
    STATE))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (NOT (= PRINCIPAL1 PRINCIPAL2))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS)) (FORGEABLE M2 STATE))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL2)
     STATE)))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (NOT (= PRINCIPAL1 PRINCIPAL2))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS)) (FORGEABLE M2 STATE))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF PRINCIPAL1
     (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL2)
       STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL1 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (NOT (= PRINCIPAL1 PRINCIPAL2))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN PRINCIPAL2 (MS!PRINCIPALS))
  (MS!KNOWN-IN M2
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF PRINCIPAL1
     (ADD-TO-STATE-STORAGE PRINCIPAL2 (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME M2 PRINCIPAL2)
       STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL1 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with STORAGE-OF-ADD-TO-STATE-HISTORY,
STORAGE-OF-ADD-TO-STATE-STORAGE, IS-GOOD-STATE-ADD-TO-STATE-HISTORY,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
EFFECTIVE-OUT-OF-BAND-STEP
Beginning proof of EFFECTIVE-OUT-OF-BAND-STEP ...
(IMPLIES
 (AND (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0))
  (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)))
Invoking OUT-OF-BAND-STEP gives ...
(IMPLIES
 (AND
  (= S1
   (IF
    (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
     (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) S0))
    S0))
  (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
FORGEABLE-PRESERVED-BY-OUT-OF-BAND-STEP
Beginning proof of FORGEABLE-PRESERVED-BY-OUT-OF-BAND-STEP ...
(= (FORGEABLE M1 (OUT-OF-BAND-STEP LABEL TIME M2 SENDER RECEIVER STATE))
 (FORGEABLE M1 STATE))
Invoking OUT-OF-BAND-STEP gives ...
(=
 (FORGEABLE M1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL M2 SENDER STATE))
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME M2 SENDER RECEIVER) STATE))
   STATE))
 (FORGEABLE M1 STATE))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M2 SENDER STATE))
 (=
  (FORGEABLE M1
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME M2 SENDER RECEIVER) STATE)))
  (FORGEABLE M1 STATE)))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M2 SENDER STATE))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (SEEN-MESSAGES
     (ADD-TO-STATE-STORAGE RECEIVER (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY
       (MAKE-OUT-OF-BAND-EVENT LABEL TIME M2 SENDER RECEIVER) STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE,
SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY, SEEN-MESSAGES-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-OUT-OF-BAND-STEP
Beginning proof of KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-OUT-OF-BAND-STEP ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (OUT-OF-BAND-STEP LABEL TIME M2 SENDER RECEIVER STATE))
  (TRUE)))
Invoking OUT-OF-BAND-STEP gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL M2 SENDER STATE))
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME M2 SENDER RECEIVER) STATE))
   STATE)))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M2 SENDER STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
  (ADD-TO-STATE-STORAGE RECEIVER (SETADD M2 (NULLSET))
   (ADD-TO-STATE-HISTORY
    (MAKE-OUT-OF-BAND-EVENT LABEL TIME M2 SENDER RECEIVER) STATE))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL1 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (MS!KNOWN-IN M2
   (UNION (STORAGE-OF SENDER STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN M1
  (UNION
   (STORAGE-OF PRINCIPAL1
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD M2 (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME M2 SENDER RECEIVER) STATE)))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with MS!KNOWN-IN-OF-SETADD, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT,
STORAGE-OF-ADD-TO-STATE-HISTORY, STORAGE-OF-ADD-TO-STATE-STORAGE,
IS-GOOD-STATE-ADD-TO-STATE-HISTORY, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-OUT-OF-BAND-STEP-NON-RECEIVER-CASE
Beginning proof of KNOWN-BY-PRINCIPAL-OUT-OF-BAND-STEP-NON-RECEIVER-CASE ...
(IMPLIES (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (NOT (= PRINCIPAL1 RECEIVER)))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (OUT-OF-BAND-STEP LABEL TIME M2 SENDER RECEIVER STATE))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)))
Invoking OUT-OF-BAND-STEP gives ...
(IMPLIES (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (NOT (= PRINCIPAL1 RECEIVER)))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL M2 SENDER STATE))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD M2 (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME M2 SENDER RECEIVER) STATE))
    STATE))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (NOT (= PRINCIPAL1 RECEIVER))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M2 SENDER STATE))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME M2 SENDER RECEIVER) STATE)))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL1 STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN PRINCIPAL1 (MS!PRINCIPALS)) (NOT (= PRINCIPAL1 RECEIVER))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (MS!KNOWN-IN M2
   (UNION (STORAGE-OF SENDER STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF PRINCIPAL1
     (ADD-TO-STATE-STORAGE RECEIVER (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY
       (MAKE-OUT-OF-BAND-EVENT LABEL TIME M2 SENDER RECEIVER) STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL1 STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with STORAGE-OF-ADD-TO-STATE-HISTORY,
STORAGE-OF-ADD-TO-STATE-STORAGE, IS-GOOD-STATE-ADD-TO-STATE-HISTORY,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
EFFECTIVE-INTRUDER-STEP
Beginning proof of EFFECTIVE-INTRUDER-STEP ...
(IMPLIES (AND (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0)) (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))))
Invoking INTRUDER-STEP gives ...
(IMPLIES
 (AND
  (= S1
   (IF
    (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
     (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0)))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) S0))
    S0))
  (NOT (= S0 S1)))
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
FORGEABLE-MONOTONIC-OVER-INTRUDER-STEP
Beginning proof of FORGEABLE-MONOTONIC-OVER-INTRUDER-STEP ...
(IMPLIES (FORGEABLE M1 STATE)
 (= (FORGEABLE M1 (INTRUDER-STEP LABEL TIME M2 STATE)) (TRUE)))
Invoking INTRUDER-STEP gives ...
(IMPLIES (FORGEABLE M1 STATE)
 (FORGEABLE M1
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN M2 (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH M2 (ALL-MESSAGES-IN-STATE STATE)))
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME M2) STATE))
   STATE)))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (FORGEABLE M1 STATE) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))))
 (FORGEABLE M1
  (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
   (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME M2) STATE))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND
  (MS!KNOWN-IN M1
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))))
 (MS!KNOWN-IN M1
  (UNION
   (SEEN-MESSAGES
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME M2) STATE)))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with MS!KNOWN-IN-OF-SETADD, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT,
SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-PRESERVED-BY-INTRUDER-STEP
Beginning proof of KNOWN-BY-PRINCIPAL-PRESERVED-BY-INTRUDER-STEP ...
(= (KNOWN-BY-PRINCIPAL M1 PRINCIPAL (INTRUDER-STEP LABEL TIME M2 STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL STATE))
Invoking INTRUDER-STEP gives ...
(=
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL
  (IF
   (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (IN M2 (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH M2 (ALL-MESSAGES-IN-STATE STATE)))
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME M2) STATE))
   STATE))
 (KNOWN-BY-PRINCIPAL M1 PRINCIPAL STATE))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))))
 (=
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME M2) STATE)))
  (KNOWN-BY-PRINCIPAL M1 PRINCIPAL STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF PRINCIPAL
     (ADD-TO-STATE-SEEN-MESSAGES (SETADD M2 (NULLSET))
      (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME M2) STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF PRINCIPAL STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE,
STORAGE-OF-ADD-TO-STATE-HISTORY, STORAGE-OF-ADD-TO-STATE-SEEN-MESSAGES,
IS-GOOD-STATE-ADD-TO-STATE-HISTORY
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-IMPLIES-NOT-FRESH
Beginning proof of KNOWN-BY-PRINCIPAL-IMPLIES-NOT-FRESH ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
 (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
ALL-MESSAGES-IN-STATE-DEFINITION, MS!D2-RULE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)))
 (NOT (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES STATE)))))
Applying MS!NOT-PART-IMPLIES-NOT-COMP-OF gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE
   (MS!PARTS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE))))))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)))
 (NOT (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES STATE)))))
Which simplifies
 when rewriting with MS!B5, UNION.DEFINITION,
MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES, MS!TEXT-MESSAGE-ATOMIC, MS!PARTS-ATOMIC,
MS!PRINCIPAL-ATOMIC, MS!PARTS-UNION
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)))
 (NOT (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES STATE)))))
Invoking (ALL-STORAGE (STORES STATE)) gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)))
 (NOT (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE))))))
Invoking (MS!IS-FRESH MESSAGE (CUP (REL!RAN (STORES STATE)))) gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)))
 (NOT
  (AND (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
   (NOT
    (SOME (M)
     (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (NOT
    (SOME (M$0)
     (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
      (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (ALL (M$1 K2)
    (AND
     (NOT
      (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
       (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
     (NOT
      (IN (MS!SHARE-ENCRYPT M$1 (MS!INVERSE MESSAGE) K2)
       (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
     (NOT
      (IN (MS!SHARE-ENCRYPT M$1 K2 MESSAGE)
       (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
     (NOT
      (IN (MS!SHARE-ENCRYPT M$1 K2 (MS!INVERSE MESSAGE))
       (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))))))
Which simplifies
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT,
MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Invoking STORAGE-OF gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Splitting
on (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL)
    (CUP (REL!RAN (STORES STATE)))) generates
...
(IF
 (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL) (CUP (REL!RAN (STORES STATE))))
 (IMPLIES
  (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
   (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
   (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
   (MS!COMP-OF MESSAGE
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
   (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
   (NOT
    (SOME (M)
     (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (NOT
    (SOME (M$0)
     (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
      (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (NOT
    (SOME (M$1 K2)
     (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
      (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (NOT
    (SOME (M$2 K2$0)
     (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
      (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (NOT
    (SOME (M$3 K2$1)
     (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
      (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
  (SOME (M$4 K2$2)
   (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
    (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
 (IMPLIES
  (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
   (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
   (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
   (MS!COMP-OF MESSAGE
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
   (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
   (NOT
    (SOME (M$5)
     (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (NOT
    (SOME (M$6)
     (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
      (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (NOT
    (SOME (M$7 K2$3)
     (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
      (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (NOT
    (SOME (M$8 K2$4)
     (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
      (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
   (NOT
    (SOME (M$9 K2$5)
     (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
      (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
  (SOME (M$10 K2$6)
   (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
    (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
Starting case 2 ...
(IMPLIES
 (AND
  (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL) (CUP (REL!RAN (STORES STATE))))
  (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Assuming MS!IN-PARTS-SUBSET with the
instantiations: (= K MESSAGE) (= S1 (CUP (REL!RAN (STORES STATE))))
                (= S2 (FN!APPLY (STORES STATE) PRINCIPAL)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
    (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL)
     (CUP (REL!RAN (STORES STATE)))))
   (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL) (CUP (REL!RAN (STORES STATE))))
  (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Which simplifies
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND
  (NOT
   (SUBSET (FN!APPLY (STORES STATE) PRINCIPAL)
    (CUP (REL!RAN (STORES STATE)))))
  (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (SOME (M$10 K2$6)
  (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Invoking SUBSET gives ...
(IMPLIES
 (AND
  (NOT
   (ALL (E)
    (IMPLIES (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
     (IN E (CUP (REL!RAN (STORES STATE)))))))
  (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (ALL (E)
    (IMPLIES (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
     (IN E (CUP (REL!RAN (STORES STATE))))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN PRINCIPAL (MS!PRINCIPALS)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (IMPLIES (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
    (IN E (CUP (REL!RAN (STORES STATE)))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (IN PRINCIPAL (MS!PRINCIPALS))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (IMPLIES (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
    (IN E (CUP (REL!RAN (STORES STATE)))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Which simplifies
 when rewriting with CUP.DEFINITION, SEQ!IN-SEQUENCE-OF
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION
 with the assumptions MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT,
MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
FN!IS-FUNCTION-BOOL, MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (IN PRINCIPAL (MS!PRINCIPALS))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Instantiating (= Y (FN!APPLY (STORES STATE) PRINCIPAL)) gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (IN PRINCIPAL (MS!PRINCIPALS))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT
   (OR
    (AND (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
     (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
    (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE))))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Which simplifies
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION
 with the assumptions MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT,
MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
FN!IS-FUNCTION-BOOL, MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (IN PRINCIPAL (MS!PRINCIPALS))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
  (NOT (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Assuming FN!APPLY-IN-RAN with the
instantiations: (= F (STORES STATE)) (= X PRINCIPAL) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (STORES STATE))
    (IN PRINCIPAL (REL!DOM (STORES STATE))))
   (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
  (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE)) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SUBSET (SEQ!MEMBERS (HISTORY STATE)) (EVENTS))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (IN PRINCIPAL (MS!PRINCIPALS))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
  (NOT (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))
 (SOME (M$4 K2$2)
  (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
   (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
Which simplifies
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION
 with the assumptions MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT,
MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, FN!IS-FUNCTION-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
FORGEABLE-IMPLIES-NOT-FRESH
Beginning proof of FORGEABLE-IMPLIES-NOT-FRESH ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (FORGEABLE MESSAGE STATE))
 (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
ALL-MESSAGES-IN-STATE-DEFINITION, MS!D2-RULE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!COMP-OF-IN-MESSAGES,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)))
 (NOT (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES STATE)))))
Applying MS!NOT-PART-IMPLIES-NOT-COMP-OF gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (IN MESSAGE
   (MS!PARTS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)))
 (NOT (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES STATE)))))
Which simplifies
 when rewriting with MS!B5, UNION.DEFINITION,
MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES, MS!TEXT-MESSAGE-ATOMIC, MS!PARTS-ATOMIC,
MS!PRINCIPAL-ATOMIC, MS!PARTS-UNION
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)))
 (NOT (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES STATE)))))
Invoking (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE)) gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE)))
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (ALL (M$1 K2)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 (MS!INVERSE MESSAGE) K2)
      (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 (MS!INVERSE MESSAGE))
      (MS!PARTS (SEEN-MESSAGES STATE)))))))
 (NOT (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES STATE)))))
Which simplifies
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
SEND-EVENT-EQUALITY
Beginning proof of SEND-EVENT-EQUALITY ...
(= (= (MAKE-SEND-EVENT L1 T1 M1 P1) (MAKE-SEND-EVENT L2 T2 M2 P2))
 (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2)))
Splitting
on (AND (= L1 L2) (AND (= T1 T2) (AND (= M1 M2) (= P1 P2)))) generates ...
(IF (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2))
 (= (= (MAKE-SEND-EVENT L1 T1 M1 P1) (MAKE-SEND-EVENT L2 T2 M2 P2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2)))
 (= (= (MAKE-SEND-EVENT L1 T1 M1 P1) (MAKE-SEND-EVENT L2 T2 M2 P2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2))))
Which simplifies
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT to ...
(TRUE)
RECEIVE-EVENT-EQUALITY
Beginning proof of RECEIVE-EVENT-EQUALITY ...
(= (= (MAKE-RECEIVE-EVENT L1 T1 M1 P1) (MAKE-RECEIVE-EVENT L2 T2 M2 P2))
 (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2)))
Splitting
on (AND (= L1 L2) (AND (= T1 T2) (AND (= M1 M2) (= P1 P2)))) generates ...
(IF (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2))
 (= (= (MAKE-RECEIVE-EVENT L1 T1 M1 P1) (MAKE-RECEIVE-EVENT L2 T2 M2 P2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2)))
 (= (= (MAKE-RECEIVE-EVENT L1 T1 M1 P1) (MAKE-RECEIVE-EVENT L2 T2 M2 P2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2))))
Which simplifies
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT to ...
(TRUE)
OUT-OF-BAND-EVENT-EQUALITY
Beginning proof of OUT-OF-BAND-EVENT-EQUALITY ...
(=
 (= (MAKE-OUT-OF-BAND-EVENT L1 T1 M1 S1 R1)
  (MAKE-OUT-OF-BAND-EVENT L2 T2 M2 S2 R2))
 (AND (= L1 L2) (= T1 T2) (= M1 M2) (= S1 S2) (= R1 R2)))
Splitting
on (AND (= L1 L2)
    (AND (= T1 T2) (AND (= M1 M2) (AND (= S1 S2) (= R1 R2))))) generates
...
(IF (AND (= L1 L2) (= T1 T2) (= M1 M2) (= S1 S2) (= R1 R2))
 (=
  (= (MAKE-OUT-OF-BAND-EVENT L1 T1 M1 S1 R1)
   (MAKE-OUT-OF-BAND-EVENT L2 T2 M2 S2 R2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= S1 S2) (= R1 R2)))
 (=
  (= (MAKE-OUT-OF-BAND-EVENT L1 T1 M1 S1 R1)
   (MAKE-OUT-OF-BAND-EVENT L2 T2 M2 S2 R2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= S1 S2) (= R1 R2))))
Which simplifies
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT to ...
(TRUE)
GENERATE-EVENT-EQUALITY
Beginning proof of GENERATE-EVENT-EQUALITY ...
(= (= (MAKE-GENERATE-EVENT L1 T1 M1 P1) (MAKE-GENERATE-EVENT L2 T2 M2 P2))
 (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2)))
Splitting
on (AND (= L1 L2) (AND (= T1 T2) (AND (= M1 M2) (= P1 P2)))) generates ...
(IF (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2))
 (= (= (MAKE-GENERATE-EVENT L1 T1 M1 P1) (MAKE-GENERATE-EVENT L2 T2 M2 P2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2)))
 (= (= (MAKE-GENERATE-EVENT L1 T1 M1 P1) (MAKE-GENERATE-EVENT L2 T2 M2 P2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2))))
Which simplifies
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT to ...
(TRUE)
CONSTRUCT-EVENT-EQUALITY
Beginning proof of CONSTRUCT-EVENT-EQUALITY ...
(= (= (MAKE-CONSTRUCT-EVENT L1 T1 M1 P1) (MAKE-CONSTRUCT-EVENT L2 T2 M2 P2))
 (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2)))
Splitting
on (AND (= L1 L2) (AND (= T1 T2) (AND (= M1 M2) (= P1 P2)))) generates ...
(IF (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2))
 (= (= (MAKE-CONSTRUCT-EVENT L1 T1 M1 P1) (MAKE-CONSTRUCT-EVENT L2 T2 M2 P2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2)))
 (= (= (MAKE-CONSTRUCT-EVENT L1 T1 M1 P1) (MAKE-CONSTRUCT-EVENT L2 T2 M2 P2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2) (= P1 P2))))
Which simplifies
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT to ...
(TRUE)
INTRUDER-EVENT-EQUALITY
Beginning proof of INTRUDER-EVENT-EQUALITY ...
(= (= (MAKE-INTRUDER-EVENT L1 T1 M1) (MAKE-INTRUDER-EVENT L2 T2 M2))
 (AND (= L1 L2) (= T1 T2) (= M1 M2)))
Splitting on (AND (= L1 L2) (AND (= T1 T2) (= M1 M2))) generates ...
(IF (AND (= L1 L2) (= T1 T2) (= M1 M2))
 (= (= (MAKE-INTRUDER-EVENT L1 T1 M1) (MAKE-INTRUDER-EVENT L2 T2 M2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2)))
 (= (= (MAKE-INTRUDER-EVENT L1 T1 M1) (MAKE-INTRUDER-EVENT L2 T2 M2))
  (AND (= L1 L2) (= T1 T2) (= M1 M2))))
Which simplifies
 with the assumptions TAG-OF-MAKE-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT to ...
(TRUE)
3COMBINE-EQUALITY
Beginning proof of 3COMBINE-EQUALITY ...
(IMPLIES
 (AND (IN 1M1 (MS!MESSAGES)) (IN 1M2 (MS!MESSAGES)) (IN 1M3 (MS!MESSAGES))
  (IN 2M1 (MS!MESSAGES)) (IN 2M2 (MS!MESSAGES)) (IN 2M3 (MS!MESSAGES)))
 (= (= (3COMBINE 1M1 1M2 1M3) (3COMBINE 2M1 2M2 2M3))
  (AND (= 1M1 2M1) (= 1M2 2M2) (= 1M3 2M3))))
Invoking 3COMBINE gives ...
(IMPLIES
 (AND (IN 1M1 (MS!MESSAGES)) (IN 1M2 (MS!MESSAGES)) (IN 1M3 (MS!MESSAGES))
  (IN 2M1 (MS!MESSAGES)) (IN 2M2 (MS!MESSAGES)) (IN 2M3 (MS!MESSAGES)))
 (=
  (= (MS!COMBINE 1M1 (MS!COMBINE 1M2 1M3))
   (MS!COMBINE 2M1 (MS!COMBINE 2M2 2M3)))
  (AND (= 1M1 2M1) (= 1M2 2M2) (= 1M3 2M3))))
Which simplifies
 when rewriting with MS!COMBINE-INJECTIVE
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
4COMBINE-EQUALITY
Beginning proof of 4COMBINE-EQUALITY ...
(IMPLIES
 (AND (IN 1M1 (MS!MESSAGES)) (IN 1M2 (MS!MESSAGES)) (IN 1M3 (MS!MESSAGES))
  (IN 1M4 (MS!MESSAGES)) (IN 2M1 (MS!MESSAGES)) (IN 2M2 (MS!MESSAGES))
  (IN 2M3 (MS!MESSAGES)) (IN 2M4 (MS!MESSAGES)))
 (= (= (4COMBINE 1M1 1M2 1M3 1M4) (4COMBINE 2M1 2M2 2M3 2M4))
  (AND (= 1M1 2M1) (= 1M2 2M2) (= 1M3 2M3) (= 1M4 2M4))))
Invoking 4COMBINE gives ...
(IMPLIES
 (AND (IN 1M1 (MS!MESSAGES)) (IN 1M2 (MS!MESSAGES)) (IN 1M3 (MS!MESSAGES))
  (IN 1M4 (MS!MESSAGES)) (IN 2M1 (MS!MESSAGES)) (IN 2M2 (MS!MESSAGES))
  (IN 2M3 (MS!MESSAGES)) (IN 2M4 (MS!MESSAGES)))
 (=
  (= (MS!COMBINE 1M1 (MS!COMBINE 1M2 (MS!COMBINE 1M3 1M4)))
   (MS!COMBINE 2M1 (MS!COMBINE 2M2 (MS!COMBINE 2M3 2M4))))
  (AND (= 1M1 2M1) (= 1M2 2M2) (= 1M3 2M3) (= 1M4 2M4))))
Which simplifies
 when rewriting with MS!COMBINE-INJECTIVE
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
5COMBINE-EQUALITY
Beginning proof of 5COMBINE-EQUALITY ...
(IMPLIES
 (AND (IN 1M1 (MS!MESSAGES)) (IN 1M2 (MS!MESSAGES)) (IN 1M3 (MS!MESSAGES))
  (IN 1M4 (MS!MESSAGES)) (IN 1M5 (MS!MESSAGES)) (IN 2M1 (MS!MESSAGES))
  (IN 2M2 (MS!MESSAGES)) (IN 2M3 (MS!MESSAGES)) (IN 2M4 (MS!MESSAGES))
  (IN 2M5 (MS!MESSAGES)))
 (= (= (5COMBINE 1M1 1M2 1M3 1M4 1M5) (5COMBINE 2M1 2M2 2M3 2M4 2M5))
  (AND (= 1M1 2M1) (= 1M2 2M2) (= 1M3 2M3) (= 1M4 2M4) (= 1M5 2M5))))
Invoking 5COMBINE gives ...
(IMPLIES
 (AND (IN 1M1 (MS!MESSAGES)) (IN 1M2 (MS!MESSAGES)) (IN 1M3 (MS!MESSAGES))
  (IN 1M4 (MS!MESSAGES)) (IN 1M5 (MS!MESSAGES)) (IN 2M1 (MS!MESSAGES))
  (IN 2M2 (MS!MESSAGES)) (IN 2M3 (MS!MESSAGES)) (IN 2M4 (MS!MESSAGES))
  (IN 2M5 (MS!MESSAGES)))
 (=
  (= (MS!COMBINE 1M1 (MS!COMBINE 1M2 (MS!COMBINE 1M3 (MS!COMBINE 1M4 1M5))))
   (MS!COMBINE 2M1 (MS!COMBINE 2M2 (MS!COMBINE 2M3 (MS!COMBINE 2M4 2M5)))))
  (AND (= 1M1 2M1) (= 1M2 2M2) (= 1M3 2M3) (= 1M4 2M4) (= 1M5 2M5))))
Which simplifies
 when rewriting with MS!COMBINE-INJECTIVE
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
6COMBINE-EQUALITY
Beginning proof of 6COMBINE-EQUALITY ...
(IMPLIES
 (AND (IN 1M1 (MS!MESSAGES)) (IN 1M2 (MS!MESSAGES)) (IN 1M3 (MS!MESSAGES))
  (IN 1M4 (MS!MESSAGES)) (IN 1M5 (MS!MESSAGES)) (IN 1M6 (MS!MESSAGES))
  (IN 2M1 (MS!MESSAGES)) (IN 2M2 (MS!MESSAGES)) (IN 2M3 (MS!MESSAGES))
  (IN 2M4 (MS!MESSAGES)) (IN 2M5 (MS!MESSAGES)) (IN 2M6 (MS!MESSAGES)))
 (= (= (6COMBINE 1M1 1M2 1M3 1M4 1M5 1M6) (6COMBINE 2M1 2M2 2M3 2M4 2M5 2M6))
  (AND (= 1M1 2M1) (= 1M2 2M2) (= 1M3 2M3) (= 1M4 2M4) (= 1M5 2M5)
   (= 1M6 2M6))))
Invoking 6COMBINE gives ...
(IMPLIES
 (AND (IN 1M1 (MS!MESSAGES)) (IN 1M2 (MS!MESSAGES)) (IN 1M3 (MS!MESSAGES))
  (IN 1M4 (MS!MESSAGES)) (IN 1M5 (MS!MESSAGES)) (IN 1M6 (MS!MESSAGES))
  (IN 2M1 (MS!MESSAGES)) (IN 2M2 (MS!MESSAGES)) (IN 2M3 (MS!MESSAGES))
  (IN 2M4 (MS!MESSAGES)) (IN 2M5 (MS!MESSAGES)) (IN 2M6 (MS!MESSAGES)))
 (=
  (=
   (MS!COMBINE 1M1
    (MS!COMBINE 1M2 (MS!COMBINE 1M3 (MS!COMBINE 1M4 (MS!COMBINE 1M5 1M6)))))
   (MS!COMBINE 2M1
    (MS!COMBINE 2M2 (MS!COMBINE 2M3 (MS!COMBINE 2M4 (MS!COMBINE 2M5 2M6))))))
  (AND (= 1M1 2M1) (= 1M2 2M2) (= 1M3 2M3) (= 1M4 2M4) (= 1M5 2M5)
   (= 1M6 2M6))))
Which simplifies
 when rewriting with MS!COMBINE-INJECTIVE
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
FORGEABLE-ADD-TO-SEEN-MESSAGES-AND-HISTORY
Beginning proof of FORGEABLE-ADD-TO-SEEN-MESSAGES-AND-HISTORY ...
(IMPLIES (IS-GOOD-STATE STATE)
 (=
  (FORGEABLE M1
   (ADD-TO-STATE-SEEN-MESSAGES M2 (ADD-TO-STATE-HISTORY EVENT STATE)))
  (FORGEABLE M1 (ADD-TO-STATE-SEEN-MESSAGES M2 STATE))))
Invoking FORGEABLE gives ...
(IMPLIES (IS-GOOD-STATE STATE)
 (=
  (MS!KNOWN-IN M1
   (UNION
    (SEEN-MESSAGES
     (ADD-TO-STATE-SEEN-MESSAGES M2 (ADD-TO-STATE-HISTORY EVENT STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES M2 STATE))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with UNION.ASSOCIATIVE, UNION.PERMUTATIVE, UNION.COMMUTATIVE,
SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
ADD-TO-STATE-SEEN-MESSAGES-IS-STATE, ADD-TO-STATE-HISTORY-IS-STATE to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-TO-SEEN-MESSAGES-AND-HISTORY
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-TO-SEEN-MESSAGES-AND-HISTORY ...
(IMPLIES (IS-GOOD-STATE STATE)
 (=
  (KNOWN-BY-PRINCIPAL M1 P
   (ADD-TO-STATE-SEEN-MESSAGES M2 (ADD-TO-STATE-HISTORY EVENT STATE)))
  (KNOWN-BY-PRINCIPAL M1 P (ADD-TO-STATE-SEEN-MESSAGES M2 STATE))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES (IS-GOOD-STATE STATE)
 (=
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF P
     (ADD-TO-STATE-SEEN-MESSAGES M2 (ADD-TO-STATE-HISTORY EVENT STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF P (ADD-TO-STATE-SEEN-MESSAGES M2 STATE))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with STORAGE-OF-ADD-TO-STATE-SEEN-MESSAGES, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
ADD-TO-STATE-SEEN-MESSAGES-IS-STATE, ADD-TO-STATE-HISTORY-IS-STATE to ...
(IMPLIES (IS-GOOD-STATE STATE)
 (=
  (MS!KNOWN-IN M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS)
      (STORAGE-OF P
       (ADD-TO-STATE-SEEN-MESSAGES M2 (ADD-TO-STATE-HISTORY EVENT STATE)))))))
  (MS!KNOWN-IN M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P STATE)))))))
Invoking STORAGE-OF gives ...
(IMPLIES (IS-GOOD-STATE STATE)
 (=
  (MS!KNOWN-IN M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS)
      (FN!APPLY
       (STORES
        (ADD-TO-STATE-SEEN-MESSAGES M2 (ADD-TO-STATE-HISTORY EVENT STATE)))
       P)))))
  (MS!KNOWN-IN M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) P)))))))
Which simplifies
 when rewriting with STORES-OF-ADD-TO-STATE-HISTORY,
STORES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
STORAGE-OF-SUBSET-ALL-STORAGE
Beginning proof of STORAGE-OF-SUBSET-ALL-STORAGE ...
(IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (IS-GOOD-STATE STATE))
 (= (SUBSET (STORAGE-OF PRINCIPAL STATE) (ALL-STORAGE (STORES STATE))) (TRUE)))
Invoking ALL-STORAGE gives ...
(IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (IS-GOOD-STATE STATE))
 (SUBSET (STORAGE-OF PRINCIPAL STATE) (CUP (REL!RAN (STORES STATE)))))
Invoking SUBSET gives ...
(IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (IS-GOOD-STATE STATE))
 (ALL (E)
  (IMPLIES (IN E (STORAGE-OF PRINCIPAL STATE))
   (IN E (CUP (REL!RAN (STORES STATE)))))))
Invoking STORAGE-OF gives ...
(IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (IS-GOOD-STATE STATE))
 (ALL (E)
  (IMPLIES (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
   (IN E (CUP (REL!RAN (STORES STATE)))))))
Which simplifies
 when rewriting with CUP.DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
>=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (IS-GOOD-STATE STATE))
 (ALL (E)
  (IMPLIES (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
   (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE))))))))
Prenexing produces ...
(IMPLIES
 (AND (IN PRINCIPAL (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL)))
 (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE))))))
Assuming FN!APPLY-IN-RAN with the
instantiations: (= F (STORES STATE)) (= X PRINCIPAL) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (STORES STATE))
    (IN PRINCIPAL (REL!DOM (STORES STATE))))
   (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
  (IN PRINCIPAL (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL)))
 (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE))))))
Rearranging gives ...
(IMPLIES
 (AND (IN PRINCIPAL (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (IMPLIES
   (AND (FN!IS-FUNCTION (STORES STATE))
    (IN PRINCIPAL (REL!DOM (STORES STATE))))
   (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE)))))
 (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
>=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions FN!IS-FUNCTION-BOOL, MS!SET-OF-PRINCIPALS-NOT-EMPTY
 with the instantiation (= Y (FN!APPLY (STORES STATE) PRINCIPAL)) to ...
(TRUE)
FORGEABLE-ADD-TO-STATE-HISTORY
Beginning proof of FORGEABLE-ADD-TO-STATE-HISTORY ...
(= (FORGEABLE MESSAGE (ADD-TO-STATE-HISTORY EVENT STATE))
 (FORGEABLE MESSAGE STATE))
Invoking FORGEABLE gives ...
(=
 (MS!KNOWN-IN MESSAGE
  (UNION (SEEN-MESSAGES (ADD-TO-STATE-HISTORY EVENT STATE))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
 (MS!KNOWN-IN MESSAGE
  (UNION (SEEN-MESSAGES STATE)
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE,
SEEN-MESSAGES-OF-ADD-TO-STATE-HISTORY
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
ADD-TO-STATE-HISTORY-IS-STATE to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-TO-STATE-HISTORY
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-TO-STATE-HISTORY ...
(= (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (ADD-TO-STATE-HISTORY EVENT STATE))
 (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
Invoking KNOWN-BY-PRINCIPAL gives ...
(=
 (MS!KNOWN-IN MESSAGE
  (UNION (STORAGE-OF PRINCIPAL (ADD-TO-STATE-HISTORY EVENT STATE))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
 (MS!KNOWN-IN MESSAGE
  (UNION (STORAGE-OF PRINCIPAL STATE)
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
ADD-TO-STATE-HISTORY-IS-STATE to ...
(=
 (MS!KNOWN-IN MESSAGE
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS)
     (STORAGE-OF PRINCIPAL (ADD-TO-STATE-HISTORY EVENT STATE))))))
 (MS!KNOWN-IN MESSAGE
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE))))))
Invoking STORAGE-OF gives ...
(=
 (MS!KNOWN-IN MESSAGE
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS)
     (FN!APPLY (STORES (ADD-TO-STATE-HISTORY EVENT STATE)) PRINCIPAL)))))
 (MS!KNOWN-IN MESSAGE
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL))))))
Which simplifies
 when rewriting with STORES-OF-ADD-TO-STATE-HISTORY
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-HISTORY-IS-STATE,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-TO-STATE-SEEN-MESSAGES
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-TO-STATE-SEEN-MESSAGES ...
(= (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-SEEN-MESSAGES M1 S))
 (KNOWN-BY-PRINCIPAL M P S))
Invoking KNOWN-BY-PRINCIPAL gives ...
(=
 (MS!KNOWN-IN M
  (UNION (STORAGE-OF P (ADD-TO-STATE-SEEN-MESSAGES M1 S))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
 (MS!KNOWN-IN M
  (UNION (STORAGE-OF P S)
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
ADD-TO-STATE-SEEN-MESSAGES-IS-STATE to ...
(=
 (MS!KNOWN-IN M
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS)
     (STORAGE-OF P (ADD-TO-STATE-SEEN-MESSAGES M1 S))))))
 (MS!KNOWN-IN M
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
Invoking STORAGE-OF gives ...
(=
 (MS!KNOWN-IN M
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS)
     (FN!APPLY (STORES (ADD-TO-STATE-SEEN-MESSAGES M1 S)) P)))))
 (MS!KNOWN-IN M
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES S) P))))))
Which simplifies
 when rewriting with STORES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
FORGEABLE-ADD-COMBINE
Beginning proof of FORGEABLE-ADD-COMBINE ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (SUBSET MS (MS!MESSAGES)))
 (=
  (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES (SETADD (MS!COMBINE M1 M2) MS) S))
  (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES (SETADD M1 (SETADD M2 MS)) S))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (SUBSET MS (MS!MESSAGES)))
 (=
  (MS!KNOWN-IN M
   (UNION
    (SEEN-MESSAGES
     (ADD-TO-STATE-SEEN-MESSAGES (SETADD (MS!COMBINE M1 M2) MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION
    (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES (SETADD M1 (SETADD M2 MS)) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with UNION.ASSOCIATIVE, UNION.PERMUTATIVE, UNION.COMMUTATIVE,
SETRULES!SETADD-UNION-LEFT, SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-COMBINE-MESSAGES, MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1,
MS!SIZE-CB2, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
ADD-TO-STATE-SEEN-MESSAGES-IS-STATE, MS!TAG-OF-COMBINE, MS!CB1-COMBINE,
MS!CB2-COMBINE, MS!COMBINE-IN-COMBINE-MESSAGES,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (SUBSET MS (MS!MESSAGES)))
 (=
  (MS!KNOWN-IN M
   (SETADD (MS!COMBINE M1 M2)
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))))
  (MS!KNOWN-IN M
   (SETADD M1
    (SETADD M2
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))))))
Applying MS!KNOWN-IN-SETADD-COMBINE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (SUBSET MS (MS!MESSAGES)))
 (=
  (IF
   (AND (IN M (MS!MESSAGES)) (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
    (SUBSET
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))
     (MS!MESSAGES)))
   (MS!KNOWN-IN M
    (SETADD M1
     (SETADD M2
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))))
   (MS!KNOWN-IN M
    (SETADD (MS!COMBINE M1 M2)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))))
  (MS!KNOWN-IN M
   (SETADD M1
    (SETADD M2
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))))))
Which simplifies
 when rewriting with MS!PUBLIC-KEYS-ARE-MESSAGES,
MS!TEXT-MESSAGES-SUBSET-OF-MESSAGES, MS!PRINCIPALS-SUBSET-OF-MESSAGES,
SETRULES!SUBSET-UNION-LEFT
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
FORGEABLE-ADD-PUBLIC-KEY
Beginning proof of FORGEABLE-ADD-PUBLIC-KEY ...
(IMPLIES (AND (IN P (MS!PUBLIC-KEYS)) (IS-GOOD-STATE S))
 (= (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES (SETADD P MS) S))
  (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES MS S))))
Invoking FORGEABLE gives ...
(IMPLIES (AND (IN P (MS!PUBLIC-KEYS)) (IS-GOOD-STATE S))
 (=
  (MS!KNOWN-IN M
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES (SETADD P MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with SETADD-MEMBER, UNION.DEFINITION, UNION.ASSOCIATIVE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC
 with the assumptions MS!KNOWN-IN-BOOL, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY to ...
(TRUE)
FORGEABLE-ADD-TEXT-MESSAGE
Beginning proof of FORGEABLE-ADD-TEXT-MESSAGE ...
(IMPLIES (AND (IN T (MS!TEXT-MESSAGES)) (IS-GOOD-STATE S))
 (= (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES (SETADD T MS) S))
  (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES MS S))))
Invoking FORGEABLE gives ...
(IMPLIES (AND (IN T (MS!TEXT-MESSAGES)) (IS-GOOD-STATE S))
 (=
  (MS!KNOWN-IN M
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES (SETADD T MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with SETADD-MEMBER, UNION.DEFINITION, UNION.ASSOCIATIVE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES
 with the assumptions MS!KNOWN-IN-BOOL, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY to ...
(TRUE)
FORGEABLE-ADD-PRINCIPAL
Beginning proof of FORGEABLE-ADD-PRINCIPAL ...
(IMPLIES (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-STATE S))
 (= (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES (SETADD P MS) S))
  (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES MS S))))
Invoking FORGEABLE gives ...
(IMPLIES (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-STATE S))
 (=
  (MS!KNOWN-IN M
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES (SETADD P MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with SETADD-MEMBER, UNION.DEFINITION, UNION.ASSOCIATIVE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions MS!KNOWN-IN-BOOL, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
FORGEABLE-ADD-SIGN
Beginning proof of FORGEABLE-ADD-SIGN ...
(IMPLIES
 (AND (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S))
 (= (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES (SETADD (SIGN M1 K) MS) S))
  (FORGEABLE M
   (ADD-TO-STATE-SEEN-MESSAGES
    (SETADD M1 (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS)) S))))
Invoking SIGN gives ...
(IMPLIES
 (AND (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S))
 (=
  (FORGEABLE M
   (ADD-TO-STATE-SEEN-MESSAGES
    (SETADD (MS!COMBINE M1 (MS!ENCRYPT (MS!HASH M1) K)) MS) S))
  (FORGEABLE M
   (ADD-TO-STATE-SEEN-MESSAGES
    (SETADD M1 (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS)) S))))
Which simplifies
 when rewriting with FORGEABLE-ADD-COMBINE
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
>=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE, MS!TAG-OF-COMBINE,
MS!CB1-COMBINE, MS!CB2-COMBINE, MS!COMBINE-IN-COMBINE-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-KEYS-NOT-EMPTY to ...
(TRUE)
FORGEABLE-COMBINE
Beginning proof of FORGEABLE-COMBINE ...
(= (FORGEABLE (MS!COMBINE M1 M2) S) (AND (FORGEABLE M1 S) (FORGEABLE M2 S)))
Invoking FORGEABLE gives ...
(=
 (MS!KNOWN-IN (MS!COMBINE M1 M2)
  (UNION (SEEN-MESSAGES S)
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
 (AND
  (MS!KNOWN-IN M1
   (UNION (SEEN-MESSAGES S)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M2
   (UNION (SEEN-MESSAGES S)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with MS!A1A2, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE to ...
(TRUE)
FORGEABLE-ADD-NONCE
Beginning proof of FORGEABLE-ADD-NONCE ...
(IMPLIES (AND (IN N (MS!NONCES)) (IN M (MS!ATOMIC-MESSAGES)))
 (= (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES (SETADD N MS) S))
  (OR (= M N) (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES MS S)))))
Invoking FORGEABLE gives ...
(IMPLIES (AND (IN N (MS!NONCES)) (IN M (MS!ATOMIC-MESSAGES)))
 (=
  (MS!KNOWN-IN M
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES (SETADD N MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (OR (= M N)
   (MS!KNOWN-IN M
    (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES MS S))
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD-BASIC, MS!D2-RULE, UNION.ASSOCIATIVE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-NONCE, MS!NONCE-IN-BASIC-MESSAGES
 with the assumptions MS!SET-OF-BASIC-MESSAGES-NOT-EMPTY, MS!COMP-OF-BOOL,
MS!KNOWN-IN-BOOL, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
ADD-TO-STATE-SEEN-MESSAGES-IS-STATE, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!SET-OF-NONCES-NOT-EMPTY to ...
(TRUE)
FORGEABLE-ADD-HASH
Beginning proof of FORGEABLE-ADD-HASH ...
(IMPLIES (AND (IN M (MS!ATOMIC-MESSAGES)) (IN M1 (MS!MESSAGES)))
 (= (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES (SETADD (MS!HASH M1) MS) S))
  (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES MS S))))
Invoking FORGEABLE gives ...
(IMPLIES (AND (IN M (MS!ATOMIC-MESSAGES)) (IN M1 (MS!MESSAGES)))
 (=
  (MS!KNOWN-IN M
   (UNION
    (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES (SETADD (MS!HASH M1) MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with MS!C1C, MS!D2-RULE, UNION.ASSOCIATIVE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT,
>=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
MS!TAG-OF-HASH, MS!HSDT-HASH, MS!HASH-IN-HASH-MESSAGES,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
FORGEABLE-ADD-ENCRYPT-HASH
Beginning proof of FORGEABLE-ADD-ENCRYPT-HASH ...
(IMPLIES
 (AND (IN M (MS!ATOMIC-MESSAGES)) (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (FORGEABLE M
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS) S))
  (FORGEABLE M (ADD-TO-STATE-SEEN-MESSAGES MS S))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IN M (MS!ATOMIC-MESSAGES)) (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (MS!KNOWN-IN M
   (UNION
    (SEEN-MESSAGES
     (ADD-TO-STATE-SEEN-MESSAGES (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (SEEN-MESSAGES (ADD-TO-STATE-SEEN-MESSAGES MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with MS!D2-RULE, UNION.ASSOCIATIVE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
SEEN-MESSAGES-OF-ADD-TO-STATE-SEEN-MESSAGES
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-HASH-MESSAGES,
MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M (MS!ATOMIC-MESSAGES)) (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (MS!COMP-OF M
   (SETADD (MS!ENCRYPT (MS!HASH M1) K)
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))))
  (MS!COMP-OF M
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))))
Applying MS!C2 gives ...
(IMPLIES
 (AND (IN M (MS!ATOMIC-MESSAGES)) (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (IF
   (AND
    (NOT
     (MS!COMP-OF M
      (SETADD (MS!HASH M1)
       (UNION MS
        (UNION (MS!PRINCIPALS)
         (UNION (MS!TEXT-MESSAGES)
          (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))))
    (IN (MS!HASH M1) (MS!MESSAGES)) (IN K (MS!KEYS))
    (NOT (= M (MS!ENCRYPT (MS!HASH M1) K))))
   (FALSE)
   (MS!COMP-OF M
    (SETADD (MS!ENCRYPT (MS!HASH M1) K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))))
  (MS!COMP-OF M
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD, MS!C1C
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
FORGEABLE-ADD-TO-STATE-STORAGE
Beginning proof of FORGEABLE-ADD-TO-STATE-STORAGE ...
(= (FORGEABLE M (ADD-TO-STATE-STORAGE P M1 S)) (FORGEABLE M S))
Invoking FORGEABLE gives ...
(=
 (MS!KNOWN-IN M
  (UNION (SEEN-MESSAGES (ADD-TO-STATE-STORAGE P M1 S))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
 (MS!KNOWN-IN M
  (UNION (SEEN-MESSAGES S)
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE,
SEEN-MESSAGES-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
ADD-TO-STATE-STORAGE-IS-STATE to ...
(TRUE)
STORAGE-OF-IS-SUBSET-MESSAGES
Beginning proof of STORAGE-OF-IS-SUBSET-MESSAGES ...
(IMPLIES (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)))
 (SUBSET (STORAGE-OF P S) (MS!MESSAGES)))
Invoking SUBSET gives ...
(IMPLIES (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)))
 (ALL (E) (IMPLIES (IN E (STORAGE-OF P S)) (IN E (MS!MESSAGES)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN E (STORAGE-OF P S)))
 (IN E (MS!MESSAGES)))
Invoking STORAGE-OF gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P)))
 (IN E (MS!MESSAGES)))
Assuming FN!APPLY-IN-RAN with the
instantiations: (= F (STORES S)) (= X P) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION (STORES S)) (IN P (REL!DOM (STORES S))))
   (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S))))
  (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P)))
 (IN E (MS!MESSAGES)))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P))
  (IMPLIES (AND (FN!IS-FUNCTION (STORES S)) (IN P (REL!DOM (STORES S))))
   (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S)))))
 (IN E (MS!MESSAGES)))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P))
  (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S))))
 (IN E (MS!MESSAGES)))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE S) (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY S))
  (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
  (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES)))
  (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P))
  (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S))))
 (IN E (MS!MESSAGES)))
Invoking SUBSET gives ...
(IMPLIES
 (AND (IS-STATE S)
  (ALL (E$0) (IMPLIES (IN E$0 (SEEN-MESSAGES S)) (IN E$0 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY S))
  (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
  (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
  (ALL (E$1)
   (IMPLIES (IN E$1 (REL!RAN (STORES S))) (IN E$1 (POWERSET (MS!MESSAGES)))))
  (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P))
  (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S))))
 (IN E (MS!MESSAGES)))
Which simplifies
 when rewriting with POWERSET.DEFINITION, SEQ!IN-SEQUENCE-OF
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE S)
  (ALL (E$0) (IMPLIES (IN E$0 (SEEN-MESSAGES S)) (IN E$0 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY S)) (SEQ!IS-SEQUENCE (HISTORY S))
  (SUBSET (SEQ!MEMBERS (HISTORY S)) (EVENTS)) (FN!IS-FUNCTION (STORES S))
  (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
  (ALL (E$1)
   (IMPLIES (IN E$1 (REL!RAN (STORES S))) (SUBSET E$1 (MS!MESSAGES))))
  (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P))
  (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S))))
 (IN E (MS!MESSAGES)))
Invoking SUBSET gives ...
(IMPLIES
 (AND (IS-STATE S)
  (ALL (E$0) (IMPLIES (IN E$0 (SEEN-MESSAGES S)) (IN E$0 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY S)) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (E$1) (IMPLIES (IN E$1 (SEQ!MEMBERS (HISTORY S))) (IN E$1 (EVENTS))))
  (FN!IS-FUNCTION (STORES S)) (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
  (ALL (E$2)
   (IMPLIES (IN E$2 (REL!RAN (STORES S)))
    (ALL (E$3) (IMPLIES (IN E$3 E$2) (IN E$3 (MS!MESSAGES))))))
  (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P))
  (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S))))
 (IN E (MS!MESSAGES)))
Which simplifies
 when rewriting with SEQ!IN-MEMBERS
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE S)
  (ALL (E$0) (IMPLIES (IN E$0 (SEEN-MESSAGES S)) (IN E$0 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY S)) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (E$1) (IMPLIES (SEQ!IS-MEMBER E$1 (HISTORY S)) (IN E$1 (EVENTS))))
  (FN!IS-FUNCTION (STORES S)) (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
  (ALL (E$2)
   (IMPLIES (IN E$2 (REL!RAN (STORES S)))
    (ALL (E$3) (IMPLIES (IN E$3 E$2) (IN E$3 (MS!MESSAGES))))))
  (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P))
  (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S))))
 (IN E (MS!MESSAGES)))
Instantiating (= E$2 (FN!APPLY (STORES S) P)) gives ...
(IMPLIES
 (AND (IS-STATE S)
  (ALL (E$0) (IMPLIES (IN E$0 (SEEN-MESSAGES S)) (IN E$0 (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY S)) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (E$1) (IMPLIES (SEQ!IS-MEMBER E$1 (HISTORY S)) (IN E$1 (EVENTS))))
  (FN!IS-FUNCTION (STORES S)) (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
  (IMPLIES (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S)))
   (ALL (E$2)
    (IMPLIES (IN E$2 (FN!APPLY (STORES S) P)) (IN E$2 (MS!MESSAGES)))))
  (ALL (E$3)
   (IMPLIES (IN E$3 (REL!RAN (STORES S)))
    (ALL (E$4) (IMPLIES (IN E$4 E$3) (IN E$4 (MS!MESSAGES))))))
  (IN P (MS!PRINCIPALS)) (IN E (FN!APPLY (STORES S) P))
  (IN (FN!APPLY (STORES S) P) (REL!RAN (STORES S))))
 (IN E (MS!MESSAGES)))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL
 with the instantiation (= E$2 E) to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-COMBINE
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-COMBINE ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN M1 (MS!MESSAGES))
  (IN M2 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)))
 (=
  (KNOWN-BY-PRINCIPAL M P
   (ADD-TO-STATE-STORAGE P (SETADD (MS!COMBINE M1 M2) MS) S))
  (KNOWN-BY-PRINCIPAL M P
   (ADD-TO-STATE-STORAGE P (SETADD M1 (SETADD M2 MS)) S))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN M1 (MS!MESSAGES))
  (IN M2 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)))
 (=
  (MS!KNOWN-IN M
   (UNION
    (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD (MS!COMBINE M1 M2) MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD M1 (SETADD M2 MS)) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with UNION.ASSOCIATIVE, UNION.PERMUTATIVE, UNION.COMMUTATIVE,
SETRULES!SETADD-UNION-LEFT, STORAGE-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!TAG-OF-COMBINE-MESSAGES, MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1,
MS!SIZE-CB2, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
ADD-TO-STATE-STORAGE-IS-STATE, MS!TAG-OF-COMBINE, MS!CB1-COMBINE,
MS!CB2-COMBINE, MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN M1 (MS!MESSAGES))
  (IN M2 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)))
 (=
  (MS!KNOWN-IN M
   (SETADD (MS!COMBINE M1 M2)
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (MS!KNOWN-IN M
   (SETADD M1
    (SETADD M2
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))))
Applying MS!KNOWN-IN-SETADD-COMBINE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN M1 (MS!MESSAGES))
  (IN M2 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)))
 (=
  (IF
   (AND (IN M (MS!MESSAGES)) (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
    (SUBSET
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))
     (MS!MESSAGES)))
   (MS!KNOWN-IN M
    (SETADD M1
     (SETADD M2
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
   (MS!KNOWN-IN M
    (SETADD (MS!COMBINE M1 M2)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (MS!KNOWN-IN M
   (SETADD M1
    (SETADD M2
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))))
Which simplifies
 when rewriting with MS!PUBLIC-KEYS-ARE-MESSAGES,
MS!TEXT-MESSAGES-SUBSET-OF-MESSAGES, MS!PRINCIPALS-SUBSET-OF-MESSAGES,
SETRULES!SUBSET-UNION-LEFT
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-PUBLIC-KEY
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-PUBLIC-KEY ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IN PK (MS!PUBLIC-KEYS)) (IS-GOOD-STATE S))
 (= (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD PK MS) S))
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P MS S))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IN PK (MS!PUBLIC-KEYS)) (IS-GOOD-STATE S))
 (=
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD PK MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with SETADD-MEMBER, UNION.DEFINITION, UNION.ASSOCIATIVE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
STORAGE-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
>=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions MS!KNOWN-IN-BOOL, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, ADD-TO-STATE-STORAGE-IS-STATE,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-TEXT-MESSAGE
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-TEXT-MESSAGE ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IN T (MS!TEXT-MESSAGES)) (IS-GOOD-STATE S))
 (= (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD T MS) S))
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P MS S))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IN T (MS!TEXT-MESSAGES)) (IS-GOOD-STATE S))
 (=
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD T MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with SETADD-MEMBER, UNION.DEFINITION, UNION.ASSOCIATIVE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
STORAGE-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions MS!KNOWN-IN-BOOL, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, ADD-TO-STATE-STORAGE-IS-STATE,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-PRINCIPAL
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-PRINCIPAL ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE S))
 (= (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD P1 MS) S))
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P MS S))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE S))
 (=
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD P1 MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with SETADD-MEMBER, UNION.DEFINITION, UNION.ASSOCIATIVE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
STORAGE-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions MS!KNOWN-IN-BOOL, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
ADD-TO-STATE-STORAGE-IS-STATE, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-SIGN
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-SIGN ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES))
  (SUBSET MS (MS!MESSAGES)) (IS-GOOD-STATE S))
 (=
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD (SIGN M1 K) MS) S))
  (KNOWN-BY-PRINCIPAL M P
   (ADD-TO-STATE-STORAGE P (SETADD M1 (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS))
    S))))
Invoking SIGN gives ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES))
  (SUBSET MS (MS!MESSAGES)) (IS-GOOD-STATE S))
 (=
  (KNOWN-BY-PRINCIPAL M P
   (ADD-TO-STATE-STORAGE P
    (SETADD (MS!COMBINE M1 (MS!ENCRYPT (MS!HASH M1) K)) MS) S))
  (KNOWN-BY-PRINCIPAL M P
   (ADD-TO-STATE-STORAGE P (SETADD M1 (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS))
    S))))
Which simplifies
 when rewriting with KNOWN-BY-PRINCIPAL-ADD-COMBINE
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE, MS!TAG-OF-COMBINE,
MS!CB1-COMBINE, MS!CB2-COMBINE, MS!COMBINE-IN-COMBINE-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-COMBINE
Beginning proof of KNOWN-BY-PRINCIPAL-COMBINE ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (= (KNOWN-BY-PRINCIPAL (MS!COMBINE M1 M2) P S)
  (AND (KNOWN-BY-PRINCIPAL M1 P S) (KNOWN-BY-PRINCIPAL M2 P S))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES (IN P (MS!PRINCIPALS))
 (=
  (MS!KNOWN-IN (MS!COMBINE M1 M2)
   (UNION (STORAGE-OF P S)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (AND
   (MS!KNOWN-IN M1
    (UNION (STORAGE-OF P S)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
   (MS!KNOWN-IN M2
    (UNION (STORAGE-OF P S)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))))
Which simplifies
 when rewriting with MS!A1A2, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!TAG-OF-COMBINE, MS!CB1-COMBINE,
MS!CB2-COMBINE, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-NONCE
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-NONCE ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN N (MS!NONCES))
  (IN M (MS!ATOMIC-MESSAGES)))
 (= (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD N MS) S))
  (OR (= M N) (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P MS S)))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (IN N (MS!NONCES))
  (IN M (MS!ATOMIC-MESSAGES)))
 (=
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD N MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (OR (= M N)
   (MS!KNOWN-IN M
    (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P MS S))
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD-BASIC, MS!D2-RULE, UNION.ASSOCIATIVE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT,
STORAGE-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-NONCE, MS!NONCE-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-BASIC-MESSAGES-NOT-EMPTY, MS!COMP-OF-BOOL,
MS!KNOWN-IN-BOOL, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
ADD-TO-STATE-STORAGE-IS-STATE, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!SET-OF-NONCES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-HASH
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-HASH ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)))
 (=
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD (MS!HASH M1) MS) S))
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P MS S))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)))
 (=
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD (MS!HASH M1) MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with MS!C1C, MS!D2-RULE, UNION.ASSOCIATIVE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT, STORAGE-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, ADD-TO-STATE-STORAGE-IS-STATE, MS!TAG-OF-HASH,
MS!HSDT-HASH, MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-ENCRYPT-HASH
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-ENCRYPT-HASH ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (KNOWN-BY-PRINCIPAL M P
   (ADD-TO-STATE-STORAGE P (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS) S))
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P MS S))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (MS!KNOWN-IN M
   (UNION
    (STORAGE-OF P
     (ADD-TO-STATE-STORAGE P (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P MS S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with MS!D2-RULE, UNION.ASSOCIATIVE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT, STORAGE-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-HASH-MESSAGES,
MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, ADD-TO-STATE-STORAGE-IS-STATE,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (MS!COMP-OF M
   (SETADD (MS!ENCRYPT (MS!HASH M1) K)
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (MS!COMP-OF M
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
Applying MS!C2 gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (IF
   (AND
    (NOT
     (MS!COMP-OF M
      (SETADD (MS!HASH M1)
       (UNION MS
        (UNION (MS!PRINCIPALS)
         (UNION (MS!TEXT-MESSAGES)
          (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
    (IN (MS!HASH M1) (MS!MESSAGES)) (IN K (MS!KEYS))
    (NOT (= M (MS!ENCRYPT (MS!HASH M1) K))))
   (FALSE)
   (MS!COMP-OF M
    (SETADD (MS!ENCRYPT (MS!HASH M1) K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (MS!COMP-OF M
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD, MS!C1C
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
PERMUTE-ADD-TO-STORAGE-ADD-TO-HISTORY
Beginning proof of PERMUTE-ADD-TO-STORAGE-ADD-TO-HISTORY ...
(= (ADD-TO-STATE-STORAGE P M (ADD-TO-STATE-HISTORY E STATE))
 (ADD-TO-STATE-HISTORY E (ADD-TO-STATE-STORAGE P M STATE)))
Which simplifies
 with invocation of ADD-TO-STORAGE, ADD-TO-STATE-STORAGE, ADD-TO-STATE-HISTORY
 forward chaining using PAIR!PAIR-COMPOSITION, SEQ!TACK-HEAD-TAIL
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
FN!IS-FUNCTION-BOOL, ADD-TO-STATE-STORAGE-IS-STATE, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE, STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
ADD-TO-STATE-HISTORY-IS-STATE to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-TO-STORAGE-AND-HISTORY
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-TO-STORAGE-AND-HISTORY ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN P2 (MS!PRINCIPALS)) (SUBSET M2 (MS!MESSAGES)))
 (=
  (KNOWN-BY-PRINCIPAL M1 P1
   (ADD-TO-STATE-STORAGE P2 M2 (ADD-TO-STATE-HISTORY EVENT STATE)))
  (KNOWN-BY-PRINCIPAL M1 P1 (ADD-TO-STATE-STORAGE P2 M2 STATE))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN P2 (MS!PRINCIPALS)) (SUBSET M2 (MS!MESSAGES)))
 (=
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF P1
     (ADD-TO-STATE-STORAGE P2 M2 (ADD-TO-STATE-HISTORY EVENT STATE)))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M1
   (UNION (STORAGE-OF P1 (ADD-TO-STATE-STORAGE P2 M2 STATE))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN P2 (MS!PRINCIPALS)) (SUBSET M2 (MS!MESSAGES)))
 (=
  (MS!KNOWN-IN M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS)
      (STORAGE-OF P1
       (ADD-TO-STATE-STORAGE P2 M2 (ADD-TO-STATE-HISTORY EVENT STATE)))))))
  (MS!KNOWN-IN M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS)
      (STORAGE-OF P1 (ADD-TO-STATE-STORAGE P2 M2 STATE))))))))
Applying PERMUTE-ADD-TO-STORAGE-ADD-TO-HISTORY gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN P2 (MS!PRINCIPALS)) (SUBSET M2 (MS!MESSAGES)))
 (=
  (MS!KNOWN-IN M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS)
      (STORAGE-OF P1
       (ADD-TO-STATE-HISTORY EVENT (ADD-TO-STATE-STORAGE P2 M2 STATE)))))))
  (MS!KNOWN-IN M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS)
      (STORAGE-OF P1 (ADD-TO-STATE-STORAGE P2 M2 STATE))))))))
Which simplifies
 when rewriting with STORAGE-OF-ADD-TO-STATE-HISTORY,
IS-GOOD-STATE-ADD-TO-STATE-STORAGE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, ADD-TO-STATE-HISTORY-IS-STATE,
ADD-TO-STATE-STORAGE-IS-STATE, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
NEWLY-KNOWN-BY-GENERATION-NOT-FORGEABLE
Beginning proof of NEWLY-KNOWN-BY-GENERATION-NOT-FORGEABLE ...
(IMPLIES
 (AND (NOT (KNOWN-BY-PRINCIPAL M1 P1 STATE)) (IN M1 (MS!ATOMIC-MESSAGES))
  (IN P1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M1 P1 (GENERATE-STEP LABEL TIME M2 P2 STATE)))
 (AND (= M1 M2) (= P1 P2) (NOT (FORGEABLE M1 STATE))))
Invoking GENERATE-STEP gives ...
(IMPLIES
 (AND (NOT (KNOWN-BY-PRINCIPAL M1 P1 STATE)) (IN M1 (MS!ATOMIC-MESSAGES))
  (IN P1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M1 P1
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN M2 (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH M2 (ALL-MESSAGES-IN-STATE STATE)) (IN P2 (MS!PRINCIPALS)))
    (ADD-TO-STATE-STORAGE P2 (SETADD M2 (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME M2 P2) STATE))
    STATE)))
 (AND (= M1 M2) (= P1 P2) (NOT (FORGEABLE M1 STATE))))
Which simplifies
 when rewriting with KNOWN-BY-PRINCIPAL-ADD-TO-STORAGE-AND-HISTORY,
SUBSET.NULLSET.LEFT, SETRULES!SUBSET-SETADD, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (NOT (KNOWN-BY-PRINCIPAL M1 P1 STATE)) (IN M1 (MS!ATOMIC-MESSAGES))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M1 P1
   (ADD-TO-STATE-STORAGE P2 (SETADD M2 (NULLSET)) STATE)))
 (AND (= M1 M2) (= P1 P2) (NOT (FORGEABLE M1 STATE))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND
  (NOT
   (MS!KNOWN-IN M1
    (UNION (STORAGE-OF P1 STATE)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (MS!KNOWN-IN M1
   (UNION
    (STORAGE-OF P1 (ADD-TO-STATE-STORAGE P2 (SETADD M2 (NULLSET)) STATE))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (AND (= M1 M2) (= P1 P2) (NOT (FORGEABLE M1 STATE))))
Which simplifies
 when rewriting with MS!D2-RULE, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT,
STORAGE-OF-ADD-TO-STATE-STORAGE, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!COMP-OF-BOOL, STORAGE-OF-IS-SUBSET-MESSAGES,
ADD-TO-STATE-STORAGE-IS-STATE, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2)
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2) (NOT (FORGEABLE M1 STATE))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2)
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!KNOWN-IN M1
    (UNION (SEEN-MESSAGES STATE)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))))
Which simplifies
 when rewriting with MS!D2-RULE, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!COMP-OF-BOOL, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2)
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Splitting
on (AND (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS))) generates ...
(IF (AND (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)))
 (IMPLIES
  (AND
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
   (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
   (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
   (= P1 P2)
   (MS!COMP-OF M1
    (SETADD M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
  (AND (= M1 M2)
   (NOT
    (MS!COMP-OF M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
 (IMPLIES
  (AND
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
   (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
   (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
   (= P1 P2)
   (MS!COMP-OF M1
    (SETADD M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
  (AND (= M1 M2)
   (NOT
    (MS!COMP-OF M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))))
Which simplifies
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!COMP-OF-BOOL, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2)
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Splitting on (IN M2 (MS!SECRET-KEYS)) generates ...
(IF (IN M2 (MS!SECRET-KEYS))
 (IMPLIES
  (AND
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
   (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
   (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
   (= P1 P2)
   (MS!COMP-OF M1
    (SETADD M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
  (AND (= M1 M2)
   (NOT
    (MS!COMP-OF M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
 (IMPLIES
  (AND
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
   (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
   (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
   (= P1 P2)
   (MS!COMP-OF M1
    (SETADD M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
  (AND (= M1 M2)
   (NOT
    (MS!COMP-OF M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD-FRESH-KEY
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!INVERSE-IN-ASYMMETRIC-KEYS, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC
 with the assumptions MS!SET-OF-KEYS-NOT-EMPTY, MS!COMP-OF-BOOL,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-SECRET-KEYS-NOT-EMPTY to ...
(IF (IN M2 (MS!SECRET-KEYS))
 (IMPLIES
  (AND
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
   (= P1 P2) (= M1 M2))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
 (IMPLIES
  (AND
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
   (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
   (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
   (= P1 P2)
   (MS!COMP-OF M1
    (SETADD M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
  (AND (= M1 M2)
   (NOT
    (MS!COMP-OF M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))))
Starting case 2 ...
(IMPLIES
 (AND (IN M2 (MS!SECRET-KEYS))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2) (= M1 M2))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Splitting on (= M1 M2) generates ...
(IF (= M1 M2)
 (IMPLIES
  (AND (IN M2 (MS!SECRET-KEYS))
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
   (= P1 P2) (= M1 M2))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
 (IMPLIES
  (AND (IN M2 (MS!SECRET-KEYS))
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
   (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
   (= P1 P2) (= M1 M2))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Which simplifies
 when rewriting with MS!D2-RULE
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!COMP-OF-IN-MESSAGES,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!INVERSE-IN-ASYMMETRIC-KEYS,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC
 with the assumptions MS!COMP-OF-BOOL, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-SECRET-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND (= M1 M2) (IN M2 (MS!SECRET-KEYS))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (>= LABEL 0) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Applying MS!NOT-PART-IMPLIES-NOT-COMP-OF to
 (MS!COMP-OF M1
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))) gives
...
(IMPLIES
 (AND (= M1 M2) (IN M2 (MS!SECRET-KEYS))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (>= LABEL 0) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2))
 (NOT
  (AND
   (IN M1
    (MS!PARTS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Which simplifies
 when rewriting with UNION.DEFINITION, MS!PARTS-ATOMIC, MS!PARTS-UNION
 forward chaining using MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!COMP-OF-IN-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!INVERSE-IN-ASYMMETRIC-KEYS, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-SECRET-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND (= M1 M2) (IN M2 (MS!SECRET-KEYS))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (>= LABEL 0) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2) (IN M1 (MS!PARTS (SEEN-MESSAGES STATE))))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Invoking MS!IS-FRESH gives ...
(IMPLIES
 (AND (= M1 M2) (IN M2 (MS!SECRET-KEYS))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (>= LABEL 0) (NOT (IN M2 (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT (SOME (M) (IN (MS!ENCRYPT M M2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE M2)) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (ALL (M$1 K2)
   (AND
    (NOT (IN (MS!SHARE-ENCRYPT M$1 M2 K2) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 (MS!INVERSE M2) K2)
      (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT (IN (MS!SHARE-ENCRYPT M$1 K2 M2) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 (MS!INVERSE M2))
      (MS!PARTS (SEEN-MESSAGES STATE))))))
  (NOT (IN M2 (MS!PARTS (ALL-STORAGE (STORES STATE)))))
  (NOT
   (SOME (M$2)
    (IN (MS!ENCRYPT M$2 M2) (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$3)
    (IN (MS!ENCRYPT M$3 (MS!INVERSE M2))
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (ALL (M$4 K2$0)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 M2 K2$0)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 (MS!INVERSE M2) K2$0)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 K2$0 M2)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 K2$0 (MS!INVERSE M2))
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))))
  (IN P2 (MS!PRINCIPALS)) (= P1 P2) (IN M1 (MS!PARTS (SEEN-MESSAGES STATE))))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!COMP-OF-IN-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!INVERSE-IN-ASYMMETRIC-KEYS, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC
 with the assumptions MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT,
MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT, MS!INVERSE-ASYMMETRIC,
MS!INVERSE-IN-KEYS-1, MS!TAG-OF-INVERSE-1, MS!TAG-OF-INVERSE-2,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-SECRET-KEYS-NOT-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2)
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Assuming MS!IS-FRESH-SUBSET with the
instantiations: (= K M2) (= S1 (ALL-STORAGE (STORES STATE)))
                (= S2 (STORAGE-OF P1 STATE)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
    (SUBSET (STORAGE-OF P1 STATE) (ALL-STORAGE (STORES STATE))))
   (MS!IS-FRESH M2 (STORAGE-OF P1 STATE)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (>= LABEL 0) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (= P1 P2)
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (IN P2 (MS!PRINCIPALS))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IMPLIES
   (AND (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
    (SUBSET (STORAGE-OF P1 STATE) (ALL-STORAGE (STORES STATE))))
   (MS!IS-FRESH M2 (STORAGE-OF P1 STATE))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Which simplifies
 when rewriting with FRESH-IN-STORAGE-OF-PRINCIPAL,
STORAGE-OF-SUBSET-ALL-STORAGE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!INVERSE-IN-ASYMMETRIC-KEYS,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC, >=.SAME.TYPE
 with the assumptions MS!COMP-OF-BOOL, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-SECRET-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Completing all cases produces ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Splitting on (IN M2 (MS!SYMMETRIC-KEYS)) generates ...
(IF (IN M2 (MS!SYMMETRIC-KEYS))
 (IMPLIES
  (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SECRET-KEYS)))
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
   (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
   (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
   (MS!COMP-OF M1
    (SETADD M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
  (AND (= M1 M2)
   (NOT
    (MS!COMP-OF M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
 (IMPLIES
  (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SECRET-KEYS)))
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
   (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
   (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
   (MS!COMP-OF M1
    (SETADD M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
  (AND (= M1 M2)
   (NOT
    (MS!COMP-OF M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD-FRESH-KEY
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!INVERSE-IN-ASYMMETRIC-KEYS, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-SYMKEY, MS!SYMMETRIC-KEY-IN-KEYS
 with the assumptions MS!SET-OF-KEYS-NOT-EMPTY, MS!COMP-OF-BOOL,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-SECRET-KEYS-NOT-EMPTY,
MS!SET-OF-SYMMETRIC-KEYS-NOT-EMPTY to ...
(IF (IN M2 (MS!SYMMETRIC-KEYS))
 (IMPLIES
  (AND (>= LABEL 0) (= P1 P2)
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (= M1 M2))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
 (IMPLIES
  (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SECRET-KEYS)))
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
   (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
   (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
   (MS!COMP-OF M1
    (SETADD M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
  (AND (= M1 M2)
   (NOT
    (MS!COMP-OF M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))))
Starting case 2 ...
(IMPLIES
 (AND (IN M2 (MS!SYMMETRIC-KEYS)) (>= LABEL 0) (= P1 P2)
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (= M1 M2))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Splitting on (= M1 M2) generates ...
(IF (= M1 M2)
 (IMPLIES
  (AND (IN M2 (MS!SYMMETRIC-KEYS)) (>= LABEL 0) (= P1 P2)
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (= M1 M2))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
 (IMPLIES
  (AND (IN M2 (MS!SYMMETRIC-KEYS)) (>= LABEL 0) (= P1 P2)
   (NOT
    (MS!KNOWN-IN M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
   (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
   (TIME-CONSTRAINT TIME STATE) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
   (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (= M1 M2))
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Which simplifies
 when rewriting with MS!D2-RULE
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!COMP-OF-IN-MESSAGES,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-SYMKEY, MS!SYMMETRIC-KEY-IN-KEYS
 with the assumptions MS!COMP-OF-BOOL, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-SYMMETRIC-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND (= M1 M2) (IN M2 (MS!SYMMETRIC-KEYS)) (>= LABEL 0) (= P1 P2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Applying MS!NOT-PART-IMPLIES-NOT-COMP-OF to
 (MS!COMP-OF M1
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))) gives
...
(IMPLIES
 (AND (= M1 M2) (IN M2 (MS!SYMMETRIC-KEYS)) (>= LABEL 0) (= P1 P2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))))
 (NOT
  (AND
   (IN M1
    (MS!PARTS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Which simplifies
 when rewriting with UNION.DEFINITION, MS!PARTS-ATOMIC, MS!PARTS-UNION
 forward chaining using MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS,
MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!COMP-OF-IN-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-SYMKEY,
MS!SYMMETRIC-KEY-IN-KEYS
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-SYMMETRIC-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND (= M1 M2) (IN M2 (MS!SYMMETRIC-KEYS)) (>= LABEL 0) (= P1 P2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (IN M1 (MS!PARTS (SEEN-MESSAGES STATE))))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Invoking MS!IS-FRESH gives ...
(IMPLIES
 (AND (= M1 M2) (IN M2 (MS!SYMMETRIC-KEYS)) (>= LABEL 0) (= P1 P2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (NOT (IN M2 (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT (SOME (M) (IN (MS!ENCRYPT M M2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE M2)) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (ALL (M$1 K2)
   (AND
    (NOT (IN (MS!SHARE-ENCRYPT M$1 M2 K2) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 (MS!INVERSE M2) K2)
      (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT (IN (MS!SHARE-ENCRYPT M$1 K2 M2) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 (MS!INVERSE M2))
      (MS!PARTS (SEEN-MESSAGES STATE))))))
  (NOT (IN M2 (MS!PARTS (ALL-STORAGE (STORES STATE)))))
  (NOT
   (SOME (M$2)
    (IN (MS!ENCRYPT M$2 M2) (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$3)
    (IN (MS!ENCRYPT M$3 (MS!INVERSE M2))
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (ALL (M$4 K2$0)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 M2 K2$0)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 (MS!INVERSE M2) K2$0)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 K2$0 M2)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 K2$0 (MS!INVERSE M2))
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))))
  (IN M1 (MS!PARTS (SEEN-MESSAGES STATE))))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!COMP-OF-IN-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-SYMKEY,
MS!SYMMETRIC-KEY-IN-KEYS
 with the assumptions MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT,
MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT, MS!INVERSE-IN-KEYS-1,
MS!TAG-OF-INVERSE-1, MS!TAG-OF-INVERSE-2, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-SYMMETRIC-KEYS-NOT-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (IN M2 (MS!SYMMETRIC-KEYS))) (>= LABEL 0) (= P1 P2)
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Assuming MS!IS-FRESH-SUBSET with the
instantiations: (= K M2) (= S1 (ALL-STORAGE (STORES STATE)))
                (= S2 (STORAGE-OF P1 STATE)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
    (SUBSET (STORAGE-OF P1 STATE) (ALL-STORAGE (STORES STATE))))
   (MS!IS-FRESH M2 (STORAGE-OF P1 STATE)))
  (NOT (IN M2 (MS!SYMMETRIC-KEYS))) (>= LABEL 0) (= P1 P2)
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IMPLIES
   (AND (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
    (SUBSET (STORAGE-OF P1 STATE) (ALL-STORAGE (STORES STATE))))
   (MS!IS-FRESH M2 (STORAGE-OF P1 STATE))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Which simplifies
 when rewriting with FRESH-IN-STORAGE-OF-PRINCIPAL,
STORAGE-OF-SUBSET-ALL-STORAGE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!INVERSE-IN-ASYMMETRIC-KEYS, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-SYMKEY, MS!SYMMETRIC-KEY-IN-KEYS,
>=.SAME.TYPE
 with the assumptions MS!COMP-OF-BOOL, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-SECRET-KEYS-NOT-EMPTY, MS!SET-OF-SYMMETRIC-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Completing all cases produces ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!ATOMIC-MESSAGES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!ATOMIC-MESSAGES))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Invoking MS!ATOMIC-MESSAGES gives ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (UNION (MS!KEYS) (MS!BASIC-MESSAGES))) (IN P1 (MS!PRINCIPALS))
  (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (IN M2 (UNION (MS!KEYS) (MS!BASIC-MESSAGES))) (NOT (IN M2 (MS!PRINCIPALS)))
  (NOT (IN M2 (MS!TEXT-MESSAGES))) (NOT (IN M2 (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Invoking MS!KEYS gives ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1
   (UNION (UNION (MS!SYMMETRIC-KEYS) (MS!ASYMMETRIC-KEYS))
    (MS!BASIC-MESSAGES)))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (IN M2
   (UNION (UNION (MS!SYMMETRIC-KEYS) (MS!ASYMMETRIC-KEYS))
    (MS!BASIC-MESSAGES)))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Invoking MS!ASYMMETRIC-KEYS gives ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1
   (UNION
    (UNION (MS!SYMMETRIC-KEYS) (UNION (MS!PUBLIC-KEYS) (MS!SECRET-KEYS)))
    (MS!BASIC-MESSAGES)))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (IN M2
   (UNION
    (UNION (MS!SYMMETRIC-KEYS) (UNION (MS!PUBLIC-KEYS) (MS!SECRET-KEYS)))
    (MS!BASIC-MESSAGES)))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Invoking MS!BASIC-MESSAGES gives ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1
   (UNION
    (UNION (MS!SYMMETRIC-KEYS) (UNION (MS!PUBLIC-KEYS) (MS!SECRET-KEYS)))
    (UNION (MS!NONCES) (UNION (MS!PRINCIPALS) (MS!TEXT-MESSAGES)))))
  (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE)
  (IN M2
   (UNION
    (UNION (MS!SYMMETRIC-KEYS) (UNION (MS!PUBLIC-KEYS) (MS!SECRET-KEYS)))
    (UNION (MS!NONCES) (UNION (MS!PRINCIPALS) (MS!TEXT-MESSAGES)))))
  (NOT (IN M2 (MS!PRINCIPALS))) (NOT (IN M2 (MS!TEXT-MESSAGES)))
  (NOT (IN M2 (MS!PUBLIC-KEYS))) (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE)))
  (MS!COMP-OF M1
   (SETADD M2
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE)))))))
 (AND (= M1 M2)
  (NOT
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD-BASIC, MS!COMP-OF-SETADD-FRESH,
FRESH-IN-STORAGE-OF-PRINCIPAL, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.DEFINITION, UNION.COMMUTATIVE, UNION.ASSOCIATIVE, UNION.PERMUTATIVE
 forward chaining using MS!COMP-OF-IN-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-NONCE,
MS!NONCE-IN-BASIC-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!INVERSE-IN-ASYMMETRIC-KEYS, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-SYMKEY, MS!SYMMETRIC-KEY-IN-KEYS,
>=.SAME.TYPE
 with the assumptions MS!SET-OF-BASIC-MESSAGES-NOT-EMPTY, MS!COMP-OF-BOOL,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-NONCES-NOT-EMPTY, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-SECRET-KEYS-NOT-EMPTY,
MS!SET-OF-SYMMETRIC-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!NONCES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!NONCES))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (= M1 M2))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Applying MS!NOT-PART-IMPLIES-NOT-COMP-OF to
 (MS!COMP-OF M1
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))) gives
...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!NONCES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!NONCES))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (= M1 M2))
 (NOT
  (AND
   (IN M1
    (MS!PARTS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))
   (MS!COMP-OF M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE))))))))
Which simplifies
 when rewriting with UNION.DEFINITION, MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!PARTS-ATOMIC, MS!PRINCIPAL-ATOMIC, MS!PARTS-UNION
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-NONCE,
MS!NONCE-IN-BASIC-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!INVERSE-IN-ASYMMETRIC-KEYS, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-SYMKEY, MS!SYMMETRIC-KEY-IN-KEYS,
>=.SAME.TYPE
 with the assumptions MS!COMP-OF-BOOL, MS!SET-OF-NONCES-NOT-EMPTY,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-SECRET-KEYS-NOT-EMPTY, MS!SET-OF-SYMMETRIC-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!NONCES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!NONCES))
  (MS!IS-FRESH M2 (SEEN-MESSAGES STATE))
  (MS!IS-FRESH M2 (ALL-STORAGE (STORES STATE))) (= M1 M2)
  (IN M1 (MS!PARTS (SEEN-MESSAGES STATE))))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Invoking MS!IS-FRESH gives ...
(IMPLIES
 (AND (>= LABEL 0) (= P1 P2) (NOT (IN M2 (MS!SYMMETRIC-KEYS)))
  (NOT (IN M2 (MS!SECRET-KEYS)))
  (NOT
   (MS!KNOWN-IN M1
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P1 STATE))))))
  (IN M1 (MS!NONCES)) (IN P1 (MS!PRINCIPALS)) (IS-GOOD-STATE STATE)
  (TIME-CONSTRAINT TIME STATE) (IN M2 (MS!NONCES))
  (NOT (IN M2 (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT (SOME (M) (IN (MS!ENCRYPT M M2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE M2)) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (ALL (M$1 K2)
   (AND
    (NOT (IN (MS!SHARE-ENCRYPT M$1 M2 K2) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 (MS!INVERSE M2) K2)
      (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT (IN (MS!SHARE-ENCRYPT M$1 K2 M2) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 (MS!INVERSE M2))
      (MS!PARTS (SEEN-MESSAGES STATE))))))
  (NOT (IN M2 (MS!PARTS (ALL-STORAGE (STORES STATE)))))
  (NOT
   (SOME (M$2)
    (IN (MS!ENCRYPT M$2 M2) (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$3)
    (IN (MS!ENCRYPT M$3 (MS!INVERSE M2))
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (ALL (M$4 K2$0)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 M2 K2$0)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 (MS!INVERSE M2) K2$0)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 K2$0 M2)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 K2$0 (MS!INVERSE M2))
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))))
  (= M1 M2) (IN M1 (MS!PARTS (SEEN-MESSAGES STATE))))
 (NOT
  (MS!COMP-OF M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
Which simplifies
 forward chaining using TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-NONCE,
MS!NONCE-IN-BASIC-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!INVERSE-IN-ASYMMETRIC-KEYS, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-SECKEY, MS!SECRET-KEY-IS-ASYMMETRIC,
MS!INVERSE-OF-SECRET-KEY-IS-PUBLIC, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-SYMKEY, MS!SYMMETRIC-KEY-IN-KEYS,
>=.SAME.TYPE
 with the assumptions MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT,
MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!SET-OF-NONCES-NOT-EMPTY,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-SECRET-KEYS-NOT-EMPTY, MS!SET-OF-SYMMETRIC-KEYS-NOT-EMPTY to ...
(TRUE)
IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION
Beginning proof of IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION ...
(IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
 (SOME (SEQUENCE)
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
Inducting using the following scheme ...
 (AND (IMPLIES (SEQ!EMPTYP (HISTORY STATE)) (*P* STATE))
  (IMPLIES
   (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
    (ALL (PREVIOUS-STATE)
     (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
      (*P* PREVIOUS-STATE) (TRUE))))
   (*P* STATE)))
 produces ...
(AND
 (IMPLIES (SEQ!EMPTYP (HISTORY STATE))
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (SEQUENCE)
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE)))))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
   (ALL (PREVIOUS-STATE)
    (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IMPLIES (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (SOME (SEQUENCE)
       (AND (IS-GOOD-EVOLUTION SEQUENCE)
        (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE))))
     (TRUE))))
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (SEQUENCE)
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))))
Starting case 2 ...
(IMPLIES (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-EVOLUTION-STATE STATE))
 (SOME (SEQUENCE)
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
Instantiating (= SEQUENCE (SEQ!TACK STATE (SEQ!EMPTY))) gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-EVOLUTION-STATE STATE)
  (NOT
   (AND (IS-GOOD-EVOLUTION (SEQ!TACK STATE (SEQ!EMPTY)))
    (= (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))) STATE))))
 (SOME (SEQUENCE)
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
Invoking IS-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-EVOLUTION-STATE STATE)
  (NOT
   (AND
    (IF (>= (SEQ!LENGTH (SEQ!TACK STATE (SEQ!EMPTY))) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))))
       (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))))
     (AND (>= (SEQ!LENGTH (SEQ!TACK STATE (SEQ!EMPTY))) 1)
      (IS-GOOD-STATE (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))))
      (= (HISTORY (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))) (SEQ!EMPTY))
      (= (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))) (SEQ!EMPTY))))
    (= (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))) STATE))))
 (SOME (SEQUENCE)
  (AND
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
   (= (SEQ!HEAD SEQUENCE) STATE))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (NOT
   (AND
    (IF (>= (SEQ!LENGTH (SEQ!TACK STATE (SEQ!EMPTY))) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))))
       (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))))
     (AND (>= (SEQ!LENGTH (SEQ!TACK STATE (SEQ!EMPTY))) 1)
      (IS-GOOD-STATE (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))))
      (= (HISTORY (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))) (SEQ!EMPTY))
      (= (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))) (SEQ!EMPTY))))
    (= (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))) STATE))))
 (SOME (SEQUENCE)
  (AND
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
   (= (SEQ!HEAD SEQUENCE) STATE))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE))
  (IF (SEQ!EMPTYP (HISTORY STATE))
   (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY STATE))
    (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
    (FN!IS-FUNCTION (STORES STATE))
    (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (NOT
   (AND
    (IF (>= (SEQ!LENGTH (SEQ!TACK STATE (SEQ!EMPTY))) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))))
       (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))))
     (AND (>= (SEQ!LENGTH (SEQ!TACK STATE (SEQ!EMPTY))) 1)
      (IS-STATE (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))))
      (SUBSET (SEEN-MESSAGES (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))))
       (MS!MESSAGES))
      (TIME-STRICTLY-INCREASES
       (HISTORY (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))))
      (IN (HISTORY (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))))
       (SEQ!SEQUENCE-OF (EVENTS)))
      (FN!IS-FUNCTION (STORES (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))))
      (= (REL!DOM (STORES (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))))
       (MS!PRINCIPALS))
      (SUBSET (REL!RAN (STORES (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))))
       (POWERSET (MS!MESSAGES)))
      (= (HISTORY (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))) (SEQ!EMPTY))
      (= (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))) (SEQ!EMPTY))))
    (= (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))) STATE))))
 (SOME (SEQUENCE)
  (AND
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-STATE (SEQ!HEAD SEQUENCE))
     (SUBSET (SEEN-MESSAGES (SEQ!HEAD SEQUENCE)) (MS!MESSAGES))
     (TIME-STRICTLY-INCREASES (HISTORY (SEQ!HEAD SEQUENCE)))
     (IN (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!SEQUENCE-OF (EVENTS)))
     (FN!IS-FUNCTION (STORES (SEQ!HEAD SEQUENCE)))
     (= (REL!DOM (STORES (SEQ!HEAD SEQUENCE))) (MS!PRINCIPALS))
     (SUBSET (REL!RAN (STORES (SEQ!HEAD SEQUENCE))) (POWERSET (MS!MESSAGES)))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
   (= (SEQ!HEAD SEQUENCE) STATE))))
Which simplifies
 when rewriting with SEQ!LENGTH-TACK, SEQ!IN-SEQUENCE-OF, SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAIL-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
FN!IS-FUNCTION-BOOL, MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
  (ALL (PREVIOUS-STATE)
   (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IMPLIES (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SOME (SEQUENCE)
      (AND (IS-GOOD-EVOLUTION SEQUENCE)
       (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE))))
    (TRUE)))
  (IS-GOOD-EVOLUTION-STATE STATE))
 (SOME (SEQUENCE)
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
    (SOME (SEQUENCE)
     (AND (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE)))))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE$0)
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (GOOD-STEP PREVIOUS-STATE$0 STATE)))))
 (SOME (SEQUENCE$0)
  (AND (IS-GOOD-EVOLUTION SEQUENCE$0) (= (SEQ!HEAD SEQUENCE$0) STATE))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
    (SOME (SEQUENCE)
     (AND (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE)))))
  (SOME (PREVIOUS-STATE$0)
   (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (GOOD-STEP PREVIOUS-STATE$0 STATE))))
 (SOME (SEQUENCE$0)
  (AND (IS-GOOD-EVOLUTION SEQUENCE$0) (= (SEQ!HEAD SEQUENCE$0) STATE))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (SEQUENCE)
     (AND (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE$0)))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE))
 (SOME (SEQUENCE$0)
  (AND (IS-GOOD-EVOLUTION SEQUENCE$0) (= (SEQ!HEAD SEQUENCE$0) STATE))))
Instantiating (= PREVIOUS-STATE$0 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
   (SOME (SEQUENCE)
    (AND (IS-GOOD-EVOLUTION SEQUENCE)
     (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE))))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (SEQUENCE$0)
     (AND (IS-GOOD-EVOLUTION SEQUENCE$0)
      (= (SEQ!HEAD SEQUENCE$0) PREVIOUS-STATE$0)))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE))
 (SOME (SEQUENCE$1)
  (AND (IS-GOOD-EVOLUTION SEQUENCE$1) (= (SEQ!HEAD SEQUENCE$1) STATE))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (SOME (SEQUENCE)
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE)))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (SEQUENCE$0)
     (AND (IS-GOOD-EVOLUTION SEQUENCE$0)
      (= (SEQ!HEAD SEQUENCE$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE))
 (SOME (SEQUENCE$1)
  (AND (IS-GOOD-EVOLUTION SEQUENCE$1) (= (SEQ!HEAD SEQUENCE$1) STATE))))
Instantiating (= SEQUENCE$1 (SEQ!TACK STATE SEQUENCE)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (SEQUENCE$0)
     (AND (IS-GOOD-EVOLUTION SEQUENCE$0)
      (= (SEQ!HEAD SEQUENCE$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE)
  (NOT
   (AND (IS-GOOD-EVOLUTION (SEQ!TACK STATE SEQUENCE))
    (= (SEQ!HEAD (SEQ!TACK STATE SEQUENCE)) STATE))))
 (SOME (SEQUENCE$1)
  (AND (IS-GOOD-EVOLUTION SEQUENCE$1) (= (SEQ!HEAD SEQUENCE$1) STATE))))
Invoking (IS-GOOD-EVOLUTION (SEQ!TACK STATE SEQUENCE)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (SEQUENCE$0)
     (AND (IS-GOOD-EVOLUTION SEQUENCE$0)
      (= (SEQ!HEAD SEQUENCE$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE)
  (NOT
   (AND
    (IF (>= (SEQ!LENGTH (SEQ!TACK STATE SEQUENCE)) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!TACK STATE SEQUENCE)))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!TACK STATE SEQUENCE)))
       (SEQ!HEAD (SEQ!TACK STATE SEQUENCE))))
     (AND (>= (SEQ!LENGTH (SEQ!TACK STATE SEQUENCE)) 1)
      (IS-GOOD-STATE (SEQ!HEAD (SEQ!TACK STATE SEQUENCE)))
      (= (HISTORY (SEQ!HEAD (SEQ!TACK STATE SEQUENCE))) (SEQ!EMPTY))
      (= (SEQ!TAIL (SEQ!TACK STATE SEQUENCE)) (SEQ!EMPTY))))
    (= (SEQ!HEAD (SEQ!TACK STATE SEQUENCE)) STATE))))
 (SOME (SEQUENCE$1)
  (AND (IS-GOOD-EVOLUTION SEQUENCE$1) (= (SEQ!HEAD SEQUENCE$1) STATE))))
Which simplifies
 when rewriting with SEQ!LENGTH-TACK
 forward chaining using SEQ!NOT-IS-TACK-FACTS, SEQ!TACK-HEAD-TAIL,
GOOD-STEP-IMPLIES-GOOD-STATES, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
TAIL-IS-SEQUENCE, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (SEQUENCE$0)
     (AND (IS-GOOD-EVOLUTION SEQUENCE$0)
      (= (SEQ!HEAD SEQUENCE$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE) (NOT (>= (+ 1 (SEQ!LENGTH SEQUENCE)) 2)))
 (SOME (SEQUENCE$1)
  (AND (IS-GOOD-EVOLUTION SEQUENCE$1) (= (SEQ!HEAD SEQUENCE$1) STATE))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (= (SEQ!HEAD SEQUENCE) PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (SEQUENCE$0)
     (AND (IS-GOOD-EVOLUTION SEQUENCE$0)
      (= (SEQ!HEAD SEQUENCE$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE) (NOT (>= (+ 1 (SEQ!LENGTH SEQUENCE)) 2)))
 (SOME (SEQUENCE$1)
  (AND (IS-GOOD-EVOLUTION SEQUENCE$1) (= (SEQ!HEAD SEQUENCE$1) STATE))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
TIME-OF-EVENT-CONSTRAINT-AUX
Beginning proof of TIME-OF-EVENT-CONSTRAINT-AUX ...
(IMPLIES
 (AND (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS))) (SEQ!IS-MEMBER EVENT HISTORY)
  (TIME-STRICTLY-INCREASES HISTORY))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Inducting using the following scheme ...
 (AND (IMPLIES (SEQ!EMPTYP HISTORY) (*P* EVENT HISTORY))
  (IMPLIES
   (AND (NOT (SEQ!EMPTYP HISTORY)) (>= (SEQ!LENGTH HISTORY) 2)
    (*P* EVENT (SEQ!TAIL HISTORY)))
   (*P* EVENT HISTORY))
  (IMPLIES (AND (NOT (SEQ!EMPTYP HISTORY)) (NOT (>= (SEQ!LENGTH HISTORY) 2)))
   (*P* EVENT HISTORY)))
 produces ...
(AND
 (IMPLIES (SEQ!EMPTYP HISTORY)
  (IMPLIES
   (AND (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS))) (SEQ!IS-MEMBER EVENT HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP HISTORY)) (>= (SEQ!LENGTH HISTORY) 2)
   (IMPLIES
    (AND (IN (SEQ!TAIL HISTORY) (SEQ!SEQUENCE-OF (EVENTS)))
     (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
     (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY)))
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))))
  (IMPLIES
   (AND (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS))) (SEQ!IS-MEMBER EVENT HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
 (IMPLIES (AND (NOT (SEQ!EMPTYP HISTORY)) (NOT (>= (SEQ!LENGTH HISTORY) 2)))
  (IMPLIES
   (AND (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS))) (SEQ!IS-MEMBER EVENT HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))))
Starting case 3 ...
(IMPLIES
 (AND (SEQ!EMPTYP HISTORY) (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS)))
  (SEQ!IS-MEMBER EVENT HISTORY) (TIME-STRICTLY-INCREASES HISTORY))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Invoking SEQ!IS-MEMBER gives ...
(IMPLIES
 (AND (SEQ!EMPTYP HISTORY) (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS)))
  (SEQ!IS-TACK HISTORY)
  (OR (= EVENT (SEQ!HEAD HISTORY)) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY)))
  (TIME-STRICTLY-INCREASES HISTORY))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2 ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP HISTORY)) (>= (SEQ!LENGTH HISTORY) 2)
  (IMPLIES
   (AND (IN (SEQ!TAIL HISTORY) (SEQ!SEQUENCE-OF (EVENTS)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
  (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS))) (SEQ!IS-MEMBER EVENT HISTORY)
  (TIME-STRICTLY-INCREASES HISTORY))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Invoking (SEQ!IS-MEMBER EVENT HISTORY) gives ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP HISTORY)) (>= (SEQ!LENGTH HISTORY) 2)
  (IMPLIES
   (AND (IN (SEQ!TAIL HISTORY) (SEQ!SEQUENCE-OF (EVENTS)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
  (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS))) (SEQ!IS-TACK HISTORY)
  (OR (= EVENT (SEQ!HEAD HISTORY)) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY)))
  (TIME-STRICTLY-INCREASES HISTORY))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Rearranging gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (NOT (SEQ!EMPTYP HISTORY))
  (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS))) (SEQ!IS-TACK HISTORY)
  (TIME-STRICTLY-INCREASES HISTORY)
  (OR (= EVENT (SEQ!HEAD HISTORY)) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY)))
  (IMPLIES
   (AND (IN (SEQ!TAIL HISTORY) (SEQ!SEQUENCE-OF (EVENTS)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, SEQ!EMPTYP-DEFINITION
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY))
 (IF (= EVENT (SEQ!HEAD HISTORY))
  (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
   (IF (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
    (IF (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
     (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
      (IMPLIES
       (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))
        (TIME-OF-EVENT EVENT))
       (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
      (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (IMPLIES (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
   (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
    (IF (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
     (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
      (IMPLIES
       (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))
        (TIME-OF-EVENT EVENT))
       (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
      (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (= EVENT (SEQ!HEAD HISTORY)))
 (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (IF (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
   (IF (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (IMPLIES
      (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
      (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Assuming TIME-OF-EVENT-IN-CONSTRAINED-HISTORY-NAT with the
instantiations: (= EVENT EVENT) (= HISTORY HISTORY) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE HISTORY) (SEQ!IS-MEMBER EVENT HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT EVENT) 0))
  (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (= EVENT (SEQ!HEAD HISTORY)))
 (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (IF (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
   (IF (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (IMPLIES
      (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
      (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Rearranging gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (= EVENT (SEQ!HEAD HISTORY))
  (SEQ!IS-SEQUENCE HISTORY) (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (TIME-STRICTLY-INCREASES HISTORY)
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE HISTORY) (SEQ!IS-MEMBER EVENT HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT EVENT) 0)))
 (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (IF (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
   (IF (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (IMPLIES
      (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
      (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (= EVENT (SEQ!HEAD HISTORY))
  (SEQ!IS-SEQUENCE HISTORY) (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (TIME-STRICTLY-INCREASES HISTORY) (NOT (SEQ!IS-MEMBER EVENT HISTORY)))
 (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (IF (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
   (IF (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (IMPLIES
      (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
      (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Invoking SEQ!IS-MEMBER gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (= EVENT (SEQ!HEAD HISTORY))
  (SEQ!IS-SEQUENCE HISTORY) (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (TIME-STRICTLY-INCREASES HISTORY)
  (NOT
   (AND (SEQ!IS-TACK HISTORY)
    (OR (= EVENT (SEQ!HEAD HISTORY))
     (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))))))
 (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (IF (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
   (IF
    (AND (SEQ!IS-TACK (SEQ!TAIL HISTORY))
     (OR (= EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))
      (SEQ!IS-MEMBER EVENT (SEQ!TAIL (SEQ!TAIL HISTORY)))))
    (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (IMPLIES
      (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
      (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY)))
 (IF (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (IF (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
   (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Starting case 2.1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY)))
 (IF (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
   (IMPLIES
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Starting case 2.1.2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS)))
 (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Assuming TIME-OF-EVENT-IN-CONSTRAINED-HISTORY-NAT with the
instantiations: (= EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))
                (= HISTORY HISTORY) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE HISTORY)
    (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY)) HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0))
  (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS)))
 (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Rearranging gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE HISTORY)
    (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY)) HISTORY)
    (TIME-STRICTLY-INCREASES HISTORY))
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)))
 (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS)))
 (IF (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY)) HISTORY)
  (IMPLIES (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
   (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
  (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
   (IMPLIES
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))))
Invoking (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY)) HISTORY) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS)))
 (IF
  (AND (SEQ!IS-TACK HISTORY)
   (OR (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY))
    (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!TAIL HISTORY))))
  (IMPLIES (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
   (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
  (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
   (IMPLIES
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS)))
 (IF (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY))
  (IMPLIES
   (AND (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
    (NOT (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (IF (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!TAIL HISTORY))
   (IMPLIES (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
    (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (IMPLIES
      (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
      (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
   (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))))
Starting case 2.1.2.2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY))
  (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
  (NOT (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Invoking (TIME-STRICTLY-INCREASES HISTORY) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (OR (SEQ!EMPTYP HISTORY)
   (IF (>= (SEQ!LENGTH HISTORY) 2)
    (AND (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (IN (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (NAT!NAT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
      (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))))))
    (IN (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (NAT!NAT))))
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY))
  (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
  (NOT (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Which simplifies
 when rewriting with NAT!IN-NAT, SEQ!EMPTYP-DEFINITION
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1.2.2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY))))
 (IF (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!TAIL HISTORY))
  (IMPLIES (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
   (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
  (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
   (IMPLIES
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))))
Invoking (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY))
          (SEQ!TAIL HISTORY)) gives
...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY))))
 (IF
  (AND (SEQ!IS-TACK (SEQ!TAIL HISTORY))
   (OR (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD (SEQ!TAIL HISTORY)))
    (SEQ!IS-MEMBER (SEQ!HEAD (SEQ!TAIL HISTORY))
     (SEQ!TAIL (SEQ!TAIL HISTORY)))))
  (IMPLIES (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
   (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
  (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
   (IMPLIES
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY))))
 (IF (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
  (IMPLIES (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
   (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (IMPLIES
     (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
  (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
   (IMPLIES
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))))
Starting case 2.1.2.2.1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
  (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
  (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0))
 (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Invoking (TIME-STRICTLY-INCREASES HISTORY) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (OR (SEQ!EMPTYP HISTORY)
   (IF (>= (SEQ!LENGTH HISTORY) 2)
    (AND (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (IN (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (NAT!NAT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
      (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))))))
    (IN (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (NAT!NAT))))
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
  (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
  (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0))
 (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Which simplifies
 when rewriting with NAT!IN-NAT, SEQ!EMPTYP-DEFINITION
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
   (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))))
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
  (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
  (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
  (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Splitting
on (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))
    (TIME-OF-EVENT EVENT)) generates
...
(IF (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
 (IMPLIES
  (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
   (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
   (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
    (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))))
   (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
   (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
   (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
   (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
   (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
   (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
   (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
    (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))))
   (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
   (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
   (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
   (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
   (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Splitting on (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0) generates ...
(IF (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
 (IF (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
  (IMPLIES
   (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
    (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
    (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
     (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))))
    (NOT (= EVENT (SEQ!HEAD HISTORY)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
    (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
    (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
    (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (IMPLIES
   (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
    (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
    (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
     (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))))
    (NOT (= EVENT (SEQ!HEAD HISTORY)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
    (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
    (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
    (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
 (IF (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
  (IMPLIES
   (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
    (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
    (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
     (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))))
    (NOT (= EVENT (SEQ!HEAD HISTORY)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
    (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
    (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
    (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (IMPLIES
   (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
    (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
    (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
     (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))))
    (NOT (= EVENT (SEQ!HEAD HISTORY)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
    (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
    (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
    (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
    (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) 0)
    (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))))
Which simplifies
 when rewriting with SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE
 with the assumptions SUCC.INT, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1.2.2.1.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1)))
 (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Invoking SEQ!LENGTH gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK HISTORY) (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 0) 2)
  (SEQ!IS-SEQUENCE HISTORY) (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (TIME-STRICTLY-INCREASES HISTORY) (NOT (= EVENT (SEQ!HEAD HISTORY)))
  (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))
  (NOT (= (SEQ!HEAD (SEQ!TAIL HISTORY)) (SEQ!HEAD HISTORY)))
  (NOT
   (>=
    (IF (SEQ!IS-TACK (SEQ!TAIL HISTORY))
     (+ 1 (SEQ!LENGTH (SEQ!TAIL (SEQ!TAIL HISTORY)))) 0)
    1)))
 (IF (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
  (IMPLIES
   (>= (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))) (TIME-OF-EVENT EVENT))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.1.2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (NOT (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Invoking (SEQ!MEMBERS HISTORY) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET
   (IF (SEQ!IS-TACK HISTORY)
    (SETADD (SEQ!HEAD HISTORY) (SEQ!MEMBERS (SEQ!TAIL HISTORY))) (NULLSET))
   (EVENTS))
  (TIME-STRICTLY-INCREASES HISTORY) (NOT (= EVENT (SEQ!HEAD HISTORY)))
  (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
  (NOT (SUBSET (SEQ!MEMBERS (SEQ!TAIL HISTORY)) (EVENTS))))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Which simplifies
 when rewriting with SETRULES!SUBSET-SETADD
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2) (SEQ!IS-SEQUENCE HISTORY)
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Invoking (SEQ!IS-SEQUENCE HISTORY) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 2)
  (IF (SEQ!IS-TACK HISTORY) (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))
   (= HISTORY (SEQ!EMPTY)))
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (TIME-STRICTLY-INCREASES HISTORY)
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (NOT (SEQ!IS-SEQUENCE (SEQ!TAIL HISTORY))))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP HISTORY)) (NOT (>= (SEQ!LENGTH HISTORY) 2))
  (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS))) (SEQ!IS-MEMBER EVENT HISTORY)
  (TIME-STRICTLY-INCREASES HISTORY))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Invoking TIME-STRICTLY-INCREASES gives ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP HISTORY)) (NOT (>= (SEQ!LENGTH HISTORY) 2))
  (IN HISTORY (SEQ!SEQUENCE-OF (EVENTS))) (SEQ!IS-MEMBER EVENT HISTORY)
  (OR (SEQ!EMPTYP HISTORY)
   (IF (>= (SEQ!LENGTH HISTORY) 2)
    (AND (TIME-STRICTLY-INCREASES (SEQ!TAIL HISTORY))
     (IN (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (NAT!NAT))
     (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY))
      (SUCC (TIME-OF-EVENT (SEQ!HEAD (SEQ!TAIL HISTORY))))))
    (IN (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (NAT!NAT)))))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Which simplifies
 when rewriting with NAT!IN-NAT, SEQ!IN-SEQUENCE-OF,
IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 1) (SEQ!IS-SEQUENCE HISTORY)
  (NOT (>= (SEQ!LENGTH HISTORY) 2)) (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (SEQ!IS-MEMBER EVENT HISTORY) (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Invoking SEQ!IS-MEMBER gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 1) (SEQ!IS-SEQUENCE HISTORY)
  (NOT (>= (SEQ!LENGTH HISTORY) 2)) (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (SEQ!IS-TACK HISTORY)
  (OR (= EVENT (SEQ!HEAD HISTORY)) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY)))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 1) (SEQ!IS-SEQUENCE HISTORY)
  (NOT (>= (SEQ!LENGTH HISTORY) 2)) (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Invoking (SEQ!IS-MEMBER EVENT (SEQ!TAIL HISTORY)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 1) (SEQ!IS-SEQUENCE HISTORY)
  (NOT (>= (SEQ!LENGTH HISTORY) 2)) (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (SEQ!IS-TACK (SEQ!TAIL HISTORY))
  (OR (= EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (SEQ!TAIL HISTORY))))
  (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH HISTORY) 1) (SEQ!IS-SEQUENCE HISTORY)
  (NOT (>= (SEQ!LENGTH HISTORY) 2)) (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS))
  (NOT (= EVENT (SEQ!HEAD HISTORY))) (>= (SEQ!LENGTH (SEQ!TAIL HISTORY)) 1))
 (IF (= EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))
  (IMPLIES (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
  (IMPLIES
   (AND (SEQ!IS-MEMBER EVENT (SEQ!TAIL (SEQ!TAIL HISTORY)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))))
Invoking SEQ!LENGTH gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK HISTORY) (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 0) 1)
  (SEQ!IS-SEQUENCE HISTORY)
  (NOT
   (>= (IF (SEQ!IS-TACK HISTORY) (+ 1 (SEQ!LENGTH (SEQ!TAIL HISTORY))) 0) 2))
  (SUBSET (SEQ!MEMBERS HISTORY) (EVENTS)) (NOT (= EVENT (SEQ!HEAD HISTORY)))
  (>=
   (IF (SEQ!IS-TACK (SEQ!TAIL HISTORY))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (SEQ!TAIL HISTORY)))) 0)
   1)
  (IF (= EVENT (SEQ!HEAD (SEQ!TAIL HISTORY)))
   (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0)
   (AND (SEQ!IS-MEMBER EVENT (SEQ!TAIL (SEQ!TAIL HISTORY)))
    (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) 0))))
 (>= (TIME-OF-EVENT (SEQ!HEAD HISTORY)) (TIME-OF-EVENT EVENT)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
TIME-OF-EVENT-CONSTRAINT
Beginning proof of TIME-OF-EVENT-CONSTRAINT ...
(IMPLIES (AND (IS-GOOD-STATE STATE) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (TIME-OF-EVENT EVENT)))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (TIME-OF-EVENT EVENT)))
Assuming TIME-OF-EVENT-CONSTRAINT-AUX with the
instantiations: (= EVENT EVENT) (= HISTORY (HISTORY STATE)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
    (SEQ!IS-MEMBER EVENT (HISTORY STATE))
    (TIME-STRICTLY-INCREASES (HISTORY STATE)))
   (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (TIME-OF-EVENT EVENT)))
  (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (>= (TIME-OF-EVENT (SEQ!HEAD (HISTORY STATE))) (TIME-OF-EVENT EVENT)))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
FORGEABLE-MONOTONIC-OVER-STEP
Beginning proof of FORGEABLE-MONOTONIC-OVER-STEP ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ N 1))))
 (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
Assuming NON-INITIAL-STATE-IS-RESULT-OF-STEP with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N)
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ N 1))))
 (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N)) (SEQ!NTH SEQUENCE N))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
 (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (SOME (LABEL TIME MESSAGE$0)
   (AND (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0
        (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEQ!NTH SEQUENCE N)
        (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE$0
       (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
      (= (SEQ!NTH SEQUENCE N)
       (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
 (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= (SEQ!NTH SEQUENCE N)
     (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (= (SEQ!NTH SEQUENCE N)
     (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
 (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE$0 (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE$0 (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE N))))
Substituting (= (SEQ!NTH SEQUENCE N)
              (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
               (SEQ!NTH SEQUENCE (+ 1 N)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE
   (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE
   (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE
   (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE
   (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE
   (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Trivially rewrites using FORGEABLE-PRESERVED-BY-OUT-OF-BAND-STEP,
FORGEABLE-PRESERVED-BY-CONSTRUCT-STEP, FORGEABLE-PRESERVED-BY-RECEIVE-STEP,
FORGEABLE-PRESERVED-BY-GENERATE-STEP, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION to ...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE$0 (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE$0 (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE$0 (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE$0 (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE$0 (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE$0 (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE
   (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE$0 (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE$0 (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE$0 (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE$0 (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE$0 (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE$0 (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE
   (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$2 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE MESSAGE (SEQ!NTH SEQUENCE (+ 1 N)))))
Which simplifies
 when rewriting with FORGEABLE-MONOTONIC-OVER-SEND-STEP,
FORGEABLE-MONOTONIC-OVER-INTRUDER-STEP, MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!IS-FRESH-ATOMIC, MS!PRINCIPAL-ATOMIC
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
TIME-CONSTRAINT-IMPLIES-NAT, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-STEP
Beginning proof of KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-STEP ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (<= N (- (SEQ!LENGTH SEQUENCE) 1))
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ N 1))))
 (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
Assuming NON-INITIAL-STATE-IS-RESULT-OF-STEP with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (GOOD-STEP (SEQ!NTH SEQUENCE (+ N 1)) (SEQ!NTH SEQUENCE N)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ N 1))))
 (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, GOOD-STEP-IMPLIES-GOOD-STATES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (GOOD-STEP (SEQ!NTH SEQUENCE (+ 1 N)) (SEQ!NTH SEQUENCE N))
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
 (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (SOME (LABEL TIME MESSAGE$0)
   (AND (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$2)
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0
        (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (= (SEQ!NTH SEQUENCE N)
        (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (SOME (PRINCIPAL$3)
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 (SEQ!NTH SEQUENCE (+ 1 N)))
       (= (SEQ!NTH SEQUENCE N)
        (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$3
         (SEQ!NTH SEQUENCE (+ 1 N))))))
     (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE$0
       (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
      (= (SEQ!NTH SEQUENCE N)
       (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))))))
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
 (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
  (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (= (SEQ!NTH SEQUENCE N)
     (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 (SEQ!NTH SEQUENCE (+ 1 N)))
    (= (SEQ!NTH SEQUENCE N)
     (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$3
      (SEQ!NTH SEQUENCE (+ 1 N)))))
   (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
    (= (SEQ!NTH SEQUENCE N)
     (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))))
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
 (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE$0 (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE$0 (MS!ATOMIC-MESSAGES)))
  (NOT
   (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$3 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$3
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N)))
 (OR (NOT (IS-GOOD-EVOLUTION SEQUENCE)) (NOT (>= N 1))
  (NOT (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
  (NOT (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N)))) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N))))
  (NOT
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N)))))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE N))))
Substituting (= (SEQ!NTH SEQUENCE N)
              (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$3
               (SEQ!NTH SEQUENCE (+ 1 N))))
             (= (SEQ!NTH SEQUENCE N)
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
               (SEQ!NTH SEQUENCE (+ 1 N)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL
   (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL
   (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL
   (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL
   (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$3 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$3
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL
   (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$3
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Trivially rewrites using KNOWN-BY-PRINCIPAL-PRESERVED-BY-CONSTRUCT-STEP,
KNOWN-BY-PRINCIPAL-PRESERVED-BY-SEND-STEP,
KNOWN-BY-PRINCIPAL-PRESERVED-BY-INTRUDER-STEP, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION to ...
(AND
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE$0 (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE$0 (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE$0 (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE$0 (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE$0 (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE$0 (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (= (SEQ!NTH SEQUENCE N)
    (INTRUDER-STEP LABEL TIME MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN MESSAGE$0 (MS!ATOMIC-MESSAGES)) (MS!IS-FRESH MESSAGE$0 (MS!PRINCIPALS))
   (MS!IS-FRESH MESSAGE$0 (MS!TEXT-MESSAGES))
   (MS!IS-FRESH MESSAGE$0 (MS!PUBLIC-KEYS))
   (MS!IS-FRESH MESSAGE$0 (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
   (MS!IS-FRESH MESSAGE$0 (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (= (SEQ!NTH SEQUENCE N)
    (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL
   (GENERATE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$2
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (SEND-STEP LABEL TIME MESSAGE$0 PRINCIPAL$0 (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE$0 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL
   (RECEIVE-STEP LABEL TIME MESSAGE$0 PRINCIPAL$1
    (SEQ!NTH SEQUENCE (+ 1 N)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN PRINCIPAL$3 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (CONSTRUCT-STEP LABEL TIME MESSAGE$0 PRINCIPAL$3
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
   (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
   (IS-GOOD-STATE (SEQ!NTH SEQUENCE (+ 1 N)))
   (TIME-CONSTRAINT TIME (SEQ!NTH SEQUENCE (+ 1 N))) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER (SEQ!NTH SEQUENCE (+ 1 N)))
   (= (SEQ!NTH SEQUENCE N)
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
     (SEQ!NTH SEQUENCE (+ 1 N))))
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE$0 SENDER RECEIVER
    (SEQ!NTH SEQUENCE (+ 1 N))))))
Which simplifies
 when rewriting with KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-OUT-OF-BAND-STEP,
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-RECEIVE-STEP,
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GENERATE-STEP,
MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES, MS!TEXT-MESSAGE-ATOMIC,
MS!IS-FRESH-ATOMIC, MS!PRINCIPAL-ATOMIC
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
TIME-CONSTRAINT-IMPLIES-NAT, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION
Beginning proof of HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
 (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (- N 1) (SEQ!TAIL SEQUENCE))
    (*P* N (SEQ!TAIL SEQUENCE)))
   (*P* N SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* N SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
     (<= (- N 1) (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
    (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- N 1)))
     (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
     (<= N (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1)))
    (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) N))
     (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
    (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N))))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1)))
   (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
    (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
     (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) (- N 1)))
    (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- N 1)))
     (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
     (>= (- (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 1) N))
    (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) N))
     (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N)))))
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
   (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
  (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
   (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
   (IF (>= (SEQ!LENGTH SEQUENCE) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
    (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
     (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
   (>= N 1) (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
  (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
   (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (>= (+ -1 N) 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
   (IMPLIES
    (AND
     (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (+ -1 N)))
      (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
     (>= N 1))
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
     (IMPLIES
      (AND
       (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) N))
        (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
       (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
       (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
      (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
       (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))
     (IMPLIES
      (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
       (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
      (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
       (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))))
   (IMPLIES
    (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
    (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
     (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N))))))
  (IMPLIES (>= N 1)
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
    (IMPLIES
     (AND
      (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) 1))
       (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
      (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1)))))
    (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
      (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1)))))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (>= (+ -1 N) 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
   (IMPLIES
    (AND
     (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (+ -1 N)))
      (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
     (>= N 1)
     (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
      (AND
       (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) N))
        (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
       (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
       (>=
        (+ -1
         (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
        N))
      (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
       (>=
        (+ -1
         (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
        N))))
    (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
     (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))
   (IMPLIES
    (AND (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (>= N 1)
     (>=
      (+ -1
       (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
      N))
    (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
     (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N))))))
  (IMPLIES
   (AND (>= N 1)
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
     (AND
      (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) 1))
       (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
   (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
    (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (>= (+ -1 N) 1)
  (IMPLIES
   (AND (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
    (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (+ -1 N)))
     (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
    (>= N 1))
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
    (IMPLIES
     (AND
      (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) N))
       (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
      (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))
    (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
      (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))))
  (IMPLIES (>= N 1)
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
    (IMPLIES
     (AND
      (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) 1))
       (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
      (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1)))))
    (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
     (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
      (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1)))))))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N) 1)
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
  (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (+ -1 N)))
   (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
  (>= N 1))
 (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
  (IMPLIES
   (AND
    (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) N))
     (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
    (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))
  (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
   (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
    (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))))
Invoking (SEQ!NTH (SEQ!TAIL SEQUENCE) N) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N) 1)
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
  (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (+ -1 N)))
   (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
  (>= N 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
   (AND
    (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) N))
     (SEQ!TAIL
      (HISTORY
       (IF (>= N 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- N 1))
        (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
 (=
  (HISTORY
   (IF (>= N 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- N 1))
    (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))
Invoking (SEQ!NTH SEQUENCE N) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (+ -1 N) 1)
  (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
  (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (+ -1 N)))
   (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
  (>= N 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
   (AND
    (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) N))
     (SEQ!TAIL
      (HISTORY
       (IF (>= N 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- N 1))
        (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
 (=
  (HISTORY
   (IF (>= N 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- N 1))
    (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SEQ!TAIL
   (HISTORY
    (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1)) (SEQ!HEAD SEQUENCE))))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1))
 (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (IMPLIES
   (AND
    (= (HISTORY (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) 1))
     (SEQ!TAIL (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
    (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1)))))
  (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
   (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))
    (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1)))))))
Invoking SEQ!NTH gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (AND
    (=
     (HISTORY
      (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL (SEQ!TAIL SEQUENCE))) (- 1 1))
       (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE)))))
     (SEQ!TAIL
      (HISTORY
       (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- 1 1))
        (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
 (=
  (HISTORY
   (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL SEQUENCE)) (- 1 1))
    (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SEQ!TAIL
   (HISTORY
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1))
 (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (IMPLIES
   (AND
    (= (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE))))
     (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
  (IMPLIES (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))))
Applying HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION to
 (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE)))) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (AND
    (=
     (IF
      (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
       (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) 2))
      (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
      (HISTORY (SEQ!HEAD (SEQ!TAIL (SEQ!TAIL SEQUENCE)))))
     (SEQ!TAIL (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))))
 (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
 (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
Applying HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
 (=
  (IF (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))
   (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
 (IF (IS-GOOD-EVOLUTION SEQUENCE)
  (OR (>= (SEQ!LENGTH SEQUENCE) 2)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
 (IF
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (OR (>= (SEQ!LENGTH SEQUENCE) 2)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
 (IF
  (IF
   (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND
    (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     1)
    (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (OR
   (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
   (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
    (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
  (= (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))
   (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
NTH-HISTORY-HEAD-EVOLUTION
Beginning proof of NTH-HISTORY-HEAD-EVOLUTION ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= N (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE)))))
 (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
  (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* (- N 1) (SEQ!TAIL SEQUENCE))
    (*P* N (SEQ!TAIL SEQUENCE)))
   (*P* N SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* N SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
     (<= (- N 1) (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
    (= (SEQ!NTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (- N 1))
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
     (<= N (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
    (= (SEQ!NTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) N)
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE)))))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE)))))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Starting case 2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= (- N 1) 1)
    (<= (- N 1) (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (- N 1))
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (>= N 1)
    (<= N (SEQ!LENGTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) N)
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N)))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= N (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE)))))
 (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
  (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (>= (+ -1 N) 1)
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
    (IMPLIES
     (AND
      (= (SEQ!NTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) (+ -1 N))
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
      (>= N 1))
     (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
      (IMPLIES
       (AND
        (= (SEQ!NTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) N)
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
        (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
       (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
        (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
      (IMPLIES
       (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
       (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
        (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
      (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
     (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
      (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))))
   (IMPLIES (>= N 1)
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
     (IMPLIES
      (AND
       (= (SEQ!NTH (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))) 1)
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
       (IS-GOOD-EVOLUTION SEQUENCE))
      (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
       (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))
     (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
       (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Applying HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (>= (+ -1 N) 1)
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
    (IMPLIES
     (AND
      (=
       (SEQ!NTH
        (IF (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
         (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))
         (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
        (+ -1 N))
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
      (>= N 1)
      (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
       (AND
        (=
         (SEQ!NTH
          (IF (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
           (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))
           (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
          N)
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
        (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
       (AND (IS-GOOD-EVOLUTION SEQUENCE)
        (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))))
     (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
      (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
      (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
     (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
      (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))))
   (IMPLIES
    (AND (>= N 1)
     (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
      (AND
       (=
        (SEQ!NTH
         (IF (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
          (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))
          (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
         1)
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))
       (IS-GOOD-EVOLUTION SEQUENCE))
      (IS-GOOD-EVOLUTION SEQUENCE)))
    (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
     (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (>= (+ -1 N) 1)
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
      (>= N 1))
     (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
      (IMPLIES
       (AND
        (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) N)
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
        (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
       (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
        (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
      (IMPLIES (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
       (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
        (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
      (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
     (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
      (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))))
   (IMPLIES (>= N 1)
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION SEQUENCE)
       (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))))
      (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
       (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))
     (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
       (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Invoking (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N) gives ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (>= (+ -1 N) 1)
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
      (>= N 1)
      (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
       (AND
        (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) N)
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
        (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
       (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)))
     (=
      (IF (>= N 2) (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (- N 1))
       (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
      (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
      (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
     (=
      (IF (>= N 2) (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (- N 1))
       (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
      (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))))
   (IMPLIES
    (AND (>= N 1)
     (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
      (AND (IS-GOOD-EVOLUTION SEQUENCE)
       (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))))
      (IS-GOOD-EVOLUTION SEQUENCE)))
    (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
     (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
   (=
    (IF (>= N 2) (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (- N 1))
     (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Invoking (SEQ!NTH SEQUENCE N) gives ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (>= (+ -1 N) 1)
   (IMPLIES
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N))
     (AND (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
       (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))
      (>= N 1)
      (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) N)
       (AND
        (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) N)
         (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
        (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
       (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)))
     (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
      (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)))
    (=
     (IF (>= N 2) (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (- N 1))
      (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
     (SEQ!HEAD
      (HISTORY
       (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))
        (SEQ!HEAD SEQUENCE))))))
   (IMPLIES
    (AND (>= N 1)
     (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
      (AND (IS-GOOD-EVOLUTION SEQUENCE)
       (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))))
      (IS-GOOD-EVOLUTION SEQUENCE)))
    (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
     (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
   (=
    (IF (>= N 2) (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (- N 1))
     (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
    (SEQ!HEAD
     (HISTORY
      (IF (>= N 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- N 1))
       (SEQ!HEAD SEQUENCE))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (>= (+ -1 N) 1)
   (IMPLIES
    (AND (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N)))
     (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
    (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
     (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))))
   (IMPLIES (>= N 1)
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION SEQUENCE)
       (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
        (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1)))))
      (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
       (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))
     (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
       (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (>= N 2))
   (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
    (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N))))))))
Applying HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (>= (+ -1 N) 1)
   (IMPLIES
    (AND (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N)))
     (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
    (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
     (SEQ!HEAD
      (IF
       (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ -1 N) 1)
        (>= (- (SEQ!LENGTH SEQUENCE) 1) (+ -1 N)))
       (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE (+ -1 N))))
       (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))))
   (IMPLIES
    (AND (>= N 1)
     (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
      (AND (IS-GOOD-EVOLUTION SEQUENCE)
       (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
        (SEQ!HEAD
         (IF
          (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= 1 1)
           (>= (- (SEQ!LENGTH SEQUENCE) 1) 1))
          (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1)))
          (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) 1))))))
      (IS-GOOD-EVOLUTION SEQUENCE)))
    (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
     (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (>= N 2))
   (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
    (SEQ!HEAD
     (IF
      (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (+ -1 N) 1)
       (>= (- (SEQ!LENGTH SEQUENCE) 1) (+ -1 N)))
      (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE (+ -1 N))))
      (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) (+ -1 N)))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (>= (+ -1 N) 1)
   (IMPLIES
    (AND (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N)))
     (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N))
    (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
     (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE (+ -1 N)))))))
   (IMPLIES (>= N 1)
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION SEQUENCE)
       (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
        (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1))))))
      (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
       (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))
     (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
       (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (>= N 2))
   (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
    (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE (+ -1 N)))))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (>= (+ -1 N) 1)
   (IMPLIES
    (AND (NOT (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ -1 N)))
     (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>=
      (+ -1
       (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
      N))
    (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
     (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE (+ -1 N)))))))
   (IMPLIES
    (AND (>= N 1)
     (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
      (AND (IS-GOOD-EVOLUTION SEQUENCE)
       (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
        (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1))))))
      (IS-GOOD-EVOLUTION SEQUENCE)))
    (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
     (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>=
     (+ -1
      (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0))
     N)
    (>= N 2))
   (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
    (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE (+ -1 N)))))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES (AND (NOT (>= (+ -1 N) 1)) (>= N 1))
   (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION SEQUENCE)
      (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
       (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1))))))
     (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
      (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))
    (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
     (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
      (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N) (>= N 2))
   (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
    (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE (+ -1 N)))))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2))
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IMPLIES
   (AND (NOT (>= (+ -1 N) 1)) (>= N 1)
    (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
     (AND
      (IF (>= (SEQ!LENGTH SEQUENCE) 2)
       (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
        (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
       (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
        (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
        (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
      (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
       (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1))))))
     (IF (>= (SEQ!LENGTH SEQUENCE) 2)
      (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
       (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
      (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
       (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
       (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))
  (IMPLIES
   (AND
    (IF (>= (SEQ!LENGTH SEQUENCE) 2)
     (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
      (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
     (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
      (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
      (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
    (>= N 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) N) (>= N 2))
   (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (+ -1 N))
    (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE (+ -1 N)))))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1))
 (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 2)
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
    (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) 1)
     (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE 1))))))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))
  (IMPLIES
   (AND (>= (SEQ!LENGTH SEQUENCE) 2)
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) 1)
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))))
Invoking SEQ!NTH gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)) (NOT (>= (+ -1 N) 1)) (>= N 1)
  (IF (>= (+ -1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 1)
   (AND (>= (SEQ!LENGTH SEQUENCE) 2)
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE))
    (=
     (IF (>= 1 2)
      (SEQ!NTH (SEQ!TAIL (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))) (- 1 1))
      (SEQ!HEAD (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
     (SEQ!HEAD
      (SEQ!TAIL
       (HISTORY
        (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1))
         (SEQ!HEAD SEQUENCE)))))))
   (AND (>= (SEQ!LENGTH SEQUENCE) 2)
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))))
 (=
  (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))) (- 1 1))
   (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (SEQ!HEAD
   (HISTORY
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= N (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE)))))
 (= (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)
  (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
SEND-EVENT-CONSEQUENCE
Beginning proof of SEND-EVENT-CONSEQUENCE ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (SEND-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M EVENT) (= S (HISTORY STATE)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
    (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (<= N (SEQ!LENGTH (HISTORY STATE))))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (SEND-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY STATE))
 (IMPLIES
  (AND (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (>= (SEQ!LENGTH (HISTORY STATE)) N)))
   (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (SEND-EVENTS)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    STATE)
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    STATE)
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (SOME (N)
   (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
    (>= (SEQ!LENGTH (HISTORY STATE)) N)))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Assuming IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION with the
instantiations: (= STATE STATE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (SEQUENCE)
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, >=.SAME.TYPE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE)
  (SOME (SEQUENCE)
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE)))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IN EVENT (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY STATE) N)) (>= (SEQ!LENGTH (HISTORY STATE)) N)
  (IN EVENT (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Substituting (= STATE (SEQ!HEAD SEQUENCE)) produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N) (IN EVENT (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Applying NTH-HISTORY-HEAD-EVOLUTION gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT
   (IF
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N))
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))
    (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N) (IN EVENT (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, >=.SAME.TYPE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Assuming SEND-EVENT-THEOREM with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS)))
   (AND
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (SEQ!NTH SEQUENCE (+ N 1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (SEND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Assuming KNOWN-BY-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE)
                (= PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
                (= MESSAGE (MESSAGE-OF-EVENT EVENT)) (= N1 (+ N 1))
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= (+ N 1) 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= (+ N 1) 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (IMPLIES
   (AND (>= 1 1) (>= (+ N 1) 1) (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))))
Assuming FORGEABLE-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE) (= MESSAGE (MESSAGE-OF-EVENT EVENT))
                (= N1 N) (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE N)))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE 1)))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE N)))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (IMPLIES
   (AND (>= 1 1) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
    (IS-GOOD-EVOLUTION SEQUENCE)
    (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE N)))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE)))))
 (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Assuming SEND-EVENT-IS-CONSTRUCTED with the
instantiations: (= E EVENT) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (SEND-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-SEND-EVENT L T M P)))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Prenexing produces ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (SEND-EVENTS))
   (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-SEND-EVENT L T M P))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE))
   (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY STATE))
    (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
    (FN!IS-FUNCTION (STORES STATE))
    (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
RECEIVE-EVENT-CONSEQUENCE
Beginning proof of RECEIVE-EVENT-CONSEQUENCE ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (RECEIVE-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M EVENT) (= S (HISTORY STATE)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
    (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (<= N (SEQ!LENGTH (HISTORY STATE))))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (RECEIVE-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY STATE))
 (IMPLIES
  (AND (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (>= (SEQ!LENGTH (HISTORY STATE)) N)))
   (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (RECEIVE-EVENTS)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    STATE)
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    STATE)
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (SOME (N)
   (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
    (>= (SEQ!LENGTH (HISTORY STATE)) N)))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Assuming IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION with the
instantiations: (= STATE STATE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (SEQUENCE)
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE)
  (SOME (SEQUENCE)
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE)))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY STATE) N)) (>= (SEQ!LENGTH (HISTORY STATE)) N)
  (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Substituting (= STATE (SEQ!HEAD SEQUENCE)) produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Applying NTH-HISTORY-HEAD-EVOLUTION gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT
   (IF
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N))
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))
    (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Assuming RECEIVE-EVENT-THEOREM with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS)))
   (AND
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (SEQ!NTH SEQUENCE (+ N 1)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Assuming KNOWN-BY-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE)
                (= PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
                (= MESSAGE (MESSAGE-OF-EVENT EVENT)) (= N1 N)
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (IMPLIES
   (AND (>= 1 1) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
    (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))))
Assuming FORGEABLE-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE) (= MESSAGE (MESSAGE-OF-EVENT EVENT))
                (= N1 (+ N 1)) (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= 1 1) (>= (+ N 1) 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE (+ N 1))))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE 1)))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= 1 1) (>= (+ N 1) 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE (+ N 1))))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (IMPLIES
   (AND (>= 1 1) (>= (+ N 1) 1) (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (IS-GOOD-EVOLUTION SEQUENCE)
    (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE (+ N 1))))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE)))))
 (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Assuming RECEIVE-EVENT-IS-CONSTRUCTED with the
instantiations: (= E EVENT) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (RECEIVE-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-RECEIVE-EVENT L T M P)))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Prenexing produces ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (RECEIVE-EVENTS))
   (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-RECEIVE-EVENT L T M P))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE))
   (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY STATE))
    (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
    (FN!IS-FUNCTION (STORES STATE))
    (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
OUT-OF-BAND-EVENT-CONSEQUENCE
Beginning proof of OUT-OF-BAND-EVENT-CONSEQUENCE ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (OUT-OF-BAND-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M EVENT) (= S (HISTORY STATE)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
    (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (<= N (SEQ!LENGTH (HISTORY STATE))))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (OUT-OF-BAND-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY STATE))
 (IMPLIES
  (AND (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (>= (SEQ!LENGTH (HISTORY STATE)) N)))
   (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (OUT-OF-BAND-EVENTS)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    STATE)
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
    STATE)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (AND
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    STATE)
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
    STATE))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (SOME (N)
   (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
    (>= (SEQ!LENGTH (HISTORY STATE)) N)))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Assuming IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION with the
instantiations: (= STATE STATE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (SEQUENCE)
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE)
  (SOME (SEQUENCE)
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE)))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY STATE) N)) (>= (SEQ!LENGTH (HISTORY STATE)) N)
  (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Substituting (= STATE (SEQ!HEAD SEQUENCE)) produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Applying NTH-HISTORY-HEAD-EVOLUTION gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT
   (IF
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N))
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))
    (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Assuming OUT-OF-BAND-EVENT-THEOREM with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS)))
   (AND
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (SEQ!NTH SEQUENCE (+ N 1)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Assuming KNOWN-BY-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE)
                (= PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
                (= MESSAGE (MESSAGE-OF-EVENT EVENT)) (= N1 N)
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Assuming KNOWN-BY-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE)
                (= PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
                (= MESSAGE (MESSAGE-OF-EVENT EVENT)) (= N1 (+ N 1))
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= (+ N 1) 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Assuming KNOWN-BY-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE)
                (= PRINCIPAL (PRINCIPAL2-OF-EVENT EVENT))
                (= MESSAGE (MESSAGE-OF-EVENT EVENT)) (= N1 N)
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= (+ N 1) 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= (+ N 1) 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (IMPLIES
   (AND (>= 1 1) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
    (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND (>= 1 1) (>= (+ N 1) 1) (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IMPLIES
   (AND (>= 1 1) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
    (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE)))))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   (SEQ!HEAD SEQUENCE))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (AND
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))
    (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE)))
  (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
   (IMPLIES
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE)))
   (AND
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))))))
Assuming OUT-OF-BAND-EVENT-IS-CONSTRUCTED with the
instantiations: (= E EVENT) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (OUT-OF-BAND-EVENTS))
   (SOME (L T M S R)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN S (MS!PRINCIPALS)) (IN R (MS!PRINCIPALS))
     (= EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (AND
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))
    (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE)))
  (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
   (IMPLIES
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE)))
   (AND
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))))))
Prenexing produces ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (OUT-OF-BAND-EVENTS))
   (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
    (IN S (MS!PRINCIPALS)) (IN R (MS!PRINCIPALS))
    (= EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IMPLIES
   (AND
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))
    (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!HEAD SEQUENCE)))
  (IF (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
   (IMPLIES
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE)))
   (AND
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
     (SEQ!HEAD SEQUENCE))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
TAG-OF-MAKE-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE))
   (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY STATE))
    (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
    (FN!IS-FUNCTION (STORES STATE))
    (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (AND
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL2-OF-EVENT EVENT)
   STATE)))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
GENERATE-EVENT-CONSEQUENCE
Beginning proof of GENERATE-EVENT-CONSEQUENCE ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (GENERATE-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M EVENT) (= S (HISTORY STATE)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
    (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (<= N (SEQ!LENGTH (HISTORY STATE))))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (GENERATE-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Which simplifies
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY STATE))
 (IMPLIES
  (AND (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (>= (SEQ!LENGTH (HISTORY STATE)) N)))
   (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (GENERATE-EVENTS)))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (SOME (N)
   (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
    (>= (SEQ!LENGTH (HISTORY STATE)) N)))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (GENERATE-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (GENERATE-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Assuming IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION with the
instantiations: (= STATE STATE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (SEQUENCE)
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (GENERATE-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Which simplifies
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE)
  (SOME (SEQUENCE)
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE)))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IN EVENT (GENERATE-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY STATE) N)) (>= (SEQ!LENGTH (HISTORY STATE)) N)
  (IN EVENT (GENERATE-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Substituting (= STATE (SEQ!HEAD SEQUENCE)) produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (GENERATE-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Applying NTH-HISTORY-HEAD-EVOLUTION gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT
   (IF
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N))
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))
    (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (GENERATE-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (GENERATE-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Assuming GENERATE-EVENT-THEOREM with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS)))
   (AND
    (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ N 1))))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (GENERATE-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Assuming KNOWN-BY-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE)
                (= PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
                (= MESSAGE (MESSAGE-OF-EVENT EVENT)) (= N1 N)
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (IMPLIES
   (AND (>= 1 1) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
    (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE N)))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE)))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS))
  (NOT
   (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (MS!PRINCIPALS)))
  (NOT
   (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (MS!TEXT-MESSAGES)))
  (NOT
   (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Assuming GENERATE-EVENT-IS-CONSTRUCTED with the
instantiations: (= E EVENT) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (GENERATE-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-GENERATE-EVENT L T M P)))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS))
  (NOT
   (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (MS!PRINCIPALS)))
  (NOT
   (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (MS!TEXT-MESSAGES)))
  (NOT
   (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Prenexing produces ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (GENERATE-EVENTS))
   (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-GENERATE-EVENT L T M P))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (GENERATE-EVENTS))
  (NOT
   (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (MS!PRINCIPALS)))
  (NOT
   (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (MS!TEXT-MESSAGES)))
  (NOT
   (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEEN-MESSAGES (SEQ!NTH SEQUENCE (+ 1 N))))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-STORAGE (STORES (SEQ!NTH SEQUENCE (+ 1 N)))))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE))
   (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY STATE))
    (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
    (FN!IS-FUNCTION (STORES STATE))
    (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
CONSTRUCT-EVENT-CONSEQUENCE
Beginning proof of CONSTRUCT-EVENT-CONSEQUENCE ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (CONSTRUCT-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M EVENT) (= S (HISTORY STATE)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
    (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (<= N (SEQ!LENGTH (HISTORY STATE))))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (CONSTRUCT-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Which simplifies
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY STATE))
 (IMPLIES
  (AND (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (>= (SEQ!LENGTH (HISTORY STATE)) N)))
   (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (CONSTRUCT-EVENTS)))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
   STATE)))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (SOME (N)
   (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
    (>= (SEQ!LENGTH (HISTORY STATE)) N)))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Assuming IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION with the
instantiations: (= STATE STATE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (SEQUENCE)
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Which simplifies
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE)
  (SOME (SEQUENCE)
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE)))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IN EVENT (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY STATE) N)) (>= (SEQ!LENGTH (HISTORY STATE)) N)
  (IN EVENT (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Substituting (= STATE (SEQ!HEAD SEQUENCE)) produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Applying NTH-HISTORY-HEAD-EVOLUTION gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT
   (IF
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N))
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))
    (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Assuming CONSTRUCT-EVENT-THEOREM with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS)))
   (KNOWN-BY-PRINCIPAL
    (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
    (SEQ!NTH SEQUENCE (+ N 1))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (CONSTRUCT-EVENTS)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Assuming KNOWN-BY-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE)
                (= PRINCIPAL (PRINCIPAL1-OF-EVENT EVENT))
                (= MESSAGE (MESSAGE-OF-EVENT EVENT)) (= N1 (+ N 1))
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= (+ N 1) 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (SEQ!NTH SEQUENCE 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS)) (>= 1 1) (>= (+ N 1) 1)
    (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (IMPLIES
   (AND (>= 1 1) (>= (+ N 1) 1) (>= (SEQ!LENGTH SEQUENCE) (+ N 1))
    (IS-GOOD-EVOLUTION SEQUENCE)
    (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
     (SEQ!NTH SEQUENCE (+ N 1))))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE)))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-CONSTRUCT-EVENT,
CONSTRUCT-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Assuming CONSTRUCT-EVENT-IS-CONSTRUCTED with the
instantiations: (= E EVENT) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (CONSTRUCT-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-CONSTRUCT-EVENT L T M P)))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Prenexing produces ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (CONSTRUCT-EVENTS))
   (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-CONSTRUCT-EVENT L T M P))))
  (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N) (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (CONSTRUCT-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE (+ 1 N)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-CONSTRUCT-EVENT,
CONSTRUCT-EVENT-IS-EVENT
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE))
   (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY STATE))
    (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
    (FN!IS-FUNCTION (STORES STATE))
    (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
  STATE))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
INTRUDER-EVENT-CONSEQUENCE
Beginning proof of INTRUDER-EVENT-CONSEQUENCE ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (INTRUDER-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M EVENT) (= S (HISTORY STATE)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
    (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (<= N (SEQ!LENGTH (HISTORY STATE))))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (INTRUDER-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Which simplifies
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY STATE))
 (IMPLIES
  (AND (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
     (>= (SEQ!LENGTH (HISTORY STATE)) N)))
   (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (INTRUDER-EVENTS)))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE)))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (SOME (N)
   (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
    (>= (SEQ!LENGTH (HISTORY STATE)) N)))
  (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (INTRUDER-EVENTS)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (INTRUDER-EVENTS)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Assuming IS-GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION with the
instantiations: (= STATE STATE) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (SEQUENCE)
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE))))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (INTRUDER-EVENTS)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Which simplifies
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE)
  (SOME (SEQUENCE)
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (= (SEQ!HEAD SEQUENCE) STATE)))
  (SEQ!IS-SEQUENCE (HISTORY STATE)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (>= N 1) (= EVENT (SEQ!NTH (HISTORY STATE) N))
  (>= (SEQ!LENGTH (HISTORY STATE)) N) (IN EVENT (INTRUDER-EVENTS)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY STATE) N)) (>= (SEQ!LENGTH (HISTORY STATE)) N)
  (IN EVENT (INTRUDER-EVENTS)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Substituting (= STATE (SEQ!HEAD SEQUENCE)) produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (INTRUDER-EVENTS)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
Applying NTH-HISTORY-HEAD-EVOLUTION gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (= EVENT
   (IF
    (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N))
    (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))
    (SEQ!NTH (HISTORY (SEQ!HEAD SEQUENCE)) N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD SEQUENCE))) N)
  (IN EVENT (INTRUDER-EVENTS)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
>=.SAME.TYPE, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (INTRUDER-EVENTS)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
Assuming INTRUDER-EVENT-THEOREM with the
instantiations: (= N N) (= SEQUENCE SEQUENCE) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (<= N (- (SEQ!LENGTH SEQUENCE) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS)))
   (AND
    (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ N 1))))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
     (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION-STATE STATE) (IS-GOOD-EVOLUTION SEQUENCE)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IN EVENT (INTRUDER-EVENTS)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
Which simplifies
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
Assuming FORGEABLE-IS-MONOTONIC with the
instantiations: (= SEQUENCE SEQUENCE) (= MESSAGE (MESSAGE-OF-EVENT EVENT))
                (= N1 N) (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE N)))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE 1)))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= 1 1) (>= N 1)
    (>= (SEQ!LENGTH SEQUENCE) N)
    (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE N)))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE) (= (SEQ!HEAD SEQUENCE) STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (+ -1 (SEQ!LENGTH SEQUENCE)) N)
  (= (SEQ!HEAD SEQUENCE) STATE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))) (INTRUDER-EVENTS))
  (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (ALL-MESSAGES-IN-STATE (SEQ!NTH SEQUENCE (+ 1 N))))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))
   (SEQ!NTH SEQUENCE N))
  (IS-GOOD-EVOLUTION-STATE STATE)
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!HEAD SEQUENCE)))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (IMPLIES
   (AND (>= 1 1) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
    (IS-GOOD-EVOLUTION SEQUENCE)
    (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!NTH SEQUENCE N)))
   (FORGEABLE (MESSAGE-OF-EVENT EVENT)
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1)) (SEQ!HEAD SEQUENCE)))))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) (SEQ!HEAD SEQUENCE)))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-EVOLUTION-STATE STATE)
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (IF (SEQ!EMPTYP (HISTORY STATE))
   (AND (IS-STATE STATE) (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY STATE))
    (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
    (FN!IS-FUNCTION (STORES STATE))
    (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (FORGEABLE (MESSAGE-OF-EVENT EVENT) STATE))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
SEND-EVENT-IS-FROM-SEND-STEP
Beginning proof of SEND-EVENT-IS-FROM-SEND-STEP ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (SEND-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(IMPLIES
 (AND
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
The conjunctive normal form ...
(AND
 (OR (SEQ!EMPTYP (HISTORY STATE))
  (NOT
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
    (NOT (= STATE STATE1)))))
 (OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
    (NOT (= STATE STATE1))))))
Starting case 2 ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (SOME (PREVIOUS-STATE)
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (GOOD-STEP PREVIOUS-STATE STATE))))
 (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Prenexing produces ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)))
 (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Instantiating (= STATE1 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE PRINCIPAL)
     (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE)))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0)
    (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE1)))
   (NOT (= STATE STATE1)))))
Concluding (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
            (SEQ!IS-SEQUENCE (HISTORY STATE))
            (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
            (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
            (GOOD-STEP PREVIOUS-STATE STATE) (IN EVENT (SEND-EVENTS))
            (SEQ!IS-MEMBER EVENT (HISTORY STATE))
            (= (SEQ!HEAD (HISTORY STATE)) EVENT)
            (NOT
             (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
              (SOME (LABEL TIME MESSAGE PRINCIPAL)
               (= STATE
                (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
              (NOT (= STATE PREVIOUS-STATE))))) generates
...
(OR
 (NOT
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
   (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (= (SEQ!HEAD (HISTORY STATE)) EVENT)
   (NOT
    (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SOME (LABEL TIME MESSAGE PRINCIPAL)
      (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
     (NOT (= STATE PREVIOUS-STATE))))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0)
    (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE1)))
   (NOT (= STATE STATE1)))))
Starting case 2.2 ...
(NOT
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE PRINCIPAL)
     (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL TIME MESSAGE PRINCIPAL)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= STATE
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= STATE
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= STATE
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= STATE
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= STATE
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE))))
Substituting (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= STATE
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= STATE
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= STATE
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= STATE
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)
    (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$1 TIME$1 MESSAGE$1 PRINCIPAL$4)
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    (SEND-STEP LABEL$1 TIME$1 MESSAGE$1 PRINCIPAL$4 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$2 TIME$2 MESSAGE$2 PRINCIPAL$5)
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    (SEND-STEP LABEL$2 TIME$2 MESSAGE$2 PRINCIPAL$5 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$3 TIME$3 MESSAGE$3 PRINCIPAL$6)
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    (SEND-STEP LABEL$3 TIME$3 MESSAGE$3 PRINCIPAL$6 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$4 TIME$4 MESSAGE$4 PRINCIPAL$7)
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (SEND-STEP LABEL$4 TIME$4 MESSAGE$4 PRINCIPAL$7 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$5 TIME$5 MESSAGE$5 PRINCIPAL$8)
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    (SEND-STEP LABEL$5 TIME$5 MESSAGE$5 PRINCIPAL$8 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (NOT (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE) PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (SEND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    PREVIOUS-STATE))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
SEQ!IS-MEMBER-TACK, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE
 with the
instantiations (= PRINCIPAL$5 PRINCIPAL) (= MESSAGE$2 MESSAGE) (= TIME$2 TIME)
               (= LABEL$2 LABEL) to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (IN EVENT (SEND-EVENTS))
  (OR (= EVENT (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) EVENT))
 (NOT
  (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE) PREVIOUS-STATE)))
Invoking SEND-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= STATE
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      PREVIOUS-STATE))
    PREVIOUS-STATE))
  (IN EVENT (SEND-EVENTS))
  (OR (= EVENT (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) EVENT))
 (NOT
  (=
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      PREVIOUS-STATE))
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     PREVIOUS-STATE)))
  (IN EVENT (SEND-EVENTS))
  (= EVENT (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)))
 (NOT
  (=
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Splitting
on (= (SEQ!LENGTH (HISTORY STATE))
    (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) generates
...
(IF (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      PREVIOUS-STATE)))
   (IN EVENT (SEND-EVENTS))
   (= EVENT (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)))
  (NOT
   (=
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      PREVIOUS-STATE))
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      PREVIOUS-STATE)))
   (IN EVENT (SEND-EVENTS))
   (= EVENT (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)))
  (NOT
   (=
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      PREVIOUS-STATE))
    PREVIOUS-STATE))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     PREVIOUS-STATE)))
  (IN EVENT (SEND-EVENTS))
  (= EVENT (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)))
 (NOT
  (=
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Invoking (SEQ!LENGTH (HISTORY STATE)) gives ...
(IMPLIES
 (AND
  (=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   1)
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     PREVIOUS-STATE)))
  (IN EVENT (SEND-EVENTS))
  (= EVENT (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)))
 (NOT
  (=
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND
  (NOT
   (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     PREVIOUS-STATE)))
  (IN EVENT (SEND-EVENTS))
  (= EVENT (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)))
 (NOT
  (=
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
 (NOT (IN EVENT (SEND-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION to ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Invoking (SEQ!IS-MEMBER EVENT (HISTORY STATE)) gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (SEND-EVENTS)) (SEQ!IS-TACK (HISTORY STATE))
  (OR (= EVENT (SEQ!HEAD (HISTORY STATE)))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY STATE))))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
RECEIVE-EVENT-IS-FROM-RECEIVE-STEP
Beginning proof of RECEIVE-EVENT-IS-FROM-RECEIVE-STEP ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (RECEIVE-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(IMPLIES
 (AND
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
The conjunctive normal form ...
(AND
 (OR (SEQ!EMPTYP (HISTORY STATE))
  (NOT
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
    (NOT (= STATE STATE1)))))
 (OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
    (NOT (= STATE STATE1))))))
Starting case 2 ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (SOME (PREVIOUS-STATE)
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (GOOD-STEP PREVIOUS-STATE STATE))))
 (NOT (IN EVENT (RECEIVE-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Prenexing produces ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)))
 (NOT (IN EVENT (RECEIVE-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Instantiating (= STATE1 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE PRINCIPAL)
     (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE)))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0)
    (= STATE (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE1)))
   (NOT (= STATE STATE1)))))
Concluding (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
            (SEQ!IS-SEQUENCE (HISTORY STATE))
            (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
            (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
            (GOOD-STEP PREVIOUS-STATE STATE) (IN EVENT (RECEIVE-EVENTS))
            (SEQ!IS-MEMBER EVENT (HISTORY STATE))
            (= (SEQ!HEAD (HISTORY STATE)) EVENT)
            (NOT
             (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
              (SOME (LABEL TIME MESSAGE PRINCIPAL)
               (= STATE
                (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
              (NOT (= STATE PREVIOUS-STATE))))) generates
...
(OR
 (NOT
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
   (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (= (SEQ!HEAD (HISTORY STATE)) EVENT)
   (NOT
    (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SOME (LABEL TIME MESSAGE PRINCIPAL)
      (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
     (NOT (= STATE PREVIOUS-STATE))))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0)
    (= STATE (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE1)))
   (NOT (= STATE STATE1)))))
Starting case 2.2 ...
(NOT
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE PRINCIPAL)
     (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL TIME MESSAGE PRINCIPAL)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= STATE
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= STATE
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= STATE
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= STATE
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= STATE
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (RECEIVE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE))))
Substituting (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= STATE
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= STATE
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= STATE
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= STATE
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)
    (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$1 TIME$1 MESSAGE$1 PRINCIPAL$4)
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    (RECEIVE-STEP LABEL$1 TIME$1 MESSAGE$1 PRINCIPAL$4 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$2 TIME$2 MESSAGE$2 PRINCIPAL$5)
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    (RECEIVE-STEP LABEL$2 TIME$2 MESSAGE$2 PRINCIPAL$5 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$3 TIME$3 MESSAGE$3 PRINCIPAL$6)
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    (RECEIVE-STEP LABEL$3 TIME$3 MESSAGE$3 PRINCIPAL$6 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$4 TIME$4 MESSAGE$4 PRINCIPAL$7)
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (RECEIVE-STEP LABEL$4 TIME$4 MESSAGE$4 PRINCIPAL$7 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$5 TIME$5 MESSAGE$5 PRINCIPAL$8)
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    (RECEIVE-STEP LABEL$5 TIME$5 MESSAGE$5 PRINCIPAL$8 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (NOT (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE) PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (RECEIVE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    PREVIOUS-STATE))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
SEQ!IS-MEMBER-TACK, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE
 with the
instantiations (= PRINCIPAL$6 PRINCIPAL$0) (= MESSAGE$3 MESSAGE)
               (= TIME$3 TIME) (= LABEL$3 LABEL) to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
  (IN EVENT (RECEIVE-EVENTS))
  (OR (= EVENT (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0) EVENT))
 (NOT
  (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
   PREVIOUS-STATE)))
Invoking RECEIVE-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= STATE
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
     (FORGEABLE MESSAGE PREVIOUS-STATE))
    (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
      PREVIOUS-STATE))
    PREVIOUS-STATE))
  (IN EVENT (RECEIVE-EVENTS))
  (OR (= EVENT (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0) EVENT))
 (NOT
  (=
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
     (FORGEABLE MESSAGE PREVIOUS-STATE))
    (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
      PREVIOUS-STATE))
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
     PREVIOUS-STATE)))
  (IN EVENT (RECEIVE-EVENTS))
  (= EVENT (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Splitting
on (= (SEQ!LENGTH (HISTORY STATE))
    (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) generates
...
(IF (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE
    (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
      PREVIOUS-STATE)))
   (IN EVENT (RECEIVE-EVENTS))
   (= EVENT (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)))
  (NOT
   (=
    (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
      PREVIOUS-STATE))
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE
    (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
      PREVIOUS-STATE)))
   (IN EVENT (RECEIVE-EVENTS))
   (= EVENT (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)))
  (NOT
   (=
    (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
      PREVIOUS-STATE))
    PREVIOUS-STATE))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
     PREVIOUS-STATE)))
  (IN EVENT (RECEIVE-EVENTS))
  (= EVENT (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Invoking (SEQ!LENGTH (HISTORY STATE)) gives ...
(IMPLIES
 (AND
  (=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   1)
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
     PREVIOUS-STATE)))
  (IN EVENT (RECEIVE-EVENTS))
  (= EVENT (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND
  (NOT
   (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
     PREVIOUS-STATE)))
  (IN EVENT (RECEIVE-EVENTS))
  (= EVENT (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE PRINCIPAL$0 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
 (NOT (IN EVENT (RECEIVE-EVENTS))) (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION to ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Invoking (SEQ!IS-MEMBER EVENT (HISTORY STATE)) gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (RECEIVE-EVENTS)) (SEQ!IS-TACK (HISTORY STATE))
  (OR (= EVENT (SEQ!HEAD (HISTORY STATE)))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY STATE))))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
OUT-OF-BAND-EVENT-IS-FROM-OUT-OF-BAND-STEP
Beginning proof of OUT-OF-BAND-EVENT-IS-FROM-OUT-OF-BAND-STEP ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (OUT-OF-BAND-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE SENDER RECEIVER)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1))
   (NOT (= STATE STATE1)))))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(IMPLIES
 (AND
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE SENDER RECEIVER)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1))
   (NOT (= STATE STATE1)))))
The conjunctive normal form ...
(AND
 (OR (SEQ!EMPTYP (HISTORY STATE))
  (NOT
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE SENDER RECEIVER)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1))
    (NOT (= STATE STATE1)))))
 (OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE SENDER RECEIVER)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1))
    (NOT (= STATE STATE1))))))
Starting case 2 ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (SOME (PREVIOUS-STATE)
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (GOOD-STEP PREVIOUS-STATE STATE))))
 (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE SENDER RECEIVER)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1))
   (NOT (= STATE STATE1)))))
Prenexing produces ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)))
 (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE SENDER RECEIVER)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE SENDER RECEIVER)
    (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1)))
   (NOT (= STATE STATE1)))))
Instantiating (= STATE1 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE SENDER RECEIVER)
     (= STATE
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE)))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
    (= STATE
     (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0 STATE1)))
   (NOT (= STATE STATE1)))))
Concluding (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
            (SEQ!IS-SEQUENCE (HISTORY STATE))
            (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
            (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
            (GOOD-STEP PREVIOUS-STATE STATE) (IN EVENT (OUT-OF-BAND-EVENTS))
            (SEQ!IS-MEMBER EVENT (HISTORY STATE))
            (= (SEQ!HEAD (HISTORY STATE)) EVENT)
            (NOT
             (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
              (SOME (LABEL TIME MESSAGE SENDER RECEIVER)
               (= STATE
                (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
                 PREVIOUS-STATE)))
              (NOT (= STATE PREVIOUS-STATE))))) generates
...
(OR
 (NOT
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
   (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (= (SEQ!HEAD (HISTORY STATE)) EVENT)
   (NOT
    (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SOME (LABEL TIME MESSAGE SENDER RECEIVER)
      (= STATE
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
     (NOT (= STATE PREVIOUS-STATE))))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
    (= STATE
     (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0 STATE1)))
   (NOT (= STATE STATE1)))))
Starting case 2.2 ...
(NOT
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE SENDER RECEIVER)
     (= STATE
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE))))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL TIME MESSAGE SENDER RECEIVER)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= STATE
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= STATE
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= STATE
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= STATE
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
   (= STATE
    (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
     PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= STATE
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
   (= STATE
    (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
     PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
   (= STATE
    (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
     PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
   (= STATE
    (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
     PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
   (= STATE
    (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
     PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
   (= STATE
    (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
     PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
   (= STATE
    (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
     PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
   (= STATE
    (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
     PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE))))
Substituting (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= STATE
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= STATE
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= STATE
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= STATE
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
   (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)
    (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
     PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$1 TIME$1 MESSAGE$1 SENDER$1 RECEIVER$1)
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    (OUT-OF-BAND-STEP LABEL$1 TIME$1 MESSAGE$1 SENDER$1 RECEIVER$1
     PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$2 TIME$2 MESSAGE$2 SENDER$2 RECEIVER$2)
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    (OUT-OF-BAND-STEP LABEL$2 TIME$2 MESSAGE$2 SENDER$2 RECEIVER$2
     PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$3 TIME$3 MESSAGE$3 SENDER$3 RECEIVER$3)
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    (OUT-OF-BAND-STEP LABEL$3 TIME$3 MESSAGE$3 SENDER$3 RECEIVER$3
     PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$4 TIME$4 MESSAGE$4 SENDER$4 RECEIVER$4)
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (OUT-OF-BAND-STEP LABEL$4 TIME$4 MESSAGE$4 SENDER$4 RECEIVER$4
     PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$5 TIME$5 MESSAGE$5 SENDER$5 RECEIVER$5)
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    (OUT-OF-BAND-STEP LABEL$5 TIME$5 MESSAGE$5 SENDER$5 RECEIVER$5
     PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (NOT (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE) PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    PREVIOUS-STATE))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
SEQ!IS-MEMBER-TACK, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE
 with the
instantiations (= RECEIVER$5 RECEIVER) (= SENDER$5 SENDER)
               (= MESSAGE$5 MESSAGE) (= TIME$5 TIME) (= LABEL$5 LABEL) to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
  (= STATE
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
  (IN EVENT (OUT-OF-BAND-EVENTS))
  (OR (= EVENT (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) EVENT))
 (NOT
  (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
   PREVIOUS-STATE)))
Invoking OUT-OF-BAND-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
  (= STATE
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
      PREVIOUS-STATE))
    PREVIOUS-STATE))
  (IN EVENT (OUT-OF-BAND-EVENTS))
  (OR (= EVENT (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) EVENT))
 (NOT
  (=
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
      PREVIOUS-STATE))
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
     PREVIOUS-STATE)))
  (IN EVENT (OUT-OF-BAND-EVENTS))
  (= EVENT (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Splitting
on (= (SEQ!LENGTH (HISTORY STATE))
    (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) generates
...
(IF (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
      PREVIOUS-STATE)))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (= EVENT (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)))
  (NOT
   (=
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
      PREVIOUS-STATE))
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
      PREVIOUS-STATE)))
   (IN EVENT (OUT-OF-BAND-EVENTS))
   (= EVENT (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)))
  (NOT
   (=
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
      PREVIOUS-STATE))
    PREVIOUS-STATE))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
     PREVIOUS-STATE)))
  (IN EVENT (OUT-OF-BAND-EVENTS))
  (= EVENT (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Invoking (SEQ!LENGTH (HISTORY STATE)) gives ...
(IMPLIES
 (AND
  (=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   1)
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
     PREVIOUS-STATE)))
  (IN EVENT (OUT-OF-BAND-EVENTS))
  (= EVENT (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND
  (NOT
   (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
     PREVIOUS-STATE)))
  (IN EVENT (OUT-OF-BAND-EVENTS))
  (= EVENT (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY
     (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
 (NOT (IN EVENT (OUT-OF-BAND-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE SENDER RECEIVER)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION to ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE SENDER RECEIVER)
    (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1)))
   (NOT (= STATE STATE1)))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE SENDER RECEIVER)
    (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1)))
   (NOT (= STATE STATE1)))))
Invoking (SEQ!IS-MEMBER EVENT (HISTORY STATE)) gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (OUT-OF-BAND-EVENTS)) (SEQ!IS-TACK (HISTORY STATE))
  (OR (= EVENT (SEQ!HEAD (HISTORY STATE)))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY STATE))))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE SENDER RECEIVER)
    (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE1)))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
GENERATE-EVENT-IS-FROM-GENERATE-STEP
Beginning proof of GENERATE-EVENT-IS-FROM-GENERATE-STEP ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (GENERATE-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(IMPLIES
 (AND
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
The conjunctive normal form ...
(AND
 (OR (SEQ!EMPTYP (HISTORY STATE))
  (NOT
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
    (NOT (= STATE STATE1)))))
 (OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
    (NOT (= STATE STATE1))))))
Starting case 2 ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (SOME (PREVIOUS-STATE)
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (GOOD-STEP PREVIOUS-STATE STATE))))
 (NOT (IN EVENT (GENERATE-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Prenexing produces ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)))
 (NOT (IN EVENT (GENERATE-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Instantiating (= STATE1 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE PRINCIPAL)
     (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE)))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0)
    (= STATE (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE1)))
   (NOT (= STATE STATE1)))))
Concluding (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
            (SEQ!IS-SEQUENCE (HISTORY STATE))
            (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
            (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
            (GOOD-STEP PREVIOUS-STATE STATE) (IN EVENT (GENERATE-EVENTS))
            (SEQ!IS-MEMBER EVENT (HISTORY STATE))
            (= (SEQ!HEAD (HISTORY STATE)) EVENT)
            (NOT
             (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
              (SOME (LABEL TIME MESSAGE PRINCIPAL)
               (= STATE
                (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
              (NOT (= STATE PREVIOUS-STATE))))) generates
...
(OR
 (NOT
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
   (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (= (SEQ!HEAD (HISTORY STATE)) EVENT)
   (NOT
    (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SOME (LABEL TIME MESSAGE PRINCIPAL)
      (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
     (NOT (= STATE PREVIOUS-STATE))))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0)
    (= STATE (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE1)))
   (NOT (= STATE STATE1)))))
Starting case 2.2 ...
(NOT
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE PRINCIPAL)
     (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE))))))
Which simplifies
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL TIME MESSAGE PRINCIPAL)
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= STATE
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= STATE
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= STATE
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= STATE
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= STATE
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (GENERATE-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE))))
Substituting (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= STATE
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= STATE
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= STATE
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= STATE
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)
    (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$1 TIME$1 MESSAGE$1 PRINCIPAL$4)
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    (GENERATE-STEP LABEL$1 TIME$1 MESSAGE$1 PRINCIPAL$4 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$2 TIME$2 MESSAGE$2 PRINCIPAL$5)
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    (GENERATE-STEP LABEL$2 TIME$2 MESSAGE$2 PRINCIPAL$5 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$3 TIME$3 MESSAGE$3 PRINCIPAL$6)
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    (GENERATE-STEP LABEL$3 TIME$3 MESSAGE$3 PRINCIPAL$6 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$4 TIME$4 MESSAGE$4 PRINCIPAL$7)
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (GENERATE-STEP LABEL$4 TIME$4 MESSAGE$4 PRINCIPAL$7 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$5 TIME$5 MESSAGE$5 PRINCIPAL$8)
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    (GENERATE-STEP LABEL$5 TIME$5 MESSAGE$5 PRINCIPAL$8 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (NOT (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE) PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (GENERATE-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    PREVIOUS-STATE))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
SEQ!IS-MEMBER-TACK, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE
 with the
instantiations (= PRINCIPAL$4 PRINCIPAL$1) (= MESSAGE$1 MESSAGE)
               (= TIME$1 TIME) (= LABEL$1 LABEL) to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
  (IN EVENT (GENERATE-EVENTS))
  (OR (= EVENT (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1) EVENT))
 (NOT
  (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
   PREVIOUS-STATE)))
Invoking GENERATE-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= STATE
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
     (IN PRINCIPAL$1 (MS!PRINCIPALS)))
    (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1) PREVIOUS-STATE))
    PREVIOUS-STATE))
  (IN EVENT (GENERATE-EVENTS))
  (OR (= EVENT (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1) EVENT))
 (NOT
  (=
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
     (IN PRINCIPAL$1 (MS!PRINCIPALS)))
    (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1) PREVIOUS-STATE))
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= STATE
   (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
     PREVIOUS-STATE)))
  (IN EVENT (GENERATE-EVENTS))
  (= EVENT (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Splitting
on (= (SEQ!LENGTH (HISTORY STATE))
    (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) generates
...
(IF (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
   (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE
    (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1) PREVIOUS-STATE)))
   (IN EVENT (GENERATE-EVENTS))
   (= EVENT (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)))
  (NOT
   (=
    (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1) PREVIOUS-STATE))
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
   (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE
    (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1) PREVIOUS-STATE)))
   (IN EVENT (GENERATE-EVENTS))
   (= EVENT (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)))
  (NOT
   (=
    (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1) PREVIOUS-STATE))
    PREVIOUS-STATE))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= STATE
   (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
     PREVIOUS-STATE)))
  (IN EVENT (GENERATE-EVENTS))
  (= EVENT (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Invoking (SEQ!LENGTH (HISTORY STATE)) gives ...
(IMPLIES
 (AND
  (=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   1)
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= STATE
   (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
     PREVIOUS-STATE)))
  (IN EVENT (GENERATE-EVENTS))
  (= EVENT (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND
  (NOT
   (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= STATE
   (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
     PREVIOUS-STATE)))
  (IN EVENT (GENERATE-EVENTS))
  (= EVENT (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)))
 (NOT
  (=
   (ADD-TO-STATE-STORAGE PRINCIPAL$1 (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
 (NOT (IN EVENT (GENERATE-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION to ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Invoking (SEQ!IS-MEMBER EVENT (HISTORY STATE)) gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (GENERATE-EVENTS)) (SEQ!IS-TACK (HISTORY STATE))
  (OR (= EVENT (SEQ!HEAD (HISTORY STATE)))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY STATE))))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
CONSTRUCT-EVENT-IS-FROM-CONSTRUCT-STEP
Beginning proof of CONSTRUCT-EVENT-IS-FROM-CONSTRUCT-STEP ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (CONSTRUCT-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(IMPLIES
 (AND
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
The conjunctive normal form ...
(AND
 (OR (SEQ!EMPTYP (HISTORY STATE))
  (NOT
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
    (NOT (= STATE STATE1)))))
 (OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
    (NOT (= STATE STATE1))))))
Starting case 2 ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (SOME (PREVIOUS-STATE)
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (GOOD-STEP PREVIOUS-STATE STATE))))
 (NOT (IN EVENT (CONSTRUCT-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Prenexing produces ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)))
 (NOT (IN EVENT (CONSTRUCT-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Instantiating (= STATE1 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE PRINCIPAL)
     (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE)))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0)
    (= STATE (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE1)))
   (NOT (= STATE STATE1)))))
Concluding (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
            (SEQ!IS-SEQUENCE (HISTORY STATE))
            (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
            (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
            (GOOD-STEP PREVIOUS-STATE STATE) (IN EVENT (CONSTRUCT-EVENTS))
            (SEQ!IS-MEMBER EVENT (HISTORY STATE))
            (= (SEQ!HEAD (HISTORY STATE)) EVENT)
            (NOT
             (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
              (SOME (LABEL TIME MESSAGE PRINCIPAL)
               (= STATE
                (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
              (NOT (= STATE PREVIOUS-STATE))))) generates
...
(OR
 (NOT
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
   (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (= (SEQ!HEAD (HISTORY STATE)) EVENT)
   (NOT
    (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SOME (LABEL TIME MESSAGE PRINCIPAL)
      (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
     (NOT (= STATE PREVIOUS-STATE))))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0)
    (= STATE (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE1)))
   (NOT (= STATE STATE1)))))
Starting case 2.2 ...
(NOT
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE PRINCIPAL)
     (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE))))))
Which simplifies
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL TIME MESSAGE PRINCIPAL)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= STATE
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= STATE
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= STATE
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= STATE
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= STATE
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= STATE
    (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (CONSTRUCT-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE))))
Substituting (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= STATE
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= STATE
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= STATE
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= STATE
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
   (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)
    (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$1 TIME$1 MESSAGE$1 PRINCIPAL$4)
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    (CONSTRUCT-STEP LABEL$1 TIME$1 MESSAGE$1 PRINCIPAL$4 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$2 TIME$2 MESSAGE$2 PRINCIPAL$5)
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    (CONSTRUCT-STEP LABEL$2 TIME$2 MESSAGE$2 PRINCIPAL$5 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$3 TIME$3 MESSAGE$3 PRINCIPAL$6)
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    (CONSTRUCT-STEP LABEL$3 TIME$3 MESSAGE$3 PRINCIPAL$6 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$4 TIME$4 MESSAGE$4 PRINCIPAL$7)
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (CONSTRUCT-STEP LABEL$4 TIME$4 MESSAGE$4 PRINCIPAL$7 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$5 TIME$5 MESSAGE$5 PRINCIPAL$8)
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    (CONSTRUCT-STEP LABEL$5 TIME$5 MESSAGE$5 PRINCIPAL$8 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (NOT (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE) PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    PREVIOUS-STATE))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
SEQ!IS-MEMBER-TACK, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE
 with the
instantiations (= PRINCIPAL$7 PRINCIPAL$2) (= MESSAGE$4 MESSAGE)
               (= TIME$4 TIME) (= LABEL$4 LABEL) to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$2 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
  (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (IN EVENT (CONSTRUCT-EVENTS))
  (OR (= EVENT (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2) EVENT))
 (NOT
  (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   PREVIOUS-STATE)))
Invoking CONSTRUCT-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$2 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
  (= STATE
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
    (ADD-TO-STATE-HISTORY
     (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2) PREVIOUS-STATE)
    PREVIOUS-STATE))
  (IN EVENT (CONSTRUCT-EVENTS))
  (OR (= EVENT (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2) EVENT))
 (NOT
  (=
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
    (ADD-TO-STATE-HISTORY
     (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2) PREVIOUS-STATE)
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$2 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
    PREVIOUS-STATE))
  (IN EVENT (CONSTRUCT-EVENTS))
  (= EVENT (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)))
 (NOT
  (=
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Splitting
on (= (SEQ!LENGTH (HISTORY STATE))
    (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) generates
...
(IF (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE
    (ADD-TO-STATE-HISTORY
     (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2) PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (= EVENT (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)))
  (NOT
   (=
    (ADD-TO-STATE-HISTORY
     (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2) PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE
    (ADD-TO-STATE-HISTORY
     (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2) PREVIOUS-STATE))
   (IN EVENT (CONSTRUCT-EVENTS))
   (= EVENT (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)))
  (NOT
   (=
    (ADD-TO-STATE-HISTORY
     (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2) PREVIOUS-STATE)
    PREVIOUS-STATE))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$2 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
    PREVIOUS-STATE))
  (IN EVENT (CONSTRUCT-EVENTS))
  (= EVENT (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)))
 (NOT
  (=
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Invoking (SEQ!LENGTH (HISTORY STATE)) gives ...
(IMPLIES
 (AND
  (=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   1)
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$2 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
    PREVIOUS-STATE))
  (IN EVENT (CONSTRUCT-EVENTS))
  (= EVENT (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)))
 (NOT
  (=
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND
  (NOT
   (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL$2 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
  (= STATE
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
    PREVIOUS-STATE))
  (IN EVENT (CONSTRUCT-EVENTS))
  (= EVENT (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)))
 (NOT
  (=
   (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL$2)
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-HISTORY-IS-STATE,
TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
 (NOT (IN EVENT (CONSTRUCT-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE PRINCIPAL)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION to ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Invoking (SEQ!IS-MEMBER EVENT (HISTORY STATE)) gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (CONSTRUCT-EVENTS)) (SEQ!IS-TACK (HISTORY STATE))
  (OR (= EVENT (SEQ!HEAD (HISTORY STATE)))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY STATE))))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE PRINCIPAL)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE1)))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
INTRUDER-EVENT-IS-FROM-INTRUDER-STEP
Beginning proof of INTRUDER-EVENT-IS-FROM-INTRUDER-STEP ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE STATE) (IN EVENT (INTRUDER-EVENTS))
  (SEQ!IS-MEMBER EVENT (HISTORY STATE)) (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1))
   (NOT (= STATE STATE1)))))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(IMPLIES
 (AND
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1))
   (NOT (= STATE STATE1)))))
The conjunctive normal form ...
(AND
 (OR (SEQ!EMPTYP (HISTORY STATE))
  (NOT
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE))))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1))
    (NOT (= STATE STATE1)))))
 (OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (STATE1 LABEL TIME MESSAGE)
   (AND (IS-GOOD-EVOLUTION-STATE STATE1)
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1))
    (NOT (= STATE STATE1))))))
Starting case 2 ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (SOME (PREVIOUS-STATE)
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (GOOD-STEP PREVIOUS-STATE STATE))))
 (NOT (IN EVENT (INTRUDER-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1))
   (NOT (= STATE STATE1)))))
Prenexing produces ...
(OR (SEQ!EMPTYP (HISTORY STATE))
 (NOT
  (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)))
 (NOT (IN EVENT (INTRUDER-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE)
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1)))
   (NOT (= STATE STATE1)))))
Instantiating (= STATE1 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE)
     (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE)))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0)
    (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE1)))
   (NOT (= STATE STATE1)))))
Concluding (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
            (SEQ!IS-SEQUENCE (HISTORY STATE))
            (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
            (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
            (GOOD-STEP PREVIOUS-STATE STATE) (IN EVENT (INTRUDER-EVENTS))
            (SEQ!IS-MEMBER EVENT (HISTORY STATE))
            (= (SEQ!HEAD (HISTORY STATE)) EVENT)
            (NOT
             (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
              (SOME (LABEL TIME MESSAGE)
               (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
              (NOT (= STATE PREVIOUS-STATE))))) generates
...
(OR
 (NOT
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
   (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
   (= (SEQ!HEAD (HISTORY STATE)) EVENT)
   (NOT
    (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SOME (LABEL TIME MESSAGE)
      (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
     (NOT (= STATE PREVIOUS-STATE))))))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL$0 TIME$0 MESSAGE$0)
    (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE1)))
   (NOT (= STATE STATE1)))))
Starting case 2.2 ...
(NOT
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT)
  (NOT
   (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (SOME (LABEL TIME MESSAGE)
     (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    (NOT (= STATE PREVIOUS-STATE))))))
Which simplifies
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE)
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL TIME MESSAGE)
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= STATE
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= STATE
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= STATE
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= STATE
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= STATE
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (AND
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 PREVIOUS-STATE)))
  (NOT (= STATE PREVIOUS-STATE))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (= STATE (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 PREVIOUS-STATE))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE)))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (NOT (IN EVENT (INTRUDER-EVENTS)))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
  (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT)) (NOT (= STATE PREVIOUS-STATE))))
Substituting (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= STATE
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= STATE
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= STATE
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= STATE
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)
    (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$1 TIME$1 MESSAGE$1)
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    (INTRUDER-STEP LABEL$1 TIME$1 MESSAGE$1 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$2 TIME$2 MESSAGE$2)
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    (INTRUDER-STEP LABEL$2 TIME$2 MESSAGE$2 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$3 TIME$3 MESSAGE$3)
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    (INTRUDER-STEP LABEL$3 TIME$3 MESSAGE$3 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$4 TIME$4 MESSAGE$4)
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (INTRUDER-STEP LABEL$4 TIME$4 MESSAGE$4 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (SOME (LABEL$5 TIME$5 MESSAGE$5)
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    (INTRUDER-STEP LABEL$5 TIME$5 MESSAGE$5 PREVIOUS-STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    EVENT))
  (NOT (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE) PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= STATE
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (IN EVENT (INTRUDER-EVENTS))
   (SEQ!IS-MEMBER EVENT
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (=
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    EVENT))
  (NOT
   (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)
    PREVIOUS-STATE))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, HISTORY-OF-GENERATE-STEP,
SEQ!IS-MEMBER-TACK, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE
 with the
instantiations (= MESSAGE$0 MESSAGE) (= TIME$0 TIME) (= LABEL$0 LABEL) to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (= STATE (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
  (IN EVENT (INTRUDER-EVENTS))
  (OR (= EVENT (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) EVENT))
 (NOT (= (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE) PREVIOUS-STATE)))
Invoking INTRUDER-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (= STATE
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
      PREVIOUS-STATE))
    PREVIOUS-STATE))
  (IN EVENT (INTRUDER-EVENTS))
  (OR (= EVENT (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE))
   (SEQ!IS-MEMBER EVENT (HISTORY PREVIOUS-STATE)))
  (= (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) EVENT))
 (NOT
  (=
   (IF
    (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
     (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
      PREVIOUS-STATE))
    PREVIOUS-STATE)
   PREVIOUS-STATE)))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (= STATE
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
     PREVIOUS-STATE)))
  (IN EVENT (INTRUDER-EVENTS))
  (= EVENT (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)))
 (NOT
  (=
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Splitting
on (= (SEQ!LENGTH (HISTORY STATE))
    (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) generates
...
(IF (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
   (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
   (= STATE
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
      PREVIOUS-STATE)))
   (IN EVENT (INTRUDER-EVENTS))
   (= EVENT (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)))
  (NOT
   (=
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
      PREVIOUS-STATE))
    PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
   (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
   (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
   (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
   (= STATE
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
      PREVIOUS-STATE)))
   (IN EVENT (INTRUDER-EVENTS))
   (= EVENT (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)))
  (NOT
   (=
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
      PREVIOUS-STATE))
    PREVIOUS-STATE))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (= STATE
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
     PREVIOUS-STATE)))
  (IN EVENT (INTRUDER-EVENTS))
  (= EVENT (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)))
 (NOT
  (=
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Invoking (SEQ!LENGTH (HISTORY STATE)) gives ...
(IMPLIES
 (AND
  (=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE))))
  (>=
   (IF (SEQ!IS-TACK (HISTORY STATE))
    (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
   1)
  (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (= STATE
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
     PREVIOUS-STATE)))
  (IN EVENT (INTRUDER-EVENTS))
  (= EVENT (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)))
 (NOT
  (=
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND
  (NOT
   (= (SEQ!LENGTH (HISTORY STATE)) (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))))
  (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (= STATE
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
     PREVIOUS-STATE)))
  (IN EVENT (INTRUDER-EVENTS))
  (= EVENT (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)))
 (NOT
  (=
   (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
    (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
     PREVIOUS-STATE))
   PREVIOUS-STATE)))
Which simplifies
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(OR (NOT (SEQ!EMPTYP (HISTORY STATE))) (NOT (IS-GOOD-STATE STATE))
 (NOT (IN EVENT (INTRUDER-EVENTS)))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY STATE)))
 (NOT (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1 LABEL TIME MESSAGE)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1))
   (NOT (= STATE STATE1)))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION to ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE)
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1)))
   (NOT (= STATE STATE1)))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-MEMBER EVENT (HISTORY STATE))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE)
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1)))
   (NOT (= STATE STATE1)))))
Invoking (SEQ!IS-MEMBER EVENT (HISTORY STATE)) gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN EVENT (INTRUDER-EVENTS)) (SEQ!IS-TACK (HISTORY STATE))
  (OR (= EVENT (SEQ!HEAD (HISTORY STATE)))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY STATE))))
  (= (SEQ!HEAD (HISTORY STATE)) EVENT))
 (SOME (STATE1)
  (AND (IS-GOOD-EVOLUTION-STATE STATE1)
   (SOME (LABEL TIME MESSAGE)
    (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE1)))
   (NOT (= STATE STATE1)))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Completing all cases produces ...
(TRUE)
KNOWN-BY-PRINCIPAL-ADD-ENCRYPT
Beginning proof of KNOWN-BY-PRINCIPAL-ADD-ENCRYPT ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (KNOWN-BY-PRINCIPAL M P
   (ADD-TO-STATE-STORAGE P (SETADD (MS!ENCRYPT M1 K) MS) S))
  (IF (KNOWN-BY-PRINCIPAL (MS!INVERSE K) P (ADD-TO-STATE-STORAGE P MS S))
   (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD M1 MS) S))
   (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P MS S)))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)))
 (=
  (MS!KNOWN-IN M
   (UNION
    (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD (MS!ENCRYPT M1 K) MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IF
   (MS!KNOWN-IN (MS!INVERSE K)
    (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P MS S))
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
   (MS!KNOWN-IN M
    (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD M1 MS) S))
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
   (MS!KNOWN-IN M
    (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P MS S))
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))))
Which simplifies
 when rewriting with MS!C1, MS!D2-RULE, UNION.ASSOCIATIVE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT, STORAGE-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, ADD-TO-STATE-STORAGE-IS-STATE,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS))
  (MS!COMP-OF (MS!INVERSE K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
 (=
  (MS!COMP-OF M
   (SETADD (MS!ENCRYPT M1 K)
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
Applying MS!C2 gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS))
  (MS!COMP-OF (MS!INVERSE K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
 (=
  (IF
   (AND
    (NOT
     (MS!COMP-OF M
      (SETADD M1
       (UNION MS
        (UNION (MS!PRINCIPALS)
         (UNION (MS!TEXT-MESSAGES)
          (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
    (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (= M (MS!ENCRYPT M1 K))))
   (FALSE)
   (MS!COMP-OF M
    (SETADD (MS!ENCRYPT M1 K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!INVERSE-IN-KEYS-1, MS!TAG-OF-INVERSE-1,
MS!TAG-OF-INVERSE-2, MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS))
  (MS!COMP-OF (MS!INVERSE K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
 (=
  (MS!COMP-OF M
   (SETADD (MS!ENCRYPT M1 K)
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (TRUE)))
Assuming MS!COMP-OF-TRANSITIVE with the
instantiations: (= M M)
                (= S1
                 (SETADD M1
                  (UNION MS
                   (UNION (MS!PRINCIPALS)
                    (UNION (MS!TEXT-MESSAGES)
                     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
                (= S2
                 (SETADD (MS!ENCRYPT M1 K)
                  (UNION MS
                   (UNION (MS!PRINCIPALS)
                    (UNION (MS!TEXT-MESSAGES)
                     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (MS!COMP-OF M
     (SETADD M1
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
    (ALL (C)
     (IMPLIES
      (AND
       (IN C
        (SETADD M1
         (UNION MS
          (UNION (MS!PRINCIPALS)
           (UNION (MS!TEXT-MESSAGES)
            (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
       (IN C (MS!MESSAGES)))
      (MS!COMP-OF C
       (SETADD (MS!ENCRYPT M1 K)
        (UNION MS
         (UNION (MS!PRINCIPALS)
          (UNION (MS!TEXT-MESSAGES)
           (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))))
   (MS!COMP-OF M
    (SETADD (MS!ENCRYPT M1 K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS))
  (MS!COMP-OF (MS!INVERSE K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
 (MS!COMP-OF M
  (SETADD (MS!ENCRYPT M1 K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS))
  (MS!COMP-OF (MS!INVERSE K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (IMPLIES
   (AND
    (MS!COMP-OF M
     (SETADD M1
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
    (ALL (C)
     (IMPLIES
      (AND
       (IN C
        (SETADD M1
         (UNION MS
          (UNION (MS!PRINCIPALS)
           (UNION (MS!TEXT-MESSAGES)
            (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
       (IN C (MS!MESSAGES)))
      (MS!COMP-OF C
       (SETADD (MS!ENCRYPT M1 K)
        (UNION MS
         (UNION (MS!PRINCIPALS)
          (UNION (MS!TEXT-MESSAGES)
           (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))))
   (MS!COMP-OF M
    (SETADD (MS!ENCRYPT M1 K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
 (MS!COMP-OF M
  (SETADD (MS!ENCRYPT M1 K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD, MS!B5, UNION.DEFINITION,
SETADD.DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!INVERSE-IN-KEYS-1, MS!TAG-OF-INVERSE-1,
MS!TAG-OF-INVERSE-2, MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS))
  (MS!COMP-OF (MS!INVERSE K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (NOT
   (MS!COMP-OF M1
    (SETADD (MS!ENCRYPT M1 K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
 (MS!COMP-OF M
  (SETADD (MS!ENCRYPT M1 K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
Assuming MS!B2 with the
instantiations: (= C M1) (= K K)
                (= S
                 (SETADD (MS!ENCRYPT M1 K)
                  (UNION MS
                   (UNION (MS!PRINCIPALS)
                    (UNION (MS!TEXT-MESSAGES)
                     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN K (MS!KEYS))
    (MS!COMP-OF (MS!ENCRYPT M1 K)
     (SETADD (MS!ENCRYPT M1 K)
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
    (MS!COMP-OF (MS!INVERSE K)
     (SETADD (MS!ENCRYPT M1 K)
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
   (MS!COMP-OF M1
    (SETADD (MS!ENCRYPT M1 K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS))
  (MS!COMP-OF (MS!INVERSE K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (NOT
   (MS!COMP-OF M1
    (SETADD (MS!ENCRYPT M1 K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
 (MS!COMP-OF M
  (SETADD (MS!ENCRYPT M1 K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN M1 (MS!MESSAGES)) (IN K (MS!KEYS))
  (MS!COMP-OF (MS!INVERSE K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (NOT
   (MS!COMP-OF M1
    (SETADD (MS!ENCRYPT M1 K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (IMPLIES
   (AND (IN K (MS!KEYS))
    (MS!COMP-OF (MS!ENCRYPT M1 K)
     (SETADD (MS!ENCRYPT M1 K)
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
    (MS!COMP-OF (MS!INVERSE K)
     (SETADD (MS!ENCRYPT M1 K)
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
   (MS!COMP-OF M1
    (SETADD (MS!ENCRYPT M1 K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
 (MS!COMP-OF M
  (SETADD (MS!ENCRYPT M1 K)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
Which simplifies
 when rewriting with MS!COMP-OF-SETADD, MS!B5, SETADD.DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!INVERSE-IN-KEYS-1, MS!TAG-OF-INVERSE-1,
MS!TAG-OF-INVERSE-2, MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-ATOMIC-ADD-SIGN
Beginning proof of KNOWN-BY-PRINCIPAL-ATOMIC-ADD-SIGN ...
(IMPLIES
 (AND (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)) (IS-GOOD-STATE S))
 (=
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD (SIGN M1 K) MS) S))
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD M1 MS) S))))
Which simplifies
 when rewriting with KNOWN-BY-PRINCIPAL-ADD-SIGN
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT,
MS!TAG-OF-COMBINE-MESSAGES, MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1,
MS!SIZE-CB2, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, ADD-TO-STATE-STORAGE-IS-STATE,
SIGN-IS-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)) (IS-GOOD-STATE S))
 (=
  (KNOWN-BY-PRINCIPAL M P
   (ADD-TO-STATE-STORAGE P (SETADD M1 (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS))
    S))
  (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P (SETADD M1 MS) S))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)) (IS-GOOD-STATE S))
 (=
  (MS!KNOWN-IN M
   (UNION
    (STORAGE-OF P
     (ADD-TO-STATE-STORAGE P
      (SETADD M1 (SETADD (MS!ENCRYPT (MS!HASH M1) K) MS)) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P (SETADD M1 MS) S))
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with MS!D2-RULE, UNION.ASSOCIATIVE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE, SETRULES!SETADD-UNION-LEFT, STORAGE-OF-ADD-TO-STATE-STORAGE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-HASH-MESSAGES,
MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, ADD-TO-STATE-STORAGE-IS-STATE,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)) (IS-GOOD-STATE S))
 (=
  (MS!COMP-OF M
   (SETADD M1
    (SETADD (MS!ENCRYPT (MS!HASH M1) K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
Splitting on (= M M1) generates ...
(IF (= M M1)
 (IMPLIES
  (AND (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)) (IS-GOOD-STATE S))
  (=
   (MS!COMP-OF M
    (SETADD M1
     (SETADD (MS!ENCRYPT (MS!HASH M1) K)
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
 (IMPLIES
  (AND (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES)) (IS-GOOD-STATE S))
  (=
   (MS!COMP-OF M
    (SETADD M1
     (SETADD (MS!ENCRYPT (MS!HASH M1) K)
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))))
Which simplifies
 when rewriting with MS!B5, SETADD.DEFINITION
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (NOT (= M M1)) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S))
 (=
  (MS!COMP-OF M
   (SETADD M1
    (SETADD (MS!ENCRYPT (MS!HASH M1) K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
Applying SETRULES!SETADD-COMMUTES gives ...
(IMPLIES
 (AND (NOT (= M M1)) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S))
 (=
  (MS!COMP-OF M
   (SETADD (MS!ENCRYPT (MS!HASH M1) K)
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
Applying MS!C2 gives ...
(IMPLIES
 (AND (NOT (= M M1)) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S))
 (=
  (IF
   (AND
    (NOT
     (MS!COMP-OF M
      (SETADD (MS!HASH M1)
       (SETADD M1
        (UNION MS
         (UNION (MS!PRINCIPALS)
          (UNION (MS!TEXT-MESSAGES)
           (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
    (IN (MS!HASH M1) (MS!MESSAGES)) (IN K (MS!KEYS))
    (NOT (= M (MS!ENCRYPT (MS!HASH M1) K))))
   (FALSE)
   (MS!COMP-OF M
    (SETADD (MS!ENCRYPT (MS!HASH M1) K)
     (SETADD M1
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
Which simplifies
 when rewriting with SETRULES!SETADD-COMMUTES
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (NOT (= M M1)) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S))
 (IF
  (MS!COMP-OF M
   (SETADD M1
    (SETADD (MS!HASH M1)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (=
   (MS!COMP-OF M
    (SETADD M1
     (SETADD (MS!ENCRYPT (MS!HASH M1) K)
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (= (FALSE)
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))))
Applying SETRULES!SETADD-COMMUTES to
 (SETADD M1
  (SETADD (MS!HASH M1)
   (UNION MS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))) gives
...
(IMPLIES
 (AND (NOT (= M M1)) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S))
 (IF
  (MS!COMP-OF M
   (SETADD (MS!HASH M1)
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (=
   (MS!COMP-OF M
    (SETADD M1
     (SETADD (MS!ENCRYPT (MS!HASH M1) K)
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (= (FALSE)
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))))
Applying MS!C1C gives ...
(IMPLIES
 (AND (NOT (= M M1)) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S))
 (IF
  (IF (AND (IN M (MS!MESSAGES)) (NOT (= M (MS!HASH M1))))
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
   (MS!COMP-OF M
    (SETADD (MS!HASH M1)
     (SETADD M1
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
  (=
   (MS!COMP-OF M
    (SETADD M1
     (SETADD (MS!ENCRYPT (MS!HASH M1) K)
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (= (FALSE)
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (NOT (= M M1)) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S)
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
 (=
  (MS!COMP-OF M
   (SETADD M1
    (SETADD (MS!ENCRYPT (MS!HASH M1) K)
     (UNION MS
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
  (TRUE)))
Assuming MS!COMP-OF-SUBSET with the
instantiations: (= C M)
                (= S1
                 (SETADD M1
                  (UNION MS
                   (UNION (MS!PRINCIPALS)
                    (UNION (MS!TEXT-MESSAGES)
                     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
                (= S2
                 (SETADD M1
                  (UNION MS
                   (SETADD (MS!ENCRYPT (MS!HASH M1) K)
                    (UNION (MS!PRINCIPALS)
                     (UNION (MS!TEXT-MESSAGES)
                      (UNION (MS!PUBLIC-KEYS)
                       (STORAGE-OF P S)))))))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (MS!COMP-OF M
     (SETADD M1
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
    (SUBSET
     (SETADD M1
      (UNION MS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
     (SETADD M1
      (UNION MS
       (SETADD (MS!ENCRYPT (MS!HASH M1) K)
        (UNION (MS!PRINCIPALS)
         (UNION (MS!TEXT-MESSAGES)
          (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
   (MS!COMP-OF M
    (SETADD M1
     (UNION MS
      (SETADD (MS!ENCRYPT (MS!HASH M1) K)
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
  (NOT (= M M1)) (IN M (MS!ATOMIC-MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (IN M1 (MS!MESSAGES)) (SUBSET MS (MS!MESSAGES))
  (IS-GOOD-STATE S)
  (MS!COMP-OF M
   (SETADD M1
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))))
 (MS!COMP-OF M
  (SETADD M1
   (SETADD (MS!ENCRYPT (MS!HASH M1) K)
    (UNION MS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))))
Which simplifies
 when rewriting with SETRULES!SUBSET-UNION-RIGHT, MS!SUBSET-SETADD,
SETRULES!SUBSET-UNION-LEFT, SETADD.DEFINITION, SETRULES!SUBSET-SETADD,
SETRULES!SETADD-UNION-RIGHT
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!COMP-OF-IN-MESSAGES
 with the assumptions MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!HASH-IN-HASH-MESSAGES, STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-ADD-TO-STATE-STORAGE
Beginning proof of KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-ADD-TO-STATE-STORAGE ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (SUBSET M1 (MS!MESSAGES))
  (KNOWN-BY-PRINCIPAL M P S))
 (= (KNOWN-BY-PRINCIPAL M P (ADD-TO-STATE-STORAGE P M1 S)) (TRUE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (SUBSET M1 (MS!MESSAGES))
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P S)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (MS!KNOWN-IN M
  (UNION (STORAGE-OF P (ADD-TO-STATE-STORAGE P M1 S))
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
Which simplifies
 when rewriting with UNION.ASSOCIATIVE, STORAGE-OF-ADD-TO-STATE-STORAGE,
UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (SUBSET M1 (MS!MESSAGES))
  (MS!KNOWN-IN M
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
 (MS!KNOWN-IN M
  (UNION M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
Assuming MS!KNOWN-IN-SUBSET with the
instantiations: (= C M)
                (= S1
                 (UNION (MS!PRINCIPALS)
                  (UNION (MS!TEXT-MESSAGES)
                   (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))
                (= S2
                 (UNION M1
                  (UNION (MS!PRINCIPALS)
                   (UNION (MS!TEXT-MESSAGES)
                    (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (MS!KNOWN-IN M
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))
    (SUBSET
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))
     (UNION M1
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
   (MS!KNOWN-IN M
    (UNION M1
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (IS-GOOD-STATE S) (IN P (MS!PRINCIPALS)) (SUBSET M1 (MS!MESSAGES))
  (MS!KNOWN-IN M
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
 (MS!KNOWN-IN M
  (UNION M1
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions STORAGE-OF-IS-SUBSET-MESSAGES,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
ADD-TO-STATE-STORAGE-COLLECTS
Beginning proof of ADD-TO-STATE-STORAGE-COLLECTS ...
(IMPLIES (IS-GOOD-STATE S)
 (= (ADD-TO-STATE-STORAGE P M1 (ADD-TO-STATE-STORAGE P M2 S))
  (ADD-TO-STATE-STORAGE P (UNION M1 M2) S)))
Invoking ADD-TO-STATE-STORAGE gives ...
(IMPLIES (IS-GOOD-STATE S)
 (=
  (MAKE-STATE
   (SEEN-MESSAGES
    (MAKE-STATE (SEEN-MESSAGES S) (ADD-TO-STORAGE (STORES S) P M2)
     (HISTORY S)))
   (ADD-TO-STORAGE
    (STORES
     (MAKE-STATE (SEEN-MESSAGES S) (ADD-TO-STORAGE (STORES S) P M2)
      (HISTORY S)))
    P M1)
   (HISTORY
    (MAKE-STATE (SEEN-MESSAGES S) (ADD-TO-STORAGE (STORES S) P M2)
     (HISTORY S))))
  (MAKE-STATE (SEEN-MESSAGES S) (ADD-TO-STORAGE (STORES S) P (UNION M1 M2))
   (HISTORY S))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MAKE-STATE-IS-STATE,
SEEN-MESSAGES-OF-MAKE-STATE, STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE,
ADD-TO-STORAGE-IS-FUNCTION, FN!IS-FUNCTION-BOOL to ...
(IMPLIES (IS-GOOD-STATE S)
 (=
  (MAKE-STATE (SEEN-MESSAGES S)
   (ADD-TO-STORAGE (ADD-TO-STORAGE (STORES S) P M2) P M1) (HISTORY S))
  (MAKE-STATE (SEEN-MESSAGES S) (ADD-TO-STORAGE (STORES S) P (UNION M1 M2))
   (HISTORY S))))
Invoking ADD-TO-STORAGE gives ...
(IMPLIES (IS-GOOD-STATE S)
 (=
  (MAKE-STATE (SEEN-MESSAGES S)
   (FN!OVERRIDE
    (FN!OVERRIDE (STORES S)
     (SETADD (PAIR!PAIR P (UNION M2 (FN!APPLY (STORES S) P))) (NULLSET)))
    (SETADD
     (PAIR!PAIR P
      (UNION M1
       (FN!APPLY
        (FN!OVERRIDE (STORES S)
         (SETADD (PAIR!PAIR P (UNION M2 (FN!APPLY (STORES S) P))) (NULLSET)))
        P)))
     (NULLSET)))
   (HISTORY S))
  (MAKE-STATE (SEEN-MESSAGES S)
   (FN!OVERRIDE (STORES S)
    (SETADD (PAIR!PAIR P (UNION (UNION M1 M2) (FN!APPLY (STORES S) P)))
     (NULLSET)))
   (HISTORY S))))
Which simplifies
 when rewriting with UNION.ASSOCIATIVE, FN!OVERRIDE-ASSOCIATIVE,
FN!APPLY-SETADD, FN!APPLY-OVERRIDE, SETADD.DEFINITION, REL!DOM-SETADD,
NULLSET.DEFINITION, REL!DOM-NULLSET, FN!IS-FUNCTION-NULLSET,
FN!IS-FUNCTION-SETADD
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, PAIR!IS-PAIR-BOOL,
FN!IS-FUNCTION-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2 to ...
(IMPLIES (IS-GOOD-STATE S)
 (=
  (MAKE-STATE (SEEN-MESSAGES S)
   (FN!OVERRIDE (STORES S)
    (FN!OVERRIDE
     (SETADD (PAIR!PAIR P (UNION M2 (FN!APPLY (STORES S) P))) (NULLSET))
     (SETADD (PAIR!PAIR P (UNION M1 (UNION M2 (FN!APPLY (STORES S) P))))
      (NULLSET))))
   (HISTORY S))
  (MAKE-STATE (SEEN-MESSAGES S)
   (FN!OVERRIDE (STORES S)
    (SETADD (PAIR!PAIR P (UNION M1 (UNION M2 (FN!APPLY (STORES S) P))))
     (NULLSET)))
   (HISTORY S))))
Invoking FN!OVERRIDE gives ...
(IMPLIES (IS-GOOD-STATE S)
 (=
  (MAKE-STATE (SEEN-MESSAGES S)
   (UNION
    (REL!DOM-REMOVE
     (REL!DOM
      (UNION
       (REL!DOM-REMOVE
        (REL!DOM
         (SETADD (PAIR!PAIR P (UNION M1 (UNION M2 (FN!APPLY (STORES S) P))))
          (NULLSET)))
        (SETADD (PAIR!PAIR P (UNION M2 (FN!APPLY (STORES S) P))) (NULLSET)))
       (SETADD (PAIR!PAIR P (UNION M1 (UNION M2 (FN!APPLY (STORES S) P))))
        (NULLSET))))
     (STORES S))
    (UNION
     (REL!DOM-REMOVE
      (REL!DOM
       (SETADD (PAIR!PAIR P (UNION M1 (UNION M2 (FN!APPLY (STORES S) P))))
        (NULLSET)))
      (SETADD (PAIR!PAIR P (UNION M2 (FN!APPLY (STORES S) P))) (NULLSET)))
     (SETADD (PAIR!PAIR P (UNION M1 (UNION M2 (FN!APPLY (STORES S) P))))
      (NULLSET))))
   (HISTORY S))
  (MAKE-STATE (SEEN-MESSAGES S)
   (UNION
    (REL!DOM-REMOVE
     (REL!DOM
      (SETADD (PAIR!PAIR P (UNION M1 (UNION M2 (FN!APPLY (STORES S) P))))
       (NULLSET)))
     (STORES S))
    (SETADD (PAIR!PAIR P (UNION M1 (UNION M2 (FN!APPLY (STORES S) P))))
     (NULLSET)))
   (HISTORY S))))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-LEFT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-RIGHT, SETRULES!UNION-SUBSET-RIGHT,
REL!DOM-REMOVE-BY-SUPERSET-DOM, MS!SUBSET-SETADD, SUBSET.SELF,
SETADD.DEFINITION, SETRULES!SUBSET-SETADD, REL!IS-RELATION-NULLSET,
REL!IS-RELATION-SETADD, REL!DOM-NULLSET, REL!DOM-SETADD
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MAKE-STATE-IS-STATE, SEEN-MESSAGES-OF-MAKE-STATE,
STORES-OF-MAKE-STATE, HISTORY-OF-MAKE-STATE, REL!IS-RELATION-BOOL,
PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
IN-HISTORY-IMPLIES-IS-HEAD-OF-HISTORY-OF-NTH
Beginning proof of IN-HISTORY-IMPLIES-IS-HEAD-OF-HISTORY-OF-NTH ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (N)
  (AND (>= N 1) (< N (SEQ!LENGTH SEQUENCE))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* EVENT (SEQ!TAIL SEQUENCE)))
   (*P* EVENT SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* EVENT SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
    (SOME (N)
     (AND (>= N 1) (< N (SEQ!LENGTH (SEQ!TAIL SEQUENCE)))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (N)
    (AND (>= N 1) (< N (SEQ!LENGTH SEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (N)
    (AND (>= N 1) (< N (SEQ!LENGTH SEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))))
Which simplifies
 when rewriting with SUCC.INT.RULE
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SUCC.INT, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IF (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IMPLIES
    (AND
     (SOME (N)
      (AND (>= N 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
       (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))))
     (IS-GOOD-EVOLUTION SEQUENCE)
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
    (SOME (N$0)
     (AND (>= N$0 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$0))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION SEQUENCE)
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
    (SOME (N$1)
     (AND (>= N$1 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$1))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$1))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (N$2)
    (AND (>= N$2 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$2))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$2))))))))
 (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))))
Starting case 2 ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IMPLIES
    (AND
     (SOME (N)
      (AND (>= N 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
       (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))))
     (IS-GOOD-EVOLUTION SEQUENCE)
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
    (SOME (N$0)
     (AND (>= N$0 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$0))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION SEQUENCE)
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
    (SOME (N$1)
     (AND (>= N$1 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$1))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$1))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (N$2)
    (AND (>= N$2 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$2))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$2)))))))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (IMPLIES
   (AND
    (SOME (N)
     (AND (>= N 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))))
    (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (N$0)
    (AND (>= N$0 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$0))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (N$1)
    (AND (>= N$1 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$1))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$1)))))))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
    (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (N$0)
  (AND (>= N$0 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$0))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) (>= N 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (N$0)
  (AND (>= N$0 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$0))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
Instantiating (= N$0 (+ N 1)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) (>= N 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT
   (AND (>= (+ N 1) 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N 1))
    (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE (+ N 1))))))))
 (SOME (N$0)
  (AND (>= N$0 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$0))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) (>= N 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF (>= (SEQ!LENGTH SEQUENCE) (+ 2 N))
  (OR (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
   (SOME (N$0)
    (AND (>= N$0 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$0))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
  (SOME (N$1)
   (AND (>= N$1 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$1))
    (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$1))))))))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(IMPLIES
 (AND
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) (>= N 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (IF
  (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
   (+ 2 N))
  (OR (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))
   (SOME (N$0)
    (AND (>= N$0 1)
     (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
      (+ 1 N$0))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
  (SOME (N$1)
   (AND (>= N$1 1)
    (>= (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)
     (+ 1 N$1))
    (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$1))))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) (>= N 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE (+ 1 N)))))))
 (SOME (N$0)
  (AND (>= N$0 1) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N$0))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
Invoking (SEQ!NTH SEQUENCE (+ 1 N)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 1)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))) (>= N 1)
  (>= (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (+ 1 N))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT
   (= EVENT
    (SEQ!HEAD
     (HISTORY
      (IF (>= (+ 1 N) 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- (+ 1 N) 1))
       (SEQ!HEAD SEQUENCE)))))))
 (SOME (N$0)
  (AND (>= N$0 1) (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) (+ 1 N$0))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (N$1)
  (AND (>= N$1 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$1))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$1)))))))
Invoking (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (OR (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION,
IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE))
 (IF (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
    (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N))))))
  (IMPLIES (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (N$0)
    (AND (>= N$0 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$0))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))))
Starting case 2.2.1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Instantiating (= N 1) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (NOT
   (AND (>= 1 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 1))
    (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1)))))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (NOT (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE 1))))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Invoking (SEQ!NTH SEQUENCE 1) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (NOT
   (= EVENT
    (SEQ!HEAD
     (HISTORY
      (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL SEQUENCE) (- 1 1))
       (SEQ!HEAD SEQUENCE)))))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))))
  (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (SOME (N$0)
  (AND (>= N$0 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$0))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$0)))))))
Applying HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT
   (SEQ!IS-MEMBER EVENT
    (IF (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
     (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))))
  (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (N$2)
  (AND (>= N$2 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N$2))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N$2)))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) (+ 1 N))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!NTH SEQUENCE N)))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))))
 (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))
 (NOT (SEQ!IS-MEMBER EVENT (SEQ!EMPTY))))
Invoking (SEQ!IS-MEMBER EVENT (SEQ!EMPTY)) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)))
 (NOT
  (AND (SEQ!IS-TACK (SEQ!EMPTY))
   (OR (= EVENT (SEQ!HEAD (SEQ!EMPTY)))
    (SEQ!IS-MEMBER EVENT (SEQ!TAIL (SEQ!EMPTY)))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
IN-HISTORY-IMPLIES-IS-HEAD-OF-HISTORY-OF-SUBSEQUENCE
Beginning proof of IN-HISTORY-IMPLIES-IS-HEAD-OF-HISTORY-OF-SUBSEQUENCE ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (S SUBSEQUENCE)
  (AND (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
   (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (>= (SEQ!LENGTH SEQUENCE) 2) (*P* EVENT (SEQ!TAIL SEQUENCE)))
   (*P* EVENT SEQUENCE))
  (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (*P* EVENT SEQUENCE)))
 produces ...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
    (SOME (S SUBSEQUENCE)
     (AND (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
      (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (S SUBSEQUENCE)
    (AND (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
     (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))))))
 (IMPLIES (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (S SUBSEQUENCE)
    (AND (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
     (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IF (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IMPLIES
    (AND
     (SOME (S)
      (AND (SEQ!IS-SEQUENCE S)
       (SOME (SUBSEQUENCE)
        (AND (IS-GOOD-EVOLUTION SUBSEQUENCE)
         (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
         (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))))))
     (IS-GOOD-EVOLUTION SEQUENCE)
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
    (SOME (S$0)
     (AND (SEQ!IS-SEQUENCE S$0)
      (SOME (SUBSEQUENCE$0)
       (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
        (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
        (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION SEQUENCE)
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
    (SOME (S$1)
     (AND (SEQ!IS-SEQUENCE S$1)
      (SOME (SUBSEQUENCE$1)
       (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$1)
        (= SEQUENCE (SEQ!JOIN S$1 SUBSEQUENCE$1))
        (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$1))))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (S$2)
    (AND (SEQ!IS-SEQUENCE S$2)
     (SOME (SUBSEQUENCE$2)
      (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$2)
       (= SEQUENCE (SEQ!JOIN S$2 SUBSEQUENCE$2))
       (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$2))))))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION SEQUENCE)
   (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
  (SOME (S$3)
   (AND (SEQ!IS-SEQUENCE S$3)
    (SOME (SUBSEQUENCE$3)
     (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$3)
      (= SEQUENCE (SEQ!JOIN S$3 SUBSEQUENCE$3))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$3))))))))))
Starting case 2 ...
(IMPLIES (>= (SEQ!LENGTH SEQUENCE) 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (IF (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (IMPLIES
    (AND
     (SOME (S)
      (AND (SEQ!IS-SEQUENCE S)
       (SOME (SUBSEQUENCE)
        (AND (IS-GOOD-EVOLUTION SUBSEQUENCE)
         (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
         (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))))))
     (IS-GOOD-EVOLUTION SEQUENCE)
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
    (SOME (S$0)
     (AND (SEQ!IS-SEQUENCE S$0)
      (SOME (SUBSEQUENCE$0)
       (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
        (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
        (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION SEQUENCE)
     (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
    (SOME (S$1)
     (AND (SEQ!IS-SEQUENCE S$1)
      (SOME (SUBSEQUENCE$1)
       (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$1)
        (= SEQUENCE (SEQ!JOIN S$1 SUBSEQUENCE$1))
        (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$1))))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (S$2)
    (AND (SEQ!IS-SEQUENCE S$2)
     (SOME (SUBSEQUENCE$2)
      (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$2)
       (= SEQUENCE (SEQ!JOIN S$2 SUBSEQUENCE$2))
       (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$2)))))))))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
 (IF (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (IMPLIES
   (AND
    (SOME (S)
     (AND (SEQ!IS-SEQUENCE S)
      (SOME (SUBSEQUENCE)
       (AND (IS-GOOD-EVOLUTION SUBSEQUENCE)
        (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
        (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))))))
    (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (S$0)
    (AND (SEQ!IS-SEQUENCE S$0)
     (SOME (SUBSEQUENCE$0)
      (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
       (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
       (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION SEQUENCE)
    (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (S$1)
    (AND (SEQ!IS-SEQUENCE S$1)
     (SOME (SUBSEQUENCE$1)
      (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$1)
       (= SEQUENCE (SEQ!JOIN S$1 SUBSEQUENCE$1))
       (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$1)))))))))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SOME (S)
   (AND (SEQ!IS-SEQUENCE S)
    (SOME (SUBSEQUENCE)
     (AND (IS-GOOD-EVOLUTION SUBSEQUENCE)
      (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (SOME (SUBSEQUENCE$0)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
     (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
  (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (SOME (SUBSEQUENCE$0)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
     (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))
Instantiating (= S$0 (SEQ!TACK (SEQ!HEAD SEQUENCE) S))
              (= SUBSEQUENCE$0 SUBSEQUENCE) gives
...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
  (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT
   (AND (SEQ!IS-SEQUENCE (SEQ!TACK (SEQ!HEAD SEQUENCE) S))
    (IS-GOOD-EVOLUTION SUBSEQUENCE)
    (= SEQUENCE (SEQ!JOIN (SEQ!TACK (SEQ!HEAD SEQUENCE) S) SUBSEQUENCE))
    (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))
 (SOME (S$0 SUBSEQUENCE$0)
  (AND (SEQ!IS-SEQUENCE S$0) (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
   (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))
Which simplifies
 when rewriting with SEQ!JOIN-TACK
 forward chaining using SEQ!TACK-HEAD-TAIL, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
  (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT (= SEQUENCE (SEQ!TACK (SEQ!HEAD SEQUENCE) (SEQ!JOIN S SUBSEQUENCE)))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (SOME (SUBSEQUENCE$0)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
     (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))
Substituting (= (SEQ!JOIN S SUBSEQUENCE) (SEQ!TAIL SEQUENCE)) produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
  (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
  (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
  (NOT (= SEQUENCE (SEQ!TACK (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (SOME (SUBSEQUENCE$0)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
     (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))
Splitting on (SEQ!IS-TACK SEQUENCE) generates ...
(IF (SEQ!IS-TACK SEQUENCE)
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
   (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))
   (IS-GOOD-EVOLUTION SEQUENCE)
   (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
   (NOT (= SEQUENCE (SEQ!TACK (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))))
  (SOME (S$0)
   (AND (SEQ!IS-SEQUENCE S$0)
    (SOME (SUBSEQUENCE$0)
     (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
      (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
   (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))
   (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
   (= (SEQ!TAIL SEQUENCE) (SEQ!JOIN S SUBSEQUENCE))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))
   (IS-GOOD-EVOLUTION SEQUENCE)
   (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE)))
   (NOT (= SEQUENCE (SEQ!TACK (SEQ!HEAD SEQUENCE) (SEQ!TAIL SEQUENCE)))))
  (SOME (S$1)
   (AND (SEQ!IS-SEQUENCE S$1)
    (SOME (SUBSEQUENCE$1)
     (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$1)
      (= SEQUENCE (SEQ!JOIN S$1 SUBSEQUENCE$1))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$1))))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAIL-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (S$1)
  (AND (SEQ!IS-SEQUENCE S$1)
   (SOME (SUBSEQUENCE$1)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$1)
     (= SEQUENCE (SEQ!JOIN S$1 SUBSEQUENCE$1))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$1)))))))))
Invoking (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE) (SEQ!IS-TACK (HISTORY (SEQ!HEAD SEQUENCE)))
  (OR (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (SOME (SUBSEQUENCE)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE) (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION,
IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE))
 (IF (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (SOME (S)
   (AND (SEQ!IS-SEQUENCE S)
    (SOME (SUBSEQUENCE)
     (AND (IS-GOOD-EVOLUTION SUBSEQUENCE)
      (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
      (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE))))))))
  (IMPLIES (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE))))
   (SOME (S$0)
    (AND (SEQ!IS-SEQUENCE S$0)
     (SOME (SUBSEQUENCE$0)
      (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
       (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
       (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))))
Starting case 2.2.1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (SOME (SUBSEQUENCE)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE) (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))))
Instantiating (= S (SEQ!EMPTY)) (= SUBSEQUENCE SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE))))
  (NOT
   (AND (SEQ!IS-SEQUENCE (SEQ!EMPTY)) (IS-GOOD-EVOLUTION SEQUENCE)
    (= SEQUENCE (SEQ!JOIN (SEQ!EMPTY) SEQUENCE))
    (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))))))
 (SOME (S SUBSEQUENCE)
  (AND (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION SUBSEQUENCE)
   (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
   (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))
Which simplifies
 when rewriting with SEQ!JOIN-EMPTY-LEFT
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE)))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))))
  (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (SOME (S$0)
  (AND (SEQ!IS-SEQUENCE S$0)
   (SOME (SUBSEQUENCE$0)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$0)
     (= SEQUENCE (SEQ!JOIN S$0 SUBSEQUENCE$0))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$0)))))))))
Applying HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2) (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
  (NOT
   (SEQ!IS-MEMBER EVENT
    (IF (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= (SEQ!LENGTH SEQUENCE) 2))
     (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))
     (HISTORY (SEQ!HEAD (SEQ!TAIL SEQUENCE))))))
  (IS-GOOD-EVOLUTION SEQUENCE)
  (NOT (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SEQUENCE)))))
  (SEQ!IS-MEMBER EVENT (SEQ!TAIL (HISTORY (SEQ!HEAD SEQUENCE)))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (SOME (SUBSEQUENCE)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE) (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (S$2)
  (AND (SEQ!IS-SEQUENCE S$2)
   (SOME (SUBSEQUENCE$2)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$2)
     (= SEQUENCE (SEQ!JOIN S$2 SUBSEQUENCE$2))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$2)))))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH SEQUENCE) 2)
  (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE)))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (SOME (SUBSEQUENCE)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE) (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (IS-GOOD-EVOLUTION SEQUENCE)
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (S$3)
  (AND (SEQ!IS-SEQUENCE S$3)
   (SOME (SUBSEQUENCE$3)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE$3)
     (= SEQUENCE (SEQ!JOIN S$3 SUBSEQUENCE$3))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE$3)))))))))
Invoking (IS-GOOD-EVOLUTION SEQUENCE) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2))
  (IF (>= (SEQ!LENGTH SEQUENCE) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL SEQUENCE))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL SEQUENCE)) (SEQ!HEAD SEQUENCE)))
   (AND (>= (SEQ!LENGTH SEQUENCE) 1) (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
    (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
    (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY))))
  (SEQ!IS-MEMBER EVENT (HISTORY (SEQ!HEAD SEQUENCE))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (SOME (SUBSEQUENCE)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE) (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-MEMBER EVENT (SEQ!EMPTY)))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (SOME (SUBSEQUENCE)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE) (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))))
Invoking (SEQ!IS-MEMBER EVENT (SEQ!EMPTY)) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH SEQUENCE) 2)) (>= (SEQ!LENGTH SEQUENCE) 1)
  (IS-GOOD-STATE (SEQ!HEAD SEQUENCE))
  (= (HISTORY (SEQ!HEAD SEQUENCE)) (SEQ!EMPTY))
  (= (SEQ!TAIL SEQUENCE) (SEQ!EMPTY)) (SEQ!IS-TACK (SEQ!EMPTY))
  (OR (= EVENT (SEQ!HEAD (SEQ!EMPTY)))
   (SEQ!IS-MEMBER EVENT (SEQ!TAIL (SEQ!EMPTY)))))
 (SOME (S)
  (AND (SEQ!IS-SEQUENCE S)
   (SOME (SUBSEQUENCE)
    (AND (IS-GOOD-EVOLUTION SUBSEQUENCE) (= SEQUENCE (SEQ!JOIN S SUBSEQUENCE))
     (= EVENT (SEQ!HEAD (HISTORY (SEQ!HEAD SUBSEQUENCE)))))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
FRESH-IMPLIES-NOT-KNOWN-BY-PRINCIPAL
Beginning proof of FRESH-IMPLIES-NOT-KNOWN-BY-PRINCIPAL ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
 (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
 (NOT
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with MS!D2-RULE, UNION.COMMUTATIVE, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
STORAGE-OF-IS-SUBSET-MESSAGES, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES STATE))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Invoking MS!IS-FRESH gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (ALL (M$1 K2)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 (MS!INVERSE MESSAGE) K2)
      (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 (MS!INVERSE MESSAGE))
      (MS!PARTS (SEEN-MESSAGES STATE))))))
  (NOT (IN MESSAGE (MS!PARTS (ALL-STORAGE (STORES STATE)))))
  (NOT
   (SOME (M$2)
    (IN (MS!ENCRYPT M$2 MESSAGE) (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$3)
    (IN (MS!ENCRYPT M$3 (MS!INVERSE MESSAGE))
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (ALL (M$4 K2$0)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 MESSAGE K2$0)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 (MS!INVERSE MESSAGE) K2$0)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 K2$0 MESSAGE)
      (MS!PARTS (ALL-STORAGE (STORES STATE)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$4 K2$0 (MS!INVERSE MESSAGE))
      (MS!PARTS (ALL-STORAGE (STORES STATE))))))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Which simplifies
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT, MS!SHENKY1-SHARE-ENCRYPT,
MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (ALL-STORAGE (STORES STATE)))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (ALL-STORAGE (STORES STATE)))))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Applying MS!NOT-PART-IMPLIES-NOT-COMP-OF gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (ALL-STORAGE (STORES STATE)))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (ALL-STORAGE (STORES STATE)))))))
 (NOT
  (AND
   (IN MESSAGE
    (MS!PARTS
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE))))))
   (MS!COMP-OF MESSAGE
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE))))))))
Which simplifies
 when rewriting with UNION.DEFINITION, MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!PARTS-ATOMIC, MS!PRINCIPAL-ATOMIC, MS!PARTS-UNION
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT, MS!SHENKY1-SHARE-ENCRYPT,
MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (ALL-STORAGE (STORES STATE)))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (ALL-STORAGE (STORES STATE))))))
  (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Invoking ALL-STORAGE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Assuming MS!IN-PARTS-SUBSET with the
instantiations: (= K MESSAGE) (= S1 (CUP (REL!RAN (STORES STATE))))
                (= S2 (STORAGE-OF PRINCIPAL STATE)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
    (SUBSET (STORAGE-OF PRINCIPAL STATE) (CUP (REL!RAN (STORES STATE)))))
   (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Which simplifies
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT, MS!SHENKY1-SHARE-ENCRYPT,
MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
  (NOT (SUBSET (STORAGE-OF PRINCIPAL STATE) (CUP (REL!RAN (STORES STATE)))))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Invoking SUBSET gives ...
(IMPLIES
 (AND (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
  (NOT
   (ALL (E)
    (IMPLIES (IN E (STORAGE-OF PRINCIPAL STATE))
     (IN E (CUP (REL!RAN (STORES STATE)))))))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Prenexing produces ...
(IMPLIES
 (AND (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
  (NOT
   (IMPLIES (IN E (STORAGE-OF PRINCIPAL STATE))
    (IN E (CUP (REL!RAN (STORES STATE))))))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Which simplifies
 when rewriting with CUP.DEFINITION
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT, MS!SHENKY1-SHARE-ENCRYPT,
MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
  (IN E (STORAGE-OF PRINCIPAL STATE))
  (NOT (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE))))))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Instantiating (= Y (STORAGE-OF PRINCIPAL STATE)) gives ...
(IMPLIES
 (AND (IN MESSAGE (MS!PARTS (STORAGE-OF PRINCIPAL STATE)))
  (IN E (STORAGE-OF PRINCIPAL STATE))
  (NOT
   (OR
    (AND (IN E (STORAGE-OF PRINCIPAL STATE))
     (IN (STORAGE-OF PRINCIPAL STATE) (REL!RAN (STORES STATE))))
    (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF PRINCIPAL STATE)))))))
Invoking STORAGE-OF gives ...
(IMPLIES
 (AND (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT
   (OR
    (AND (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
     (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
    (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))))
Assuming FN!APPLY-IN-RAN with the
instantiations: (= F (STORES STATE)) (= X PRINCIPAL) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (STORES STATE))
    (IN PRINCIPAL (REL!DOM (STORES STATE))))
   (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
  (IN MESSAGE (MS!PARTS (FN!APPLY (STORES STATE) PRINCIPAL)))
  (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
  (NOT
   (OR
    (AND (IN E (FN!APPLY (STORES STATE) PRINCIPAL))
     (IN (FN!APPLY (STORES STATE) PRINCIPAL) (REL!RAN (STORES STATE))))
    (SOME (Y) (AND (IN E Y) (IN Y (REL!RAN (STORES STATE)))))))
  (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES)) (NOT (IN MESSAGE (MS!PRINCIPALS)))
  (NOT (IN MESSAGE (MS!TEXT-MESSAGES))) (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES STATE))))
  (NOT
   (SOME (M) (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$1 K2)
    (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2) (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$2 K2$0)
    (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2$0)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$3 K2$1)
    (IN (MS!SHARE-ENCRYPT M$3 K2$1 MESSAGE)
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT
   (SOME (M$4 K2$2)
    (IN (MS!SHARE-ENCRYPT M$4 K2$2 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES STATE)))))
  (NOT (IN MESSAGE (MS!PARTS (CUP (REL!RAN (STORES STATE))))))
  (NOT
   (SOME (M$5)
    (IN (MS!ENCRYPT M$5 MESSAGE) (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$6)
    (IN (MS!ENCRYPT M$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$7 K2$3)
    (IN (MS!SHARE-ENCRYPT M$7 MESSAGE K2$3)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$8 K2$4)
    (IN (MS!SHARE-ENCRYPT M$8 (MS!INVERSE MESSAGE) K2$4)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$9 K2$5)
    (IN (MS!SHARE-ENCRYPT M$9 K2$5 MESSAGE)
     (MS!PARTS (CUP (REL!RAN (STORES STATE)))))))
  (NOT
   (SOME (M$10 K2$6)
    (IN (MS!SHARE-ENCRYPT M$10 K2$6 (MS!INVERSE MESSAGE))
     (MS!PARTS (CUP (REL!RAN (STORES STATE))))))))
 (NOT
  (MS!COMP-OF MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (FN!APPLY (STORES STATE) PRINCIPAL)))))))
Which simplifies
 forward chaining using IS-GOOD-STATE-IMPLICATION, FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL to
...
(TRUE)
FRESH-IN-ALL-MESSAGES-IMPLIES-FRESH-IN-STORAGE-OF-PRINCIPAL
Beginning proof
of FRESH-IN-ALL-MESSAGES-IMPLIES-FRESH-IN-STORAGE-OF-PRINCIPAL ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
 (MS!IS-FRESH MESSAGE (STORAGE-OF PRINCIPAL STATE)))
Which simplifies
 when rewriting with FRESH-IN-STORAGE-OF-PRINCIPAL, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
>=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions STORAGE-OF-IS-SUBSET-MESSAGES,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
FRESH-OUTSIDE-PRINCIPAL
FRESH-OUTSIDE-PRINCIPAL-IMPLIES-NOT-FORGEABLE
Beginning proof of FRESH-OUTSIDE-PRINCIPAL-IMPLIES-NOT-FORGEABLE ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (FRESH-OUTSIDE-PRINCIPAL MESSAGE PRINCIPAL STATE))
 (NOT (FORGEABLE MESSAGE STATE)))
Invoking FRESH-OUTSIDE-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (MS!IS-FRESH MESSAGE
   (UNION (MS!PUBLIC-KEYS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))
  (ALL (P)
   (IMPLIES (AND (IN P (MS!PRINCIPALS)) (NOT (= P PRINCIPAL)))
    (MS!IS-FRESH MESSAGE (STORAGE-OF P STATE)))))
 (NOT (FORGEABLE MESSAGE STATE)))
Invoking (MS!IS-FRESH MESSAGE
          (UNION (MS!PUBLIC-KEYS)
           (UNION (MS!TEXT-MESSAGES)
            (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE))))) gives
...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT
   (IN MESSAGE
    (MS!PARTS
     (UNION (MS!PUBLIC-KEYS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE)
     (MS!PARTS
      (UNION (MS!PUBLIC-KEYS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE))))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS
      (UNION (MS!PUBLIC-KEYS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE))))))))
  (ALL (M$1 K2)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
      (MS!PARTS
       (UNION (MS!PUBLIC-KEYS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 (MS!INVERSE MESSAGE) K2)
      (MS!PARTS
       (UNION (MS!PUBLIC-KEYS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 MESSAGE)
      (MS!PARTS
       (UNION (MS!PUBLIC-KEYS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 (MS!INVERSE MESSAGE))
      (MS!PARTS
       (UNION (MS!PUBLIC-KEYS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))))
  (ALL (P)
   (IMPLIES (AND (IN P (MS!PRINCIPALS)) (NOT (= P PRINCIPAL)))
    (MS!IS-FRESH MESSAGE (STORAGE-OF P STATE)))))
 (NOT (FORGEABLE MESSAGE STATE)))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN PRINCIPAL (MS!PRINCIPALS))
  (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT
   (IN MESSAGE
    (MS!PARTS
     (UNION (MS!PUBLIC-KEYS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))
  (NOT
   (SOME (M)
    (IN (MS!ENCRYPT M MESSAGE)
     (MS!PARTS
      (UNION (MS!PUBLIC-KEYS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE))))))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 (MS!INVERSE MESSAGE))
     (MS!PARTS
      (UNION (MS!PUBLIC-KEYS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE))))))))
  (ALL (M$1 K2)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 MESSAGE K2)
      (MS!PARTS
       (UNION (MS!PUBLIC-KEYS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 (MS!INVERSE MESSAGE) K2)
      (MS!PARTS
       (UNION (MS!PUBLIC-KEYS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 MESSAGE)
      (MS!PARTS
       (UNION (MS!PUBLIC-KEYS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$1 K2 (MS!INVERSE MESSAGE))
      (MS!PARTS
       (UNION (MS!PUBLIC-KEYS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PRINCIPALS) (SEEN-MESSAGES STATE)))))))))
  (ALL (P)
   (IMPLIES (AND (IN P (MS!PRINCIPALS)) (NOT (= P PRINCIPAL)))
    (MS!IS-FRESH MESSAGE (STORAGE-OF P STATE)))))
 (NOT
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))))
Which simplifies
 when rewriting with MS!NOT-PART-IMPLIES-NOT-COMP-OF, MS!D2-RULE,
UNION.COMMUTATIVE, UNION.DEFINITION, MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!PARTS-ATOMIC, MS!PRINCIPAL-ATOMIC, MS!PARTS-UNION,
UNION.PERMUTATIVE
 forward chaining using MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!COMP-OF-BOOL, MS!KNOWN-IN-BOOL,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-SHARE-ENCRYPT,
MS!SHENDT-SHARE-ENCRYPT, MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-MONOTONIC-JOIN
Beginning proof of KNOWN-BY-PRINCIPAL-MONOTONIC-JOIN ...
(IMPLIES
 (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Inducting using the following scheme ...
 (AND
  (IMPLIES (AND (SEQ!IS-TACK S2) (*P* M P S1 (SEQ!TAIL S2))) (*P* M P S1 S2))
  (IMPLIES (NOT (SEQ!IS-TACK S2)) (*P* M P S1 S2)))
 produces ...
(AND
 (IMPLIES
  (AND (SEQ!IS-TACK S2)
   (IMPLIES
    (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
     (SEQ!IS-SEQUENCE (SEQ!TAIL S2))
     (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
     (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))))
  (IMPLIES
   (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
    (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1)))))
 (IMPLIES (NOT (SEQ!IS-TACK S2))
  (IMPLIES
   (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
    (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2)
  (IMPLIES
   (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
    (SEQ!IS-SEQUENCE (SEQ!TAIL S2))
    (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
  (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Rearranging gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IMPLIES
   (AND (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
    (SEQ!IS-SEQUENCE (SEQ!TAIL S2))
    (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAIL-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
 (IF (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (IMPLIES (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Starting case 2.2 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Assuming KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-STEP with the
instantiations: (= N 1) (= SEQUENCE (SEQ!JOIN S2 S1)) (= MESSAGE M)
                (= PRINCIPAL P) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (>= 1 1)
    (<= 1 (- (SEQ!LENGTH (SEQ!JOIN S2 S1)) 1)) (IN P (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL M P (SEQ!NTH (SEQ!JOIN S2 S1) (+ 1 1))))
   (KNOWN-BY-PRINCIPAL M P (SEQ!NTH (SEQ!JOIN S2 S1) 1)))
  (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Rearranging gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (IMPLIES
   (AND (>= 1 1) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
    (<= 1 (- (SEQ!LENGTH (SEQ!JOIN S2 S1)) 1)) (IN P (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL M P (SEQ!NTH (SEQ!JOIN S2 S1) (+ 1 1))))
   (KNOWN-BY-PRINCIPAL M P (SEQ!NTH (SEQ!JOIN S2 S1) 1))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Which simplifies
 when rewriting with SEQ!LENGTH-JOIN
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, TAIL-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (IF (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)
  (IF (KNOWN-BY-PRINCIPAL M P (SEQ!NTH (SEQ!JOIN S2 S1) 2))
   (IMPLIES (KNOWN-BY-PRINCIPAL M P (SEQ!NTH (SEQ!JOIN S2 S1) 1))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1))
 (IF (KNOWN-BY-PRINCIPAL M P (SEQ!NTH (SEQ!JOIN S2 S1) 2))
  (IMPLIES (KNOWN-BY-PRINCIPAL M P (SEQ!NTH (SEQ!JOIN S2 S1) 1))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Invoking SEQ!NTH gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1))
 (IF
  (KNOWN-BY-PRINCIPAL M P
   (IF (>= 2 2) (SEQ!NTH (SEQ!TAIL (SEQ!JOIN S2 S1)) (- 2 1))
    (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL M P
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!JOIN S2 S1)) (- 1 1))
     (SEQ!HEAD (SEQ!JOIN S2 S1))))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Invoking SEQ!NTH gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1))
 (IF
  (KNOWN-BY-PRINCIPAL M P
   (IF (>= 2 2)
    (IF (>= (- 2 1) 2)
     (SEQ!NTH (SEQ!TAIL (SEQ!TAIL (SEQ!JOIN S2 S1))) (- (- 2 1) 1))
     (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN S2 S1))))
    (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (IMPLIES
   (KNOWN-BY-PRINCIPAL M P
    (IF (>= 1 2)
     (IF (>= (- 1 1) 2)
      (SEQ!NTH (SEQ!TAIL (SEQ!TAIL (SEQ!JOIN S2 S1))) (- (- 1 1) 1))
      (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN S2 S1))))
     (SEQ!HEAD (SEQ!JOIN S2 S1))))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, TAIL-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)
  (NOT (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN S2 S1))))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Invoking (SEQ!JOIN S2 S1) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION
   (IF (SEQ!IS-TACK S2) (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))
    S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)
  (NOT
   (KNOWN-BY-PRINCIPAL M P
    (SEQ!HEAD
     (SEQ!TAIL
      (IF (SEQ!IS-TACK S2)
       (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1)) S1))))))
 (KNOWN-BY-PRINCIPAL M P
  (SEQ!HEAD
   (IF (SEQ!IS-TACK S2) (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))
    S1))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAIL-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (NOT (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Invoking (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1)) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IF (>= (SEQ!LENGTH (SEQ!JOIN (SEQ!TAIL S2) S1)) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
     (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
   (AND (>= (SEQ!LENGTH (SEQ!JOIN (SEQ!TAIL S2) S1)) 1)
    (IS-GOOD-STATE (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (= (HISTORY (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))) (SEQ!EMPTY))
    (= (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)) (SEQ!EMPTY))))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (NOT (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Which simplifies
 when rewriting with SEQ!LENGTH-JOIN, IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
 (IF (>= (+ (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
     (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (NOT (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (IMPLIES
   (AND (>= (+ (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 1)
    (IS-GOOD-STATE (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (= (HISTORY (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))) (SEQ!EMPTY))
    (= (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)) (SEQ!EMPTY))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (NOT (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))))
Invoking (SEQ!LENGTH S2) gives ...
(IMPLIES
 (AND (>= (IF (SEQ!IS-TACK S2) (+ 1 (SEQ!LENGTH (SEQ!TAIL S2))) 0) 1)
  (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (IF (>= (+ (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
     (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (NOT
     (>=
      (+ -1 (SEQ!LENGTH S1)
       (IF (SEQ!IS-TACK S2) (+ 1 (SEQ!LENGTH (SEQ!TAIL S2))) 0))
      1)))
   (AND (>= (+ (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 1)
    (IS-GOOD-STATE (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (= (HISTORY (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))) (SEQ!EMPTY))
    (= (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)) (SEQ!EMPTY))
    (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (NOT
     (>=
      (+ -1 (SEQ!LENGTH S1)
       (IF (SEQ!IS-TACK S2) (+ 1 (SEQ!LENGTH (SEQ!TAIL S2))) 0))
      1)))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Invoking (SEQ!JOIN S2 S1) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION
   (IF (SEQ!IS-TACK S2) (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))
    S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (KNOWN-BY-PRINCIPAL M P
  (SEQ!HEAD
   (IF (SEQ!IS-TACK S2) (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))
    S1))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S2)))
Invoking (IS-GOOD-EVOLUTION
          (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))) gives
...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2)
  (IF (>= (SEQ!LENGTH (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))) 2)
   (AND
    (IS-GOOD-EVOLUTION
     (SEQ!TAIL (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
    (GOOD-STEP
     (SEQ!HEAD
      (SEQ!TAIL (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
     (SEQ!HEAD (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1)))))
   (AND
    (>= (SEQ!LENGTH (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))) 1)
    (IS-GOOD-STATE
     (SEQ!HEAD (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
    (=
     (HISTORY (SEQ!HEAD (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
     (SEQ!EMPTY))
    (= (SEQ!TAIL (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1)))
     (SEQ!EMPTY))))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S2)))
Which simplifies
 when rewriting with SEQ!LENGTH-JOIN, SEQ!LENGTH-TACK
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
SEQ!TACK-HEAD-TAIL, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAIL-IS-SEQUENCE, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, SEQ!TYPE-OF-IS-TACK,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2)
  (NOT (>= (+ 1 (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 2))
  (IS-GOOD-STATE (SEQ!HEAD S2)) (= (HISTORY (SEQ!HEAD S2)) (SEQ!EMPTY))
  (= (SEQ!JOIN (SEQ!TAIL S2) S1) (SEQ!EMPTY))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!EMPTY))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S2)))
Invoking (IS-GOOD-EVOLUTION S1) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IN P (MS!PRINCIPALS))
  (IF (>= (SEQ!LENGTH S1) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S1))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL S1)) (SEQ!HEAD S1)))
   (AND (>= (SEQ!LENGTH S1) 1) (IS-GOOD-STATE (SEQ!HEAD S1))
    (= (HISTORY (SEQ!HEAD S1)) (SEQ!EMPTY)) (= (SEQ!TAIL S1) (SEQ!EMPTY))))
  (SEQ!IS-SEQUENCE S2)
  (NOT (>= (+ 1 (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 2))
  (IS-GOOD-STATE (SEQ!HEAD S2)) (= (HISTORY (SEQ!HEAD S2)) (SEQ!EMPTY))
  (= (SEQ!JOIN (SEQ!TAIL S2) S1) (SEQ!EMPTY))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!EMPTY))))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S2)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!IS-TACK S2)) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
  (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
 (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
Splitting on (= S2 (SEQ!EMPTY)) generates ...
(IF (= S2 (SEQ!EMPTY))
 (IMPLIES
  (AND (NOT (SEQ!IS-TACK S2)) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
   (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1))))
 (IMPLIES
  (AND (NOT (SEQ!IS-TACK S2)) (IN P (MS!PRINCIPALS)) (IS-GOOD-EVOLUTION S1)
   (SEQ!IS-SEQUENCE S2) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
   (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD S1)))
  (KNOWN-BY-PRINCIPAL M P (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Which simplifies
 when rewriting with SEQ!JOIN-EMPTY-LEFT
 forward chaining using SEQ!TACK-HEAD-TAIL, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY to ...
(TRUE)
Completing all cases produces ...
(TRUE)
FORGEABLE-MONOTONIC-JOIN
Beginning proof of FORGEABLE-MONOTONIC-JOIN ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1)))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (SEQ!IS-TACK S2) (*P* M S1 (SEQ!TAIL S2))) (*P* M S1 S2))
  (IMPLIES (NOT (SEQ!IS-TACK S2)) (*P* M S1 S2)))
 produces ...
(AND
 (IMPLIES
  (AND (SEQ!IS-TACK S2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE (SEQ!TAIL S2))
     (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
     (FORGEABLE M (SEQ!HEAD S1)))
    (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
    (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1)))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1)))))
 (IMPLIES (NOT (SEQ!IS-TACK S2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
    (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1)))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE (SEQ!TAIL S2))
    (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
    (FORGEABLE M (SEQ!HEAD S1)))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
  (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1)))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Rearranging gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE (SEQ!TAIL S2))
    (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
    (FORGEABLE M (SEQ!HEAD S1)))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAIL-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1)))
 (IF (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (IMPLIES (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Starting case 2.2 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Assuming FORGEABLE-MONOTONIC-OVER-STEP with the
instantiations: (= N 1) (= SEQUENCE (SEQ!JOIN S2 S1)) (= MESSAGE M) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (>= 1 1)
    (<= 1 (- (SEQ!LENGTH (SEQ!JOIN S2 S1)) 1))
    (FORGEABLE M (SEQ!NTH (SEQ!JOIN S2 S1) (+ 1 1))))
   (FORGEABLE M (SEQ!NTH (SEQ!JOIN S2 S1) 1)))
  (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Rearranging gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (IMPLIES
   (AND (>= 1 1) (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1))
    (<= 1 (- (SEQ!LENGTH (SEQ!JOIN S2 S1)) 1))
    (FORGEABLE M (SEQ!NTH (SEQ!JOIN S2 S1) (+ 1 1))))
   (FORGEABLE M (SEQ!NTH (SEQ!JOIN S2 S1) 1))))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Which simplifies
 when rewriting with SEQ!LENGTH-JOIN
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, TAIL-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (IF (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)
  (IF (FORGEABLE M (SEQ!NTH (SEQ!JOIN S2 S1) 2))
   (IMPLIES (FORGEABLE M (SEQ!NTH (SEQ!JOIN S2 S1) 1))
    (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1))
 (IF (FORGEABLE M (SEQ!NTH (SEQ!JOIN S2 S1) 2))
  (IMPLIES (FORGEABLE M (SEQ!NTH (SEQ!JOIN S2 S1) 1))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Invoking SEQ!NTH gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1))
 (IF
  (FORGEABLE M
   (IF (>= 2 2) (SEQ!NTH (SEQ!TAIL (SEQ!JOIN S2 S1)) (- 2 1))
    (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (IMPLIES
   (FORGEABLE M
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!JOIN S2 S1)) (- 1 1))
     (SEQ!HEAD (SEQ!JOIN S2 S1))))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Invoking SEQ!NTH gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1))
 (IF
  (FORGEABLE M
   (IF (>= 2 2)
    (IF (>= (- 2 1) 2)
     (SEQ!NTH (SEQ!TAIL (SEQ!TAIL (SEQ!JOIN S2 S1))) (- (- 2 1) 1))
     (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN S2 S1))))
    (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (IMPLIES
   (FORGEABLE M
    (IF (>= 1 2)
     (IF (>= (- 1 1) 2)
      (SEQ!NTH (SEQ!TAIL (SEQ!TAIL (SEQ!JOIN S2 S1))) (- (- 1 1) 1))
      (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN S2 S1))))
     (SEQ!HEAD (SEQ!JOIN S2 S1))))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)
  (NOT (FORGEABLE M (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN S2 S1))))))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Invoking (SEQ!JOIN S2 S1) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION
   (IF (SEQ!IS-TACK S2) (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))
    S1))
  (FORGEABLE M (SEQ!HEAD S1)) (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)
  (NOT
   (FORGEABLE M
    (SEQ!HEAD
     (SEQ!TAIL
      (IF (SEQ!IS-TACK S2)
       (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1)) S1))))))
 (FORGEABLE M
  (SEQ!HEAD
   (IF (SEQ!IS-TACK S2) (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))
    S1))))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions TAIL-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (NOT (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Invoking (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1)) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IF (>= (SEQ!LENGTH (SEQ!JOIN (SEQ!TAIL S2) S1)) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
     (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))))
   (AND (>= (SEQ!LENGTH (SEQ!JOIN (SEQ!TAIL S2) S1)) 1)
    (IS-GOOD-STATE (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (= (HISTORY (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))) (SEQ!EMPTY))
    (= (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)) (SEQ!EMPTY))))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (NOT (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Which simplifies
 when rewriting with SEQ!LENGTH-JOIN, IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1)))
 (IF (>= (+ (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
     (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (NOT (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
  (IMPLIES
   (AND (>= (+ (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 1)
    (IS-GOOD-STATE (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (= (HISTORY (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))) (SEQ!EMPTY))
    (= (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)) (SEQ!EMPTY))
    (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (NOT (>= (+ -1 (SEQ!LENGTH S1) (SEQ!LENGTH S2)) 1)))
   (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))))
Invoking (SEQ!LENGTH S2) gives ...
(IMPLIES
 (AND (>= (IF (SEQ!IS-TACK S2) (+ 1 (SEQ!LENGTH (SEQ!TAIL S2))) 0) 1)
  (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (IF (>= (+ (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)))
     (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (NOT
     (>=
      (+ -1 (SEQ!LENGTH S1)
       (IF (SEQ!IS-TACK S2) (+ 1 (SEQ!LENGTH (SEQ!TAIL S2))) 0))
      1)))
   (AND (>= (+ (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 1)
    (IS-GOOD-STATE (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (= (HISTORY (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1))) (SEQ!EMPTY))
    (= (SEQ!TAIL (SEQ!JOIN (SEQ!TAIL S2) S1)) (SEQ!EMPTY))
    (FORGEABLE M (SEQ!HEAD (SEQ!JOIN (SEQ!TAIL S2) S1)))
    (NOT
     (>=
      (+ -1 (SEQ!LENGTH S1)
       (IF (SEQ!IS-TACK S2) (+ 1 (SEQ!LENGTH (SEQ!TAIL S2))) 0))
      1)))))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Invoking (SEQ!JOIN S2 S1) gives ...
(IMPLIES
 (AND (SEQ!IS-TACK S2) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION
   (IF (SEQ!IS-TACK S2) (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))
    S1))
  (FORGEABLE M (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (FORGEABLE M
  (SEQ!HEAD
   (IF (SEQ!IS-TACK S2) (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))
    S1))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1)))
  (FORGEABLE M (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (FORGEABLE M (SEQ!HEAD S2)))
Invoking (IS-GOOD-EVOLUTION
          (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))) gives
...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IF (>= (SEQ!LENGTH (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))) 2)
   (AND
    (IS-GOOD-EVOLUTION
     (SEQ!TAIL (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
    (GOOD-STEP
     (SEQ!HEAD
      (SEQ!TAIL (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
     (SEQ!HEAD (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1)))))
   (AND
    (>= (SEQ!LENGTH (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))) 1)
    (IS-GOOD-STATE
     (SEQ!HEAD (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
    (=
     (HISTORY (SEQ!HEAD (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1))))
     (SEQ!EMPTY))
    (= (SEQ!TAIL (SEQ!TACK (SEQ!HEAD S2) (SEQ!JOIN (SEQ!TAIL S2) S1)))
     (SEQ!EMPTY))))
  (FORGEABLE M (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!JOIN (SEQ!TAIL S2) S1))))
 (FORGEABLE M (SEQ!HEAD S2)))
Which simplifies
 when rewriting with SEQ!LENGTH-JOIN, SEQ!LENGTH-TACK
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
SEQ!TACK-HEAD-TAIL, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAIL-IS-SEQUENCE, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (NOT (>= (+ 1 (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 2))
  (IS-GOOD-STATE (SEQ!HEAD S2)) (= (HISTORY (SEQ!HEAD S2)) (SEQ!EMPTY))
  (= (SEQ!JOIN (SEQ!TAIL S2) S1) (SEQ!EMPTY)) (FORGEABLE M (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!EMPTY))))
 (FORGEABLE M (SEQ!HEAD S2)))
Invoking (IS-GOOD-EVOLUTION S1) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH S2) 1)
  (IF (>= (SEQ!LENGTH S1) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S1))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL S1)) (SEQ!HEAD S1)))
   (AND (>= (SEQ!LENGTH S1) 1) (IS-GOOD-STATE (SEQ!HEAD S1))
    (= (HISTORY (SEQ!HEAD S1)) (SEQ!EMPTY)) (= (SEQ!TAIL S1) (SEQ!EMPTY))))
  (SEQ!IS-SEQUENCE S2)
  (NOT (>= (+ 1 (SEQ!LENGTH S1) (SEQ!LENGTH (SEQ!TAIL S2))) 2))
  (IS-GOOD-STATE (SEQ!HEAD S2)) (= (HISTORY (SEQ!HEAD S2)) (SEQ!EMPTY))
  (= (SEQ!JOIN (SEQ!TAIL S2) S1) (SEQ!EMPTY)) (FORGEABLE M (SEQ!HEAD S1))
  (NOT (IS-GOOD-EVOLUTION (SEQ!EMPTY))))
 (FORGEABLE M (SEQ!HEAD S2)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!IS-TACK S2)) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
  (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1)))
 (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
Splitting on (= S2 (SEQ!EMPTY)) generates ...
(IF (= S2 (SEQ!EMPTY))
 (IMPLIES
  (AND (NOT (SEQ!IS-TACK S2)) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
   (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1)))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1))))
 (IMPLIES
  (AND (NOT (SEQ!IS-TACK S2)) (IS-GOOD-EVOLUTION S1) (SEQ!IS-SEQUENCE S2)
   (IS-GOOD-EVOLUTION (SEQ!JOIN S2 S1)) (FORGEABLE M (SEQ!HEAD S1)))
  (FORGEABLE M (SEQ!HEAD (SEQ!JOIN S2 S1)))))
Which simplifies
 when rewriting with SEQ!JOIN-EMPTY-LEFT
 forward chaining using SEQ!TACK-HEAD-TAIL, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY to ...
(TRUE)
Completing all cases produces ...
(TRUE)
FORGEABLE-MONOTONIC-OVER-GOOD-STEP
Beginning proof of FORGEABLE-MONOTONIC-OVER-GOOD-STEP ...
(IMPLIES (AND (GOOD-STEP S0 S1) (FORGEABLE M S0)) (FORGEABLE M S1))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S0)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0)
       (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0)
       (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)
       (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0)
       (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
      (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0))))))
  (FORGEABLE M S0))
 (FORGEABLE M S1))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0)
    (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0)
    (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)
    (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0)
    (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
    (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0))))
  (FORGEABLE M S0))
 (FORGEABLE M S1))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0)))
  (NOT (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0))) (NOT (FORGEABLE M S0))
  (FORGEABLE M S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
  (NOT (FORGEABLE M S0)) (FORGEABLE M S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0))
  (NOT (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)))
  (NOT (FORGEABLE M S0)) (FORGEABLE M S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE S0))
  (NOT (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
  (NOT (FORGEABLE M S0)) (FORGEABLE M S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0))
  (NOT (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
  (NOT (FORGEABLE M S0)) (FORGEABLE M S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0))
  (NOT (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0)))
  (NOT (FORGEABLE M S0)) (FORGEABLE M S1)))
Substituting (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0))
             (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0))
             (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0))
             (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0))
             (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0))
             (= S1
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               S0)) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
   (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0)) (FORGEABLE M S0))
  (FORGEABLE M (INTRUDER-STEP LABEL TIME MESSAGE S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)) (FORGEABLE M S0))
  (FORGEABLE M (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0)
   (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)) (FORGEABLE M S0))
  (FORGEABLE M (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0)
   (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)) (FORGEABLE M S0))
  (FORGEABLE M (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0)
   (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)) (FORGEABLE M S0))
  (FORGEABLE M (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)
   (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0))
   (FORGEABLE M S0))
  (FORGEABLE M (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0))))
Which simplifies
 when rewriting with FORGEABLE-PRESERVED-BY-OUT-OF-BAND-STEP,
FORGEABLE-PRESERVED-BY-CONSTRUCT-STEP, FORGEABLE-PRESERVED-BY-RECEIVE-STEP,
FORGEABLE-MONOTONIC-OVER-SEND-STEP, FORGEABLE-PRESERVED-BY-GENERATE-STEP,
FORGEABLE-MONOTONIC-OVER-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GOOD-STEP
Beginning proof of KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GOOD-STEP ...
(IMPLIES
 (AND (GOOD-STEP S0 S1) (IN P (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M P S0))
 (KNOWN-BY-PRINCIPAL M P S1))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE S0)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0)
       (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0)
       (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)
       (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0)
       (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
      (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0))))))
  (IN P (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M P S0))
 (KNOWN-BY-PRINCIPAL M P S1))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0)
    (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0)
    (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)
    (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0)
    (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
    (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0))))
  (IN P (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M P S0))
 (KNOWN-BY-PRINCIPAL M P S1))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0)))
  (NOT (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0))
  (NOT (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE S0))
  (NOT (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0))
  (NOT (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P S1))
 (OR (NOT (IS-GOOD-STATE S0)) (NOT (TIME-CONSTRAINT TIME S0))
  (NOT (>= LABEL 0)) (NOT (IN SENDER (MS!PRINCIPALS)))
  (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0))
  (NOT (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P S1)))
Substituting (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0))
             (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0))
             (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0))
             (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0))
             (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0))
             (= S1
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               S0)) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
   (= S1 (INTRUDER-STEP LABEL TIME MESSAGE S0)) (IN P (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P (INTRUDER-STEP LABEL TIME MESSAGE S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE S0))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S1 (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0))
   (IN P (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL S0)
   (= S1 (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)) (IN P (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P (SEND-STEP LABEL TIME MESSAGE PRINCIPAL S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE S0)
   (= S1 (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0))
   (IN P (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 S0)
   (= S1 (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0))
   (IN P (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 S0)))
 (IMPLIES
  (AND (IS-GOOD-STATE S0) (TIME-CONSTRAINT TIME S0) (>= LABEL 0)
   (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER S0)
   (= S1 (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0))
   (IN P (MS!PRINCIPALS)) (KNOWN-BY-PRINCIPAL M P S0))
  (KNOWN-BY-PRINCIPAL M P
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER S0))))
Which simplifies
 when rewriting with KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-OUT-OF-BAND-STEP,
KNOWN-BY-PRINCIPAL-PRESERVED-BY-CONSTRUCT-STEP,
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-RECEIVE-STEP,
KNOWN-BY-PRINCIPAL-PRESERVED-BY-SEND-STEP,
KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GENERATE-STEP,
KNOWN-BY-PRINCIPAL-PRESERVED-BY-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
IS-GENERATED
ENCRYPTED-PART-OF-SENT
ENCRYPTED-MESSAGE-THEOREM-1
Beginning proof of ENCRYPTED-MESSAGE-THEOREM-1 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IS-GENERATED K S))
 (ENCRYPTED-PART-OF-SENT M K S))
Inducting using the following scheme ...
 (AND (IMPLIES (SEQ!EMPTYP (HISTORY S)) (*P* K M S))
  (IMPLIES
   (AND (NOT (SEQ!EMPTYP (HISTORY S)))
    (ALL (PREVIOUS-STATE)
     (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
      (*P* K M PREVIOUS-STATE) (TRUE))))
   (*P* K M S)))
 produces ...
(AND
 (IMPLIES (SEQ!EMPTYP (HISTORY S))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
    (IS-GENERATED K S))
   (ENCRYPTED-PART-OF-SENT M K S)))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY S)))
   (ALL (PREVIOUS-STATE)
    (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
       (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
       (IS-GENERATED K PREVIOUS-STATE))
      (ENCRYPTED-PART-OF-SENT M K PREVIOUS-STATE))
     (TRUE))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
    (IS-GENERATED K S))
   (ENCRYPTED-PART-OF-SENT M K S))))
Invoking IS-GENERATED gives ...
(AND
 (IMPLIES
  (AND (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-EVOLUTION-STATE S)
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
   (SOME (L T P1)
    (AND (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)))))
  (ENCRYPTED-PART-OF-SENT M K S))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY S)))
   (ALL (PREVIOUS-STATE)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
      (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
      (SOME (L$0 T$0 P1$0)
       (AND (IN P1$0 (MS!PRINCIPALS))
        (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
         (HISTORY PREVIOUS-STATE)))))
     (ENCRYPTED-PART-OF-SENT M K PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
   (SOME (L$1 T$1 P1$1)
    (AND (IN P1$1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1) (HISTORY S)))))
  (ENCRYPTED-PART-OF-SENT M K S)))
Invoking ENCRYPTED-PART-OF-SENT gives ...
(AND
 (IMPLIES
  (AND (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-EVOLUTION-STATE S)
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
   (SOME (L T P1)
    (AND (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)))))
  (SOME (L2 T2 M2 P2)
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY S)))
   (ALL (PREVIOUS-STATE)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
      (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
      (SOME (L$0 T$0 P1$0)
       (AND (IN P1$0 (MS!PRINCIPALS))
        (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
         (HISTORY PREVIOUS-STATE)))))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
       (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
       (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
       (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
        (HISTORY PREVIOUS-STATE))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
   (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
   (SOME (L$1 T$1 P1$1)
    (AND (IN P1$1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1) (HISTORY S)))))
  (SOME (L2$1 T2$1 M2$1 P2$1)
   (AND (>= L2$1 0) (>= T2$1 0) (IN M2$1 (MS!MESSAGES))
    (IN P2$1 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IS-GOOD-EVOLUTION-STATE S)
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-EVOLUTION-STATE S)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)))))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
Invoking (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)) gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-EVOLUTION-STATE S)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS)) (SEQ!IS-TACK (HISTORY S))
    (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))))))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S))
   (AND (IS-STATE S) (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY S))
    (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
    (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, SEQ!EMPTYP-DEFINITION
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY S)))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (SOME (L$0 T$0 P1$0)
      (AND (IN P1$0 (MS!PRINCIPALS))
       (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
        (HISTORY PREVIOUS-STATE)))))
    (SOME (L2$0 T2$0 M2$0 P2$0)
     (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
      (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
       (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (SOME (L$1 T$1 P1$1)
   (AND (IN P1$1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1) (HISTORY S)))))
 (SOME (L2$1 T2$1 M2$1 P2$1)
  (AND (>= L2$1 0) (>= T2$1 0) (IN M2$1 (MS!MESSAGES))
   (IN P2$1 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))
Prenexing produces ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY S)))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (SOME (L$0 T$0 P1$0)
      (AND (IN P1$0 (MS!PRINCIPALS))
       (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
        (HISTORY PREVIOUS-STATE)))))
    (SOME (L2 T2 M2 P2)
     (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
      (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)))
 (SOME (L2$0 T2$0 M2$0 P2$0)
  (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
   (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))
Invoking (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)) gives ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY S)))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (SOME (L$0 T$0 P1$0)
      (AND (IN P1$0 (MS!PRINCIPALS))
       (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
        (HISTORY PREVIOUS-STATE)))))
    (SOME (L2 T2 M2 P2)
     (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
      (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS)) (SEQ!IS-TACK (HISTORY S))
  (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))))
 (SOME (L2$0 T2$0 M2$0 P2$0)
  (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
   (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS)))
 (IF (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (IMPLIES
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))))
Starting case 1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Invoking (IS-GOOD-EVOLUTION-STATE S) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE$0)
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (GOOD-STEP PREVIOUS-STATE$0 S))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Which simplifies
 when rewriting with SEQ!EMPTYP-DEFINITION
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, SEQ!NOT-IS-TACK-FACTS,
TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (SOME (PREVIOUS-STATE$0)
   (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (GOOD-STEP PREVIOUS-STATE$0 S)))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE$0))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Instantiating (= PREVIOUS-STATE$0 PREVIOUS-STATE) (= L$0 L) (= T$0 T)
              (= P1$0 P1) gives
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0)))
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY PREVIOUS-STATE$0))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
 (SOME (L2$1)
  (AND (>= L2$1 0)
   (SOME (T2$1)
    (AND (>= T2$1 0)
     (SOME (M2$1)
      (AND (IN M2$1 (MS!MESSAGES))
       (SOME (P2$1)
        (AND (IN P2$1 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0)))
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY PREVIOUS-STATE$0))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))))
 (SOME (L2$1)
  (AND (>= L2$1 0)
   (SOME (T2$1)
    (AND (>= T2$1 0)
     (SOME (M2$1)
      (AND (IN M2$1 (MS!MESSAGES))
       (SOME (P2$1)
        (AND (IN P2$1 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
Deleting
hypotheses (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
            (IMPLIES
             (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
              (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
              (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
              (IN P1$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
               (HISTORY PREVIOUS-STATE$0)))
             (SOME (L2$0)
              (AND (>= L2$0 0)
               (SOME (T2$0)
                (AND (>= T2$0 0)
                 (SOME (M2$0)
                  (AND (IN M2$0 (MS!MESSAGES))
                   (SOME (P2$0)
                    (AND (IN P2$0 (MS!PRINCIPALS))
                     (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
                      (HISTORY PREVIOUS-STATE$0))
                     (IN (MS!ENCRYPT M K)
                      (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))) produces
...
(OR
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
   (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
   (IN P1 (MS!PRINCIPALS))
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
   (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
   (IN P1 (MS!PRINCIPALS))
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
   (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
      (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE$0))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
      (IN P1$0 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
       (HISTORY PREVIOUS-STATE$0)))
     (SOME (L2$0)
      (AND (>= L2$0 0)
       (SOME (T2$0)
        (AND (>= T2$0 0)
         (SOME (M2$0)
          (AND (IN M2$0 (MS!MESSAGES))
           (SOME (P2$0)
            (AND (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
              (HISTORY PREVIOUS-STATE$0))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
Starting case 1.2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L2$1)
  (AND (>= L2$1 0)
   (SOME (T2$1)
    (AND (>= T2$1 0)
     (SOME (M2$1)
      (AND (IN M2$1 (MS!MESSAGES))
       (SOME (P2$1)
        (AND (IN P2$1 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
GOOD-STEP-IMPLIES-GOOD-STATES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, SEQ!TYPE-OF-IS-TACK, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS)))
 (IF (FORGEABLE K PREVIOUS-STATE)
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (IF (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
   (IF (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (IMPLIES
     (SOME (L2$0)
      (AND (>= L2$0 0)
       (SOME (T2$0)
        (AND (>= T2$0 0)
         (SOME (M2$0)
          (AND (IN M2$0 (MS!MESSAGES))
           (SOME (P2$0)
            (AND (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
     (SOME (L2$1)
      (AND (>= L2$1 0)
       (SOME (T2$1)
        (AND (>= T2$1 0)
         (SOME (M2$1)
          (AND (IN M2$1 (MS!MESSAGES))
           (SOME (P2$1)
            (AND (IN P2$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
    (SOME (L2$2)
     (AND (>= L2$2 0)
      (SOME (T2$2)
       (AND (>= T2$2 0)
        (SOME (M2$2)
         (AND (IN M2$2 (MS!MESSAGES))
          (SOME (P2$2)
           (AND (IN P2$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2) (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))))
   (SOME (L2$3)
    (AND (>= L2$3 0)
     (SOME (T2$3)
      (AND (>= T2$3 0)
       (SOME (M2$3)
        (AND (IN M2$3 (MS!MESSAGES))
         (SOME (P2$3)
          (AND (IN P2$3 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$3 T2$3 M2$3 P2$3) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET)))))))))))))))
Assuming FORGEABLE-MONOTONIC-OVER-GOOD-STEP with the
instantiations: (= M K) (= S0 PREVIOUS-STATE) (= S1 S) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (GOOD-STEP PREVIOUS-STATE S) (FORGEABLE K PREVIOUS-STATE))
   (FORGEABLE K S))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS)))
 (IF (FORGEABLE K PREVIOUS-STATE)
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (IF (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
   (IF (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (IMPLIES
     (SOME (L2$0)
      (AND (>= L2$0 0)
       (SOME (T2$0)
        (AND (>= T2$0 0)
         (SOME (M2$0)
          (AND (IN M2$0 (MS!MESSAGES))
           (SOME (P2$0)
            (AND (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
     (SOME (L2$1)
      (AND (>= L2$1 0)
       (SOME (T2$1)
        (AND (>= T2$1 0)
         (SOME (M2$1)
          (AND (IN M2$1 (MS!MESSAGES))
           (SOME (P2$1)
            (AND (IN P2$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
    (SOME (L2$2)
     (AND (>= L2$2 0)
      (SOME (T2$2)
       (AND (>= T2$2 0)
        (SOME (M2$2)
         (AND (IN M2$2 (MS!MESSAGES))
          (SOME (P2$2)
           (AND (IN P2$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2) (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))))
   (SOME (L2$3)
    (AND (>= L2$3 0)
     (SOME (T2$3)
      (AND (>= T2$3 0)
       (SOME (M2$3)
        (AND (IN M2$3 (MS!MESSAGES))
         (SOME (P2$3)
          (AND (IN P2$3 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$3 T2$3 M2$3 P2$3) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET)))))))))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS)))
 (IF (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (IF (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
   (IMPLIES
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
  (SOME (L2$2)
   (AND (>= L2$2 0)
    (SOME (T2$2)
     (AND (>= T2$2 0)
      (SOME (M2$2)
       (AND (IN M2$2 (MS!MESSAGES))
        (SOME (P2$2)
         (AND (IN P2$2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
Starting case 1.2.2.2 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
 (IF (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (IMPLIES
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
Starting case 1.2.2.2.2 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Instantiating (= L2$0 L2) (= T2$0 T2) (= M2$0 M2) (= P2$0 P2) gives ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
 (SOME (L2$0 T2$0 M2$0 P2$0)
  (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
   (IN P2$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Assuming KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GOOD-STEP with the
instantiations: (= M K) (= P P2) (= S0 PREVIOUS-STATE) (= S1 S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (GOOD-STEP PREVIOUS-STATE S) (IN P2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL K P2 PREVIOUS-STATE))
   (KNOWN-BY-PRINCIPAL K P2 S))
  (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES (AND (GOOD-STEP PREVIOUS-STATE S) (IN P2 (MS!PRINCIPALS)))
 (IF (KNOWN-BY-PRINCIPAL K P2 PREVIOUS-STATE)
  (IMPLIES
   (AND (KNOWN-BY-PRINCIPAL K P2 S) (NOT (FORGEABLE K PREVIOUS-STATE))
    (>= (SEQ!LENGTH (HISTORY S)) 1)
    (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
    (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))))
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
  (IMPLIES
   (AND (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
    (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
    (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))))
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))))
Invoking (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S)) gives ...
(IMPLIES (AND (GOOD-STEP PREVIOUS-STATE S) (IN P2 (MS!PRINCIPALS)))
 (IF (KNOWN-BY-PRINCIPAL K P2 PREVIOUS-STATE)
  (IMPLIES
   (AND (KNOWN-BY-PRINCIPAL K P2 S) (NOT (FORGEABLE K PREVIOUS-STATE))
    (>= (SEQ!LENGTH (HISTORY S)) 1)
    (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
    (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT
     (AND (SEQ!IS-TACK (HISTORY S))
      (OR (= (MAKE-SEND-EVENT L2 T2 M2 P2) (SEQ!HEAD (HISTORY S)))
       (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
        (SEQ!TAIL (HISTORY S)))))))
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
  (IMPLIES
   (AND (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
    (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
    (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT
     (AND (SEQ!IS-TACK (HISTORY S))
      (OR (= (MAKE-SEND-EVENT L2 T2 M2 P2) (SEQ!HEAD (HISTORY S)))
       (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
        (SEQ!TAIL (HISTORY S)))))))
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions SEQ!TYPE-OF-IS-TACK, TAG-OF-MAKE-SEND-EVENT,
MAKE-SEND-EVENT-IS-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT,
SEQ!LENGTH-NON-NEGATIVE, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Starting case 1.2.2.2.1 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))))
 (SOME (L2$1)
  (AND (>= L2$1 0)
   (SOME (T2$1)
    (AND (>= T2$1 0)
     (SOME (M2$1)
      (AND (IN M2$1 (MS!MESSAGES))
       (SOME (P2$1)
        (AND (IN P2$1 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= S
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= S
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
Substituting (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
             (= S
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
                 PREVIOUS-STATE))))
             (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
             (= S
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
                 PREVIOUS-STATE))))
             (= S
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
                 PREVIOUS-STATE))))
             (= S
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
                 PREVIOUS-STATE)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
     (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
           (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY
       (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
           (HISTORY
            (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1)
           (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY
       (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))))
  (SOME (L2$2)
   (AND (>= L2$2 0)
    (SOME (T2$2)
     (AND (>= T2$2 0)
      (SOME (M2$2)
       (AND (IN M2$2 (MS!MESSAGES))
        (SOME (P2$2)
         (AND (IN P2$2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2)
           (HISTORY
            (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))))
  (SOME (L2$3)
   (AND (>= L2$3 0)
    (SOME (T2$3)
     (AND (>= T2$3 0)
      (SOME (M2$3)
       (AND (IN M2$3 (MS!MESSAGES))
        (SOME (P2$3)
         (AND (IN P2$3 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$3 T2$3 M2$3 P2$3)
           (HISTORY
            (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
        PREVIOUS-STATE))))))
  (SOME (L2$4)
   (AND (>= L2$4 0)
    (SOME (T2$4)
     (AND (>= T2$4 0)
      (SOME (M2$4)
       (AND (IN M2$4 (MS!MESSAGES))
        (SOME (P2$4)
         (AND (IN P2$4 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$4 T2$4 M2$4 P2$4)
           (HISTORY
            (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
             PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, SEQ!IS-MEMBER-TACK,
SEEN-MESSAGES-GENERATE-STEP, FORGEABLE-PRESERVED-BY-GENERATE-STEP,
GENERATE-EVENT-EQUALITY, HISTORY-OF-GENERATE-STEP, SEQ!LENGTH-TACK,
HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT,
MAKE-SEND-EVENT-IS-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, TAIL-IS-SEQUENCE,
SEQ!TYPE-OF-IS-TACK, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
TAG-OF-MAKE-INTRUDER-EVENT, MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT, TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (= L LABEL) (= T TIME) (= K MESSAGE)
  (= P1 PRINCIPAL$1)
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE))))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
Invoking (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE)) gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 MESSAGE) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
  (NOT
   (SOME (M$1)
    (IN (MS!ENCRYPT M$1 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
  (ALL (M$2 K2)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 MESSAGE K2)
      (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2)
      (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 K2 MESSAGE)
      (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 K2 (MS!INVERSE MESSAGE))
      (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (= L LABEL) (= T TIME) (= K MESSAGE)
  (= P1 PRINCIPAL$1)
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE))))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
Instantiating (= M$0 M) gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (NOT (IN MESSAGE (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (NOT
   (OR (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (SOME (M$0)
     (IN (MS!ENCRYPT M$0 MESSAGE)
      (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))))
  (NOT
   (SOME (M$1)
    (IN (MS!ENCRYPT M$1 (MS!INVERSE MESSAGE))
     (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
  (ALL (M$2 K2)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 MESSAGE K2)
      (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2)
      (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 K2 MESSAGE)
      (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 K2 (MS!INVERSE MESSAGE))
      (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL (MS!PRINCIPALS))
  (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (= L LABEL) (= T TIME) (= K MESSAGE)
  (= P1 PRINCIPAL)
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE))))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, SEQ!TACK-HEAD-TAIL,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
TAG-OF-MAKE-GENERATE-EVENT, MAKE-GENERATE-EVENT-IS-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!TAG-OF-SHARE-ENCRYPT,
MS!SHENDT-SHARE-ENCRYPT, MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1.2.2.1 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
 (SOME (L2$2)
  (AND (>= L2$2 0)
   (SOME (T2$2)
    (AND (>= T2$2 0)
     (SOME (M2$2)
      (AND (IN M2$2 (MS!MESSAGES))
       (SOME (P2$2)
        (AND (IN P2$2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= S
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= S
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
Substituting (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= S
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= S
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= S
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= S
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
           (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
           (HISTORY
            (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1)
           (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
  (SOME (L2$2)
   (AND (>= L2$2 0)
    (SOME (T2$2)
     (AND (>= T2$2 0)
      (SOME (M2$2)
       (AND (IN M2$2 (MS!MESSAGES))
        (SOME (P2$2)
         (AND (IN P2$2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2)
           (HISTORY
            (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
  (SOME (L2$3)
   (AND (>= L2$3 0)
    (SOME (T2$3)
     (AND (>= T2$3 0)
      (SOME (M2$3)
       (AND (IN M2$3 (MS!MESSAGES))
        (SOME (P2$3)
         (AND (IN P2$3 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$3 T2$3 M2$3 P2$3)
           (HISTORY
            (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET)))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))))
  (SOME (L2$4)
   (AND (>= L2$4 0)
    (SOME (T2$4)
     (AND (>= T2$4 0)
      (SOME (M2$4)
       (AND (IN M2$4 (MS!MESSAGES))
        (SOME (P2$4)
         (AND (IN P2$4 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$4 T2$4 M2$4 P2$4)
           (HISTORY
            (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
             PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, SEEN-MESSAGES-GENERATE-STEP,
FORGEABLE-PRESERVED-BY-GENERATE-STEP, GENERATE-EVENT-EQUALITY,
HISTORY-OF-GENERATE-STEP, SEQ!LENGTH-TACK, HISTORY-OF-INTRUDER-STEP,
MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
TAG-OF-MAKE-INTRUDER-EVENT, MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT, TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2$1)
  (AND (>= L2$1 0)
   (SOME (T2$1)
    (AND (>= T2$1 0)
     (SOME (M2$1)
      (AND (IN M2$1 (MS!MESSAGES))
       (SOME (P2$1)
        (AND (IN P2$1 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
Invoking (IS-GOOD-EVOLUTION-STATE S) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE$0)
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (GOOD-STEP PREVIOUS-STATE$0 S))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Which simplifies
 when rewriting with SEQ!EMPTYP-DEFINITION
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, SEQ!NOT-IS-TACK-FACTS,
TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (SOME (PREVIOUS-STATE$0)
   (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (GOOD-STEP PREVIOUS-STATE$0 S)))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE$0))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Instantiating (= PREVIOUS-STATE$0 PREVIOUS-STATE) (= L$0 L) (= T$0 T)
              (= P1$0 P1) gives
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0)))
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY PREVIOUS-STATE$0))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2$1)
  (AND (>= L2$1 0)
   (SOME (T2$1)
    (AND (>= T2$1 0)
     (SOME (M2$1)
      (AND (IN M2$1 (MS!MESSAGES))
       (SOME (P2$1)
        (AND (IN P2$1 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
Deleting
hypotheses (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
            (IMPLIES
             (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
              (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
              (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
              (IN P1$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
               (HISTORY PREVIOUS-STATE$0)))
             (SOME (L2$0)
              (AND (>= L2$0 0)
               (SOME (T2$0)
                (AND (>= T2$0 0)
                 (SOME (M2$0)
                  (AND (IN M2$0 (MS!MESSAGES))
                   (SOME (P2$0)
                    (AND (IN P2$0 (MS!PRINCIPALS))
                     (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
                      (HISTORY PREVIOUS-STATE$0))
                     (IN (MS!ENCRYPT M K)
                      (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))) produces
...
(OR
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
   (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
     (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
   (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
      (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE$0))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE$0)))
      (IN P1$0 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
       (HISTORY PREVIOUS-STATE$0)))
     (SOME (L2$0)
      (AND (>= L2$0 0)
       (SOME (T2$0)
        (AND (>= T2$0 0)
         (SOME (M2$0)
          (AND (IN M2$0 (MS!MESSAGES))
           (SOME (P2$0)
            (AND (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
              (HISTORY PREVIOUS-STATE$0))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
   (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
Starting case 1.1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2$1)
  (AND (>= L2$1 0)
   (SOME (T2$1)
    (AND (>= T2$1 0)
     (SOME (M2$1)
      (AND (IN M2$1 (MS!MESSAGES))
       (SOME (P2$1)
        (AND (IN P2$1 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, GOOD-STEP-IMPLIES-GOOD-STATES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)))
 (IF (FORGEABLE K PREVIOUS-STATE)
  (IMPLIES
   (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
    (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (IF (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
   (IMPLIES
    (AND (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
     (SOME (L2$0)
      (AND (>= L2$0 0)
       (SOME (T2$0)
        (AND (>= T2$0 0)
         (SOME (M2$0)
          (AND (IN M2$0 (MS!MESSAGES))
           (SOME (P2$0)
            (AND (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
     (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
     (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))))
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
   (IMPLIES
    (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
     (IN P1 (MS!PRINCIPALS))
     (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
    (SOME (L2$2)
     (AND (>= L2$2 0)
      (SOME (T2$2)
       (AND (>= T2$2 0)
        (SOME (M2$2)
         (AND (IN M2$2 (MS!MESSAGES))
          (SOME (P2$2)
           (AND (IN P2$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2) (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))))
Starting case 1.1.2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (FORGEABLE K PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (FORGEABLE K PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= S
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (FORGEABLE K PREVIOUS-STATE) (IS-GOOD-STATE PREVIOUS-STATE)
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= S
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
Substituting (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= S
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= S
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= S
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= S
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (FORGEABLE K PREVIOUS-STATE)
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
           (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (FORGEABLE K PREVIOUS-STATE)
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
           (HISTORY
            (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (FORGEABLE K PREVIOUS-STATE)
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1)
           (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (FORGEABLE K PREVIOUS-STATE)
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))))
  (SOME (L2$2)
   (AND (>= L2$2 0)
    (SOME (T2$2)
     (AND (>= T2$2 0)
      (SOME (M2$2)
       (AND (IN M2$2 (MS!MESSAGES))
        (SOME (P2$2)
         (AND (IN P2$2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2)
           (HISTORY
            (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (FORGEABLE K PREVIOUS-STATE)
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))))
  (SOME (L2$3)
   (AND (>= L2$3 0)
    (SOME (T2$3)
     (AND (>= T2$3 0)
      (SOME (M2$3)
       (AND (IN M2$3 (MS!MESSAGES))
        (SOME (P2$3)
         (AND (IN P2$3 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$3 T2$3 M2$3 P2$3)
           (HISTORY
            (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (FORGEABLE K PREVIOUS-STATE)
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
        PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))))
  (SOME (L2$4)
   (AND (>= L2$4 0)
    (SOME (T2$4)
     (AND (>= T2$4 0)
      (SOME (M2$4)
       (AND (IN M2$4 (MS!MESSAGES))
        (SOME (P2$4)
         (AND (IN P2$4 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$4 T2$4 M2$4 P2$4)
           (HISTORY
            (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
             PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
Which simplifies
 when rewriting with FORGEABLE-PRESERVED-BY-OUT-OF-BAND-STEP,
FORGEABLE-PRESERVED-BY-CONSTRUCT-STEP, FORGEABLE-PRESERVED-BY-RECEIVE-STEP,
FORGEABLE-MONOTONIC-OVER-SEND-STEP, FORGEABLE-PRESERVED-BY-GENERATE-STEP,
FORGEABLE-MONOTONIC-OVER-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS,
MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to
...
(TRUE)
Starting case 1.1.2.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE)))
 (IF (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (IMPLIES
   (AND (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
    (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
    (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))))
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
  (IMPLIES
   (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
    (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
   (SOME (L2$2)
    (AND (>= L2$2 0)
     (SOME (T2$2)
      (AND (>= T2$2 0)
       (SOME (M2$2)
        (AND (IN M2$2 (MS!MESSAGES))
         (SOME (P2$2)
          (AND (IN P2$2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))))))
Starting case 1.1.2.1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))))
 (SOME (L2$1)
  (AND (>= L2$1 0)
   (SOME (T2$1)
    (AND (>= T2$1 0)
     (SOME (M2$1)
      (AND (IN M2$1 (MS!MESSAGES))
       (SOME (P2$1)
        (AND (IN P2$1 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
Instantiating (= L2$1 L2$0) (= T2$1 T2$0) (= M2$1 M2$0) (= P2$1 P2$0) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
 (SOME (L2$0 T2$0 M2$0 P2$0)
  (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
   (IN P2$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Invoking (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (AND (SEQ!IS-TACK (HISTORY S))
    (OR (= (MAKE-SEND-EVENT L2 T2 M2 P2) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (SEQ!TAIL (HISTORY S)))))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to
...
(TRUE)
Starting case 1.1.2.1.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2$2)
  (AND (>= L2$2 0)
   (SOME (T2$2)
    (AND (>= T2$2 0)
     (SOME (M2$2)
      (AND (IN M2$2 (MS!MESSAGES))
       (SOME (P2$2)
        (AND (IN P2$2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= S
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= S
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (NOT (FORGEABLE K S)) (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S)))
  (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
The conjunctive normal form ...
(AND
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (OR (NOT (>= (SEQ!LENGTH (HISTORY S)) 1)) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN K (MS!KEYS))) (FORGEABLE K PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE)))
  (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K S) (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
Substituting (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= S
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= S
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= S
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= S
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
           (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
           (HISTORY
            (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1)
           (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))))
  (SOME (L2$2)
   (AND (>= L2$2 0)
    (SOME (T2$2)
     (AND (>= T2$2 0)
      (SOME (M2$2)
       (AND (IN M2$2 (MS!MESSAGES))
        (SOME (P2$2)
         (AND (IN P2$2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2)
           (HISTORY
            (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))))
  (SOME (L2$3)
   (AND (>= L2$3 0)
    (SOME (T2$3)
     (AND (>= T2$3 0)
      (SOME (M2$3)
       (AND (IN M2$3 (MS!MESSAGES))
        (SOME (P2$3)
         (AND (IN P2$3 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$3 T2$3 M2$3 P2$3)
           (HISTORY
            (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET)))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
   (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SEEN-MESSAGES
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
        PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))))
  (SOME (L2$4)
   (AND (>= L2$4 0)
    (SOME (T2$4)
     (AND (>= T2$4 0)
      (SOME (M2$4)
       (AND (IN M2$4 (MS!MESSAGES))
        (SOME (P2$4)
         (AND (IN P2$4 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$4 T2$4 M2$4 P2$4)
           (HISTORY
            (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
             PREVIOUS-STATE)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
Which simplifies
 when rewriting with SEEN-MESSAGES-OUT-OF-BAND-STEP,
FORGEABLE-PRESERVED-BY-OUT-OF-BAND-STEP, SEEN-MESSAGES-CONSTRUCT-STEP,
FORGEABLE-PRESERVED-BY-CONSTRUCT-STEP, SEEN-MESSAGES-RECEIVE-STEP,
FORGEABLE-PRESERVED-BY-RECEIVE-STEP, SEND-EVENT-EQUALITY, SEQ!IS-MEMBER-TACK,
HISTORY-OF-SEND-STEP, SEEN-MESSAGES-SEND-STEP, SEEN-MESSAGES-GENERATE-STEP,
FORGEABLE-PRESERVED-BY-GENERATE-STEP, SETADD.DEFINITION,
MS!PARTS-SETADD-ATOMIC, SEEN-MESSAGES-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
SEQ!TACK-HEAD-TAIL, MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS,
MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions MAKE-SEND-EVENT-IS-SEND-EVENT, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (OR (AND (= L2 LABEL) (= T2 TIME) (= M2 MESSAGE) (= P2 PRINCIPAL))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
Splitting
on (= (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
    (UNION (SETADD MESSAGE (NULLSET))
     (SEEN-MESSAGES PREVIOUS-STATE))) generates
...
(IF
 (= (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (UNION (SETADD MESSAGE (NULLSET)) (SEEN-MESSAGES PREVIOUS-STATE)))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (SOME (L2 T2 M2 P2)
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (OR (AND (= L2 LABEL) (= T2 TIME) (= M2 MESSAGE) (= P2 PRINCIPAL))
     (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
   (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
   (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (SOME (L2$0 T2$0 M2$0 P2$0)
   (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
    (IN P2$0 (MS!PRINCIPALS))
    (OR (AND (= L2$0 LABEL) (= T2$0 TIME) (= M2$0 MESSAGE) (= P2$0 PRINCIPAL))
     (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
      (HISTORY PREVIOUS-STATE)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
Starting case 1.1.2.1.1.2 ...
(IMPLIES
 (AND
  (= (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
   (UNION (SETADD MESSAGE (NULLSET)) (SEEN-MESSAGES PREVIOUS-STATE)))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (OR (AND (= L2 LABEL) (= T2 TIME) (= M2 MESSAGE) (= P2 PRINCIPAL))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
Substituting (= (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
              (UNION (SETADD MESSAGE (NULLSET))
               (SEEN-MESSAGES PREVIOUS-STATE))) produces
...
(IMPLIES
 (AND
  (= (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
   (UNION (SETADD MESSAGE (NULLSET)) (SEEN-MESSAGES PREVIOUS-STATE)))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (UNION (SETADD MESSAGE (NULLSET)) (SEEN-MESSAGES PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IF (= L2 LABEL)
    (IF (= T2 TIME)
     (IF (= M2 MESSAGE)
      (IF (= P2 PRINCIPAL)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
       (AND
        (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
      (AND
       (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
     (AND
      (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
    (AND
     (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Applying MS!PARTS-UNION gives ...
(IMPLIES
 (AND
  (= (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
   (UNION (SETADD MESSAGE (NULLSET)) (SEEN-MESSAGES PREVIOUS-STATE)))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IN (MS!ENCRYPT M K)
   (UNION (MS!PARTS (SETADD MESSAGE (NULLSET)))
    (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IF (= L2 LABEL)
    (IF (= T2 TIME)
     (IF (= M2 MESSAGE)
      (IF (= P2 PRINCIPAL)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
       (AND
        (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
      (AND
       (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
     (AND
      (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
    (AND
     (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 when rewriting with UNION.DEFINITION, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2 to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (IF (= L2 LABEL)
          (IF (= T2 TIME)
           (IF (= M2 MESSAGE)
            (OR (= P2 PRINCIPAL)
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE)))
            (AND
             (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
           (AND
            (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
          (AND
           (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))))
Instantiating (= L2 LABEL) (= T2 TIME) (= M2 MESSAGE) (= P2 PRINCIPAL) gives
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (AND (>= LABEL 0) (>= TIME 0) (IN MESSAGE (MS!MESSAGES))
    (IN PRINCIPAL (MS!PRINCIPALS))
    (IF (= LABEL LABEL)
     (IF (= TIME TIME)
      (IF (= MESSAGE MESSAGE)
       (OR (= PRINCIPAL PRINCIPAL)
        (SEQ!IS-MEMBER (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
         (HISTORY PREVIOUS-STATE)))
       (AND
        (SEQ!IS-MEMBER (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
         (HISTORY PREVIOUS-STATE))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))))
      (AND
       (SEQ!IS-MEMBER (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
        (HISTORY PREVIOUS-STATE))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))))
     (AND
      (SEQ!IS-MEMBER (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET)))))))))
 (SOME (L2 T2 M2 P2)
  (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IF (= L2 LABEL)
    (IF (= T2 TIME)
     (IF (= M2 MESSAGE)
      (OR (= P2 PRINCIPAL)
       (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
      (AND
       (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
     (AND
      (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
    (AND
     (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT (IN MESSAGE (MS!MESSAGES))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
          (HISTORY PREVIOUS-STATE))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Invoking (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF PRINCIPAL PREVIOUS-STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT (IN MESSAGE (MS!MESSAGES))))
 (SOME (L2)
  (AND (>= L2 0)
   (SOME (T2)
    (AND (>= T2 0)
     (SOME (M2)
      (AND (IN M2 (MS!MESSAGES))
       (SOME (P2)
        (AND (IN P2 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2)
          (HISTORY PREVIOUS-STATE))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
TIME-CONSTRAINT-IMPLIES-NAT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to
...
(TRUE)
Starting case 1.1.2.1.1.1 ...
(IMPLIES
 (AND
  (NOT
   (= (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
    (UNION (SETADD MESSAGE (NULLSET)) (SEEN-MESSAGES PREVIOUS-STATE))))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES PREVIOUS-STATE))))
  (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
  (IN PRINCIPAL (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
  (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (SOME (L2$0 T2$0 M2$0 P2$0)
  (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
   (IN P2$0 (MS!PRINCIPALS))
   (OR (AND (= L2$0 LABEL) (= T2$0 TIME) (= M2$0 MESSAGE) (= P2$0 PRINCIPAL))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0)
     (HISTORY PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
Completing all cases produces ...
(TRUE)
ENCRYPTED-PART-OF-RECEIVED
ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND
Warning RULE-LOOPS for IN-PARTS-SETADD:
 The rule IN-PARTS-SETADD loops upon itself.
IN-PARTS-SETADD
Beginning proof of IN-PARTS-SETADD ...
(IMPLIES (NOT (= S (NULLSET)))
 (= (IN M (MS!PARTS (SETADD M1 S)))
  (OR (IN M (MS!PARTS (SETADD M1 (NULLSET)))) (IN M (MS!PARTS S)))))
Splitting on (= (SETADD M1 S) (UNION (SETADD M1 (NULLSET)) S)) generates ...
(IF (= (SETADD M1 S) (UNION (SETADD M1 (NULLSET)) S))
 (IMPLIES (NOT (= S (NULLSET)))
  (= (IN M (MS!PARTS (SETADD M1 S)))
   (OR (IN M (MS!PARTS (SETADD M1 (NULLSET)))) (IN M (MS!PARTS S)))))
 (IMPLIES (NOT (= S (NULLSET)))
  (= (IN M (MS!PARTS (SETADD M1 S)))
   (OR (IN M (MS!PARTS (SETADD M1 (NULLSET)))) (IN M (MS!PARTS S))))))
Starting case 2 ...
(IMPLIES
 (AND (= (SETADD M1 S) (UNION (SETADD M1 (NULLSET)) S)) (NOT (= S (NULLSET))))
 (= (IN M (MS!PARTS (SETADD M1 S)))
  (OR (IN M (MS!PARTS (SETADD M1 (NULLSET)))) (IN M (MS!PARTS S)))))
Substituting (= (SETADD M1 S) (UNION (SETADD M1 (NULLSET)) S)) produces ...
(IMPLIES
 (AND (= (SETADD M1 S) (UNION (SETADD M1 (NULLSET)) S)) (NOT (= S (NULLSET))))
 (= (IN M (MS!PARTS (UNION (SETADD M1 (NULLSET)) S)))
  (OR (IN M (MS!PARTS (SETADD M1 (NULLSET)))) (IN M (MS!PARTS S)))))
Applying MS!PARTS-UNION gives ...
(IMPLIES
 (AND (= (SETADD M1 S) (UNION (SETADD M1 (NULLSET)) S)) (NOT (= S (NULLSET))))
 (= (IN M (UNION (MS!PARTS (SETADD M1 (NULLSET))) (MS!PARTS S)))
  (OR (IN M (MS!PARTS (SETADD M1 (NULLSET)))) (IN M (MS!PARTS S)))))
Which simplifies
 when rewriting with UNION.DEFINITION, UNION.COMMUTATIVE,
SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (= (SETADD M1 S) (UNION (SETADD M1 (NULLSET)) S)))
  (NOT (= S (NULLSET))))
 (= (IN M (MS!PARTS (SETADD M1 S)))
  (OR (IN M (MS!PARTS (SETADD M1 (NULLSET)))) (IN M (MS!PARTS S)))))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
Completing all cases produces ...
(TRUE)
ENCRYPTED-MESSAGE-THEOREM-2
Beginning proof of ENCRYPTED-MESSAGE-THEOREM-2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IS-GENERATED K S))
 (OR (ENCRYPTED-PART-OF-RECEIVED M K S)
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)))
Inducting using the following scheme ...
 (AND (IMPLIES (SEQ!EMPTYP (HISTORY S)) (*P* K M P S))
  (IMPLIES
   (AND (NOT (SEQ!EMPTYP (HISTORY S)))
    (ALL (PREVIOUS-STATE)
     (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
      (*P* K M P PREVIOUS-STATE) (TRUE))))
   (*P* K M P S)))
 produces ...
(AND
 (IMPLIES (SEQ!EMPTYP (HISTORY S))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
    (NOT (KNOWN-BY-PRINCIPAL K P S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IS-GENERATED K S))
   (OR (ENCRYPTED-PART-OF-RECEIVED M K S)
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY S)))
   (ALL (PREVIOUS-STATE)
    (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
       (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
       (NOT (FORGEABLE K PREVIOUS-STATE))
       (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
       (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
       (IS-GENERATED K PREVIOUS-STATE))
      (OR (ENCRYPTED-PART-OF-RECEIVED M K PREVIOUS-STATE)
       (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K PREVIOUS-STATE)))
     (TRUE))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)) (NOT (FORGEABLE K S))
    (NOT (KNOWN-BY-PRINCIPAL K P S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IS-GENERATED K S))
   (OR (ENCRYPTED-PART-OF-RECEIVED M K S)
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)))))
Invoking IS-GENERATED gives ...
(AND
 (IMPLIES
  (AND (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-EVOLUTION-STATE S)
   (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
   (SOME (L T P1)
    (AND (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S))))
   (NOT (ENCRYPTED-PART-OF-RECEIVED M K S)))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY S)))
   (ALL (PREVIOUS-STATE)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
      (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
      (NOT (FORGEABLE K PREVIOUS-STATE))
      (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
      (SOME (L$0 T$0 P1$0)
       (AND (IN P1$0 (MS!PRINCIPALS))
        (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
         (HISTORY PREVIOUS-STATE))))
      (NOT (ENCRYPTED-PART-OF-RECEIVED M K PREVIOUS-STATE)))
     (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
   (SOME (L$1 T$1 P1$1)
    (AND (IN P1$1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1) (HISTORY S))))
   (NOT (ENCRYPTED-PART-OF-RECEIVED M K S)))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)))
Invoking ENCRYPTED-PART-OF-RECEIVED gives ...
(AND
 (IMPLIES
  (AND (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-EVOLUTION-STATE S)
   (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
   (SOME (L T P1)
    (AND (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S))))
   (NOT
    (SOME (L2 T2 M2 P2)
     (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
      (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
      (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY S)))
   (ALL (PREVIOUS-STATE)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
      (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
      (NOT (FORGEABLE K PREVIOUS-STATE))
      (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
      (SOME (L$0 T$0 P1$0)
       (AND (IN P1$0 (MS!PRINCIPALS))
        (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
         (HISTORY PREVIOUS-STATE))))
      (NOT
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
         (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
         (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
         (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
          (HISTORY PREVIOUS-STATE))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
     (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
   (SOME (L$1 T$1 P1$1)
    (AND (IN P1$1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1) (HISTORY S))))
   (NOT
    (SOME (L2$1 T2$1 M2$1 P2$1)
     (AND (>= L2$1 0) (>= T2$1 0) (IN M2$1 (MS!MESSAGES))
      (IN P2$1 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
      (IS-GOOD-EVOLUTION-STATE S)
      (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)))
Invoking ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND gives ...
(AND
 (IMPLIES
  (AND (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-EVOLUTION-STATE S)
   (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
   (SOME (L T P1)
    (AND (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S))))
   (NOT
    (SOME (L2 T2 M2 P2)
     (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
      (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
      (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
  (SOME (L3 T3 M3 P3 P4)
   (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IS-GOOD-EVOLUTION-STATE S)
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY S)))
   (ALL (PREVIOUS-STATE)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
      (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
      (NOT (FORGEABLE K PREVIOUS-STATE))
      (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
      (SOME (L$0 T$0 P1$0)
       (AND (IN P1$0 (MS!PRINCIPALS))
        (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
         (HISTORY PREVIOUS-STATE))))
      (NOT
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
         (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
         (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
         (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
          (HISTORY PREVIOUS-STATE))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND (>= L3$0 0) (>= T3$0 0) (IN M3$0 (MS!MESSAGES))
       (IN P3$0 (MS!PRINCIPALS)) (IN P4$0 (MS!PRINCIPALS))
       (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
       (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
       (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
        (HISTORY PREVIOUS-STATE))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET))))))))
   (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
   (SOME (L$1 T$1 P1$1)
    (AND (IN P1$1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1) (HISTORY S))))
   (NOT
    (SOME (L2$1 T2$1 M2$1 P2$1)
     (AND (>= L2$1 0) (>= T2$1 0) (IN M2$1 (MS!MESSAGES))
      (IN P2$1 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
      (IS-GOOD-EVOLUTION-STATE S)
      (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))
  (SOME (L3$1 T3$1 M3$1 P3$1 P4$1)
   (AND (>= L3$1 0) (>= T3$1 0) (IN M3$1 (MS!MESSAGES))
    (IN P3$1 (MS!PRINCIPALS)) (IN P4$1 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
     (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET))))))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-EVOLUTION-STATE S)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S))))
  (NOT
   (SOME (L2 T2 M2 P2)
    (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Invoking (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)) gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-EVOLUTION-STATE S)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS)) (SEQ!IS-TACK (HISTORY S))
    (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))))
  (NOT
   (SOME (L2 T2 M2 P2)
    (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S))
   (AND (IS-STATE S) (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY S))
    (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
    (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, SEQ!EMPTYP-DEFINITION
 forward chaining using SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY S)))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (SOME (L$0 T$0 P1$0)
      (AND (IN P1$0 (MS!PRINCIPALS))
       (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
        (HISTORY PREVIOUS-STATE))))
     (NOT
      (SOME (L2$0 T2$0 M2$0 P2$0)
       (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
        (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
        (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
        (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
         (HISTORY PREVIOUS-STATE))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
    (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
     (AND (>= L3$0 0) (>= T3$0 0) (IN M3$0 (MS!MESSAGES))
      (IN P3$0 (MS!PRINCIPALS)) (IN P4$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
      (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
       (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (SOME (L$1 T$1 P1$1)
   (AND (IN P1$1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1) (HISTORY S))))
  (NOT
   (SOME (L2$1 T2$1 M2$1 P2$1)
    (AND (>= L2$1 0) (>= T2$1 0) (IN M2$1 (MS!MESSAGES))
     (IN P2$1 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
     (IS-GOOD-EVOLUTION-STATE S)
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))
 (SOME (L3$1 T3$1 M3$1 P3$1 P4$1)
  (AND (>= L3$1 0) (>= T3$1 0) (IN M3$1 (MS!MESSAGES))
   (IN P3$1 (MS!PRINCIPALS)) (IN P4$1 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
    (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET)))))))
Prenexing produces ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY S)))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (SOME (L$0 T$0 P1$0)
      (AND (IN P1$0 (MS!PRINCIPALS))
       (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
        (HISTORY PREVIOUS-STATE))))
     (NOT
      (SOME (L2 T2 M2 P2)
       (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
        (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
        (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
        (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
         (HISTORY PREVIOUS-STATE))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
    (SOME (L3 T3 M3 P3 P4)
     (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
      (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
       (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S))
  (NOT
   (SOME (L2$0 T2$0 M2$0 P2$0)
    (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
     (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
     (IS-GOOD-EVOLUTION-STATE S)
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
 (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
  (AND (>= L3$0 0) (>= T3$0 0) (IN M3$0 (MS!MESSAGES))
   (IN P3$0 (MS!PRINCIPALS)) (IN P4$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
    (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))
Invoking (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY S)) gives ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY S)))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (SOME (L$0 T$0 P1$0)
      (AND (IN P1$0 (MS!PRINCIPALS))
       (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
        (HISTORY PREVIOUS-STATE))))
     (NOT
      (SOME (L2 T2 M2 P2)
       (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
        (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
        (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
        (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
         (HISTORY PREVIOUS-STATE))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
    (SOME (L3 T3 M3 P3 P4)
     (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
      (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
       (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-TACK (HISTORY S))
  (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (NOT
   (SOME (L2$0 T2$0 M2$0 P2$0)
    (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
     (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
     (IS-GOOD-EVOLUTION-STATE S)
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
 (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
  (AND (>= L3$0 0) (>= T3$0 0) (IN M3$0 (MS!MESSAGES))
   (IN P3$0 (MS!PRINCIPALS)) (IN P4$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
    (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS)))
 (IF (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (OR
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
   (SOME (L3$0)
    (AND (>= L3$0 0)
     (SOME (T3$0)
      (AND (>= T3$0 0)
       (SOME (M3$0)
        (AND (IN M3$0 (MS!MESSAGES))
         (SOME (P3$0)
          (AND (IN P3$0 (MS!PRINCIPALS))
           (SOME (P4$0)
            (AND (IN P4$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
  (IMPLIES
   (AND (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
    (NOT
     (SOME (L2$1)
      (AND (>= L2$1 0)
       (SOME (T2$1)
        (AND (>= T2$1 0)
         (SOME (M2$1)
          (AND (IN M2$1 (MS!MESSAGES))
           (SOME (P2$1)
            (AND (IN P2$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
   (SOME (L3$1)
    (AND (>= L3$1 0)
     (SOME (T3$1)
      (AND (>= T3$1 0)
       (SOME (M3$1)
        (AND (IN M3$1 (MS!MESSAGES))
         (SOME (P3$1)
          (AND (IN P3$1 (MS!PRINCIPALS))
           (SOME (P4$1)
            (AND (IN P4$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))))
Starting case 1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Invoking (IS-GOOD-EVOLUTION-STATE S) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE$0)
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (GOOD-STEP PREVIOUS-STATE$0 S))))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Which simplifies
 when rewriting with SEQ!EMPTYP-DEFINITION
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, SEQ!NOT-IS-TACK-FACTS,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, TAG-OF-RECEIVE-EVENT,
RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
  (SOME (PREVIOUS-STATE$0)
   (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (GOOD-STEP PREVIOUS-STATE$0 S)))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Instantiating (= PREVIOUS-STATE$0 PREVIOUS-STATE) (= L$0 L) (= T$0 T)
              (= P1$0 P1) gives
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (NOT
     (SOME (L2)
      (AND (>= L2 0)
       (SOME (T2)
        (AND (>= T2 0)
         (SOME (M2)
          (AND (IN M2 (MS!MESSAGES))
           (SOME (P2)
            (AND (IN P2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0))
     (NOT
      (SOME (L2$0)
       (AND (>= L2$0 0)
        (SOME (T2$0)
         (AND (>= T2$0 0)
          (SOME (M2$0)
           (AND (IN M2$0 (MS!MESSAGES))
            (SOME (P2$0)
             (AND (IN P2$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
    (SOME (L3$0)
     (AND (>= L3$0 0)
      (SOME (T3$0)
       (AND (>= T3$0 0)
        (SOME (M3$0)
         (AND (IN M3$0 (MS!MESSAGES))
          (SOME (P3$0)
           (AND (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND (IN P4$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$0 (NULLSET))))))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
 (SOME (L3$1)
  (AND (>= L3$1 0)
   (SOME (T3$1)
    (AND (>= T3$1 0)
     (SOME (M3$1)
      (AND (IN M3$1 (MS!MESSAGES))
       (SOME (P3$1)
        (AND (IN P3$1 (MS!PRINCIPALS))
         (SOME (P4$1)
          (AND (IN P4$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (NOT
     (SOME (L2)
      (AND (>= L2 0)
       (SOME (T2)
        (AND (>= T2 0)
         (SOME (M2)
          (AND (IN M2 (MS!MESSAGES))
           (SOME (P2)
            (AND (IN P2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0))
     (NOT
      (SOME (L2$0)
       (AND (>= L2$0 0)
        (SOME (T2$0)
         (AND (>= T2$0 0)
          (SOME (M2$0)
           (AND (IN M2$0 (MS!MESSAGES))
            (SOME (P2$0)
             (AND (IN P2$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
    (SOME (L3$0)
     (AND (>= L3$0 0)
      (SOME (T3$0)
       (AND (>= T3$0 0)
        (SOME (M3$0)
         (AND (IN M3$0 (MS!MESSAGES))
          (SOME (P3$0)
           (AND (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND (IN P4$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$0 (NULLSET))))))))))))))))
  (NOT
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
 (SOME (L3$1)
  (AND (>= L3$1 0)
   (SOME (T3$1)
    (AND (>= T3$1 0)
     (SOME (M3$1)
      (AND (IN M3$1 (MS!MESSAGES))
       (SOME (P3$1)
        (AND (IN P3$1 (MS!PRINCIPALS))
         (SOME (P4$1)
          (AND (IN P4$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
Deleting
hypotheses (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
            (IMPLIES
             (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
              (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
              (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
              (NOT (FORGEABLE K PREVIOUS-STATE$0))
              (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
              (IN P1$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
               (HISTORY PREVIOUS-STATE$0))
              (NOT
               (SOME (L2$0)
                (AND (>= L2$0 0)
                 (SOME (T2$0)
                  (AND (>= T2$0 0)
                   (SOME (M2$0)
                    (AND (IN M2$0 (MS!MESSAGES))
                     (SOME (P2$0)
                      (AND (IN P2$0 (MS!PRINCIPALS))
                       (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
                        (HISTORY PREVIOUS-STATE$0))
                       (IN (MS!ENCRYPT M K)
                        (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
             (SOME (L3$0)
              (AND (>= L3$0 0)
               (SOME (T3$0)
                (AND (>= T3$0 0)
                 (SOME (M3$0)
                  (AND (IN M3$0 (MS!MESSAGES))
                   (SOME (P3$0)
                    (AND (IN P3$0 (MS!PRINCIPALS))
                     (SOME (P4$0)
                      (AND (IN P4$0 (MS!PRINCIPALS))
                       (SEQ!IS-MEMBER
                        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
                        (HISTORY PREVIOUS-STATE$0))
                       (IN (MS!ENCRYPT M K)
                        (MS!PARTS
                         (SETADD M3$0 (NULLSET)))))))))))))))) produces
...
(OR
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
   (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
   (NOT
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
   (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
   (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
   (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
      (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
      (NOT (FORGEABLE K PREVIOUS-STATE$0))
      (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
      (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
      (IN P1$0 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
       (HISTORY PREVIOUS-STATE$0))
      (NOT
       (SOME (L2$0)
        (AND (>= L2$0 0)
         (SOME (T2$0)
          (AND (>= T2$0 0)
           (SOME (M2$0)
            (AND (IN M2$0 (MS!MESSAGES))
             (SOME (P2$0)
              (AND (IN P2$0 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
                (HISTORY PREVIOUS-STATE$0))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
     (SOME (L3$0)
      (AND (>= L3$0 0)
       (SOME (T3$0)
        (AND (>= T3$0 0)
         (SOME (M3$0)
          (AND (IN M3$0 (MS!MESSAGES))
           (SOME (P3$0)
            (AND (IN P3$0 (MS!PRINCIPALS))
             (SOME (P4$0)
              (AND (IN P4$0 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
                (HISTORY PREVIOUS-STATE$0))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$0 (NULLSET))))))))))))))))
   (NOT
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))))
Starting case 1.2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (NOT
     (SOME (L2)
      (AND (>= L2 0)
       (SOME (T2)
        (AND (>= T2 0)
         (SOME (M2)
          (AND (IN M2 (MS!MESSAGES))
           (SOME (P2)
            (AND (IN P2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (NOT
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
 (SOME (L3$1)
  (AND (>= L3$1 0)
   (SOME (T3$1)
    (AND (>= T3$1 0)
     (SOME (M3$1)
      (AND (IN M3$1 (MS!MESSAGES))
       (SOME (P3$1)
        (AND (IN P3$1 (MS!PRINCIPALS))
         (SOME (P4$1)
          (AND (IN P4$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, GOOD-STEP-IMPLIES-GOOD-STATES,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, SEQ!TYPE-OF-IS-TACK,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS)))
 (IF (FORGEABLE K PREVIOUS-STATE)
  (OR
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (IF (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
   (OR
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
    (SOME (L3$0)
     (AND (>= L3$0 0)
      (SOME (T3$0)
       (AND (>= T3$0 0)
        (SOME (M3$0)
         (AND (IN M3$0 (MS!MESSAGES))
          (SOME (P3$0)
           (AND (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND (IN P4$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
   (IF (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
    (IF
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
     (IF
      (SOME (L2$1)
       (AND (>= L2$1 0)
        (SOME (T2$1)
         (AND (>= T2$1 0)
          (SOME (M2$1)
           (AND (IN M2$1 (MS!MESSAGES))
            (SOME (P2$1)
             (AND (IN P2$1 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
      (OR
       (SOME (L2$2)
        (AND (>= L2$2 0)
         (SOME (T2$2)
          (AND (>= T2$2 0)
           (SOME (M2$2)
            (AND (IN M2$2 (MS!MESSAGES))
             (SOME (P2$2)
              (AND (IN P2$2 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
                (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))
       (SOME (L3$1)
        (AND (>= L3$1 0)
         (SOME (T3$1)
          (AND (>= T3$1 0)
           (SOME (M3$1)
            (AND (IN M3$1 (MS!MESSAGES))
             (SOME (P3$1)
              (AND (IN P3$1 (MS!PRINCIPALS))
               (SOME (P4$1)
                (AND (IN P4$1 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
      (IMPLIES
       (AND
        (SOME (L3$2)
         (AND (>= L3$2 0)
          (SOME (T3$2)
           (AND (>= T3$2 0)
            (SOME (M3$2)
             (AND (IN M3$2 (MS!MESSAGES))
              (SOME (P3$2)
               (AND (IN P3$2 (MS!PRINCIPALS))
                (SOME (P4$2)
                 (AND (IN P4$2 (MS!PRINCIPALS))
                  (SEQ!IS-MEMBER
                   (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
                   (HISTORY PREVIOUS-STATE))
                  (IN (MS!ENCRYPT M K)
                   (MS!PARTS (SETADD M3$2 (NULLSET))))))))))))))
        (NOT
         (SOME (L2$3)
          (AND (>= L2$3 0)
           (SOME (T2$3)
            (AND (>= T2$3 0)
             (SOME (M2$3)
              (AND (IN M2$3 (MS!MESSAGES))
               (SOME (P2$3)
                (AND (IN P2$3 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
       (SOME (L3$3)
        (AND (>= L3$3 0)
         (SOME (T3$3)
          (AND (>= T3$3 0)
           (SOME (M3$3)
            (AND (IN M3$3 (MS!MESSAGES))
             (SOME (P3$3)
              (AND (IN P3$3 (MS!PRINCIPALS))
               (SOME (P4$3)
                (AND (IN P4$3 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$3 (NULLSET))))))))))))))))
     (OR
      (SOME (L2$4)
       (AND (>= L2$4 0)
        (SOME (T2$4)
         (AND (>= T2$4 0)
          (SOME (M2$4)
           (AND (IN M2$4 (MS!MESSAGES))
            (SOME (P2$4)
             (AND (IN P2$4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
               (HISTORY S))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))
      (SOME (L3$4)
       (AND (>= L3$4 0)
        (SOME (T3$4)
         (AND (>= T3$4 0)
          (SOME (M3$4)
           (AND (IN M3$4 (MS!MESSAGES))
            (SOME (P3$4)
             (AND (IN P3$4 (MS!PRINCIPALS))
              (SOME (P4$4)
               (AND (IN P4$4 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER
                 (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
                 (HISTORY S))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M3$4 (NULLSET))))))))))))))))
    (OR
     (SOME (L2$5)
      (AND (>= L2$5 0)
       (SOME (T2$5)
        (AND (>= T2$5 0)
         (SOME (M2$5)
          (AND (IN M2$5 (MS!MESSAGES))
           (SOME (P2$5)
            (AND (IN P2$5 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$5 T2$5 M2$5 P2$5)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$5 (NULLSET))))))))))))
     (SOME (L3$5)
      (AND (>= L3$5 0)
       (SOME (T3$5)
        (AND (>= T3$5 0)
         (SOME (M3$5)
          (AND (IN M3$5 (MS!MESSAGES))
           (SOME (P3$5)
            (AND (IN P3$5 (MS!PRINCIPALS))
             (SOME (P4$5)
              (AND (IN P4$5 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$5 T3$5 M3$5 P3$5 P4$5) (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$5 (NULLSET)))))))))))))))))))
Assuming FORGEABLE-MONOTONIC-OVER-GOOD-STEP with the
instantiations: (= M K) (= S0 PREVIOUS-STATE) (= S1 S) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (GOOD-STEP PREVIOUS-STATE S) (FORGEABLE K PREVIOUS-STATE))
   (FORGEABLE K S))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (GOOD-STEP PREVIOUS-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS)))
 (IF (FORGEABLE K PREVIOUS-STATE)
  (OR
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (IF (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
   (OR
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
    (SOME (L3$0)
     (AND (>= L3$0 0)
      (SOME (T3$0)
       (AND (>= T3$0 0)
        (SOME (M3$0)
         (AND (IN M3$0 (MS!MESSAGES))
          (SOME (P3$0)
           (AND (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND (IN P4$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
   (IF (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
    (IF
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
     (IF
      (SOME (L2$1)
       (AND (>= L2$1 0)
        (SOME (T2$1)
         (AND (>= T2$1 0)
          (SOME (M2$1)
           (AND (IN M2$1 (MS!MESSAGES))
            (SOME (P2$1)
             (AND (IN P2$1 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
      (OR
       (SOME (L2$2)
        (AND (>= L2$2 0)
         (SOME (T2$2)
          (AND (>= T2$2 0)
           (SOME (M2$2)
            (AND (IN M2$2 (MS!MESSAGES))
             (SOME (P2$2)
              (AND (IN P2$2 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
                (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))
       (SOME (L3$1)
        (AND (>= L3$1 0)
         (SOME (T3$1)
          (AND (>= T3$1 0)
           (SOME (M3$1)
            (AND (IN M3$1 (MS!MESSAGES))
             (SOME (P3$1)
              (AND (IN P3$1 (MS!PRINCIPALS))
               (SOME (P4$1)
                (AND (IN P4$1 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
      (IMPLIES
       (AND
        (SOME (L3$2)
         (AND (>= L3$2 0)
          (SOME (T3$2)
           (AND (>= T3$2 0)
            (SOME (M3$2)
             (AND (IN M3$2 (MS!MESSAGES))
              (SOME (P3$2)
               (AND (IN P3$2 (MS!PRINCIPALS))
                (SOME (P4$2)
                 (AND (IN P4$2 (MS!PRINCIPALS))
                  (SEQ!IS-MEMBER
                   (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
                   (HISTORY PREVIOUS-STATE))
                  (IN (MS!ENCRYPT M K)
                   (MS!PARTS (SETADD M3$2 (NULLSET))))))))))))))
        (NOT
         (SOME (L2$3)
          (AND (>= L2$3 0)
           (SOME (T2$3)
            (AND (>= T2$3 0)
             (SOME (M2$3)
              (AND (IN M2$3 (MS!MESSAGES))
               (SOME (P2$3)
                (AND (IN P2$3 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
       (SOME (L3$3)
        (AND (>= L3$3 0)
         (SOME (T3$3)
          (AND (>= T3$3 0)
           (SOME (M3$3)
            (AND (IN M3$3 (MS!MESSAGES))
             (SOME (P3$3)
              (AND (IN P3$3 (MS!PRINCIPALS))
               (SOME (P4$3)
                (AND (IN P4$3 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$3 (NULLSET))))))))))))))))
     (OR
      (SOME (L2$4)
       (AND (>= L2$4 0)
        (SOME (T2$4)
         (AND (>= T2$4 0)
          (SOME (M2$4)
           (AND (IN M2$4 (MS!MESSAGES))
            (SOME (P2$4)
             (AND (IN P2$4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
               (HISTORY S))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))
      (SOME (L3$4)
       (AND (>= L3$4 0)
        (SOME (T3$4)
         (AND (>= T3$4 0)
          (SOME (M3$4)
           (AND (IN M3$4 (MS!MESSAGES))
            (SOME (P3$4)
             (AND (IN P3$4 (MS!PRINCIPALS))
              (SOME (P4$4)
               (AND (IN P4$4 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER
                 (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
                 (HISTORY S))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M3$4 (NULLSET))))))))))))))))
    (OR
     (SOME (L2$5)
      (AND (>= L2$5 0)
       (SOME (T2$5)
        (AND (>= T2$5 0)
         (SOME (M2$5)
          (AND (IN M2$5 (MS!MESSAGES))
           (SOME (P2$5)
            (AND (IN P2$5 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$5 T2$5 M2$5 P2$5)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$5 (NULLSET))))))))))))
     (SOME (L3$5)
      (AND (>= L3$5 0)
       (SOME (T3$5)
        (AND (>= T3$5 0)
         (SOME (M3$5)
          (AND (IN M3$5 (MS!MESSAGES))
           (SOME (P3$5)
            (AND (IN P3$5 (MS!PRINCIPALS))
             (SOME (P4$5)
              (AND (IN P4$5 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$5 T3$5 M3$5 P3$5 P4$5) (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$5 (NULLSET)))))))))))))))))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS)))
 (IF (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (OR
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (IF (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (IF (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (IF
     (SOME (L2$0)
      (AND (>= L2$0 0)
       (SOME (T2$0)
        (AND (>= T2$0 0)
         (SOME (M2$0)
          (AND (IN M2$0 (MS!MESSAGES))
           (SOME (P2$0)
            (AND (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
     (OR
      (SOME (L2$1)
       (AND (>= L2$1 0)
        (SOME (T2$1)
         (AND (>= T2$1 0)
          (SOME (M2$1)
           (AND (IN M2$1 (MS!MESSAGES))
            (SOME (P2$1)
             (AND (IN P2$1 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
               (HISTORY S))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
      (SOME (L3$0)
       (AND (>= L3$0 0)
        (SOME (T3$0)
         (AND (>= T3$0 0)
          (SOME (M3$0)
           (AND (IN M3$0 (MS!MESSAGES))
            (SOME (P3$0)
             (AND (IN P3$0 (MS!PRINCIPALS))
              (SOME (P4$0)
               (AND (IN P4$0 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER
                 (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
                 (HISTORY S))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
     (IMPLIES
      (AND
       (SOME (L3$1)
        (AND (>= L3$1 0)
         (SOME (T3$1)
          (AND (>= T3$1 0)
           (SOME (M3$1)
            (AND (IN M3$1 (MS!MESSAGES))
             (SOME (P3$1)
              (AND (IN P3$1 (MS!PRINCIPALS))
               (SOME (P4$1)
                (AND (IN P4$1 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
                  (HISTORY PREVIOUS-STATE))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))
       (NOT
        (SOME (L2$2)
         (AND (>= L2$2 0)
          (SOME (T2$2)
           (AND (>= T2$2 0)
            (SOME (M2$2)
             (AND (IN M2$2 (MS!MESSAGES))
              (SOME (P2$2)
               (AND (IN P2$2 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
                 (HISTORY S))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
      (SOME (L3$2)
       (AND (>= L3$2 0)
        (SOME (T3$2)
         (AND (>= T3$2 0)
          (SOME (M3$2)
           (AND (IN M3$2 (MS!MESSAGES))
            (SOME (P3$2)
             (AND (IN P3$2 (MS!PRINCIPALS))
              (SOME (P4$2)
               (AND (IN P4$2 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER
                 (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
                 (HISTORY S))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M3$2 (NULLSET))))))))))))))))
    (OR
     (SOME (L2$3)
      (AND (>= L2$3 0)
       (SOME (T2$3)
        (AND (>= T2$3 0)
         (SOME (M2$3)
          (AND (IN M2$3 (MS!MESSAGES))
           (SOME (P2$3)
            (AND (IN P2$3 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))
     (SOME (L3$3)
      (AND (>= L3$3 0)
       (SOME (T3$3)
        (AND (>= T3$3 0)
         (SOME (M3$3)
          (AND (IN M3$3 (MS!MESSAGES))
           (SOME (P3$3)
            (AND (IN P3$3 (MS!PRINCIPALS))
             (SOME (P4$3)
              (AND (IN P4$3 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3) (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$3 (NULLSET))))))))))))))))
   (OR
    (SOME (L2$4)
     (AND (>= L2$4 0)
      (SOME (T2$4)
       (AND (>= T2$4 0)
        (SOME (M2$4)
         (AND (IN M2$4 (MS!MESSAGES))
          (SOME (P2$4)
           (AND (IN P2$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))
    (SOME (L3$4)
     (AND (>= L3$4 0)
      (SOME (T3$4)
       (AND (>= T3$4 0)
        (SOME (M3$4)
         (AND (IN M3$4 (MS!MESSAGES))
          (SOME (P3$4)
           (AND (IN P3$4 (MS!PRINCIPALS))
            (SOME (P4$4)
             (AND (IN P4$4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$4 (NULLSET))))))))))))))))))
Starting case 1.2.2.2 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Assuming KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GOOD-STEP with the
instantiations: (= M K) (= P P) (= S0 PREVIOUS-STATE) (= S1 S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (GOOD-STEP PREVIOUS-STATE S) (IN P (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (KNOWN-BY-PRINCIPAL K P S))
  (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT,
SEQ!LENGTH-NON-NEGATIVE, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Starting case 1.2.2.1 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)))
 (IF (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IF (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
   (IF
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
    (OR
     (SOME (L2$1)
      (AND (>= L2$1 0)
       (SOME (T2$1)
        (AND (>= T2$1 0)
         (SOME (M2$1)
          (AND (IN M2$1 (MS!MESSAGES))
           (SOME (P2$1)
            (AND (IN P2$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
     (SOME (L3$0)
      (AND (>= L3$0 0)
       (SOME (T3$0)
        (AND (>= T3$0 0)
         (SOME (M3$0)
          (AND (IN M3$0 (MS!MESSAGES))
           (SOME (P3$0)
            (AND (IN P3$0 (MS!PRINCIPALS))
             (SOME (P4$0)
              (AND (IN P4$0 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0) (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
    (IMPLIES
     (AND
      (SOME (L3$1)
       (AND (>= L3$1 0)
        (SOME (T3$1)
         (AND (>= T3$1 0)
          (SOME (M3$1)
           (AND (IN M3$1 (MS!MESSAGES))
            (SOME (P3$1)
             (AND (IN P3$1 (MS!PRINCIPALS))
              (SOME (P4$1)
               (AND (IN P4$1 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER
                 (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
                 (HISTORY PREVIOUS-STATE))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))
      (NOT
       (SOME (L2$2)
        (AND (>= L2$2 0)
         (SOME (T2$2)
          (AND (>= T2$2 0)
           (SOME (M2$2)
            (AND (IN M2$2 (MS!MESSAGES))
             (SOME (P2$2)
              (AND (IN P2$2 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
                (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
     (SOME (L3$2)
      (AND (>= L3$2 0)
       (SOME (T3$2)
        (AND (>= T3$2 0)
         (SOME (M3$2)
          (AND (IN M3$2 (MS!MESSAGES))
           (SOME (P3$2)
            (AND (IN P3$2 (MS!PRINCIPALS))
             (SOME (P4$2)
              (AND (IN P4$2 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2) (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$2 (NULLSET))))))))))))))))
   (OR
    (SOME (L2$3)
     (AND (>= L2$3 0)
      (SOME (T2$3)
       (AND (>= T2$3 0)
        (SOME (M2$3)
         (AND (IN M2$3 (MS!MESSAGES))
          (SOME (P2$3)
           (AND (IN P2$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))
    (SOME (L3$3)
     (AND (>= L3$3 0)
      (SOME (T3$3)
       (AND (>= T3$3 0)
        (SOME (M3$3)
         (AND (IN M3$3 (MS!MESSAGES))
          (SOME (P3$3)
           (AND (IN P3$3 (MS!PRINCIPALS))
            (SOME (P4$3)
             (AND (IN P4$3 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$3 (NULLSET))))))))))))))))
  (OR
   (SOME (L2$4)
    (AND (>= L2$4 0)
     (SOME (T2$4)
      (AND (>= T2$4 0)
       (SOME (M2$4)
        (AND (IN M2$4 (MS!MESSAGES))
         (SOME (P2$4)
          (AND (IN P2$4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))
   (SOME (L3$4)
    (AND (>= L3$4 0)
     (SOME (T3$4)
      (AND (>= T3$4 0)
       (SOME (M3$4)
        (AND (IN M3$4 (MS!MESSAGES))
         (SOME (P3$4)
          (AND (IN P3$4 (MS!PRINCIPALS))
           (SOME (P4$4)
            (AND (IN P4$4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$4 (NULLSET)))))))))))))))))
Starting case 1.2.2.1.2 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
 (IF (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (IF
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
   (OR
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
    (SOME (L3$0)
     (AND (>= L3$0 0)
      (SOME (T3$0)
       (AND (>= T3$0 0)
        (SOME (M3$0)
         (AND (IN M3$0 (MS!MESSAGES))
          (SOME (P3$0)
           (AND (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND (IN P4$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
   (IMPLIES
    (AND
     (SOME (L3$1)
      (AND (>= L3$1 0)
       (SOME (T3$1)
        (AND (>= T3$1 0)
         (SOME (M3$1)
          (AND (IN M3$1 (MS!MESSAGES))
           (SOME (P3$1)
            (AND (IN P3$1 (MS!PRINCIPALS))
             (SOME (P4$1)
              (AND (IN P4$1 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
                (HISTORY PREVIOUS-STATE))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))
     (NOT
      (SOME (L2$2)
       (AND (>= L2$2 0)
        (SOME (T2$2)
         (AND (>= T2$2 0)
          (SOME (M2$2)
           (AND (IN M2$2 (MS!MESSAGES))
            (SOME (P2$2)
             (AND (IN P2$2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
    (SOME (L3$2)
     (AND (>= L3$2 0)
      (SOME (T3$2)
       (AND (>= T3$2 0)
        (SOME (M3$2)
         (AND (IN M3$2 (MS!MESSAGES))
          (SOME (P3$2)
           (AND (IN P3$2 (MS!PRINCIPALS))
            (SOME (P4$2)
             (AND (IN P4$2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$2 (NULLSET))))))))))))))))
  (OR
   (SOME (L2$3)
    (AND (>= L2$3 0)
     (SOME (T2$3)
      (AND (>= T2$3 0)
       (SOME (M2$3)
        (AND (IN M2$3 (MS!MESSAGES))
         (SOME (P2$3)
          (AND (IN P2$3 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))
   (SOME (L3$3)
    (AND (>= L3$3 0)
     (SOME (T3$3)
      (AND (>= T3$3 0)
       (SOME (M3$3)
        (AND (IN M3$3 (MS!MESSAGES))
         (SOME (P3$3)
          (AND (IN P3$3 (MS!PRINCIPALS))
           (SOME (P4$3)
            (AND (IN P4$3 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))))
Starting case 1.2.2.1.2.2 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (IF
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (OR
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
   (SOME (L3$0)
    (AND (>= L3$0 0)
     (SOME (T3$0)
      (AND (>= T3$0 0)
       (SOME (M3$0)
        (AND (IN M3$0 (MS!MESSAGES))
         (SOME (P3$0)
          (AND (IN P3$0 (MS!PRINCIPALS))
           (SOME (P4$0)
            (AND (IN P4$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
  (IMPLIES
   (AND
    (SOME (L3$1)
     (AND (>= L3$1 0)
      (SOME (T3$1)
       (AND (>= T3$1 0)
        (SOME (M3$1)
         (AND (IN M3$1 (MS!MESSAGES))
          (SOME (P3$1)
           (AND (IN P3$1 (MS!PRINCIPALS))
            (SOME (P4$1)
             (AND (IN P4$1 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))
    (NOT
     (SOME (L2$2)
      (AND (>= L2$2 0)
       (SOME (T2$2)
        (AND (>= T2$2 0)
         (SOME (M2$2)
          (AND (IN M2$2 (MS!MESSAGES))
           (SOME (P2$2)
            (AND (IN P2$2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
   (SOME (L3$2)
    (AND (>= L3$2 0)
     (SOME (T3$2)
      (AND (>= T3$2 0)
       (SOME (M3$2)
        (AND (IN M3$2 (MS!MESSAGES))
         (SOME (P3$2)
          (AND (IN P3$2 (MS!PRINCIPALS))
           (SOME (P4$2)
            (AND (IN P4$2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= S
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (IF
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (OR
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (IMPLIES
   (AND
    (SOME (L3$0)
     (AND (>= L3$0 0)
      (SOME (T3$0)
       (AND (>= T3$0 0)
        (SOME (M3$0)
         (AND (IN M3$0 (MS!MESSAGES))
          (SOME (P3$0)
           (AND (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND (IN P4$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$0 (NULLSET))))))))))))))
    (NOT
     (SOME (L2$1)
      (AND (>= L2$1 0)
       (SOME (T2$1)
        (AND (>= T2$1 0)
         (SOME (M2$1)
          (AND (IN M2$1 (MS!MESSAGES))
           (SOME (P2$1)
            (AND (IN P2$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
   (SOME (L3$1)
    (AND (>= L3$1 0)
     (SOME (T3$1)
      (AND (>= T3$1 0)
       (SOME (M3$1)
        (AND (IN M3$1 (MS!MESSAGES))
         (SOME (P3$1)
          (AND (IN P3$1 (MS!PRINCIPALS))
           (SOME (P4$1)
            (AND (IN P4$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= S
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (IF
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (OR
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
   (SOME (L3$0)
    (AND (>= L3$0 0)
     (SOME (T3$0)
      (AND (>= T3$0 0)
       (SOME (M3$0)
        (AND (IN M3$0 (MS!MESSAGES))
         (SOME (P3$0)
          (AND (IN P3$0 (MS!PRINCIPALS))
           (SOME (P4$0)
            (AND (IN P4$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
  (IMPLIES
   (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (HISTORY PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
    (NOT
     (SOME (L2$1)
      (AND (>= L2$1 0)
       (SOME (T2$1)
        (AND (>= T2$1 0)
         (SOME (M2$1)
          (AND (IN M2$1 (MS!MESSAGES))
           (SOME (P2$1)
            (AND (IN P2$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
   (SOME (L3$1)
    (AND (>= L3$1 0)
     (SOME (T3$1)
      (AND (>= T3$1 0)
       (SOME (M3$1)
        (AND (IN M3$1 (MS!MESSAGES))
         (SOME (P3$1)
          (AND (IN P3$1 (MS!PRINCIPALS))
           (SOME (P4$1)
            (AND (IN P4$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (NOT (>= L3 0)) (NOT (>= T3 0)) (NOT (IN M3 (MS!MESSAGES)))
  (NOT (IN P3 (MS!PRINCIPALS))) (NOT (IN P4 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (NOT (>= L3 0)) (NOT (>= T3 0)) (NOT (IN M3 (MS!MESSAGES)))
  (NOT (IN P3 (MS!PRINCIPALS))) (NOT (IN P4 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (NOT (>= L3 0)) (NOT (>= T3 0)) (NOT (IN M3 (MS!MESSAGES)))
  (NOT (IN P3 (MS!PRINCIPALS))) (NOT (IN P4 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (NOT (>= L3 0)) (NOT (>= T3 0)) (NOT (IN M3 (MS!MESSAGES)))
  (NOT (IN P3 (MS!PRINCIPALS))) (NOT (IN P4 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (NOT (>= L3 0)) (NOT (>= T3 0)) (NOT (IN M3 (MS!MESSAGES)))
  (NOT (IN P3 (MS!PRINCIPALS))) (NOT (IN P4 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (NOT (>= L3 0)) (NOT (>= T3 0)) (NOT (IN M3 (MS!MESSAGES)))
  (NOT (IN P3 (MS!PRINCIPALS))) (NOT (IN P4 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
  (SOME (L2$1)
   (AND (>= L2$1 0)
    (SOME (T2$1)
     (AND (>= T2$1 0)
      (SOME (M2$1)
       (AND (IN M2$1 (MS!MESSAGES))
        (SOME (P2$1)
         (AND (IN P2$1 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET))))))))))))))))
Substituting (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
             (= S
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
                 PREVIOUS-STATE))))
             (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
             (= S
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
                 PREVIOUS-STATE))))
             (= S
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
                 PREVIOUS-STATE))))
             (= S
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
                 PREVIOUS-STATE)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (NOT
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
             (SEQ!TAIL
              (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
   (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
   (NOT
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (NOT
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (SEQ!TAIL
              (HISTORY
               (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
                PREVIOUS-STATE))))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))))
   (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
   (NOT
    (SOME (L2$2)
     (AND (>= L2$2 0)
      (SOME (T2$2)
       (AND (>= T2$2 0)
        (SOME (M2$2)
         (AND (IN M2$2 (MS!MESSAGES))
          (SOME (P2$2)
           (AND (IN P2$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (NOT
    (SOME (L2$3)
     (AND (>= L2$3 0)
      (SOME (T2$3)
       (AND (>= T2$3 0)
        (SOME (M2$3)
         (AND (IN M2$3 (MS!MESSAGES))
          (SOME (P2$3)
           (AND (IN P2$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
             (SEQ!TAIL
              (HISTORY
               (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET)))))))))))))
   (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
   (NOT
    (SOME (L2$4)
     (AND (>= L2$4 0)
      (SOME (T2$4)
       (AND (>= T2$4 0)
        (SOME (M2$4)
         (AND (IN M2$4 (MS!MESSAGES))
          (SOME (P2$4)
           (AND (IN P2$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
  (SOME (L3$2)
   (AND (>= L3$2 0)
    (SOME (T3$2)
     (AND (>= T3$2 0)
      (SOME (M3$2)
       (AND (IN M3$2 (MS!MESSAGES))
        (SOME (P3$2)
         (AND (IN P3$2 (MS!PRINCIPALS))
          (SOME (P4$2)
           (AND (IN P4$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (NOT
    (SOME (L2$5)
     (AND (>= L2$5 0)
      (SOME (T2$5)
       (AND (>= T2$5 0)
        (SOME (M2$5)
         (AND (IN M2$5 (MS!MESSAGES))
          (SOME (P2$5)
           (AND (IN P2$5 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$5 T2$5 M2$5 P2$5)
             (SEQ!TAIL
              (HISTORY
               (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$5 (NULLSET)))))))))))))
   (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
   (NOT
    (SOME (L2$6)
     (AND (>= L2$6 0)
      (SOME (T2$6)
       (AND (>= T2$6 0)
        (SOME (M2$6)
         (AND (IN M2$6 (MS!MESSAGES))
          (SOME (P2$6)
           (AND (IN P2$6 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$6 T2$6 M2$6 P2$6)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$6 (NULLSET))))))))))))))
  (SOME (L3$3)
   (AND (>= L3$3 0)
    (SOME (T3$3)
     (AND (>= T3$3 0)
      (SOME (M3$3)
       (AND (IN M3$3 (MS!MESSAGES))
        (SOME (P3$3)
         (AND (IN P3$3 (MS!PRINCIPALS))
          (SOME (P4$3)
           (AND (IN P4$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (NOT
    (SOME (L2$7)
     (AND (>= L2$7 0)
      (SOME (T2$7)
       (AND (>= T2$7 0)
        (SOME (M2$7)
         (AND (IN M2$7 (MS!MESSAGES))
          (SOME (P2$7)
           (AND (IN P2$7 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$7 T2$7 M2$7 P2$7)
             (SEQ!TAIL
              (HISTORY
               (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
                PREVIOUS-STATE))))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$7 (NULLSET)))))))))))))
   (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
   (NOT
    (SOME (L2$8)
     (AND (>= L2$8 0)
      (SOME (T2$8)
       (AND (>= T2$8 0)
        (SOME (M2$8)
         (AND (IN M2$8 (MS!MESSAGES))
          (SOME (P2$8)
           (AND (IN P2$8 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$8 T2$8 M2$8 P2$8)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$8 (NULLSET))))))))))))))
  (SOME (L3$4)
   (AND (>= L3$4 0)
    (SOME (T3$4)
     (AND (>= T3$4 0)
      (SOME (M3$4)
       (AND (IN M3$4 (MS!MESSAGES))
        (SOME (P3$4)
         (AND (IN P3$4 (MS!PRINCIPALS))
          (SOME (P4$4)
           (AND (IN P4$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$4 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (NOT
    (SOME (L2$9)
     (AND (>= L2$9 0)
      (SOME (T2$9)
       (AND (>= T2$9 0)
        (SOME (M2$9)
         (AND (IN M2$9 (MS!MESSAGES))
          (SOME (P2$9)
           (AND (IN P2$9 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$9 T2$9 M2$9 P2$9)
             (SEQ!TAIL
              (HISTORY
               (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
                PREVIOUS-STATE))))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$9 (NULLSET)))))))))))))
   (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
   (NOT
    (SOME (L2$10)
     (AND (>= L2$10 0)
      (SOME (T2$10)
       (AND (>= T2$10 0)
        (SOME (M2$10)
         (AND (IN M2$10 (MS!MESSAGES))
          (SOME (P2$10)
           (AND (IN P2$10 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$10 T2$10 M2$10 P2$10)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M2$10 (NULLSET))))))))))))))
  (SOME (L3$5)
   (AND (>= L3$5 0)
    (SOME (T3$5)
     (AND (>= T3$5 0)
      (SOME (M3$5)
       (AND (IN M3$5 (MS!MESSAGES))
        (SOME (P3$5)
         (AND (IN P3$5 (MS!PRINCIPALS))
          (SOME (P4$5)
           (AND (IN P4$5 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$5 T3$5 M3$5 P3$5 P4$5)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$5 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (SOME (L2$11)
    (AND (>= L2$11 0)
     (SOME (T2$11)
      (AND (>= T2$11 0)
       (SOME (M2$11)
        (AND (IN M2$11 (MS!MESSAGES))
         (SOME (P2$11)
          (AND (IN P2$11 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$11 T2$11 M2$11 P2$11)
            (SEQ!TAIL
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$11 (NULLSET))))))))))))
   (NOT
    (SOME (L2$12)
     (AND (>= L2$12 0)
      (SOME (T2$12)
       (AND (>= T2$12 0)
        (SOME (M2$12)
         (AND (IN M2$12 (MS!MESSAGES))
          (SOME (P2$12)
           (AND (IN P2$12 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$12 T2$12 M2$12 P2$12)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M2$12 (NULLSET))))))))))))))
  (SOME (L3$6)
   (AND (>= L3$6 0)
    (SOME (T3$6)
     (AND (>= T3$6 0)
      (SOME (M3$6)
       (AND (IN M3$6 (MS!MESSAGES))
        (SOME (P3$6)
         (AND (IN P3$6 (MS!PRINCIPALS))
          (SOME (P4$6)
           (AND (IN P4$6 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$6 T3$6 M3$6 P3$6 P4$6)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$6 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (SOME (L2$13)
    (AND (>= L2$13 0)
     (SOME (T2$13)
      (AND (>= T2$13 0)
       (SOME (M2$13)
        (AND (IN M2$13 (MS!MESSAGES))
         (SOME (P2$13)
          (AND (IN P2$13 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$13 T2$13 M2$13 P2$13)
            (SEQ!TAIL
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$13 (NULLSET))))))))))))
   (NOT
    (SOME (L2$14)
     (AND (>= L2$14 0)
      (SOME (T2$14)
       (AND (>= T2$14 0)
        (SOME (M2$14)
         (AND (IN M2$14 (MS!MESSAGES))
          (SOME (P2$14)
           (AND (IN P2$14 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$14 T2$14 M2$14 P2$14)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M2$14 (NULLSET))))))))))))))
  (SOME (L3$7)
   (AND (>= L3$7 0)
    (SOME (T3$7)
     (AND (>= T3$7 0)
      (SOME (M3$7)
       (AND (IN M3$7 (MS!MESSAGES))
        (SOME (P3$7)
         (AND (IN P3$7 (MS!PRINCIPALS))
          (SOME (P4$7)
           (AND (IN P4$7 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$7 T3$7 M3$7 P3$7 P4$7)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$7 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (SOME (L2$15)
    (AND (>= L2$15 0)
     (SOME (T2$15)
      (AND (>= T2$15 0)
       (SOME (M2$15)
        (AND (IN M2$15 (MS!MESSAGES))
         (SOME (P2$15)
          (AND (IN P2$15 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$15 T2$15 M2$15 P2$15)
            (SEQ!TAIL
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$15 (NULLSET))))))))))))
   (NOT
    (SOME (L2$16)
     (AND (>= L2$16 0)
      (SOME (T2$16)
       (AND (>= T2$16 0)
        (SOME (M2$16)
         (AND (IN M2$16 (MS!MESSAGES))
          (SOME (P2$16)
           (AND (IN P2$16 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$16 T2$16 M2$16 P2$16)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M2$16 (NULLSET))))))))))))))
  (SOME (L3$8)
   (AND (>= L3$8 0)
    (SOME (T3$8)
     (AND (>= T3$8 0)
      (SOME (M3$8)
       (AND (IN M3$8 (MS!MESSAGES))
        (SOME (P3$8)
         (AND (IN P3$8 (MS!PRINCIPALS))
          (SOME (P4$8)
           (AND (IN P4$8 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$8 T3$8 M3$8 P3$8 P4$8)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$8 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (SOME (L2$17)
    (AND (>= L2$17 0)
     (SOME (T2$17)
      (AND (>= T2$17 0)
       (SOME (M2$17)
        (AND (IN M2$17 (MS!MESSAGES))
         (SOME (P2$17)
          (AND (IN P2$17 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$17 T2$17 M2$17 P2$17)
            (SEQ!TAIL
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$17 (NULLSET))))))))))))
   (NOT
    (SOME (L2$18)
     (AND (>= L2$18 0)
      (SOME (T2$18)
       (AND (>= T2$18 0)
        (SOME (M2$18)
         (AND (IN M2$18 (MS!MESSAGES))
          (SOME (P2$18)
           (AND (IN P2$18 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$18 T2$18 M2$18 P2$18)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M2$18 (NULLSET))))))))))))))
  (SOME (L3$9)
   (AND (>= L3$9 0)
    (SOME (T3$9)
     (AND (>= T3$9 0)
      (SOME (M3$9)
       (AND (IN M3$9 (MS!MESSAGES))
        (SOME (P3$9)
         (AND (IN P3$9 (MS!PRINCIPALS))
          (SOME (P4$9)
           (AND (IN P4$9 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$9 T3$9 M3$9 P3$9 P4$9)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$9 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (SOME (L2$19)
    (AND (>= L2$19 0)
     (SOME (T2$19)
      (AND (>= T2$19 0)
       (SOME (M2$19)
        (AND (IN M2$19 (MS!MESSAGES))
         (SOME (P2$19)
          (AND (IN P2$19 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$19 T2$19 M2$19 P2$19)
            (SEQ!TAIL
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
               PREVIOUS-STATE))))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$19 (NULLSET))))))))))))
   (NOT
    (SOME (L2$20)
     (AND (>= L2$20 0)
      (SOME (T2$20)
       (AND (>= T2$20 0)
        (SOME (M2$20)
         (AND (IN M2$20 (MS!MESSAGES))
          (SOME (P2$20)
           (AND (IN P2$20 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$20 T2$20 M2$20 P2$20)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M2$20 (NULLSET))))))))))))))
  (SOME (L3$10)
   (AND (>= L3$10 0)
    (SOME (T3$10)
     (AND (>= T3$10 0)
      (SOME (M3$10)
       (AND (IN M3$10 (MS!MESSAGES))
        (SOME (P3$10)
         (AND (IN P3$10 (MS!PRINCIPALS))
          (SOME (P4$10)
           (AND (IN P4$10 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER
             (MAKE-OUT-OF-BAND-EVENT L3$10 T3$10 M3$10 P3$10 P4$10)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$10 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (SEQ!IS-MEMBER
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (SOME (L2$21)
    (AND (>= L2$21 0)
     (SOME (T2$21)
      (AND (>= T2$21 0)
       (SOME (M2$21)
        (AND (IN M2$21 (MS!MESSAGES))
         (SOME (P2$21)
          (AND (IN P2$21 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$21 T2$21 M2$21 P2$21)
            (SEQ!TAIL
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE))))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$21 (NULLSET))))))))))))
   (NOT
    (SOME (L2$22)
     (AND (>= L2$22 0)
      (SOME (T2$22)
       (AND (>= T2$22 0)
        (SOME (M2$22)
         (AND (IN M2$22 (MS!MESSAGES))
          (SOME (P2$22)
           (AND (IN P2$22 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$22 T2$22 M2$22 P2$22)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M2$22 (NULLSET))))))))))))))
  (SOME (L3$11)
   (AND (>= L3$11 0)
    (SOME (T3$11)
     (AND (>= T3$11 0)
      (SOME (M3$11)
       (AND (IN M3$11 (MS!MESSAGES))
        (SOME (P3$11)
         (AND (IN P3$11 (MS!PRINCIPALS))
          (SOME (P4$11)
           (AND (IN P4$11 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER
             (MAKE-OUT-OF-BAND-EVENT L3$11 T3$11 M3$11 P3$11 P4$11)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$11 (NULLSET))))))))))))))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, SEQ!IS-MEMBER-TACK,
SETADD.DEFINITION, MS!PARTS-SETADD-ATOMIC, STORAGE-OF-GENERATE-STEP,
KNOWN-BY-PRINCIPAL-GENERATE-STEP-ATOMIC-CASE,
FORGEABLE-PRESERVED-BY-GENERATE-STEP, GENERATE-EVENT-EQUALITY,
HISTORY-OF-GENERATE-STEP, SEQ!LENGTH-TACK, HISTORY-OF-INTRUDER-STEP,
MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-OUT-OF-BAND-EVENT, MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
TAIL-IS-SEQUENCE, SEQ!TYPE-OF-IS-TACK, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
TAG-OF-MAKE-INTRUDER-EVENT, MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT, TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY
 with the
instantiations (= L2$1 L2$2) (= T2$1 T2$2) (= M2$1 M2$2) (= P2$1 P2$2)
               (= M3$1 M3) (= P4$1 P4) (= P3$1 P3) (= T3$1 T3) (= L3$1 L3) to
...
(TRUE)
Starting case 1.2.2.1.2.1 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2$3)
    (AND (>= L2$3 0)
     (SOME (T2$3)
      (AND (>= T2$3 0)
       (SOME (M2$3)
        (AND (IN M2$3 (MS!MESSAGES))
         (SOME (P2$3)
          (AND (IN P2$3 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
 (SOME (L3$3)
  (AND (>= L3$3 0)
   (SOME (T3$3)
    (AND (>= T3$3 0)
     (SOME (M3$3)
      (AND (IN M3$3 (MS!MESSAGES))
       (SOME (P3$3)
        (AND (IN P3$3 (MS!PRINCIPALS))
         (SOME (P4$3)
          (AND (IN P4$3 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= S
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= S
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
Substituting (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
             (= S
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
                 PREVIOUS-STATE))))
             (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
             (= S
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
                 PREVIOUS-STATE))))
             (= S
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
                 PREVIOUS-STATE))))
             (= S
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
                 PREVIOUS-STATE))))
             (= (MAKE-GENERATE-EVENT L T K P1)
              (SEQ!HEAD
               (HISTORY
                (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
                 PREVIOUS-STATE)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
     (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))))
   (NOT
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY
       (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY
       (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$2)
     (AND (>= L2$2 0)
      (SOME (T2$2)
       (AND (>= T2$2 0)
        (SOME (M2$2)
         (AND (IN M2$2 (MS!MESSAGES))
          (SOME (P2$2)
           (AND (IN P2$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
  (SOME (L3$2)
   (AND (>= L3$2 0)
    (SOME (T3$2)
     (AND (>= T3$2 0)
      (SOME (M3$2)
       (AND (IN M3$2 (MS!MESSAGES))
        (SOME (P3$2)
         (AND (IN P3$2 (MS!PRINCIPALS))
          (SOME (P4$2)
           (AND (IN P4$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$3)
     (AND (>= L2$3 0)
      (SOME (T2$3)
       (AND (>= T2$3 0)
        (SOME (M2$3)
         (AND (IN M2$3 (MS!MESSAGES))
          (SOME (P2$3)
           (AND (IN P2$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
  (SOME (L3$3)
   (AND (>= L3$3 0)
    (SOME (T3$3)
     (AND (>= T3$3 0)
      (SOME (M3$3)
       (AND (IN M3$3 (MS!MESSAGES))
        (SOME (P3$3)
         (AND (IN P3$3 (MS!PRINCIPALS))
          (SOME (P4$3)
           (AND (IN P4$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (NOT
    (SEQ!IS-MEMBER
     (SEQ!HEAD
      (HISTORY
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
     (SEQ!TAIL
      (HISTORY
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
        PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$4)
     (AND (>= L2$4 0)
      (SOME (T2$4)
       (AND (>= T2$4 0)
        (SOME (M2$4)
         (AND (IN M2$4 (MS!MESSAGES))
          (SOME (P2$4)
           (AND (IN P2$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
  (SOME (L3$4)
   (AND (>= L3$4 0)
    (SOME (T3$4)
     (AND (>= T3$4 0)
      (SOME (M3$4)
       (AND (IN M3$4 (MS!MESSAGES))
        (SOME (P3$4)
         (AND (IN P3$4 (MS!PRINCIPALS))
          (SOME (P4$4)
           (AND (IN P4$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$4 (NULLSET))))))))))))))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, SEQ!IS-MEMBER-TACK,
SETADD.DEFINITION, MS!PARTS-SETADD-ATOMIC, STORAGE-OF-GENERATE-STEP,
KNOWN-BY-PRINCIPAL-GENERATE-STEP-ATOMIC-CASE,
FORGEABLE-PRESERVED-BY-GENERATE-STEP, GENERATE-EVENT-EQUALITY,
HISTORY-OF-GENERATE-STEP, SEQ!LENGTH-TACK, HISTORY-OF-INTRUDER-STEP,
MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
TAG-OF-MAKE-OUT-OF-BAND-EVENT, MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
TAIL-IS-SEQUENCE, SEQ!TYPE-OF-IS-TACK, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
TAG-OF-MAKE-INTRUDER-EVENT, MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT, TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (= L LABEL) (= T TIME) (= K MESSAGE)
  (= P1 PRINCIPAL$1)
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT
   (AND (= P PRINCIPAL$1)
    (NOT
     (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
      PREVIOUS-STATE))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2 T2 M2 P2)
    (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Assuming FRESH-IN-ALL-MESSAGES-IMPLIES-FRESH-IN-STORAGE-OF-PRINCIPAL with the
instantiations: (= MESSAGE MESSAGE) (= PRINCIPAL P)
                (= STATE PREVIOUS-STATE) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-STATE PREVIOUS-STATE) (IN P (MS!PRINCIPALS))
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
   (MS!IS-FRESH MESSAGE (STORAGE-OF P PREVIOUS-STATE)))
  (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (= L LABEL) (= T TIME) (= K MESSAGE)
  (= P1 PRINCIPAL$1)
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT
   (AND (= P PRINCIPAL$1)
    (NOT
     (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
      PREVIOUS-STATE))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2 T2 M2 P2)
    (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Invoking (MS!IS-FRESH MESSAGE (STORAGE-OF P PREVIOUS-STATE)) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-STATE PREVIOUS-STATE) (IN P (MS!PRINCIPALS))
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
   (AND (NOT (IN MESSAGE (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
    (NOT
     (SOME (M$0)
      (IN (MS!ENCRYPT M$0 MESSAGE) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))))
    (NOT
     (SOME (M$1)
      (IN (MS!ENCRYPT M$1 (MS!INVERSE MESSAGE))
       (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))))
    (ALL (M$2 K2)
     (AND
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 MESSAGE K2)
        (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2)
        (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K2 MESSAGE)
        (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K2 (MS!INVERSE MESSAGE))
        (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))))))
  (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL$1 (MS!PRINCIPALS))
  (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (= L LABEL) (= T TIME) (= K MESSAGE)
  (= P1 PRINCIPAL$1)
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT
   (AND (= P PRINCIPAL$1)
    (NOT
     (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)
      PREVIOUS-STATE))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL$1)
    (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2 T2 M2 P2)
    (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Instantiating (= M$0 M) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-STATE PREVIOUS-STATE) (IN P (MS!PRINCIPALS))
    (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
   (AND (NOT (IN MESSAGE (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
    (NOT
     (OR (IN (MS!ENCRYPT M MESSAGE) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
      (SOME (M$0)
       (IN (MS!ENCRYPT M$0 MESSAGE)
        (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))))
    (NOT
     (SOME (M$1)
      (IN (MS!ENCRYPT M$1 (MS!INVERSE MESSAGE))
       (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))))
    (ALL (M$2 K2)
     (AND
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 MESSAGE K2)
        (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE MESSAGE) K2)
        (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K2 MESSAGE)
        (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K2 (MS!INVERSE MESSAGE))
        (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))))))
  (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
  (NOT (IN MESSAGE (MS!PRINCIPALS))) (NOT (IN MESSAGE (MS!TEXT-MESSAGES)))
  (NOT (IN MESSAGE (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH MESSAGE (SEEN-MESSAGES PREVIOUS-STATE))
  (MS!IS-FRESH MESSAGE (ALL-STORAGE (STORES PREVIOUS-STATE)))
  (IN PRINCIPAL (MS!PRINCIPALS))
  (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (= L LABEL) (= T TIME) (= K MESSAGE)
  (= P1 PRINCIPAL)
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT
   (AND (= P PRINCIPAL)
    (NOT
     (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)
      PREVIOUS-STATE))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (NOT
   (SOME (L2 T2 M2 P2)
    (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, SEQ!TACK-HEAD-TAIL,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TIME-CONSTRAINT-IMPLIES-NAT,
>=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!TAG-OF-SHARE-ENCRYPT,
MS!SHENDT-SHARE-ENCRYPT, MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
STORAGE-OF-IS-SUBSET-MESSAGES, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Starting case 1.2.2.1.1 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SOME (L2$4)
    (AND (>= L2$4 0)
     (SOME (T2$4)
      (AND (>= T2$4 0)
       (SOME (M2$4)
        (AND (IN M2$4 (MS!MESSAGES))
         (SOME (P2$4)
          (AND (IN P2$4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
 (SOME (L3$4)
  (AND (>= L3$4 0)
   (SOME (T3$4)
    (AND (>= T3$4 0)
     (SOME (M3$4)
      (AND (IN M3$4 (MS!MESSAGES))
       (SOME (P3$4)
        (AND (IN P3$4 (MS!PRINCIPALS))
         (SOME (P4$4)
          (AND (IN P4$4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$4 (NULLSET)))))))))))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= S
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= S
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SEQ!IS-SEQUENCE (HISTORY S)) (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS))) (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
Substituting (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= S
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= S
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= S
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= S
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (SOME (L2$2)
     (AND (>= L2$2 0)
      (SOME (T2$2)
       (AND (>= T2$2 0)
        (SOME (M2$2)
         (AND (IN M2$2 (MS!MESSAGES))
          (SOME (P2$2)
           (AND (IN P2$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
  (SOME (L3$2)
   (AND (>= L3$2 0)
    (SOME (T3$2)
     (AND (>= T3$2 0)
      (SOME (M3$2)
       (AND (IN M3$2 (MS!MESSAGES))
        (SOME (P3$2)
         (AND (IN P3$2 (MS!PRINCIPALS))
          (SOME (P4$2)
           (AND (IN P4$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (SOME (L2$3)
     (AND (>= L2$3 0)
      (SOME (T2$3)
       (AND (>= T2$3 0)
        (SOME (M2$3)
         (AND (IN M2$3 (MS!MESSAGES))
          (SOME (P2$3)
           (AND (IN P2$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
  (SOME (L3$3)
   (AND (>= L3$3 0)
    (SOME (T3$3)
     (AND (>= T3$3 0)
      (SOME (M3$3)
       (AND (IN M3$3 (MS!MESSAGES))
        (SOME (P3$3)
         (AND (IN P3$3 (MS!PRINCIPALS))
          (SOME (P4$3)
           (AND (IN P4$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    1)
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (SEQ!IS-SEQUENCE
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (SOME (L2$4)
     (AND (>= L2$4 0)
      (SOME (T2$4)
       (AND (>= T2$4 0)
        (SOME (M2$4)
         (AND (IN M2$4 (MS!MESSAGES))
          (SOME (P2$4)
           (AND (IN P2$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
  (SOME (L3$4)
   (AND (>= L3$4 0)
    (SOME (T3$4)
     (AND (>= T3$4 0)
      (SOME (M3$4)
       (AND (IN M3$4 (MS!MESSAGES))
        (SOME (P3$4)
         (AND (IN P3$4 (MS!PRINCIPALS))
          (SOME (P4$4)
           (AND (IN P4$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$4 (NULLSET))))))))))))))))
Which simplifies
 when rewriting with HISTORY-OF-OUT-OF-BAND-STEP, HISTORY-OF-CONSTRUCT-STEP,
HISTORY-OF-RECEIVE-STEP, HISTORY-OF-SEND-STEP, SETADD.DEFINITION,
MS!PARTS-SETADD-ATOMIC, STORAGE-OF-GENERATE-STEP,
KNOWN-BY-PRINCIPAL-GENERATE-STEP-ATOMIC-CASE,
FORGEABLE-PRESERVED-BY-GENERATE-STEP, GENERATE-EVENT-EQUALITY,
HISTORY-OF-GENERATE-STEP, SEQ!LENGTH-TACK, HISTORY-OF-INTRUDER-STEP,
MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, SEQ!TACK-HEAD-TAIL, TAG-OF-INTRUDER-EVENT,
INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
>=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-CONSTRUCT-EVENT,
LABEL-OF-CONSTRUCT-EVENT, TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
TAG-OF-MAKE-INTRUDER-EVENT, MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT, TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
 (SOME (L3$1)
  (AND (>= L3$1 0)
   (SOME (T3$1)
    (AND (>= T3$1 0)
     (SOME (M3$1)
      (AND (IN M3$1 (MS!MESSAGES))
       (SOME (P3$1)
        (AND (IN P3$1 (MS!PRINCIPALS))
         (SOME (P4$1)
          (AND (IN P4$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
Invoking (IS-GOOD-EVOLUTION-STATE S) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE$0)
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (GOOD-STEP PREVIOUS-STATE$0 S))))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Which simplifies
 when rewriting with SEQ!EMPTYP-DEFINITION
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, SEQ!NOT-IS-TACK-FACTS,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, TAG-OF-RECEIVE-EVENT,
RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
  (SOME (PREVIOUS-STATE$0)
   (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (GOOD-STEP PREVIOUS-STATE$0 S)))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Instantiating (= PREVIOUS-STATE$0 PREVIOUS-STATE) (= L$0 L) (= T$0 T)
              (= P1$0 P1) gives
...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (NOT
     (SOME (L2)
      (AND (>= L2 0)
       (SOME (T2)
        (AND (>= T2 0)
         (SOME (M2)
          (AND (IN M2 (MS!MESSAGES))
           (SOME (P2)
            (AND (IN P2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE$0))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
     (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY PREVIOUS-STATE$0))
     (NOT
      (SOME (L2$0)
       (AND (>= L2$0 0)
        (SOME (T2$0)
         (AND (>= T2$0 0)
          (SOME (M2$0)
           (AND (IN M2$0 (MS!MESSAGES))
            (SOME (P2$0)
             (AND (IN P2$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
    (SOME (L3$0)
     (AND (>= L3$0 0)
      (SOME (T3$0)
       (AND (>= T3$0 0)
        (SOME (M3$0)
         (AND (IN M3$0 (MS!MESSAGES))
          (SOME (P3$0)
           (AND (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND (IN P4$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
               (HISTORY PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$0 (NULLSET))))))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
 (SOME (L3$1)
  (AND (>= L3$1 0)
   (SOME (T3$1)
    (AND (>= T3$1 0)
     (SOME (M3$1)
      (AND (IN M3$1 (MS!MESSAGES))
       (SOME (P3$1)
        (AND (IN P3$1 (MS!PRINCIPALS))
         (SOME (P4$1)
          (AND (IN P4$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
Deleting
hypotheses (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
            (IMPLIES
             (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
              (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
              (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
              (NOT (FORGEABLE K PREVIOUS-STATE$0))
              (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
              (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
              (IN P1$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
               (HISTORY PREVIOUS-STATE$0))
              (NOT
               (SOME (L2$0)
                (AND (>= L2$0 0)
                 (SOME (T2$0)
                  (AND (>= T2$0 0)
                   (SOME (M2$0)
                    (AND (IN M2$0 (MS!MESSAGES))
                     (SOME (P2$0)
                      (AND (IN P2$0 (MS!PRINCIPALS))
                       (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
                        (HISTORY PREVIOUS-STATE$0))
                       (IN (MS!ENCRYPT M K)
                        (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
             (SOME (L3$0)
              (AND (>= L3$0 0)
               (SOME (T3$0)
                (AND (>= T3$0 0)
                 (SOME (M3$0)
                  (AND (IN M3$0 (MS!MESSAGES))
                   (SOME (P3$0)
                    (AND (IN P3$0 (MS!PRINCIPALS))
                     (SOME (P4$0)
                      (AND (IN P4$0 (MS!PRINCIPALS))
                       (SEQ!IS-MEMBER
                        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
                        (HISTORY PREVIOUS-STATE$0))
                       (IN (MS!ENCRYPT M K)
                        (MS!PARTS
                         (SETADD M3$0 (NULLSET)))))))))))))))) produces
...
(OR
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
   (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
   (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
   (NOT
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
     (NOT (FORGEABLE K PREVIOUS-STATE))
     (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
     (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
     (NOT
      (SOME (L2)
       (AND (>= L2 0)
        (SOME (T2)
         (AND (>= T2 0)
          (SOME (M2)
           (AND (IN M2 (MS!MESSAGES))
            (SOME (P2)
             (AND (IN P2 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
    (SOME (L3)
     (AND (>= L3 0)
      (SOME (T3)
       (AND (>= T3 0)
        (SOME (M3)
         (AND (IN M3 (MS!MESSAGES))
          (SOME (P3)
           (AND (IN P3 (MS!PRINCIPALS))
            (SOME (P4)
             (AND (IN P4 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
   (ALL (PREVIOUS-STATE$0 L$0 T$0 P1$0)
    (IMPLIES
     (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY S)))
      (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0) (IN M (MS!MESSAGES))
      (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
      (NOT (FORGEABLE K PREVIOUS-STATE$0))
      (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE$0))
      (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE$0)))
      (IN P1$0 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
       (HISTORY PREVIOUS-STATE$0))
      (NOT
       (SOME (L2$0)
        (AND (>= L2$0 0)
         (SOME (T2$0)
          (AND (>= T2$0 0)
           (SOME (M2$0)
            (AND (IN M2$0 (MS!MESSAGES))
             (SOME (P2$0)
              (AND (IN P2$0 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
                (HISTORY PREVIOUS-STATE$0))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
     (SOME (L3$0)
      (AND (>= L3$0 0)
       (SOME (T3$0)
        (AND (>= T3$0 0)
         (SOME (M3$0)
          (AND (IN M3$0 (MS!MESSAGES))
           (SOME (P3$0)
            (AND (IN P3$0 (MS!PRINCIPALS))
             (SOME (P4$0)
              (AND (IN P4$0 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
                (HISTORY PREVIOUS-STATE$0))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$0 (NULLSET))))))))))))))))
   (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
   (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
   (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
   (NOT
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY S))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))))
Starting case 1.1.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
    (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)) (NOT (FORGEABLE K PREVIOUS-STATE))
    (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
    (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
    (NOT
     (SOME (L2)
      (AND (>= L2 0)
       (SOME (T2)
        (AND (>= T2 0)
         (SOME (M2)
          (AND (IN M2 (MS!MESSAGES))
           (SOME (P2)
            (AND (IN P2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S)
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
 (SOME (L3$1)
  (AND (>= L3$1 0)
   (SOME (T3$1)
    (AND (>= T3$1 0)
     (SOME (M3$1)
      (AND (IN M3$1 (MS!MESSAGES))
       (SOME (P3$1)
        (AND (IN P3$1 (MS!PRINCIPALS))
         (SOME (P4$1)
          (AND (IN P4$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
GOOD-STEP-IMPLIES-GOOD-STATES, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)))
 (IF (FORGEABLE K PREVIOUS-STATE)
  (IMPLIES
   (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
    (NOT (KNOWN-BY-PRINCIPAL K P S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
    (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
    (NOT
     (SOME (L2)
      (AND (>= L2 0)
       (SOME (T2)
        (AND (>= T2 0)
         (SOME (M2)
          (AND (IN M2 (MS!MESSAGES))
           (SOME (P2)
            (AND (IN P2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (IF (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
   (IMPLIES
    (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
     (NOT (KNOWN-BY-PRINCIPAL K P S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
     (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
     (NOT
      (SOME (L2$0)
       (AND (>= L2$0 0)
        (SOME (T2$0)
         (AND (>= T2$0 0)
          (SOME (M2$0)
           (AND (IN M2$0 (MS!MESSAGES))
            (SOME (P2$0)
             (AND (IN P2$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
    (SOME (L3$0)
     (AND (>= L3$0 0)
      (SOME (T3$0)
       (AND (>= T3$0 0)
        (SOME (M3$0)
         (AND (IN M3$0 (MS!MESSAGES))
          (SOME (P3$0)
           (AND (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND (IN P4$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
   (IF (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
    (IMPLIES
     (AND (IN P1 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
     (IF
      (SOME (L2$1)
       (AND (>= L2$1 0)
        (SOME (T2$1)
         (AND (>= T2$1 0)
          (SOME (M2$1)
           (AND (IN M2$1 (MS!MESSAGES))
            (SOME (P2$1)
             (AND (IN P2$1 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
      (IMPLIES
       (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
        (NOT (KNOWN-BY-PRINCIPAL K P S))
        (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
        (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
        (NOT
         (SOME (L2$2)
          (AND (>= L2$2 0)
           (SOME (T2$2)
            (AND (>= T2$2 0)
             (SOME (M2$2)
              (AND (IN M2$2 (MS!MESSAGES))
               (SOME (P2$2)
                (AND (IN P2$2 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
       (SOME (L3$1)
        (AND (>= L3$1 0)
         (SOME (T3$1)
          (AND (>= T3$1 0)
           (SOME (M3$1)
            (AND (IN M3$1 (MS!MESSAGES))
             (SOME (P3$1)
              (AND (IN P3$1 (MS!PRINCIPALS))
               (SOME (P4$1)
                (AND (IN P4$1 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
      (IMPLIES
       (AND
        (SOME (L3$2)
         (AND (>= L3$2 0)
          (SOME (T3$2)
           (AND (>= T3$2 0)
            (SOME (M3$2)
             (AND (IN M3$2 (MS!MESSAGES))
              (SOME (P3$2)
               (AND (IN P3$2 (MS!PRINCIPALS))
                (SOME (P4$2)
                 (AND (IN P4$2 (MS!PRINCIPALS))
                  (SEQ!IS-MEMBER
                   (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
                   (HISTORY PREVIOUS-STATE))
                  (IN (MS!ENCRYPT M K)
                   (MS!PARTS (SETADD M3$2 (NULLSET))))))))))))))
        (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
        (NOT (KNOWN-BY-PRINCIPAL K P S))
        (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
        (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
        (NOT
         (SOME (L2$3)
          (AND (>= L2$3 0)
           (SOME (T2$3)
            (AND (>= T2$3 0)
             (SOME (M2$3)
              (AND (IN M2$3 (MS!MESSAGES))
               (SOME (P2$3)
                (AND (IN P2$3 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
       (SOME (L3$3)
        (AND (>= L3$3 0)
         (SOME (T3$3)
          (AND (>= T3$3 0)
           (SOME (M3$3)
            (AND (IN M3$3 (MS!MESSAGES))
             (SOME (P3$3)
              (AND (IN P3$3 (MS!PRINCIPALS))
               (SOME (P4$3)
                (AND (IN P4$3 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))))
    (IMPLIES
     (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
      (NOT (KNOWN-BY-PRINCIPAL K P S))
      (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
      (IN P1 (MS!PRINCIPALS))
      (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
      (NOT
       (SOME (L2$4)
        (AND (>= L2$4 0)
         (SOME (T2$4)
          (AND (>= T2$4 0)
           (SOME (M2$4)
            (AND (IN M2$4 (MS!MESSAGES))
             (SOME (P2$4)
              (AND (IN P2$4 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
                (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
     (SOME (L3$4)
      (AND (>= L3$4 0)
       (SOME (T3$4)
        (AND (>= T3$4 0)
         (SOME (M3$4)
          (AND (IN M3$4 (MS!MESSAGES))
           (SOME (P3$4)
            (AND (IN P3$4 (MS!PRINCIPALS))
             (SOME (P4$4)
              (AND (IN P4$4 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4) (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$4 (NULLSET)))))))))))))))))))
Assuming FORGEABLE-MONOTONIC-OVER-GOOD-STEP with the
instantiations: (= M K) (= S0 PREVIOUS-STATE) (= S1 S) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (GOOD-STEP PREVIOUS-STATE S) (FORGEABLE K PREVIOUS-STATE))
   (FORGEABLE K S))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)))
 (IF (FORGEABLE K PREVIOUS-STATE)
  (IMPLIES
   (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
    (NOT (KNOWN-BY-PRINCIPAL K P S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
    (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
    (NOT
     (SOME (L2)
      (AND (>= L2 0)
       (SOME (T2)
        (AND (>= T2 0)
         (SOME (M2)
          (AND (IN M2 (MS!MESSAGES))
           (SOME (P2)
            (AND (IN P2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (IF (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
   (IMPLIES
    (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
     (NOT (KNOWN-BY-PRINCIPAL K P S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
     (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
     (NOT
      (SOME (L2$0)
       (AND (>= L2$0 0)
        (SOME (T2$0)
         (AND (>= T2$0 0)
          (SOME (M2$0)
           (AND (IN M2$0 (MS!MESSAGES))
            (SOME (P2$0)
             (AND (IN P2$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
    (SOME (L3$0)
     (AND (>= L3$0 0)
      (SOME (T3$0)
       (AND (>= T3$0 0)
        (SOME (M3$0)
         (AND (IN M3$0 (MS!MESSAGES))
          (SOME (P3$0)
           (AND (IN P3$0 (MS!PRINCIPALS))
            (SOME (P4$0)
             (AND (IN P4$0 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
   (IF (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
    (IMPLIES
     (AND (IN P1 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
     (IF
      (SOME (L2$1)
       (AND (>= L2$1 0)
        (SOME (T2$1)
         (AND (>= T2$1 0)
          (SOME (M2$1)
           (AND (IN M2$1 (MS!MESSAGES))
            (SOME (P2$1)
             (AND (IN P2$1 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))
      (IMPLIES
       (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
        (NOT (KNOWN-BY-PRINCIPAL K P S))
        (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
        (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
        (NOT
         (SOME (L2$2)
          (AND (>= L2$2 0)
           (SOME (T2$2)
            (AND (>= T2$2 0)
             (SOME (M2$2)
              (AND (IN M2$2 (MS!MESSAGES))
               (SOME (P2$2)
                (AND (IN P2$2 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
       (SOME (L3$1)
        (AND (>= L3$1 0)
         (SOME (T3$1)
          (AND (>= T3$1 0)
           (SOME (M3$1)
            (AND (IN M3$1 (MS!MESSAGES))
             (SOME (P3$1)
              (AND (IN P3$1 (MS!PRINCIPALS))
               (SOME (P4$1)
                (AND (IN P4$1 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
      (IMPLIES
       (AND
        (SOME (L3$2)
         (AND (>= L3$2 0)
          (SOME (T3$2)
           (AND (>= T3$2 0)
            (SOME (M3$2)
             (AND (IN M3$2 (MS!MESSAGES))
              (SOME (P3$2)
               (AND (IN P3$2 (MS!PRINCIPALS))
                (SOME (P4$2)
                 (AND (IN P4$2 (MS!PRINCIPALS))
                  (SEQ!IS-MEMBER
                   (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
                   (HISTORY PREVIOUS-STATE))
                  (IN (MS!ENCRYPT M K)
                   (MS!PARTS (SETADD M3$2 (NULLSET))))))))))))))
        (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
        (NOT (KNOWN-BY-PRINCIPAL K P S))
        (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
        (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
        (NOT
         (SOME (L2$3)
          (AND (>= L2$3 0)
           (SOME (T2$3)
            (AND (>= T2$3 0)
             (SOME (M2$3)
              (AND (IN M2$3 (MS!MESSAGES))
               (SOME (P2$3)
                (AND (IN P2$3 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
       (SOME (L3$3)
        (AND (>= L3$3 0)
         (SOME (T3$3)
          (AND (>= T3$3 0)
           (SOME (M3$3)
            (AND (IN M3$3 (MS!MESSAGES))
             (SOME (P3$3)
              (AND (IN P3$3 (MS!PRINCIPALS))
               (SOME (P4$3)
                (AND (IN P4$3 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
                  (HISTORY S))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))))
    (IMPLIES
     (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K S))
      (NOT (KNOWN-BY-PRINCIPAL K P S))
      (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
      (IN P1 (MS!PRINCIPALS))
      (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
      (NOT
       (SOME (L2$4)
        (AND (>= L2$4 0)
         (SOME (T2$4)
          (AND (>= T2$4 0)
           (SOME (M2$4)
            (AND (IN M2$4 (MS!MESSAGES))
             (SOME (P2$4)
              (AND (IN P2$4 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
                (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
     (SOME (L3$4)
      (AND (>= L3$4 0)
       (SOME (T3$4)
        (AND (>= T3$4 0)
         (SOME (M3$4)
          (AND (IN M3$4 (MS!MESSAGES))
           (SOME (P3$4)
            (AND (IN P3$4 (MS!PRINCIPALS))
             (SOME (P4$4)
              (AND (IN P4$4 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4) (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$4 (NULLSET)))))))))))))))))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS)))
 (IF (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IMPLIES
   (AND (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
    (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
    (NOT
     (SOME (L2)
      (AND (>= L2 0)
       (SOME (T2)
        (AND (>= T2 0)
         (SOME (M2)
          (AND (IN M2 (MS!MESSAGES))
           (SOME (P2)
            (AND (IN P2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY S))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (IF (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (IMPLIES
    (AND (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
    (IF
     (SOME (L2$0)
      (AND (>= L2$0 0)
       (SOME (T2$0)
        (AND (>= T2$0 0)
         (SOME (M2$0)
          (AND (IN M2$0 (MS!MESSAGES))
           (SOME (P2$0)
            (AND (IN P2$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
     (IMPLIES
      (AND (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
       (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
       (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
       (NOT
        (SOME (L2$1)
         (AND (>= L2$1 0)
          (SOME (T2$1)
           (AND (>= T2$1 0)
            (SOME (M2$1)
             (AND (IN M2$1 (MS!MESSAGES))
              (SOME (P2$1)
               (AND (IN P2$1 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
                 (HISTORY S))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
      (SOME (L3$0)
       (AND (>= L3$0 0)
        (SOME (T3$0)
         (AND (>= T3$0 0)
          (SOME (M3$0)
           (AND (IN M3$0 (MS!MESSAGES))
            (SOME (P3$0)
             (AND (IN P3$0 (MS!PRINCIPALS))
              (SOME (P4$0)
               (AND (IN P4$0 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER
                 (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
                 (HISTORY S))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
     (IMPLIES
      (AND
       (SOME (L3$1)
        (AND (>= L3$1 0)
         (SOME (T3$1)
          (AND (>= T3$1 0)
           (SOME (M3$1)
            (AND (IN M3$1 (MS!MESSAGES))
             (SOME (P3$1)
              (AND (IN P3$1 (MS!PRINCIPALS))
               (SOME (P4$1)
                (AND (IN P4$1 (MS!PRINCIPALS))
                 (SEQ!IS-MEMBER
                  (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
                  (HISTORY PREVIOUS-STATE))
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))
       (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
       (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
       (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
       (NOT
        (SOME (L2$2)
         (AND (>= L2$2 0)
          (SOME (T2$2)
           (AND (>= T2$2 0)
            (SOME (M2$2)
             (AND (IN M2$2 (MS!MESSAGES))
              (SOME (P2$2)
               (AND (IN P2$2 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
                 (HISTORY S))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
      (SOME (L3$2)
       (AND (>= L3$2 0)
        (SOME (T3$2)
         (AND (>= T3$2 0)
          (SOME (M3$2)
           (AND (IN M3$2 (MS!MESSAGES))
            (SOME (P3$2)
             (AND (IN P3$2 (MS!PRINCIPALS))
              (SOME (P4$2)
               (AND (IN P4$2 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER
                 (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
                 (HISTORY S))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))))
   (IMPLIES
    (AND (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
     (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
     (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
     (NOT
      (SOME (L2$3)
       (AND (>= L2$3 0)
        (SOME (T2$3)
         (AND (>= T2$3 0)
          (SOME (M2$3)
           (AND (IN M2$3 (MS!MESSAGES))
            (SOME (P2$3)
             (AND (IN P2$3 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
    (SOME (L3$3)
     (AND (>= L3$3 0)
      (SOME (T3$3)
       (AND (>= T3$3 0)
        (SOME (M3$3)
         (AND (IN M3$3 (MS!MESSAGES))
          (SOME (P3$3)
           (AND (IN P3$3 (MS!PRINCIPALS))
            (SOME (P4$3)
             (AND (IN P4$3 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
               (HISTORY S))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$3 (NULLSET))))))))))))))))))
Starting case 1.1.2.2 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE) (NOT (FORGEABLE K S))
  (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Assuming KNOWN-BY-PRINCIPAL-MONOTONIC-OVER-GOOD-STEP with the
instantiations: (= M K) (= P P) (= S0 PREVIOUS-STATE) (= S1 S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (GOOD-STEP PREVIOUS-STATE S) (IN P (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (KNOWN-BY-PRINCIPAL K P S))
  (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE) (NOT (FORGEABLE K S))
  (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Starting case 1.1.2.1 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)))
 (IF (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IMPLIES
   (AND (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
   (IF
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
    (IMPLIES
     (AND (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
      (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
      (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
      (NOT
       (SOME (L2$1)
        (AND (>= L2$1 0)
         (SOME (T2$1)
          (AND (>= T2$1 0)
           (SOME (M2$1)
            (AND (IN M2$1 (MS!MESSAGES))
             (SOME (P2$1)
              (AND (IN P2$1 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
                (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
     (SOME (L3$0)
      (AND (>= L3$0 0)
       (SOME (T3$0)
        (AND (>= T3$0 0)
         (SOME (M3$0)
          (AND (IN M3$0 (MS!MESSAGES))
           (SOME (P3$0)
            (AND (IN P3$0 (MS!PRINCIPALS))
             (SOME (P4$0)
              (AND (IN P4$0 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0) (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
    (IMPLIES
     (AND
      (SOME (L3$1)
       (AND (>= L3$1 0)
        (SOME (T3$1)
         (AND (>= T3$1 0)
          (SOME (M3$1)
           (AND (IN M3$1 (MS!MESSAGES))
            (SOME (P3$1)
             (AND (IN P3$1 (MS!PRINCIPALS))
              (SOME (P4$1)
               (AND (IN P4$1 (MS!PRINCIPALS))
                (SEQ!IS-MEMBER
                 (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
                 (HISTORY PREVIOUS-STATE))
                (IN (MS!ENCRYPT M K)
                 (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))
      (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
      (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
      (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
      (NOT
       (SOME (L2$2)
        (AND (>= L2$2 0)
         (SOME (T2$2)
          (AND (>= T2$2 0)
           (SOME (M2$2)
            (AND (IN M2$2 (MS!MESSAGES))
             (SOME (P2$2)
              (AND (IN P2$2 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
                (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
     (SOME (L3$2)
      (AND (>= L3$2 0)
       (SOME (T3$2)
        (AND (>= T3$2 0)
         (SOME (M3$2)
          (AND (IN M3$2 (MS!MESSAGES))
           (SOME (P3$2)
            (AND (IN P3$2 (MS!PRINCIPALS))
             (SOME (P4$2)
              (AND (IN P4$2 (MS!PRINCIPALS))
               (SEQ!IS-MEMBER
                (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2) (HISTORY S))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))))
  (IMPLIES
   (AND (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
    (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
    (NOT
     (SOME (L2$3)
      (AND (>= L2$3 0)
       (SOME (T2$3)
        (AND (>= T2$3 0)
         (SOME (M2$3)
          (AND (IN M2$3 (MS!MESSAGES))
           (SOME (P2$3)
            (AND (IN P2$3 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
   (SOME (L3$3)
    (AND (>= L3$3 0)
     (SOME (T3$3)
      (AND (>= T3$3 0)
       (SOME (M3$3)
        (AND (IN M3$3 (MS!MESSAGES))
         (SOME (P3$3)
          (AND (IN P3$3 (MS!PRINCIPALS))
           (SOME (P4$3)
            (AND (IN P4$3 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))))
Starting case 1.1.2.1.2 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (IF
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (IMPLIES
   (AND (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
    (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
    (NOT
     (SOME (L2$1)
      (AND (>= L2$1 0)
       (SOME (T2$1)
        (AND (>= T2$1 0)
         (SOME (M2$1)
          (AND (IN M2$1 (MS!MESSAGES))
           (SOME (P2$1)
            (AND (IN P2$1 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
   (SOME (L3$0)
    (AND (>= L3$0 0)
     (SOME (T3$0)
      (AND (>= T3$0 0)
       (SOME (M3$0)
        (AND (IN M3$0 (MS!MESSAGES))
         (SOME (P3$0)
          (AND (IN P3$0 (MS!PRINCIPALS))
           (SOME (P4$0)
            (AND (IN P4$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
  (IMPLIES
   (AND
    (SOME (L3$1)
     (AND (>= L3$1 0)
      (SOME (T3$1)
       (AND (>= T3$1 0)
        (SOME (M3$1)
         (AND (IN M3$1 (MS!MESSAGES))
          (SOME (P3$1)
           (AND (IN P3$1 (MS!PRINCIPALS))
            (SOME (P4$1)
             (AND (IN P4$1 (MS!PRINCIPALS))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))
    (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
    (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
    (NOT
     (SOME (L2$2)
      (AND (>= L2$2 0)
       (SOME (T2$2)
        (AND (>= T2$2 0)
         (SOME (M2$2)
          (AND (IN M2$2 (MS!MESSAGES))
           (SOME (P2$2)
            (AND (IN P2$2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
   (SOME (L3$2)
    (AND (>= L3$2 0)
     (SOME (T3$2)
      (AND (>= T3$2 0)
       (SOME (M3$2)
        (AND (IN M3$2 (MS!MESSAGES))
         (SOME (P3$2)
          (AND (IN P3$2 (MS!PRINCIPALS))
           (SOME (P4$2)
            (AND (IN P4$2 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
              (HISTORY S))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))))
Starting case 1.1.2.1.2.2 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (SOME (L2$1)
    (AND (>= L2$1 0)
     (SOME (T2$1)
      (AND (>= T2$1 0)
       (SOME (M2$1)
        (AND (IN M2$1 (MS!MESSAGES))
         (SOME (P2$1)
          (AND (IN P2$1 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= S
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
           (HISTORY PREVIOUS-STATE))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= S
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (FORGEABLE K S))
  (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT (>= L2 0)) (NOT (>= T2 0)) (NOT (IN M2 (MS!MESSAGES)))
  (NOT (IN P2 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT (>= L2 0)) (NOT (>= T2 0)) (NOT (IN M2 (MS!MESSAGES)))
  (NOT (IN P2 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT (>= L2 0)) (NOT (>= T2 0)) (NOT (IN M2 (MS!MESSAGES)))
  (NOT (IN P2 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT (>= L2 0)) (NOT (>= T2 0)) (NOT (IN M2 (MS!MESSAGES)))
  (NOT (IN P2 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT (>= L2 0)) (NOT (>= T2 0)) (NOT (IN M2 (MS!MESSAGES)))
  (NOT (IN P2 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
  (NOT (>= L2 0)) (NOT (>= T2 0)) (NOT (IN M2 (MS!MESSAGES)))
  (NOT (IN P2 (MS!PRINCIPALS)))
  (NOT
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE)))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))) (FORGEABLE K S)
  (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (SOME (L2$0)
   (AND (>= L2$0 0)
    (SOME (T2$0)
     (AND (>= T2$0 0)
      (SOME (M2$0)
       (AND (IN M2$0 (MS!MESSAGES))
        (SOME (P2$0)
         (AND (IN P2$0 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
Substituting (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
             (= S
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1
                 PREVIOUS-STATE))))
             (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
             (= S
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0
                 PREVIOUS-STATE))))
             (= S
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2
                 PREVIOUS-STATE))))
             (= S
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE))
             (= (HISTORY PREVIOUS-STATE)
              (SEQ!TAIL
               (HISTORY
                (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
                 PREVIOUS-STATE)))) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$2)
     (AND (>= L2$2 0)
      (SOME (T2$2)
       (AND (>= T2$2 0)
        (SOME (M2$2)
         (AND (IN M2$2 (MS!MESSAGES))
          (SOME (P2$2)
           (AND (IN P2$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$3)
     (AND (>= L2$3 0)
      (SOME (T2$3)
       (AND (>= T2$3 0)
        (SOME (M2$3)
         (AND (IN M2$3 (MS!MESSAGES))
          (SOME (P2$3)
           (AND (IN P2$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
  (SOME (L3$2)
   (AND (>= L3$2 0)
    (SOME (T3$2)
     (AND (>= T3$2 0)
      (SOME (M3$2)
       (AND (IN M3$2 (MS!MESSAGES))
        (SOME (P3$2)
         (AND (IN P3$2 (MS!PRINCIPALS))
          (SOME (P4$2)
           (AND (IN P4$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$4)
     (AND (>= L2$4 0)
      (SOME (T2$4)
       (AND (>= T2$4 0)
        (SOME (M2$4)
         (AND (IN M2$4 (MS!MESSAGES))
          (SOME (P2$4)
           (AND (IN P2$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
  (SOME (L3$3)
   (AND (>= L3$3 0)
    (SOME (T3$3)
     (AND (>= T3$3 0)
      (SOME (M3$3)
       (AND (IN M3$3 (MS!MESSAGES))
        (SOME (P3$3)
         (AND (IN P3$3 (MS!PRINCIPALS))
          (SOME (P4$3)
           (AND (IN P4$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
        PREVIOUS-STATE)))))
   (NOT
    (SOME (L2$5)
     (AND (>= L2$5 0)
      (SOME (T2$5)
       (AND (>= T2$5 0)
        (SOME (M2$5)
         (AND (IN M2$5 (MS!MESSAGES))
          (SOME (P2$5)
           (AND (IN P2$5 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$5 T2$5 M2$5 P2$5)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$5 (NULLSET))))))))))))))
  (SOME (L3$4)
   (AND (>= L3$4 0)
    (SOME (T3$4)
     (AND (>= T3$4 0)
      (SOME (M3$4)
       (AND (IN M3$4 (MS!MESSAGES))
        (SOME (P3$4)
         (AND (IN P3$4 (MS!PRINCIPALS))
          (SOME (P4$4)
           (AND (IN P4$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$4 (NULLSET))))))))))))))))
Which simplifies
 when rewriting with STORAGE-OF-OUT-OF-BAND-STEP,
FORGEABLE-PRESERVED-BY-OUT-OF-BAND-STEP, HISTORY-OF-OUT-OF-BAND-STEP,
STORAGE-OF-CONSTRUCT-STEP, KNOWN-BY-PRINCIPAL-PRESERVED-BY-CONSTRUCT-STEP,
FORGEABLE-PRESERVED-BY-CONSTRUCT-STEP, HISTORY-OF-CONSTRUCT-STEP,
RECEIVE-EVENT-EQUALITY, STORAGE-OF-RECEIVE-STEP,
FORGEABLE-PRESERVED-BY-RECEIVE-STEP, HISTORY-OF-RECEIVE-STEP,
STORAGE-OF-SEND-STEP, KNOWN-BY-PRINCIPAL-PRESERVED-BY-SEND-STEP,
HISTORY-OF-SEND-STEP, GENERATE-EVENT-EQUALITY, SETADD.DEFINITION,
MS!PARTS-SETADD-ATOMIC, STORAGE-OF-GENERATE-STEP,
KNOWN-BY-PRINCIPAL-GENERATE-STEP-ATOMIC-CASE,
FORGEABLE-PRESERVED-BY-GENERATE-STEP, HISTORY-OF-GENERATE-STEP,
SEQ!IS-MEMBER-TACK, STORAGE-OF-INTRUDER-STEP,
KNOWN-BY-PRINCIPAL-PRESERVED-BY-INTRUDER-STEP, SEQ!LENGTH-TACK,
HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION,
UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, TAG-OF-RECEIVE-EVENT,
RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, SEQ!TACK-HEAD-TAIL,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!SET-OF-MESSAGES-NOT-EMPTY, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
TAIL-IS-SEQUENCE, SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE,
SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK,
TAG-OF-MAKE-INTRUDER-EVENT, MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT,
LABEL-OF-INTRUDER-EVENT, TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY
 with the
instantiations (= M2$0 M2) (= P2$0 P2) (= T2$0 T2) (= L2$0 L2) (= M2$1 M2)
               (= P2$1 P2) (= T2$1 T2) (= L2$1 L2) (= M2$2 M2) (= P2$2 P2)
               (= T2$2 T2) (= L2$2 L2) (= M2$4 M2) (= P2$4 P2) (= T2$4 T2)
               (= L2$4 L2) (= M2$5 M2) (= P2$5 P2) (= T2$5 T2) (= L2$5 L2) to
...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
  (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (IMPLIES (= P PRINCIPAL$0)
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE)))))
  (NOT
   (SOME (L2$0 T2$0 M2$0 P2$0)
    (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
     (IN P2$0 (MS!PRINCIPALS))
     (OR
      (AND (= L2$0 LABEL) (= T2$0 TIME) (= M2$0 MESSAGE) (= P2$0 PRINCIPAL$0))
      (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
       (HISTORY PREVIOUS-STATE)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Instantiating (= L2$0 L2) (= T2$0 T2) (= M2$0 M2) (= P2$0 P2) gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (IMPLIES (= P PRINCIPAL)
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE)))))
  (NOT
   (OR
    (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (OR (AND (= L2 LABEL) (= T2 TIME) (= M2 MESSAGE) (= P2 PRINCIPAL))
      (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
       (HISTORY PREVIOUS-STATE)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
    (SOME (L2$0 T2$0 M2$0 P2$0)
     (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
      (IN P2$0 (MS!PRINCIPALS))
      (OR
       (AND (= L2$0 LABEL) (= T2$0 TIME) (= M2$0 MESSAGE) (= P2$0 PRINCIPAL))
       (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
        (HISTORY PREVIOUS-STATE)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, SEQ!TACK-HEAD-TAIL,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Starting case 1.1.2.1.2.1 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET))))))))))))))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (SOME (L2$2)
    (AND (>= L2$2 0)
     (SOME (T2$2)
      (AND (>= T2$2 0)
       (SOME (M2$2)
        (AND (IN M2$2 (MS!MESSAGES))
         (SOME (P2$2)
          (AND (IN P2$2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
 (SOME (L3$2)
  (AND (>= L3$2 0)
   (SOME (T3$2)
    (AND (>= T3$2 0)
     (SOME (M3$2)
      (AND (IN M3$2 (MS!MESSAGES))
       (SOME (P3$2)
        (AND (IN P3$2 (MS!PRINCIPALS))
         (SOME (P4$2)
          (AND (IN P4$2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))) (NOT (FORGEABLE K S))
  (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Instantiating (= L3$0 L3) (= T3$0 T3) (= M3$0 M3) (= P3$0 P3)
              (= P4$0 P4) gives
...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))) (NOT (FORGEABLE K S))
  (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
  (NOT
   (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
 (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
  (AND (>= L3$0 0) (>= T3$0 0) (IN M3$0 (MS!MESSAGES))
   (IN P3$0 (MS!PRINCIPALS)) (IN P4$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
    (HISTORY S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))) (NOT (FORGEABLE K S))
  (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
  (NOT (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Invoking (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
          (HISTORY S)) gives
...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY PREVIOUS-STATE))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))) (NOT (FORGEABLE K S))
  (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S)))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
  (NOT
   (AND (SEQ!IS-TACK (HISTORY S))
    (OR (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (SEQ!HEAD (HISTORY S)))
     (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
      (SEQ!TAIL (HISTORY S)))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, GOOD-STEP-IMPLIES-GOOD-STATES
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.1.2.1.1 ...
(IMPLIES
 (AND (GOOD-STEP PREVIOUS-STATE S) (NOT (FORGEABLE K PREVIOUS-STATE))
  (>= (SEQ!LENGTH (HISTORY S)) 1) (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2$3)
    (AND (>= L2$3 0)
     (SOME (T2$3)
      (AND (>= T2$3 0)
       (SOME (M2$3)
        (AND (IN M2$3 (MS!MESSAGES))
         (SOME (P2$3)
          (AND (IN P2$3 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
 (SOME (L3$3)
  (AND (>= L3$3 0)
   (SOME (T3$3)
    (AND (>= T3$3 0)
     (SOME (M3$3)
      (AND (IN M3$3 (MS!MESSAGES))
       (SOME (P3$3)
        (AND (IN P3$3 (MS!PRINCIPALS))
         (SOME (P4$3)
          (AND (IN P4$3 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
            (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))
Invoking GOOD-STEP gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE)
  (SOME (LABEL TIME MESSAGE)
   (AND (TIME-CONSTRAINT TIME PREVIOUS-STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
       (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
       (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
       (= S
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
         PREVIOUS-STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
       (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
      (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0)
  (OR
   (AND (IN PRINCIPAL (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
    (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE PREVIOUS-STATE)
    (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
    (= S
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (IN PRINCIPAL$1 (MS!PRINCIPALS))
    (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
    (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
    (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
  (NOT (FORGEABLE K PREVIOUS-STATE)) (>= (SEQ!LENGTH (HISTORY S)) 1)
  (SEQ!IS-SEQUENCE (HISTORY S))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT (FORGEABLE K S)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))) (IN P1 (MS!PRINCIPALS))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
The conjunctive normal form ...
(AND
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (FORGEABLE K S) (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN MESSAGE (MS!ATOMIC-MESSAGES)))
  (NOT (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE)))
  (NOT (IN PRINCIPAL$1 (MS!PRINCIPALS)))
  (NOT (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (FORGEABLE K S) (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (FORGEABLE K S) (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$0 (MS!PRINCIPALS)))
  (NOT (FORGEABLE MESSAGE PREVIOUS-STATE))
  (NOT (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (FORGEABLE K S) (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN PRINCIPAL$2 (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
  (NOT (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (FORGEABLE K S) (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (OR (NOT (IS-GOOD-STATE PREVIOUS-STATE))
  (NOT (TIME-CONSTRAINT TIME PREVIOUS-STATE)) (NOT (>= LABEL 0))
  (NOT (IN SENDER (MS!PRINCIPALS))) (NOT (IN RECEIVER (MS!PRINCIPALS)))
  (NOT (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE))
  (NOT
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (FORGEABLE K PREVIOUS-STATE) (NOT (>= (SEQ!LENGTH (HISTORY S)) 1))
  (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (NOT (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S))))
  (NOT (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)) (NOT (IN M (MS!MESSAGES)))
  (NOT (IN P (MS!PRINCIPALS))) (NOT (IN K (MS!KEYS)))
  (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE)
  (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE)))
  (FORGEABLE K S) (KNOWN-BY-PRINCIPAL K P S)
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
  (NOT (IN P1 (MS!PRINCIPALS)))
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY S)))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (SEQ!TAIL (HISTORY S))))
  (SOME (L2)
   (AND (>= L2 0)
    (SOME (T2)
     (AND (>= T2 0)
      (SOME (M2)
       (AND (IN M2 (MS!MESSAGES))
        (SOME (P2)
         (AND (IN P2 (MS!PRINCIPALS))
          (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY S))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
Substituting (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
             (= S
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
             (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
             (= S
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
             (= S
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
             (= S
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)) produces
...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (= S (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT (FORGEABLE K (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE))))
   (NOT
    (SOME (L2)
     (AND (>= L2 0)
      (SOME (T2)
       (AND (>= T2 0)
        (SOME (M2)
         (AND (IN M2 (MS!MESSAGES))
          (SOME (P2)
           (AND (IN P2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (SOME (L3)
   (AND (>= L3 0)
    (SOME (T3)
     (AND (>= T3 0)
      (SOME (M3)
       (AND (IN M3 (MS!MESSAGES))
        (SOME (P3)
         (AND (IN P3 (MS!PRINCIPALS))
          (SOME (P4)
           (AND (IN P4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
             (HISTORY (INTRUDER-STEP LABEL TIME MESSAGE PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN MESSAGE (MS!ATOMIC-MESSAGES))
   (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE PREVIOUS-STATE))
   (IN PRINCIPAL$1 (MS!PRINCIPALS))
   (= S (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (FORGEABLE K
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE))))
   (NOT
    (SOME (L2$0)
     (AND (>= L2$0 0)
      (SOME (T2$0)
       (AND (>= T2$0 0)
        (SOME (M2$0)
         (AND (IN M2$0 (MS!MESSAGES))
          (SOME (P2$0)
           (AND (IN P2$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY
              (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL PREVIOUS-STATE)
   (= S (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT (FORGEABLE K (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))))
   (NOT
    (SOME (L2$1)
     (AND (>= L2$1 0)
      (SOME (T2$1)
       (AND (>= T2$1 0)
        (SOME (M2$1)
         (AND (IN M2$1 (MS!MESSAGES))
          (SOME (P2$1)
           (AND (IN P2$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$1 T2$1 M2$1 P2$1)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))))))
  (SOME (L3$1)
   (AND (>= L3$1 0)
    (SOME (T3$1)
     (AND (>= T3$1 0)
      (SOME (M3$1)
       (AND (IN M3$1 (MS!MESSAGES))
        (SOME (P3$1)
         (AND (IN P3$1 (MS!PRINCIPALS))
          (SOME (P4$1)
           (AND (IN P4$1 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1)
             (HISTORY
              (SEND-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (FORGEABLE K
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))))
   (NOT
    (SOME (L2$2)
     (AND (>= L2$2 0)
      (SOME (T2$2)
       (AND (>= T2$2 0)
        (SOME (M2$2)
         (AND (IN M2$2 (MS!MESSAGES))
          (SOME (P2$2)
           (AND (IN P2$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$2 T2$2 M2$2 P2$2)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))))
  (SOME (L3$2)
   (AND (>= L3$2 0)
    (SOME (T3$2)
     (AND (>= T3$2 0)
      (SOME (M3$2)
       (AND (IN M3$2 (MS!MESSAGES))
        (SOME (P3$2)
         (AND (IN P3$2 (MS!PRINCIPALS))
          (SOME (P4$2)
           (AND (IN P4$2 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2)
             (HISTORY
              (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$2 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 PREVIOUS-STATE)
   (= S (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (FORGEABLE K
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE))))
   (NOT
    (SOME (L2$3)
     (AND (>= L2$3 0)
      (SOME (T2$3)
       (AND (>= T2$3 0)
        (SOME (M2$3)
         (AND (IN M2$3 (MS!MESSAGES))
          (SOME (P2$3)
           (AND (IN P2$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$3 T2$3 M2$3 P2$3)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))))))
  (SOME (L3$3)
   (AND (>= L3$3 0)
    (SOME (T3$3)
     (AND (>= T3$3 0)
      (SOME (M3$3)
       (AND (IN M3$3 (MS!MESSAGES))
        (SOME (P3$3)
         (AND (IN P3$3 (MS!PRINCIPALS))
          (SOME (P4$3)
           (AND (IN P4$3 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3)
             (HISTORY
              (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (>=
    (SEQ!LENGTH
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
    1)
   (SEQ!IS-SEQUENCE
    (HISTORY
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (= (HISTORY PREVIOUS-STATE)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (FORGEABLE K
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF P
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (NOT
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD
      (HISTORY
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
        PREVIOUS-STATE)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL
     (HISTORY
      (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))))
   (NOT
    (SOME (L2$4)
     (AND (>= L2$4 0)
      (SOME (T2$4)
       (AND (>= T2$4 0)
        (SOME (M2$4)
         (AND (IN M2$4 (MS!MESSAGES))
          (SOME (P2$4)
           (AND (IN P2$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$4 T2$4 M2$4 P2$4)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$4 (NULLSET))))))))))))))
  (SOME (L3$4)
   (AND (>= L3$4 0)
    (SOME (T3$4)
     (AND (>= T3$4 0)
      (SOME (M3$4)
       (AND (IN M3$4 (MS!MESSAGES))
        (SOME (P3$4)
         (AND (IN P3$4 (MS!PRINCIPALS))
          (SOME (P4$4)
           (AND (IN P4$4 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$4 T3$4 M3$4 P3$4 P4$4)
             (HISTORY
              (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER
               PREVIOUS-STATE)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$4 (NULLSET))))))))))))))))
Which simplifies
 when rewriting with OUT-OF-BAND-EVENT-EQUALITY, STORAGE-OF-OUT-OF-BAND-STEP,
FORGEABLE-PRESERVED-BY-OUT-OF-BAND-STEP, HISTORY-OF-OUT-OF-BAND-STEP,
STORAGE-OF-CONSTRUCT-STEP, KNOWN-BY-PRINCIPAL-PRESERVED-BY-CONSTRUCT-STEP,
FORGEABLE-PRESERVED-BY-CONSTRUCT-STEP, HISTORY-OF-CONSTRUCT-STEP,
RECEIVE-EVENT-EQUALITY, SEQ!IS-MEMBER-TACK, STORAGE-OF-RECEIVE-STEP,
FORGEABLE-PRESERVED-BY-RECEIVE-STEP, HISTORY-OF-RECEIVE-STEP,
STORAGE-OF-SEND-STEP, KNOWN-BY-PRINCIPAL-PRESERVED-BY-SEND-STEP,
HISTORY-OF-SEND-STEP, SETADD.DEFINITION, MS!PARTS-SETADD-ATOMIC,
STORAGE-OF-GENERATE-STEP, KNOWN-BY-PRINCIPAL-GENERATE-STEP-ATOMIC-CASE,
FORGEABLE-PRESERVED-BY-GENERATE-STEP, HISTORY-OF-GENERATE-STEP,
STORAGE-OF-INTRUDER-STEP, KNOWN-BY-PRINCIPAL-PRESERVED-BY-INTRUDER-STEP,
SEQ!LENGTH-TACK, HISTORY-OF-INTRUDER-STEP, MS!IS-FRESH-ATOMIC,
MS!IS-FRESH-UNION, UNION.PERMUTATIVE, ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, SEQ!TACK-HEAD-TAIL,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-MESSAGES-NOT-EMPTY,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY, TAIL-IS-SEQUENCE,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK,
SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(AND
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
   (FORGEABLE MESSAGE PREVIOUS-STATE)
   (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (SEQ!IS-SEQUENCE
    (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
     (HISTORY PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
   (= P PRINCIPAL$0)
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
   (NOT
    (SOME (L2 T2 M2 P2)
     (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
      (OR (AND (= L2 LABEL) (= T2 TIME) (= M2 MESSAGE) (= P2 PRINCIPAL$0))
       (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
        (HISTORY PREVIOUS-STATE)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
  (SOME (L3 T3 M3 P3 P4)
   (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (HISTORY PREVIOUS-STATE))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
 (IMPLIES
  (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
   (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
   (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
   (NOT (FORGEABLE K PREVIOUS-STATE))
   (SEQ!IS-SEQUENCE
    (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
     (HISTORY PREVIOUS-STATE)))
   (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
   (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
   (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (NOT
    (KNOWN-BY-PRINCIPAL K P
     (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
   (= P RECEIVER)
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
   (IN P1 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
   (NOT
    (SOME (L2$0 T2$0 M2$0 P2$0)
     (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
      (IN P2$0 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
       (HISTORY PREVIOUS-STATE))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
  (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
   (AND (>= L3$0 0) (>= T3$0 0) (IN M3$0 (MS!MESSAGES))
    (IN P3$0 (MS!PRINCIPALS)) (IN P4$0 (MS!PRINCIPALS))
    (OR
     (AND (= L3$0 LABEL) (= T3$0 TIME) (= M3$0 MESSAGE) (= P3$0 SENDER)
      (= P4$0 RECEIVER))
     (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
      (HISTORY PREVIOUS-STATE)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET))))))))
Starting case 1.1.2.1.1.2 ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN PRINCIPAL$0 (MS!PRINCIPALS))
  (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL$0)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 PREVIOUS-STATE)))
  (= P PRINCIPAL$0)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2 T2 M2 P2)
    (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (OR (AND (= L2 LABEL) (= T2 TIME) (= M2 MESSAGE) (= P2 PRINCIPAL$0))
      (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
       (HISTORY PREVIOUS-STATE)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Instantiating (= L2 LABEL) (= T2 TIME) (= M2 MESSAGE) (= P2 PRINCIPAL$0) gives
...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (= P PRINCIPAL)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (OR
    (AND (>= LABEL 0) (>= TIME 0) (IN MESSAGE (MS!MESSAGES))
     (IN PRINCIPAL (MS!PRINCIPALS))
     (OR
      (AND (= LABEL LABEL) (= TIME TIME) (= MESSAGE MESSAGE)
       (= PRINCIPAL PRINCIPAL))
      (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
       (HISTORY PREVIOUS-STATE)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET)))))
    (SOME (L2 T2 M2 P2)
     (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
      (OR (AND (= L2 LABEL) (= T2 TIME) (= M2 MESSAGE) (= P2 PRINCIPAL))
       (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
        (HISTORY PREVIOUS-STATE)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY PREVIOUS-STATE))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
SEQ!TACK-HEAD-TAIL, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (= P PRINCIPAL)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE)))
 (IF (IN MESSAGE (MS!MESSAGES))
  (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (IF (= L2 LABEL)
            (IF (= T2 TIME)
             (AND (NOT (= M2 MESSAGE))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
             (AND
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
            (AND
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
  (OR
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))
   (SOME (L3$0)
    (AND (>= L3$0 0)
     (SOME (T3$0)
      (AND (>= T3$0 0)
       (SOME (M3$0)
        (AND (IN M3$0 (MS!MESSAGES))
         (SOME (P3$0)
          (AND (IN P3$0 (MS!PRINCIPALS))
           (SOME (P4$0)
            (AND (IN P4$0 (MS!PRINCIPALS))
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))))
Starting case 1.1.2.1.1.2.2 ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (= P PRINCIPAL)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (IN MESSAGE (MS!MESSAGES))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET)))))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (IF (= L2 LABEL)
            (IF (= T2 TIME)
             (AND (NOT (= M2 MESSAGE))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
             (AND
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
            (AND
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M2 (NULLSET))))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Applying IN-PARTS-SETADD gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (= P PRINCIPAL)
  (IF (NOT (= (STORAGE-OF P PREVIOUS-STATE) (NULLSET)))
   (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE)))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (IN MESSAGE (MS!MESSAGES))
  (NOT
   (IF (NOT (= (NULLSET) (NULLSET)))
    (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (IF (= L2 LABEL)
            (IF (= T2 TIME)
             (AND (NOT (= M2 MESSAGE))
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IF (NOT (= (NULLSET) (NULLSET)))
               (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
                (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
               (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
             (AND
              (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
               (HISTORY PREVIOUS-STATE))
              (IF (NOT (= (NULLSET) (NULLSET)))
               (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
                (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
               (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
            (AND
             (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
              (HISTORY PREVIOUS-STATE))
             (IF (NOT (= (NULLSET) (NULLSET)))
              (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
               (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M2 (NULLSET)))))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
            (HISTORY PREVIOUS-STATE))
           (IF (NOT (= (NULLSET) (NULLSET)))
            (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
             (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
SEQ!TACK-HEAD-TAIL, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Starting case 1.1.2.1.1.2.1 ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (FORGEABLE MESSAGE PREVIOUS-STATE)
  (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (= P PRINCIPAL)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT (IN MESSAGE (MS!MESSAGES)))
  (NOT
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))))))
 (SOME (L3$0)
  (AND (>= L3$0 0)
   (SOME (T3$0)
    (AND (>= T3$0 0)
     (SOME (M3$0)
      (AND (IN M3$0 (MS!MESSAGES))
       (SOME (P3$0)
        (AND (IN P3$0 (MS!PRINCIPALS))
         (SOME (P4$0)
          (AND (IN P4$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))))))
Invoking (FORGEABLE MESSAGE PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN PRINCIPAL (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (SEEN-MESSAGES PREVIOUS-STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (= S (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL PREVIOUS-STATE)))
  (= P PRINCIPAL)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT (IN MESSAGE (MS!MESSAGES)))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
SEQ!TACK-HEAD-TAIL, TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Starting case 1.1.2.1.1.1 ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
  (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (= P RECEIVER)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2$0 T2$0 M2$0 P2$0)
    (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
     (IN P2$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
      (HISTORY PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
 (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
  (AND (>= L3$0 0) (>= T3$0 0) (IN M3$0 (MS!MESSAGES))
   (IN P3$0 (MS!PRINCIPALS)) (IN P4$0 (MS!PRINCIPALS))
   (OR
    (AND (= L3$0 LABEL) (= T3$0 TIME) (= M3$0 MESSAGE) (= P3$0 SENDER)
     (= P4$0 RECEIVER))
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
     (HISTORY PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))
Instantiating (= L3$0 LABEL) (= T3$0 TIME) (= M3$0 MESSAGE) (= P3$0 SENDER)
              (= P4$0 RECEIVER) gives
...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
  (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (= P RECEIVER)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2 T2 M2 P2)
    (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY PREVIOUS-STATE))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
  (NOT
   (AND (>= LABEL 0) (>= TIME 0) (IN MESSAGE (MS!MESSAGES))
    (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
    (OR
     (AND (= LABEL LABEL) (= TIME TIME) (= MESSAGE MESSAGE) (= SENDER SENDER)
      (= RECEIVER RECEIVER))
     (SEQ!IS-MEMBER
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
      (HISTORY PREVIOUS-STATE)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
 (SOME (L3 T3 M3 P3 P4)
  (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (OR
    (AND (= L3 LABEL) (= T3 TIME) (= M3 MESSAGE) (= P3 SENDER)
     (= P4 RECEIVER))
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (HISTORY PREVIOUS-STATE)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
SEQ!TACK-HEAD-TAIL, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE)
  (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (= P RECEIVER)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (IF (IN MESSAGE (MS!MESSAGES))
  (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (IF (= L3 LABEL)
              (IF (= T3 TIME)
               (AND (NOT (= M3 MESSAGE))
                (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
                 (HISTORY PREVIOUS-STATE))
                (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
               (AND
                (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
                 (HISTORY PREVIOUS-STATE))
                (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))
              (AND
               (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
                (HISTORY PREVIOUS-STATE))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET))))))))))))))))
Invoking (KNOWN-BY-PRINCIPAL MESSAGE SENDER PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (STORAGE-OF SENDER PREVIOUS-STATE)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (= P RECEIVER)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
 (IF (IN MESSAGE (MS!MESSAGES))
  (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
   (SOME (L3)
    (AND (>= L3 0)
     (SOME (T3)
      (AND (>= T3 0)
       (SOME (M3)
        (AND (IN M3 (MS!MESSAGES))
         (SOME (P3)
          (AND (IN P3 (MS!PRINCIPALS))
           (SOME (P4)
            (AND (IN P4 (MS!PRINCIPALS))
             (IF (= L3 LABEL)
              (IF (= T3 TIME)
               (AND (NOT (= M3 MESSAGE))
                (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
                 (HISTORY PREVIOUS-STATE))
                (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
               (AND
                (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
                 (HISTORY PREVIOUS-STATE))
                (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))
              (AND
               (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
                (HISTORY PREVIOUS-STATE))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))))
  (SOME (L3$0)
   (AND (>= L3$0 0)
    (SOME (T3$0)
     (AND (>= T3$0 0)
      (SOME (M3$0)
       (AND (IN M3$0 (MS!MESSAGES))
        (SOME (P3$0)
         (AND (IN P3$0 (MS!PRINCIPALS))
          (SOME (P4$0)
           (AND (IN P4$0 (MS!PRINCIPALS))
            (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0)
             (HISTORY PREVIOUS-STATE))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SETADD M3$0 (NULLSET))))))))))))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, SEQ!TACK-HEAD-TAIL,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF SENDER PREVIOUS-STATE)))))
  (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (= P RECEIVER)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))))))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (IF (= L3 LABEL)
            (IF (= T3 TIME)
             (AND (NOT (= M3 MESSAGE))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
             (AND
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))
            (AND
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY PREVIOUS-STATE))
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SETADD M3 (NULLSET)))))))))))))))))
Applying IN-PARTS-SETADD gives ...
(IMPLIES
 (AND (IS-GOOD-STATE PREVIOUS-STATE) (TIME-CONSTRAINT TIME PREVIOUS-STATE)
  (>= LABEL 0) (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
  (MS!KNOWN-IN MESSAGE
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES)
     (UNION (MS!PUBLIC-KEYS) (STORAGE-OF SENDER PREVIOUS-STATE)))))
  (= S (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE))
  (NOT (FORGEABLE K PREVIOUS-STATE))
  (SEQ!IS-SEQUENCE
   (SEQ!TACK (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
    (HISTORY PREVIOUS-STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IN M (MS!MESSAGES))
  (IN P (MS!PRINCIPALS)) (IN K (MS!KEYS))
  (NOT (KNOWN-BY-PRINCIPAL K P PREVIOUS-STATE))
  (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
  (NOT
   (KNOWN-BY-PRINCIPAL K P
    (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER PREVIOUS-STATE)))
  (= P RECEIVER)
  (IF (NOT (= (STORAGE-OF P PREVIOUS-STATE) (NULLSET)))
   (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
    (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P PREVIOUS-STATE))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD MESSAGE (STORAGE-OF P PREVIOUS-STATE)))))
  (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY PREVIOUS-STATE))
  (NOT
   (SOME (L2)
    (AND (>= L2 0)
     (SOME (T2)
      (AND (>= T2 0)
       (SOME (M2)
        (AND (IN M2 (MS!MESSAGES))
         (SOME (P2)
          (AND (IN P2 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
            (HISTORY PREVIOUS-STATE))
           (IF (NOT (= (NULLSET) (NULLSET)))
            (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
             (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))))))
  (NOT
   (IF (NOT (= (NULLSET) (NULLSET)))
    (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
 (SOME (L3)
  (AND (>= L3 0)
   (SOME (T3)
    (AND (>= T3 0)
     (SOME (M3)
      (AND (IN M3 (MS!MESSAGES))
       (SOME (P3)
        (AND (IN P3 (MS!PRINCIPALS))
         (SOME (P4)
          (AND (IN P4 (MS!PRINCIPALS))
           (IF (= L3 LABEL)
            (IF (= T3 TIME)
             (AND (NOT (= M3 MESSAGE))
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IF (NOT (= (NULLSET) (NULLSET)))
               (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
                (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
               (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))
             (AND
              (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
               (HISTORY PREVIOUS-STATE))
              (IF (NOT (= (NULLSET) (NULLSET)))
               (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
                (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
               (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
            (AND
             (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
              (HISTORY PREVIOUS-STATE))
             (IF (NOT (= (NULLSET) (NULLSET)))
              (OR (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
               (IN (MS!ENCRYPT M K) (MS!PARTS (NULLSET))))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS (SETADD M3 (NULLSET))))))))))))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, SEQ!TACK-HEAD-TAIL,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
Completing all cases produces ...
(TRUE)
GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION
Beginning proof of GOOD-EVOLUTION-STATE-HAS-GOOD-EVOLUTION ...
(IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Inducting using the following scheme ...
 (AND (IMPLIES (SEQ!EMPTYP (HISTORY STATE)) (*P* STATE))
  (IMPLIES
   (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
    (ALL (PREVIOUS-STATE)
     (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
      (*P* PREVIOUS-STATE) (TRUE))))
   (*P* STATE)))
 produces ...
(AND
 (IMPLIES (SEQ!EMPTYP (HISTORY STATE))
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE)))))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
   (ALL (PREVIOUS-STATE)
    (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IMPLIES (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
      (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) PREVIOUS-STATE))))
     (TRUE))))
  (IMPLIES (IS-GOOD-EVOLUTION-STATE STATE)
   (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))))
Starting case 2 ...
(IMPLIES (AND (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-EVOLUTION-STATE STATE))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (SEQ!EMPTYP (HISTORY STATE))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (GOOD-STEP PREVIOUS-STATE STATE)))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IF (>= (SEQ!LENGTH (HISTORY STATE)) 1)
 (IMPLIES (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-STATE STATE))
  (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
 (IMPLIES (IS-GOOD-STATE STATE)
  (SOME (S$0) (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) STATE)))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-STATE STATE))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Instantiating (= S (SEQ!TACK STATE (SEQ!EMPTY))) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-STATE STATE)
  (NOT
   (AND (IS-GOOD-EVOLUTION (SEQ!TACK STATE (SEQ!EMPTY)))
    (= (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))) STATE))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
>=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-GOOD-STATE STATE)
  (NOT (IS-GOOD-EVOLUTION (SEQ!TACK STATE (SEQ!EMPTY)))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1)
  (NOT (SEQ!IS-SEQUENCE (HISTORY STATE))) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (NOT (IS-GOOD-EVOLUTION (SEQ!TACK STATE (SEQ!EMPTY)))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using >=.SAME.TYPE
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES (AND (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE))
 (SOME (S$0) (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) STATE))))
Instantiating (= S$0 (SEQ!TACK STATE (SEQ!EMPTY))) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE)
  (NOT
   (AND (IS-GOOD-EVOLUTION (SEQ!TACK STATE (SEQ!EMPTY)))
    (= (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))) STATE))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
>=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!IS-TACK-TACK,
SEQ!HEAD-TACK, SEQ!TAIL-TACK, SEQ!IS-SEQUENCE-TACK, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE)
  (NOT (IS-GOOD-EVOLUTION (SEQ!TACK STATE (SEQ!EMPTY)))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Invoking (IS-GOOD-EVOLUTION (SEQ!TACK STATE (SEQ!EMPTY))) gives ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE)
  (NOT
   (IF (>= (SEQ!LENGTH (SEQ!TACK STATE (SEQ!EMPTY))) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))))
      (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))))
    (AND (>= (SEQ!LENGTH (SEQ!TACK STATE (SEQ!EMPTY))) 1)
     (IS-GOOD-STATE (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY))))
     (= (HISTORY (SEQ!HEAD (SEQ!TACK STATE (SEQ!EMPTY)))) (SEQ!EMPTY))
     (= (SEQ!TAIL (SEQ!TACK STATE (SEQ!EMPTY))) (SEQ!EMPTY))))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Which simplifies
 when rewriting with SEQ!LENGTH-TACK
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
>=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, TAIL-IS-SEQUENCE,
SEQ!TYPE-OF-IS-TACK, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE)
  (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Splitting on (SEQ!IS-SEQUENCE (HISTORY STATE)) generates ...
(IF (SEQ!IS-SEQUENCE (HISTORY STATE))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE)
   (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
  (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE)
   (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
  (SOME (S$0) (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) STATE)))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!EMPTYP-EMPTY,
SEQ!IS-SEQUENCE-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY STATE))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE)
   (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
  (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
 (IMPLIES
  (AND (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE))
  (SOME (S$0) (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) STATE)))))
Starting case 2.1.2 ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
  (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE)
  (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Invoking SEQ!LENGTH gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY STATE))
  (NOT
   (>=
    (IF (SEQ!IS-TACK (HISTORY STATE))
     (+ 1 (SEQ!LENGTH (SEQ!TAIL (HISTORY STATE)))) 0)
    1))
  (IS-GOOD-STATE STATE) (NOT (= (HISTORY STATE) (SEQ!EMPTY))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, TAIL-IS-SEQUENCE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 2.1.1 ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-GOOD-STATE STATE))
 (SOME (S$0) (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) STATE))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY STATE)))
  (NOT (>= (SEQ!LENGTH (HISTORY STATE)) 1)) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES))))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using >=.SAME.TYPE
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
  (ALL (PREVIOUS-STATE)
   (IF (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IMPLIES (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
     (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) PREVIOUS-STATE))))
    (TRUE)))
  (IS-GOOD-EVOLUTION-STATE STATE))
 (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) STATE))))
Invoking (IS-GOOD-EVOLUTION-STATE STATE) gives ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP (HISTORY STATE)))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
    (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) PREVIOUS-STATE)))))
  (IF (SEQ!EMPTYP (HISTORY STATE)) (IS-GOOD-STATE STATE)
   (SOME (PREVIOUS-STATE$0)
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
     (GOOD-STEP PREVIOUS-STATE$0 STATE)))))
 (SOME (S$0) (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) STATE))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
>=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (PREVIOUS-STATE)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
    (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) PREVIOUS-STATE)))))
  (SOME (PREVIOUS-STATE$0)
   (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0)
    (GOOD-STEP PREVIOUS-STATE$0 STATE))))
 (SOME (S$0) (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) STATE))))
Prenexing produces ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) PREVIOUS-STATE$0)))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE))
 (SOME (S$0) (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) STATE))))
Instantiating (= PREVIOUS-STATE$0 PREVIOUS-STATE) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (IMPLIES
   (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
    (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE))
   (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) PREVIOUS-STATE))))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (S$0)
     (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) PREVIOUS-STATE$0)))))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE STATE))
 (SOME (S$1) (AND (IS-GOOD-EVOLUTION S$1) (= (SEQ!HEAD S$1) STATE))))
Which simplifies
 forward chaining using GOOD-STEP-IMPLIES-GOOD-STATES, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (SOME (S) (AND (IS-GOOD-EVOLUTION S) (= (SEQ!HEAD S) PREVIOUS-STATE)))
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (S$0)
     (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE))
 (SOME (S$1) (AND (IS-GOOD-EVOLUTION S$1) (= (SEQ!HEAD S$1) STATE))))
Instantiating (= S$1 (SEQ!TACK STATE S)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-EVOLUTION S)
  (= (SEQ!HEAD S) PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (S$0)
     (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE)
  (NOT
   (AND (IS-GOOD-EVOLUTION (SEQ!TACK STATE S))
    (= (SEQ!HEAD (SEQ!TACK STATE S)) STATE))))
 (SOME (S$1) (AND (IS-GOOD-EVOLUTION S$1) (= (SEQ!HEAD S$1) STATE))))
Which simplifies
 forward chaining using SEQ!TACK-HEAD-TAIL, GOOD-STEP-IMPLIES-GOOD-STATES,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-EVOLUTION S)
  (= (SEQ!HEAD S) PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (S$0)
     (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE)
  (NOT (IS-GOOD-EVOLUTION (SEQ!TACK STATE S))))
 (SOME (S$1) (AND (IS-GOOD-EVOLUTION S$1) (= (SEQ!HEAD S$1) STATE))))
Invoking (IS-GOOD-EVOLUTION (SEQ!TACK STATE S)) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-EVOLUTION S)
  (= (SEQ!HEAD S) PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (S$0)
     (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE)
  (NOT
   (IF (>= (SEQ!LENGTH (SEQ!TACK STATE S)) 2)
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL (SEQ!TACK STATE S)))
     (GOOD-STEP (SEQ!HEAD (SEQ!TAIL (SEQ!TACK STATE S)))
      (SEQ!HEAD (SEQ!TACK STATE S))))
    (AND (>= (SEQ!LENGTH (SEQ!TACK STATE S)) 1)
     (IS-GOOD-STATE (SEQ!HEAD (SEQ!TACK STATE S)))
     (= (HISTORY (SEQ!HEAD (SEQ!TACK STATE S))) (SEQ!EMPTY))
     (= (SEQ!TAIL (SEQ!TACK STATE S)) (SEQ!EMPTY))))))
 (SOME (S$1) (AND (IS-GOOD-EVOLUTION S$1) (= (SEQ!HEAD S$1) STATE))))
Which simplifies
 when rewriting with SEQ!LENGTH-TACK
 forward chaining using SEQ!NOT-IS-TACK-FACTS, SEQ!TACK-HEAD-TAIL,
GOOD-STEP-IMPLIES-GOOD-STATES, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
TAIL-IS-SEQUENCE, SEQ!IS-TACK-TACK, SEQ!HEAD-TACK, SEQ!TAIL-TACK,
SEQ!IS-SEQUENCE-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (IS-GOOD-EVOLUTION S)
  (= (SEQ!HEAD S) PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (S$0)
     (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE) (NOT (>= (+ 1 (SEQ!LENGTH S)) 2)))
 (SOME (S$1) (AND (IS-GOOD-EVOLUTION S$1) (= (SEQ!HEAD S$1) STATE))))
Invoking (IS-GOOD-EVOLUTION S) gives ...
(IMPLIES
 (AND (>= (SEQ!LENGTH (HISTORY STATE)) 1) (SEQ!IS-SEQUENCE (HISTORY STATE))
  (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY STATE)))
  (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE)
  (IF (>= (SEQ!LENGTH S) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL S)) (SEQ!HEAD S)))
   (AND (>= (SEQ!LENGTH S) 1) (IS-GOOD-STATE (SEQ!HEAD S))
    (= (HISTORY (SEQ!HEAD S)) (SEQ!EMPTY)) (= (SEQ!TAIL S) (SEQ!EMPTY))))
  (= (SEQ!HEAD S) PREVIOUS-STATE)
  (ALL (PREVIOUS-STATE$0)
   (IMPLIES
    (AND (= (HISTORY PREVIOUS-STATE$0) (SEQ!TAIL (HISTORY STATE)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE$0))
    (SOME (S$0)
     (AND (IS-GOOD-EVOLUTION S$0) (= (SEQ!HEAD S$0) PREVIOUS-STATE$0)))))
  (GOOD-STEP PREVIOUS-STATE STATE) (NOT (>= (+ 1 (SEQ!LENGTH S)) 2)))
 (SOME (S$1) (AND (IS-GOOD-EVOLUTION S$1) (= (SEQ!HEAD S$1) STATE))))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, GOOD-STEP-IMPLIES-GOOD-STATES,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
SEND-EVENTS-CONTAINING-ENCRYPT
ENCRYPTED-PART-OF-SENT-IMPLICATION
Beginning proof of ENCRYPTED-PART-OF-SENT-IMPLICATION ...
(IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
Invoking ENCRYPTED-PART-OF-SENT gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S)
  (SOME (L2 T2 M2 P2)
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IS-GOOD-EVOLUTION-STATE S)
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
SEND-EVENTS-CONTAINING-ENCRYPT.DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, TAG-OF-MAKE-SEND-EVENT,
MAKE-SEND-EVENT-IS-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S)) (IN EVENT (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))))
Instantiating (= EVENT (MAKE-SEND-EVENT L2 T2 M2 P2)) gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (AND (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY S))
    (IN (MAKE-SEND-EVENT L2 T2 M2 P2) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (MAKE-SEND-EVENT L2 T2 M2 P2)) (NULLSET)))))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S)) (IN EVENT (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, TAG-OF-MAKE-SEND-EVENT,
MAKE-SEND-EVENT-IS-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
ENCRYPTED-PART-OF-SENT-IMPLICATION-2
Beginning proof of ENCRYPTED-PART-OF-SENT-IMPLICATION-2 ...
(IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S))
 (SOME (N)
  (AND (>= N 1) (<= N (SEQ!LENGTH (HISTORY S)))
   (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
Assuming ENCRYPTED-PART-OF-SENT-IMPLICATION with the
instantiations: (= M M) (= K K) (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S))
   (SOME (EVENT)
    (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
     (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S)
  (SOME (EVENT)
   (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
    (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S)
  (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M EVENT) (= S (HISTORY S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY S)) (SEQ!IS-MEMBER EVENT (HISTORY S)))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY S) N))
     (<= N (SEQ!LENGTH (HISTORY S))))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S)
  (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))
 (SOME (N$0)
  (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
   (IN (SEQ!NTH (HISTORY S) N$0) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY S))
 (IMPLIES
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY S) N))
     (>= (SEQ!LENGTH (HISTORY S)) N)))
   (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S)
   (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))
  (SOME (N$0)
   (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
    (IN (SEQ!NTH (HISTORY S) N$0) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S)
   (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))
  (SOME (N$1)
   (AND (>= N$1 1) (>= (SEQ!LENGTH (HISTORY S)) N$1)
    (IN (SEQ!NTH (HISTORY S) N$1) (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))
Instantiating (= N$0 N) gives ...
(IF (SEQ!IS-SEQUENCE (HISTORY S))
 (ALL (N)
  (IMPLIES
   (AND (SEQ!IS-MEMBER EVENT (HISTORY S)) (>= N 1)
    (= EVENT (SEQ!NTH (HISTORY S) N)) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S)
    (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K))
    (NOT
     (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
      (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
   (SOME (N$0)
    (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
     (IN (SEQ!NTH (HISTORY S) N$0) (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S)
   (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (SEND-EVENTS-CONTAINING-ENCRYPT M K)))
  (SOME (N$1)
   (AND (>= N$1 1) (>= (SEQ!LENGTH (HISTORY S)) N$1)
    (IN (SEQ!NTH (HISTORY S) N$1) (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
SEND-EVENTS-CONTAINING-ENCRYPT.DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S))) (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-SENT M K S) (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-SENT M K S) (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION, >=.SAME.TYPE,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S))) (IS-GOOD-STATE S)
  (ENCRYPTED-PART-OF-SENT M K S) (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S))) (IS-STATE S)
  (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY S))
  (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
  (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES)))
  (ENCRYPTED-PART-OF-SENT M K S) (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
REVERSE-INDICES
EARLIEST-IN-SEQUENCE-WITH-PROPERTY
Beginning proof of EARLIEST-IN-SEQUENCE-WITH-PROPERTY ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE SEQUENCE)
  (SOME (N)
   (AND (>= N 1) (<= N (SEQ!LENGTH SEQUENCE)) (IN (SEQ!NTH SEQUENCE N) SET))))
 (SOME (N1)
  (AND (>= N1 1) (<= N1 (SEQ!LENGTH SEQUENCE)) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH SEQUENCE))
      (IN (SEQ!NTH SEQUENCE N2) SET)))))))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
  (IN (SEQ!NTH SEQUENCE N) SET))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) N1) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (>= (SEQ!LENGTH SEQUENCE) N2)
      (IN (SEQ!NTH SEQUENCE N2) SET)))))))
Assuming NAT!SMALLEST-IS-SMALLEST-2 with the
instantiations: (= N (- (SEQ!LENGTH SEQUENCE) N))
                (= X (REVERSE-INDICES SEQUENCE SET)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (- (SEQ!LENGTH SEQUENCE) N) (REVERSE-INDICES SEQUENCE SET))
    (IN (- (SEQ!LENGTH SEQUENCE) N) (NAT!NAT)))
   (AND
    (IN (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))
     (REVERSE-INDICES SEQUENCE SET))
    (IN (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) (NAT!NAT))
    (<= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))
     (- (SEQ!LENGTH SEQUENCE) N))))
  (SEQ!IS-SEQUENCE SEQUENCE) (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
  (IN (SEQ!NTH SEQUENCE N) SET))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) N1) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (>= (SEQ!LENGTH SEQUENCE) N2)
      (IN (SEQ!NTH SEQUENCE N2) SET)))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N) (SEQ!IS-SEQUENCE SEQUENCE)
  (IN (SEQ!NTH SEQUENCE N) SET)
  (IMPLIES
   (AND (IN (- (SEQ!LENGTH SEQUENCE) N) (REVERSE-INDICES SEQUENCE SET))
    (IN (- (SEQ!LENGTH SEQUENCE) N) (NAT!NAT)))
   (AND
    (IN (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))
     (REVERSE-INDICES SEQUENCE SET))
    (IN (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) (NAT!NAT))
    (<= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))
     (- (SEQ!LENGTH SEQUENCE) N)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) N1) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (>= (SEQ!LENGTH SEQUENCE) N2)
      (IN (SEQ!NTH SEQUENCE N2) SET)))))))
Which simplifies
 when rewriting with NAT!IN-NAT, REVERSE-INDICES.DEFINITION
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N) (SEQ!IS-SEQUENCE SEQUENCE)
  (IN (SEQ!NTH SEQUENCE N) SET)
  (>= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) 0)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (IN
   (SEQ!NTH SEQUENCE
    (+ (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
     (SEQ!LENGTH SEQUENCE)))
   SET)
  (>= (+ (* -1 N) (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) N1) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH SEQUENCE) N2)
      (IN (SEQ!NTH SEQUENCE N2) SET)))))))
Instantiating (= N1
               (- (SEQ!LENGTH SEQUENCE)
                (NAT!SMALLEST-NAT-MEMBER
                 (REVERSE-INDICES SEQUENCE SET)))) gives
...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N) (SEQ!IS-SEQUENCE SEQUENCE)
  (IN (SEQ!NTH SEQUENCE N) SET)
  (>= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) 0)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (IN
   (SEQ!NTH SEQUENCE
    (+ (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
     (SEQ!LENGTH SEQUENCE)))
   SET)
  (>= (+ (* -1 N) (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (NOT
   (AND
    (>=
     (- (SEQ!LENGTH SEQUENCE)
      (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
     1)
    (>= (SEQ!LENGTH SEQUENCE)
     (- (SEQ!LENGTH SEQUENCE)
      (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))))
    (IN
     (SEQ!NTH SEQUENCE
      (- (SEQ!LENGTH SEQUENCE)
       (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))))
     SET)
    (NOT
     (SOME (N2)
      (AND
       (>= N2
        (+ 1
         (- (SEQ!LENGTH SEQUENCE)
          (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))))
       (>= (SEQ!LENGTH SEQUENCE) N2) (IN (SEQ!NTH SEQUENCE N2) SET)))))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) N1) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH SEQUENCE) N2$0)
      (IN (SEQ!NTH SEQUENCE N2$0) SET)))))))
Which simplifies
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N) (SEQ!IS-SEQUENCE SEQUENCE)
  (IN (SEQ!NTH SEQUENCE N) SET)
  (>= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) 0)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (IN
   (SEQ!NTH SEQUENCE
    (+ (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
     (SEQ!LENGTH SEQUENCE)))
   SET)
  (>= (+ (* -1 N) (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (SOME (N2)
   (AND
    (>= N2
     (+ 1 (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
      (SEQ!LENGTH SEQUENCE)))
    (>= (SEQ!LENGTH SEQUENCE) N2) (IN (SEQ!NTH SEQUENCE N2) SET))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) N1) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH SEQUENCE) N2$0)
      (IN (SEQ!NTH SEQUENCE N2$0) SET)))))))
Prenexing produces ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N) (SEQ!IS-SEQUENCE SEQUENCE)
  (IN (SEQ!NTH SEQUENCE N) SET)
  (>= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) 0)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (IN
   (SEQ!NTH SEQUENCE
    (+ (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
     (SEQ!LENGTH SEQUENCE)))
   SET)
  (>= (+ (* -1 N) (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (>= N2
   (+ 1 (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
    (SEQ!LENGTH SEQUENCE)))
  (>= (SEQ!LENGTH SEQUENCE) N2) (IN (SEQ!NTH SEQUENCE N2) SET))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) N1) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH SEQUENCE) N2$0)
      (IN (SEQ!NTH SEQUENCE N2$0) SET)))))))
Assuming NAT!SMALLEST-IS-SMALLEST-2 with the
instantiations: (= N (- (SEQ!LENGTH SEQUENCE) N2))
                (= X (REVERSE-INDICES SEQUENCE SET)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (- (SEQ!LENGTH SEQUENCE) N2) (REVERSE-INDICES SEQUENCE SET))
    (IN (- (SEQ!LENGTH SEQUENCE) N2) (NAT!NAT)))
   (AND
    (IN (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))
     (REVERSE-INDICES SEQUENCE SET))
    (IN (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) (NAT!NAT))
    (<= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))
     (- (SEQ!LENGTH SEQUENCE) N2))))
  (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N) (SEQ!IS-SEQUENCE SEQUENCE)
  (IN (SEQ!NTH SEQUENCE N) SET)
  (>= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) 0)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (IN
   (SEQ!NTH SEQUENCE
    (+ (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
     (SEQ!LENGTH SEQUENCE)))
   SET)
  (>= (+ (* -1 N) (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (>= N2
   (+ 1 (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
    (SEQ!LENGTH SEQUENCE)))
  (>= (SEQ!LENGTH SEQUENCE) N2) (IN (SEQ!NTH SEQUENCE N2) SET))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) N1) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH SEQUENCE) N2$0)
      (IN (SEQ!NTH SEQUENCE N2$0) SET)))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH SEQUENCE) N)
  (>= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) 0)
  (>= (+ -1 (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (>= (+ (* -1 N) (SEQ!LENGTH SEQUENCE))
   (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
  (>= N2
   (+ 1 (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
    (SEQ!LENGTH SEQUENCE)))
  (>= (SEQ!LENGTH SEQUENCE) N2) (SEQ!IS-SEQUENCE SEQUENCE)
  (IN (SEQ!NTH SEQUENCE N) SET)
  (IN
   (SEQ!NTH SEQUENCE
    (+ (* -1 (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)))
     (SEQ!LENGTH SEQUENCE)))
   SET)
  (IN (SEQ!NTH SEQUENCE N2) SET)
  (IMPLIES
   (AND (IN (- (SEQ!LENGTH SEQUENCE) N2) (REVERSE-INDICES SEQUENCE SET))
    (IN (- (SEQ!LENGTH SEQUENCE) N2) (NAT!NAT)))
   (AND
    (IN (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))
     (REVERSE-INDICES SEQUENCE SET))
    (IN (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET)) (NAT!NAT))
    (<= (NAT!SMALLEST-NAT-MEMBER (REVERSE-INDICES SEQUENCE SET))
     (- (SEQ!LENGTH SEQUENCE) N2)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH SEQUENCE) N1) (IN (SEQ!NTH SEQUENCE N1) SET)
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH SEQUENCE) N2$0)
      (IN (SEQ!NTH SEQUENCE N2$0) SET)))))))
Which simplifies
 when rewriting with NAT!IN-NAT, REVERSE-INDICES.DEFINITION
 forward chaining using >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
ENCRYPTED-PART-OF-SENT-IMPLICATION-3
Beginning proof of ENCRYPTED-PART-OF-SENT-IMPLICATION-3 ...
(IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S))
 (SOME (N1)
  (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY S)))
   (IN (SEQ!NTH (HISTORY S) N1) (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY S)))
      (IN (SEQ!NTH (HISTORY S) N2) (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Assuming ENCRYPTED-PART-OF-SENT-IMPLICATION-2 with the
instantiations: (= M M) (= K K) (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S))
   (SOME (N)
    (AND (>= N 1) (<= N (SEQ!LENGTH (HISTORY S)))
     (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2) (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2) (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Assuming EARLIEST-IN-SEQUENCE-WITH-PROPERTY with the
instantiations: (= SEQUENCE (HISTORY S))
                (= SET (SEND-EVENTS-CONTAINING-ENCRYPT M K)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY S))
    (SOME (N)
     (AND (>= N 1) (<= N (SEQ!LENGTH (HISTORY S)))
      (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
   (SOME (N1)
    (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY S)))
     (IN (SEQ!NTH (HISTORY S) N1) (SEND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY S)))
        (IN (SEQ!NTH (HISTORY S) N2)
         (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-SENT M K S)
  (SOME (N$0)
   (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
    (IN (SEQ!NTH (HISTORY S) N$0) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1$0)
  (AND (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY S)) N1$0)
   (IN (SEQ!NTH (HISTORY S) N1$0) (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1$0)) (>= (SEQ!LENGTH (HISTORY S)) N2$0)
      (IN (SEQ!NTH (HISTORY S) N2$0)
       (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE
 with the instantiation (= N N$0) to ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S))) (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-SENT M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2) (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-SENT M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2) (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S))
   (AND (IS-STATE S) (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY S))
    (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
    (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-SENT M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N) (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2) (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
RECEIVE-EVENTS-CONTAINING-ENCRYPT
OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT
ENCRYPTED-PART-OF-RECEIVED-IMPLICATION
Beginning proof of ENCRYPTED-PART-OF-RECEIVED-IMPLICATION ...
(IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
Invoking ENCRYPTED-PART-OF-RECEIVED gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S)
  (SOME (L2 T2 M2 P2)
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
    (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IS-GOOD-EVOLUTION-STATE S)
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
RECEIVE-EVENTS-CONTAINING-ENCRYPT.DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S)) (IN EVENT (RECEIVE-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))))
Instantiating (= EVENT (MAKE-RECEIVE-EVENT L2 T2 M2 P2)) gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (AND (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY S))
    (IN (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (RECEIVE-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (MAKE-RECEIVE-EVENT L2 T2 M2 P2))
       (NULLSET)))))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S)) (IN EVENT (RECEIVE-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
ENCRYPTED-PART-OF-RECEIVED-IMPLICATION-2
Beginning proof of ENCRYPTED-PART-OF-RECEIVED-IMPLICATION-2 ...
(IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S))
 (SOME (N)
  (AND (>= N 1) (<= N (SEQ!LENGTH (HISTORY S)))
   (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
Assuming ENCRYPTED-PART-OF-RECEIVED-IMPLICATION with the
instantiations: (= M M) (= K K) (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S))
   (SOME (EVENT)
    (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
     (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S)
  (SOME (EVENT)
   (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
    (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S)
  (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M EVENT) (= S (HISTORY S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY S)) (SEQ!IS-MEMBER EVENT (HISTORY S)))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY S) N))
     (<= N (SEQ!LENGTH (HISTORY S))))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S)
  (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))
 (SOME (N$0)
  (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
   (IN (SEQ!NTH (HISTORY S) N$0) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY S))
 (IMPLIES
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY S) N))
     (>= (SEQ!LENGTH (HISTORY S)) N)))
   (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S)
   (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))
  (SOME (N$0)
   (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
    (IN (SEQ!NTH (HISTORY S) N$0) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S)
   (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))
  (SOME (N$1)
   (AND (>= N$1 1) (>= (SEQ!LENGTH (HISTORY S)) N$1)
    (IN (SEQ!NTH (HISTORY S) N$1) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))
Instantiating (= N$0 N) gives ...
(IF (SEQ!IS-SEQUENCE (HISTORY S))
 (ALL (N)
  (IMPLIES
   (AND (SEQ!IS-MEMBER EVENT (HISTORY S)) (>= N 1)
    (= EVENT (SEQ!NTH (HISTORY S) N)) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S)
    (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))
    (NOT
     (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
      (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
   (SOME (N$0)
    (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
     (IN (SEQ!NTH (HISTORY S) N$0)
      (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S)
   (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))
  (SOME (N$1)
   (AND (>= N$1 1) (>= (SEQ!LENGTH (HISTORY S)) N$1)
    (IN (SEQ!NTH (HISTORY S) N$1) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
RECEIVE-EVENTS-CONTAINING-ENCRYPT.DEFINITION
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S))) (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED M K S) (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (RECEIVE-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-RECEIVED M K S) (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (RECEIVE-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S))
   (AND (IS-STATE S) (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY S))
    (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
    (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-RECEIVED M K S) (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (RECEIVE-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
ENCRYPTED-PART-OF-RECEIVED-IMPLICATION-3
Beginning proof of ENCRYPTED-PART-OF-RECEIVED-IMPLICATION-3 ...
(IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S))
 (SOME (N1)
  (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY S)))
   (IN (SEQ!NTH (HISTORY S) N1) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY S)))
      (IN (SEQ!NTH (HISTORY S) N2)
       (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))))
Assuming ENCRYPTED-PART-OF-RECEIVED-IMPLICATION-2 with the
instantiations: (= M M) (= K K) (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S))
   (SOME (N)
    (AND (>= N 1) (<= N (SEQ!LENGTH (HISTORY S)))
     (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))))
Assuming EARLIEST-IN-SEQUENCE-WITH-PROPERTY with the
instantiations: (= SEQUENCE (HISTORY S))
                (= SET (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY S))
    (SOME (N)
     (AND (>= N 1) (<= N (SEQ!LENGTH (HISTORY S)))
      (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
   (SOME (N1)
    (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY S)))
     (IN (SEQ!NTH (HISTORY S) N1) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY S)))
        (IN (SEQ!NTH (HISTORY S) N2)
         (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED M K S)
  (SOME (N$0)
   (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
    (IN (SEQ!NTH (HISTORY S) N$0) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1$0)
  (AND (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY S)) N1$0)
   (IN (SEQ!NTH (HISTORY S) N1$0) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1$0)) (>= (SEQ!LENGTH (HISTORY S)) N2$0)
      (IN (SEQ!NTH (HISTORY S) N2$0)
       (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE
 with the instantiation (= N N$0) to ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S))) (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-RECEIVED M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S))
   (AND (IS-STATE S) (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY S))
    (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
    (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-RECEIVED M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (RECEIVE-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION
Beginning proof of ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
Invoking ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S)
  (SOME (L3 T3 M3 P3 P4)
   (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IS-GOOD-EVOLUTION-STATE S)
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES))
  (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE S)
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT.DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES))
  (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S)) (IN EVENT (OUT-OF-BAND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))))
Instantiating (= EVENT (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)) gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES))
  (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
  (NOT
   (AND (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (HISTORY S))
    (IN (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4) (OUT-OF-BAND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (NULLSET)))))))
 (SOME (EVENT)
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S)) (IN EVENT (OUT-OF-BAND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION-2
Beginning proof of ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION-2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))
 (SOME (N)
  (AND (>= N 1) (<= N (SEQ!LENGTH (HISTORY S)))
   (IN (SEQ!NTH (HISTORY S) N) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
Assuming ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION with the
instantiations: (= M M) (= K K) (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE S)
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))
   (SOME (EVENT)
    (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
     (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SOME (EVENT)
   (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
    (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M EVENT) (= S (HISTORY S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY S)) (SEQ!IS-MEMBER EVENT (HISTORY S)))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY S) N))
     (<= N (SEQ!LENGTH (HISTORY S))))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SEQ!IS-MEMBER EVENT (HISTORY S))
  (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))
 (SOME (N$0)
  (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
   (IN (SEQ!NTH (HISTORY S) N$0)
    (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IF (SEQ!IS-SEQUENCE (HISTORY S))
 (IMPLIES
  (AND (SEQ!IS-MEMBER EVENT (HISTORY S))
   (SOME (N)
    (AND (>= N 1) (= EVENT (SEQ!NTH (HISTORY S) N))
     (>= (SEQ!LENGTH (HISTORY S)) N)))
   (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
   (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))
  (SOME (N$0)
   (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
    (IN (SEQ!NTH (HISTORY S) N$0)
     (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE S)
   (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
   (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))
  (SOME (N$1)
   (AND (>= N$1 1) (>= (SEQ!LENGTH (HISTORY S)) N$1)
    (IN (SEQ!NTH (HISTORY S) N$1)
     (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))
Instantiating (= N$0 N) gives ...
(IF (SEQ!IS-SEQUENCE (HISTORY S))
 (ALL (N)
  (IMPLIES
   (AND (SEQ!IS-MEMBER EVENT (HISTORY S)) (>= N 1)
    (= EVENT (SEQ!NTH (HISTORY S) N)) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
    (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
    (NOT
     (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
      (IN (SEQ!NTH (HISTORY S) N)
       (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
   (SOME (N$0)
    (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
     (IN (SEQ!NTH (HISTORY S) N$0)
      (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE S)
   (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
   (SEQ!IS-MEMBER EVENT (HISTORY S))
   (IN EVENT (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))
  (SOME (N$1)
   (AND (>= N$1 1) (>= (SEQ!LENGTH (HISTORY S)) N$1)
    (IN (SEQ!NTH (HISTORY S) N$1)
     (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT.DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S))) (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SEQ!IS-MEMBER EVENT (HISTORY S)) (IN EVENT (OUT-OF-BAND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (OUT-OF-BAND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SEQ!IS-MEMBER EVENT (HISTORY S)) (IN EVENT (OUT-OF-BAND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (OUT-OF-BAND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S))
   (AND (IS-STATE S) (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY S))
    (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
    (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SEQ!IS-MEMBER EVENT (HISTORY S)) (IN EVENT (OUT-OF-BAND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS (SETADD (MESSAGE-OF-EVENT EVENT) (NULLSET)))))
 (SOME (N)
  (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
   (IN (SEQ!NTH (HISTORY S) N) (OUT-OF-BAND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY S) N)) (NULLSET)))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION-3
Beginning proof of ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION-3 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))
 (SOME (N1)
  (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY S)))
   (IN (SEQ!NTH (HISTORY S) N1) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY S)))
      (IN (SEQ!NTH (HISTORY S) N2)
       (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Assuming ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION-2 with the
instantiations: (= M M) (= K K) (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE S)
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))
   (SOME (N)
    (AND (>= N 1) (<= N (SEQ!LENGTH (HISTORY S)))
     (IN (SEQ!NTH (HISTORY S) N)
      (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N)
     (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Assuming EARLIEST-IN-SEQUENCE-WITH-PROPERTY with the
instantiations: (= SEQUENCE (HISTORY S))
                (= SET (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY S))
    (SOME (N)
     (AND (>= N 1) (<= N (SEQ!LENGTH (HISTORY S)))
      (IN (SEQ!NTH (HISTORY S) N)
       (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
   (SOME (N1)
    (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY S)))
     (IN (SEQ!NTH (HISTORY S) N1) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY S)))
        (IN (SEQ!NTH (HISTORY S) N2)
         (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
  (IS-GOOD-EVOLUTION-STATE S) (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SOME (N$0)
   (AND (>= N$0 1) (>= (SEQ!LENGTH (HISTORY S)) N$0)
    (IN (SEQ!NTH (HISTORY S) N$0)
     (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1$0)
  (AND (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY S)) N1$0)
   (IN (SEQ!NTH (HISTORY S) N1$0) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1$0)) (>= (SEQ!LENGTH (HISTORY S)) N2$0)
      (IN (SEQ!NTH (HISTORY S) N2$0)
       (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE
 with the instantiation (= N N$0) to ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S))) (IS-GOOD-EVOLUTION-STATE S)
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N)
     (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Invoking IS-GOOD-EVOLUTION-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S)) (IS-GOOD-STATE S)
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N)
     (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (NOT (SEQ!IS-SEQUENCE (HISTORY S)))
  (IF (SEQ!EMPTYP (HISTORY S))
   (AND (IS-STATE S) (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
    (TIME-STRICTLY-INCREASES (HISTORY S))
    (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
    (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES))))
   (SOME (PREVIOUS-STATE)
    (AND (= (HISTORY PREVIOUS-STATE) (SEQ!TAIL (HISTORY S)))
     (IS-GOOD-EVOLUTION-STATE PREVIOUS-STATE) (GOOD-STEP PREVIOUS-STATE S))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K S)
  (SOME (N)
   (AND (>= N 1) (>= (SEQ!LENGTH (HISTORY S)) N)
    (IN (SEQ!NTH (HISTORY S) N)
     (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K)))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY S)) N1)
   (IN (SEQ!NTH (HISTORY S) N1) (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY S)) N2)
      (IN (SEQ!NTH (HISTORY S) N2)
       (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
HEAD-IS-GOOD-EVOLUTION-STATE
Beginning proof of HEAD-IS-GOOD-EVOLUTION-STATE ...
(IMPLIES (IS-GOOD-EVOLUTION S) (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD S)))
Assuming HEAD-OF-GOOD-EVOLUTION generates ...
(IMPLIES
 (AND
  (ALL (SEQUENCE)
   (IMPLIES (IS-GOOD-EVOLUTION SEQUENCE)
    (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD SEQUENCE))))
  (IS-GOOD-EVOLUTION S))
 (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD S)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(TRUE)
FORGEABLE-ENCRYPTED-IMPLIES-IN-PARTS
Beginning proof of FORGEABLE-ENCRYPTED-IMPLIES-IN-PARTS ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (FORGEABLE (MS!ENCRYPT M K) S))
 (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT
   (MS!KNOWN-IN K
    (UNION (SEEN-MESSAGES S)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
  (MS!KNOWN-IN (MS!ENCRYPT M K)
   (UNION (SEEN-MESSAGES S)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
Which simplifies
 when rewriting with MS!STRONG-D3-D4, MS!D2-RULE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT
   (MS!COMP-OF K
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
  (MS!COMP-OF (MS!ENCRYPT M K)
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
Applying MS!NOT-PART-IMPLIES-NOT-COMP-OF to
 (MS!COMP-OF (MS!ENCRYPT M K)
  (UNION (MS!PRINCIPALS)
   (UNION (MS!TEXT-MESSAGES)
    (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))) gives
...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT
   (MS!COMP-OF K
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
  (MS!COMP-OF (MS!ENCRYPT M K)
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
Which simplifies
 when rewriting with UNION.DEFINITION, MS!PARTS-ATOMIC, MS!PARTS-UNION
 forward chaining using MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS,
MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
HISTORY-IS-SEQUENCE
Beginning proof of HISTORY-IS-SEQUENCE ...
(IMPLIES (IS-GOOD-EVOLUTION-STATE S) (SEQ!IS-SEQUENCE (HISTORY S)))
Splitting on (IS-GOOD-STATE S) generates ...
(IF (IS-GOOD-STATE S)
 (IMPLIES (IS-GOOD-EVOLUTION-STATE S) (SEQ!IS-SEQUENCE (HISTORY S)))
 (IMPLIES (IS-GOOD-EVOLUTION-STATE S) (SEQ!IS-SEQUENCE (HISTORY S))))
Which simplifies
 forward chaining using IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION to ...
(IMPLIES (AND (IS-GOOD-STATE S) (IS-GOOD-EVOLUTION-STATE S))
 (SEQ!IS-SEQUENCE (HISTORY S)))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE S) (SUBSET (SEEN-MESSAGES S) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY S))
  (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (FN!IS-FUNCTION (STORES S))
  (= (REL!DOM (STORES S)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES S)) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE S))
 (SEQ!IS-SEQUENCE (HISTORY S)))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
KNOWN-BY-PRINCIPAL-IS-MESSAGE
Beginning proof of KNOWN-BY-PRINCIPAL-IS-MESSAGE ...
(IMPLIES (KNOWN-BY-PRINCIPAL M P S) (IN M (MS!MESSAGES)))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (MS!KNOWN-IN M
  (UNION (STORAGE-OF P S)
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
 (IN M (MS!MESSAGES)))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY to ...
(TRUE)
FORGEABLE-IS-MESSAGE
Beginning proof of FORGEABLE-IS-MESSAGE ...
(IMPLIES (FORGEABLE M S) (IN M (MS!MESSAGES)))
Invoking FORGEABLE gives ...
(IMPLIES
 (MS!KNOWN-IN M
  (UNION (SEEN-MESSAGES S)
   (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
 (IN M (MS!MESSAGES)))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY to ...
(TRUE)
MESSAGE-INDUCTION
Beginning proof of MESSAGE-INDUCTION ...
(IF (OR (NOT (IN M (MS!MESSAGES))) (IN M (MS!ATOMIC-MESSAGES))) (TRUE)
 (ALL (N)
  (IF (< (MS!SIZE N) (MS!SIZE M)) (M< (MS!SIZE N) (MS!SIZE M)) (TRUE))))
Which simplifies
 when rewriting with M<.NAT, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions SUCC.INT, MS!SIZE-NAT,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
SIZE-PROPER-PART
Beginning proof of SIZE-PROPER-PART ...
(IMPLIES
 (AND (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Splitting on (IN M2 (MS!COMBINE-MESSAGES)) generates ...
(IF (IN M2 (MS!COMBINE-MESSAGES))
 (IMPLIES
  (AND (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
   (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
 (IMPLIES
  (AND (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
   (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1))))
Starting case 2 ...
(IMPLIES
 (AND (IN M2 (MS!COMBINE-MESSAGES)) (IN M1 (MS!MESSAGES))
  (IN M2 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Assuming MS!COMBINE-MESSAGES-ARE-CONSTRUCTED with the
instantiations: (= X M2) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN M2 (MS!COMBINE-MESSAGES))
   (SOME (M1$0 M2$0)
    (AND (IN M1$0 (MS!MESSAGES)) (IN M2$0 (MS!MESSAGES))
     (= M2 (MS!COMBINE M1$0 M2$0)))))
  (IN M2 (MS!COMBINE-MESSAGES)) (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!SIZE-NAT, MS!TAG-OF-COMBINE, MS!CB1-COMBINE,
MS!CB2-COMBINE, MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-COMBINE-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M2 (MS!COMBINE-MESSAGES))
  (SOME (M1$0)
   (AND (IN M1$0 (MS!MESSAGES))
    (SOME (M2$0)
     (AND (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0))))))
  (IN M1 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ 1 (MS!SIZE M1))))
Prenexing produces ...
(IMPLIES
 (AND (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
  (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ 1 (MS!SIZE M1))))
Substituting (= M2 (MS!COMBINE M1$0 M2$0)) produces ...
(IMPLIES
 (AND (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
  (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD (MS!COMBINE M1$0 M2$0) (NULLSET))))
  (NOT (= M1 (MS!COMBINE M1$0 M2$0))))
 (>= (MS!SIZE (MS!COMBINE M1$0 M2$0)) (+ 1 (MS!SIZE M1))))
Which simplifies
 when rewriting with IN-PARTS-SETADD, SETADD.DEFINITION,
MS!PARTS-SETADD-COMBINATION
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2
 with the assumptions MS!SIZE-NAT, MS!TAG-OF-COMBINE, MS!CB1-COMBINE,
MS!CB2-COMBINE, MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-COMBINE-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
  (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
  (NOT (= M1 (MS!COMBINE M1$0 M2$0)))
  (OR (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET))))
   (IN M1 (MS!PARTS (SETADD M2$0 (NULLSET))))))
 (>= (MS!SIZE (MS!COMBINE M1$0 M2$0)) (+ 1 (MS!SIZE M1))))
Splitting
on (= (MS!PARTS (SETADD M1$0 (SETADD M2$0 (NULLSET))))
    (MS!PARTS
     (UNION (SETADD M1$0 (NULLSET)) (SETADD M2$0 (NULLSET))))) generates
...
(IF
 (= (MS!PARTS (SETADD M1$0 (SETADD M2$0 (NULLSET))))
  (MS!PARTS (UNION (SETADD M1$0 (NULLSET)) (SETADD M2$0 (NULLSET)))))
 (IMPLIES
  (AND (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
   (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
   (NOT (= M1 (MS!COMBINE M1$0 M2$0)))
   (OR (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET))))
    (IN M1 (MS!PARTS (SETADD M2$0 (NULLSET))))))
  (>= (MS!SIZE (MS!COMBINE M1$0 M2$0)) (+ 1 (MS!SIZE M1))))
 (IMPLIES
  (AND (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
   (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
   (NOT (= M1 (MS!COMBINE M1$0 M2$0)))
   (OR (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET))))
    (IN M1 (MS!PARTS (SETADD M2$0 (NULLSET))))))
  (>= (MS!SIZE (MS!COMBINE M1$0 M2$0)) (+ 1 (MS!SIZE M1)))))
Starting case 2.2 ...
(IMPLIES
 (AND
  (= (MS!PARTS (SETADD M1$0 (SETADD M2$0 (NULLSET))))
   (MS!PARTS (UNION (SETADD M1$0 (NULLSET)) (SETADD M2$0 (NULLSET)))))
  (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
  (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
  (NOT (= M1 (MS!COMBINE M1$0 M2$0)))
  (OR (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET))))
   (IN M1 (MS!PARTS (SETADD M2$0 (NULLSET))))))
 (>= (MS!SIZE (MS!COMBINE M1$0 M2$0)) (+ 1 (MS!SIZE M1))))
Applying MS!PARTS-UNION gives ...
(IMPLIES
 (AND
  (= (MS!PARTS (SETADD M1$0 (SETADD M2$0 (NULLSET))))
   (UNION (MS!PARTS (SETADD M1$0 (NULLSET)))
    (MS!PARTS (SETADD M2$0 (NULLSET)))))
  (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
  (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
  (NOT (= M1 (MS!COMBINE M1$0 M2$0)))
  (OR (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET))))
   (IN M1 (MS!PARTS (SETADD M2$0 (NULLSET))))))
 (>= (MS!SIZE (MS!COMBINE M1$0 M2$0)) (+ 1 (MS!SIZE M1))))
Assuming MS!SIZE-PART with the instantiations: (= M1 M1) (= M2 M1$0) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN M1 (MS!MESSAGES)) (IN M1$0 (MS!MESSAGES))
    (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET)))))
   (>= (MS!SIZE M1$0) (MS!SIZE M1)))
  (= (MS!PARTS (SETADD M1$0 (SETADD M2$0 (NULLSET))))
   (UNION (MS!PARTS (SETADD M1$0 (NULLSET)))
    (MS!PARTS (SETADD M2$0 (NULLSET)))))
  (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
  (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
  (NOT (= M1 (MS!COMBINE M1$0 M2$0)))
  (OR (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET))))
   (IN M1 (MS!PARTS (SETADD M2$0 (NULLSET))))))
 (>= (MS!SIZE (MS!COMBINE M1$0 M2$0)) (+ 1 (MS!SIZE M1))))
Assuming MS!SIZE-PART with the instantiations: (= M1 M1) (= M2 M2$0) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN M1 (MS!MESSAGES)) (IN M2$0 (MS!MESSAGES))
    (IN M1 (MS!PARTS (SETADD M2$0 (NULLSET)))))
   (>= (MS!SIZE M2$0) (MS!SIZE M1)))
  (IMPLIES
   (AND (IN M1 (MS!MESSAGES)) (IN M1$0 (MS!MESSAGES))
    (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET)))))
   (>= (MS!SIZE M1$0) (MS!SIZE M1)))
  (= (MS!PARTS (SETADD M1$0 (SETADD M2$0 (NULLSET))))
   (UNION (MS!PARTS (SETADD M1$0 (NULLSET)))
    (MS!PARTS (SETADD M2$0 (NULLSET)))))
  (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
  (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
  (NOT (= M1 (MS!COMBINE M1$0 M2$0)))
  (OR (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET))))
   (IN M1 (MS!PARTS (SETADD M2$0 (NULLSET))))))
 (>= (MS!SIZE (MS!COMBINE M1$0 M2$0)) (+ 1 (MS!SIZE M1))))
Which simplifies
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-COMBINE, MS!CB1-COMBINE, MS!CB2-COMBINE,
MS!COMBINE-IN-COMBINE-MESSAGES, MS!SET-OF-COMBINE-MESSAGES-NOT-EMPTY,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SIZE-NAT, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND
  (NOT
   (= (MS!PARTS (SETADD M1$0 (SETADD M2$0 (NULLSET))))
    (MS!PARTS (UNION (SETADD M1$0 (NULLSET)) (SETADD M2$0 (NULLSET))))))
  (IN M2 (MS!COMBINE-MESSAGES)) (IN M1$0 (MS!MESSAGES))
  (IN M2$0 (MS!MESSAGES)) (= M2 (MS!COMBINE M1$0 M2$0)) (IN M1 (MS!MESSAGES))
  (NOT (= M1 (MS!COMBINE M1$0 M2$0)))
  (OR (IN M1 (MS!PARTS (SETADD M1$0 (NULLSET))))
   (IN M1 (MS!PARTS (SETADD M2$0 (NULLSET))))))
 (>= (MS!SIZE (MS!COMBINE M1$0 M2$0)) (+ 1 (MS!SIZE M1))))
Which simplifies
 when rewriting with SETRULES!SETADD-COMMUTES, SETRULES!UNION-SUBSET-LEFT,
MS!SUBSET-SETADD, SUBSET.SELF, SETRULES!SETADD-UNION-RIGHT
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (IN M2 (MS!COMBINE-MESSAGES))) (IN M1 (MS!MESSAGES))
  (IN M2 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Splitting on (IN M2 (MS!ENCRYPT-MESSAGES)) generates ...
(IF (IN M2 (MS!ENCRYPT-MESSAGES))
 (IMPLIES
  (AND (NOT (IN M2 (MS!COMBINE-MESSAGES))) (IN M1 (MS!MESSAGES))
   (IN M2 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
 (IMPLIES
  (AND (NOT (IN M2 (MS!COMBINE-MESSAGES))) (IN M1 (MS!MESSAGES))
   (IN M2 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1))))
Starting case 1.2 ...
(IMPLIES
 (AND (IN M2 (MS!ENCRYPT-MESSAGES)) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Assuming MS!ENCRYPT-MESSAGES-ARE-CONSTRUCTED with the
instantiations: (= X M2) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN M2 (MS!ENCRYPT-MESSAGES))
   (SOME (M K)
    (AND (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (= M2 (MS!ENCRYPT M K)))))
  (IN M2 (MS!ENCRYPT-MESSAGES)) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Which simplifies
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY
 with the assumptions MS!SIZE-NAT, MS!SET-OF-COMBINE-MESSAGES-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-ENCRYPT-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M2 (MS!ENCRYPT-MESSAGES))
  (SOME (M)
   (AND (IN M (MS!MESSAGES))
    (SOME (K) (AND (IN K (MS!KEYS)) (= M2 (MS!ENCRYPT M K))))))
  (IN M1 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ 1 (MS!SIZE M1))))
Prenexing produces ...
(IMPLIES
 (AND (IN M2 (MS!ENCRYPT-MESSAGES)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (= M2 (MS!ENCRYPT M K)) (IN M1 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ 1 (MS!SIZE M1))))
Substituting (= M2 (MS!ENCRYPT M K)) produces ...
(IMPLIES
 (AND (IN M2 (MS!ENCRYPT-MESSAGES)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (= M2 (MS!ENCRYPT M K)) (IN M1 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD (MS!ENCRYPT M K) (NULLSET))))
  (NOT (= M1 (MS!ENCRYPT M K))))
 (>= (MS!SIZE (MS!ENCRYPT M K)) (+ 1 (MS!SIZE M1))))
Which simplifies
 when rewriting with SETADD.DEFINITION, MS!PARTS-SETADD-ENCRYPTION
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, >=.SAME.TYPE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY
 with the assumptions MS!SIZE-NAT, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-ENCRYPT-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M2 (MS!ENCRYPT-MESSAGES)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (= M2 (MS!ENCRYPT M K)) (IN M1 (MS!MESSAGES)) (NOT (= M1 (MS!ENCRYPT M K)))
  (IN M1 (MS!PARTS (SETADD M (NULLSET)))))
 (>= (MS!SIZE (MS!ENCRYPT M K)) (+ 1 (MS!SIZE M1))))
Assuming MS!SIZE-PART with the instantiations: (= M1 M1) (= M2 M) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN M1 (MS!MESSAGES)) (IN M (MS!MESSAGES))
    (IN M1 (MS!PARTS (SETADD M (NULLSET)))))
   (>= (MS!SIZE M) (MS!SIZE M1)))
  (IN M2 (MS!ENCRYPT-MESSAGES)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (= M2 (MS!ENCRYPT M K)) (IN M1 (MS!MESSAGES)) (NOT (= M1 (MS!ENCRYPT M K)))
  (IN M1 (MS!PARTS (SETADD M (NULLSET)))))
 (>= (MS!SIZE (MS!ENCRYPT M K)) (+ 1 (MS!SIZE M1))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-ENCRYPT-MESSAGES-NOT-EMPTY, MS!SIZE-NAT,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Splitting on (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)) generates ...
(IF (IN M2 (MS!SHARE-ENCRYPT-MESSAGES))
 (IMPLIES
  (AND (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
   (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
   (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
 (IMPLIES
  (AND (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
   (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
   (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1))))
Starting case 1.1.2 ...
(IMPLIES
 (AND (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)) (NOT (IN M2 (MS!ENCRYPT-MESSAGES)))
  (NOT (IN M2 (MS!COMBINE-MESSAGES))) (IN M1 (MS!MESSAGES))
  (IN M2 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Assuming MS!SHARE-ENCRYPT-MESSAGES-ARE-CONSTRUCTED with the
instantiations: (= X M2) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN M2 (MS!SHARE-ENCRYPT-MESSAGES))
   (SOME (M K1 K2)
    (AND (IN M (MS!MESSAGES)) (IN K1 (MS!ASYMMETRIC-KEYS))
     (IN K2 (MS!ASYMMETRIC-KEYS)) (= M2 (MS!SHARE-ENCRYPT M K1 K2)))))
  (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)) (NOT (IN M2 (MS!ENCRYPT-MESSAGES)))
  (NOT (IN M2 (MS!COMBINE-MESSAGES))) (IN M1 (MS!MESSAGES))
  (IN M2 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Which simplifies
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, >=.SAME.TYPE,
MS!TAG-OF-SHARE-ENCRYPT-MESSAGES, MS!SHARE-ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-SHENDT, MS!SIZE-SHENKY1, MS!SIZE-SHENKY2
 with the assumptions MS!SIZE-NAT, MS!SET-OF-COMBINE-MESSAGES-NOT-EMPTY,
MS!SET-OF-ENCRYPT-MESSAGES-NOT-EMPTY, MS!TAG-OF-SHARE-ENCRYPT,
MS!SHENDT-SHARE-ENCRYPT, MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT,
MS!SHARE-ENCRYPT-IN-SHARE-ENCRYPT-MESSAGES,
MS!SET-OF-ASYMMETRIC-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-SHARE-ENCRYPT-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M2 (MS!SHARE-ENCRYPT-MESSAGES))
  (SOME (M)
   (AND (IN M (MS!MESSAGES))
    (SOME (K1)
     (AND (IN K1 (MS!ASYMMETRIC-KEYS))
      (SOME (K2)
       (AND (IN K2 (MS!ASYMMETRIC-KEYS))
        (= M2 (MS!SHARE-ENCRYPT M K1 K2))))))))
  (IN M1 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ 1 (MS!SIZE M1))))
Prenexing produces ...
(IMPLIES
 (AND (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)) (IN M (MS!MESSAGES))
  (IN K1 (MS!ASYMMETRIC-KEYS)) (IN K2 (MS!ASYMMETRIC-KEYS))
  (= M2 (MS!SHARE-ENCRYPT M K1 K2)) (IN M1 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ 1 (MS!SIZE M1))))
Substituting (= M2 (MS!SHARE-ENCRYPT M K1 K2)) produces ...
(IMPLIES
 (AND (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)) (IN M (MS!MESSAGES))
  (IN K1 (MS!ASYMMETRIC-KEYS)) (IN K2 (MS!ASYMMETRIC-KEYS))
  (= M2 (MS!SHARE-ENCRYPT M K1 K2)) (IN M1 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD (MS!SHARE-ENCRYPT M K1 K2) (NULLSET))))
  (NOT (= M1 (MS!SHARE-ENCRYPT M K1 K2))))
 (>= (MS!SIZE (MS!SHARE-ENCRYPT M K1 K2)) (+ 1 (MS!SIZE M1))))
Which simplifies
 when rewriting with SETADD.DEFINITION, MS!PARTS-SETADD-SHARE-ENCRYPTION
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, >=.SAME.TYPE, MS!TAG-OF-SHARE-ENCRYPT-MESSAGES,
MS!SHARE-ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-SHENDT, MS!SIZE-SHENKY1,
MS!SIZE-SHENKY2
 with the assumptions MS!SIZE-NAT, MS!TAG-OF-SHARE-ENCRYPT,
MS!SHENDT-SHARE-ENCRYPT, MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT,
MS!SHARE-ENCRYPT-IN-SHARE-ENCRYPT-MESSAGES,
MS!SET-OF-ASYMMETRIC-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-SHARE-ENCRYPT-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)) (IN M (MS!MESSAGES))
  (IN K1 (MS!ASYMMETRIC-KEYS)) (IN K2 (MS!ASYMMETRIC-KEYS))
  (= M2 (MS!SHARE-ENCRYPT M K1 K2)) (IN M1 (MS!MESSAGES))
  (NOT (= M1 (MS!SHARE-ENCRYPT M K1 K2)))
  (IN M1 (MS!PARTS (SETADD M (NULLSET)))))
 (>= (MS!SIZE (MS!SHARE-ENCRYPT M K1 K2)) (+ 1 (MS!SIZE M1))))
Assuming MS!SIZE-PART with the instantiations: (= M1 M1) (= M2 M) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN M1 (MS!MESSAGES)) (IN M (MS!MESSAGES))
    (IN M1 (MS!PARTS (SETADD M (NULLSET)))))
   (>= (MS!SIZE M) (MS!SIZE M1)))
  (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)) (IN M (MS!MESSAGES))
  (IN K1 (MS!ASYMMETRIC-KEYS)) (IN K2 (MS!ASYMMETRIC-KEYS))
  (= M2 (MS!SHARE-ENCRYPT M K1 K2)) (IN M1 (MS!MESSAGES))
  (NOT (= M1 (MS!SHARE-ENCRYPT M K1 K2)))
  (IN M1 (MS!PARTS (SETADD M (NULLSET)))))
 (>= (MS!SIZE (MS!SHARE-ENCRYPT M K1 K2)) (+ 1 (MS!SIZE M1))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-SHARE-ENCRYPT-MESSAGES,
MS!SHARE-ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-SHENDT, MS!SIZE-SHENKY1,
MS!SIZE-SHENKY2, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT,
MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT,
MS!SHARE-ENCRYPT-IN-SHARE-ENCRYPT-MESSAGES,
MS!SET-OF-ASYMMETRIC-KEYS-NOT-EMPTY,
MS!SET-OF-SHARE-ENCRYPT-MESSAGES-NOT-EMPTY, MS!SIZE-NAT,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1.1.1 ...
(IMPLIES
 (AND (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
  (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Splitting on (IN M2 (MS!HASH-MESSAGES)) generates ...
(IF (IN M2 (MS!HASH-MESSAGES))
 (IMPLIES
  (AND (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
   (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
   (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
   (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
 (IMPLIES
  (AND (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
   (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
   (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
   (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1))))
Starting case 1.1.1.2 ...
(IMPLIES
 (AND (IN M2 (MS!HASH-MESSAGES)) (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
  (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Assuming MS!HASH-MESSAGES-ARE-CONSTRUCTED with the
instantiations: (= X M2) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN M2 (MS!HASH-MESSAGES))
   (SOME (M) (AND (IN M (MS!MESSAGES)) (= M2 (MS!HASH M)))))
  (IN M2 (MS!HASH-MESSAGES)) (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
  (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Which simplifies
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-SHARE-ENCRYPT-MESSAGES,
MS!SHARE-ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-SHENDT, MS!SIZE-SHENKY1,
MS!SIZE-SHENKY2, >=.SAME.TYPE, MS!TAG-OF-HASH-MESSAGES,
MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT
 with the assumptions MS!SIZE-NAT, MS!SET-OF-COMBINE-MESSAGES-NOT-EMPTY,
MS!SET-OF-ENCRYPT-MESSAGES-NOT-EMPTY,
MS!SET-OF-SHARE-ENCRYPT-MESSAGES-NOT-EMPTY, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-HASH-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M2 (MS!HASH-MESSAGES))
  (SOME (M) (AND (IN M (MS!MESSAGES)) (= M2 (MS!HASH M))))
  (IN M1 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ 1 (MS!SIZE M1))))
Prenexing produces ...
(IMPLIES
 (AND (IN M2 (MS!HASH-MESSAGES)) (IN M (MS!MESSAGES)) (= M2 (MS!HASH M))
  (IN M1 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ 1 (MS!SIZE M1))))
Substituting (= M2 (MS!HASH M)) produces ...
(IMPLIES
 (AND (IN M2 (MS!HASH-MESSAGES)) (IN M (MS!MESSAGES)) (= M2 (MS!HASH M))
  (IN M1 (MS!MESSAGES)) (IN M1 (MS!PARTS (SETADD (MS!HASH M) (NULLSET))))
  (NOT (= M1 (MS!HASH M))))
 (>= (MS!SIZE (MS!HASH M)) (+ 1 (MS!SIZE M1))))
Which simplifies
 when rewriting with SETADD.DEFINITION, MS!PARTS-SETADD-HASH
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-HASH-MESSAGES,
MS!HASH-MESSAGE-IN-MESSAGES, MS!SIZE-HSDT
 with the assumptions MS!SIZE-NAT, MS!TAG-OF-HASH, MS!HSDT-HASH,
MS!HASH-IN-HASH-MESSAGES, MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-HASH-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN M2 (MS!HASH-MESSAGES)) (IN M (MS!MESSAGES)) (= M2 (MS!HASH M))
  (IN M1 (MS!MESSAGES)) (NOT (= M1 (MS!HASH M)))
  (IN M1 (MS!PARTS (SETADD M (NULLSET)))))
 (>= (MS!SIZE (MS!HASH M)) (+ 1 (MS!SIZE M1))))
Assuming MS!SIZE-PART with the instantiations: (= M1 M1) (= M2 M) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN M1 (MS!MESSAGES)) (IN M (MS!MESSAGES))
    (IN M1 (MS!PARTS (SETADD M (NULLSET)))))
   (>= (MS!SIZE M) (MS!SIZE M1)))
  (IN M2 (MS!HASH-MESSAGES)) (IN M (MS!MESSAGES)) (= M2 (MS!HASH M))
  (IN M1 (MS!MESSAGES)) (NOT (= M1 (MS!HASH M)))
  (IN M1 (MS!PARTS (SETADD M (NULLSET)))))
 (>= (MS!SIZE (MS!HASH M)) (+ 1 (MS!SIZE M1))))
Which simplifies
 forward chaining using MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-HASH, MS!HSDT-HASH, MS!HASH-IN-HASH-MESSAGES,
MS!SET-OF-HASH-MESSAGES-NOT-EMPTY, MS!SIZE-NAT,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1.1.1.1 ...
(IMPLIES
 (AND (NOT (IN M2 (MS!HASH-MESSAGES)))
  (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
  (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Splitting on (IN M2 (MS!ATOMIC-MESSAGES)) generates ...
(IF (IN M2 (MS!ATOMIC-MESSAGES))
 (IMPLIES
  (AND (NOT (IN M2 (MS!HASH-MESSAGES)))
   (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
   (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
   (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
   (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
 (IMPLIES
  (AND (NOT (IN M2 (MS!HASH-MESSAGES)))
   (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
   (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
   (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
   (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
  (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1))))
Starting case 1.1.1.1.2 ...
(IMPLIES
 (AND (IN M2 (MS!ATOMIC-MESSAGES)) (NOT (IN M2 (MS!HASH-MESSAGES)))
  (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
  (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Which simplifies
 when rewriting with NULLSET.DEFINITION, SETADD.DEFINITION, MS!PARTS-ATOMIC,
SUBSET.NULLSET.LEFT, SETRULES!SUBSET-SETADD
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-SHARE-ENCRYPT-MESSAGES,
MS!SHARE-ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-SHENDT, MS!SIZE-SHENKY1,
MS!SIZE-SHENKY2, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-COMBINE-MESSAGES-NOT-EMPTY, MS!SET-OF-ENCRYPT-MESSAGES-NOT-EMPTY,
MS!SET-OF-SHARE-ENCRYPT-MESSAGES-NOT-EMPTY, MS!SET-OF-HASH-MESSAGES-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1.1.1.1.1 ...
(IMPLIES
 (AND (NOT (IN M2 (MS!ATOMIC-MESSAGES))) (NOT (IN M2 (MS!HASH-MESSAGES)))
  (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
  (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES)) (IN M2 (MS!MESSAGES))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Applying MS!IN-MESSAGES-DEFINITION to
 (IN M2 (MS!MESSAGES)) gives ...
(IMPLIES
 (AND (NOT (IN M2 (MS!ATOMIC-MESSAGES))) (NOT (IN M2 (MS!HASH-MESSAGES)))
  (NOT (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)))
  (NOT (IN M2 (MS!ENCRYPT-MESSAGES))) (NOT (IN M2 (MS!COMBINE-MESSAGES)))
  (IN M1 (MS!MESSAGES))
  (OR (IN M2 (MS!ATOMIC-MESSAGES)) (IN M2 (MS!ENCRYPT-MESSAGES))
   (IN M2 (MS!SHARE-ENCRYPT-MESSAGES)) (IN M2 (MS!COMBINE-MESSAGES))
   (IN M2 (MS!HASH-MESSAGES)))
  (IN M1 (MS!PARTS (SETADD M2 (NULLSET)))) (NOT (= M1 M2)))
 (>= (MS!SIZE M2) (+ (MS!SIZE M1) 1)))
Which simplifies
 forward chaining using MS!TAG-OF-COMBINE-MESSAGES,
MS!COMBINE-MESSAGE-IN-MESSAGES, MS!SIZE-CB1, MS!SIZE-CB2,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-SHARE-ENCRYPT-MESSAGES,
MS!SHARE-ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-SHENDT, MS!SIZE-SHENKY1,
MS!SIZE-SHENKY2, MS!TAG-OF-HASH-MESSAGES, MS!HASH-MESSAGE-IN-MESSAGES,
MS!SIZE-HSDT, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC
 with the assumptions MS!SET-OF-MESSAGES-NOT-EMPTY,
MS!SET-OF-COMBINE-MESSAGES-NOT-EMPTY, MS!SET-OF-ENCRYPT-MESSAGES-NOT-EMPTY,
MS!SET-OF-SHARE-ENCRYPT-MESSAGES-NOT-EMPTY, MS!SET-OF-HASH-MESSAGES-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
Completing all cases produces ...
(TRUE)
N-SEQUENCE-INDUCTION
Beginning proof of N-SEQUENCE-INDUCTION ...
(IF (SEQ!EMPTYP SEQUENCE) (TRUE)
 (M< (SEQ!LENGTH (SEQ!TAIL SEQUENCE)) (SEQ!LENGTH SEQUENCE)))
Invoking (SEQ!LENGTH SEQUENCE) gives ...
(OR (SEQ!EMPTYP SEQUENCE)
 (M< (SEQ!LENGTH (SEQ!TAIL SEQUENCE))
  (IF (SEQ!IS-TACK SEQUENCE) (+ 1 (SEQ!LENGTH (SEQ!TAIL SEQUENCE))) 0)))
Which simplifies
 when rewriting with M<.NAT, SUCC.INT.RULE, IS-TACK-EQUIV-NON-ZERO-LENGTH,
SEQ!EMPTYP-DEFINITION
 forward chaining using >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SUCC.INT, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION-2
Beginning proof of HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION-2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (<= (+ N 1) (SEQ!LENGTH SEQUENCE)))
 (= (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N))
  (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))
Applying HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
  (>= (SEQ!LENGTH SEQUENCE) (+ N 1)))
 (=
  (IF
   (AND (IS-GOOD-EVOLUTION SEQUENCE) (>= N 1)
    (>= (- (SEQ!LENGTH SEQUENCE) 1) N))
   (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))
   (HISTORY (SEQ!NTH (SEQ!TAIL SEQUENCE) N)))
  (SEQ!TAIL (HISTORY (SEQ!NTH SEQUENCE N)))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
N1-N2-INDUCTION
Beginning proof of N1-N2-INDUCTION ...
(IF (>= N2 2) (M< (- N2 1) N2) (TRUE))
Which simplifies
 when rewriting with M<.NAT
 forward chaining using >=.SAME.TYPE
 with the assumptions SUCC.INT to ...
(TRUE)
LENGTH-HISTORY-NTH
Beginning proof of LENGTH-HISTORY-NTH ...
(IMPLIES (AND (IS-GOOD-EVOLUTION S) (>= N 1) (<= N (SEQ!LENGTH S)))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (- (SEQ!LENGTH S) N)))
Inducting using the following scheme ...
 (AND (IMPLIES (SEQ!EMPTYP S) (*P* N S))
  (IMPLIES (AND (NOT (SEQ!EMPTYP S)) (*P* (- N 1) (SEQ!TAIL S))) (*P* N S)))
 produces ...
(AND
 (IMPLIES (SEQ!EMPTYP S)
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (>= N 1) (<= N (SEQ!LENGTH S)))
   (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (- (SEQ!LENGTH S) N))))
 (IMPLIES
  (AND (NOT (SEQ!EMPTYP S))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= (- N 1) 1)
     (<= (- N 1) (SEQ!LENGTH (SEQ!TAIL S))))
    (= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N 1))))
     (- (SEQ!LENGTH (SEQ!TAIL S)) (- N 1)))))
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (>= N 1) (<= N (SEQ!LENGTH S)))
   (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (- (SEQ!LENGTH S) N)))))
Starting case 2 ...
(IMPLIES
 (AND (SEQ!EMPTYP S) (IS-GOOD-EVOLUTION S) (>= N 1) (<= N (SEQ!LENGTH S)))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (- (SEQ!LENGTH S) N)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (SEQ!EMPTYP S))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= (- N 1) 1)
    (<= (- N 1) (SEQ!LENGTH (SEQ!TAIL S))))
   (= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N 1))))
    (- (SEQ!LENGTH (SEQ!TAIL S)) (- N 1))))
  (IS-GOOD-EVOLUTION S) (>= N 1) (<= N (SEQ!LENGTH S)))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (- (SEQ!LENGTH S) N)))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (NOT (SEQ!EMPTYP S)) (IS-GOOD-EVOLUTION S)
  (<= N (SEQ!LENGTH S))
  (IMPLIES
   (AND (>= (- N 1) 1) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
    (<= (- N 1) (SEQ!LENGTH (SEQ!TAIL S))))
   (= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N 1))))
    (- (SEQ!LENGTH (SEQ!TAIL S)) (- N 1)))))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (- (SEQ!LENGTH S) N)))
Which simplifies
 when rewriting with HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION-2,
IS-GOOD-EVOLUTION-TAIL, IS-TACK-EQUIV-NON-ZERO-LENGTH, SEQ!EMPTYP-DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N))
 (IF (>= (+ -1 N) 1)
  (IF (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N))
   (IMPLIES
    (= (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))
     (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S))))
    (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (+ (* -1 N) (SEQ!LENGTH S))))
   (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (+ (* -1 N) (SEQ!LENGTH S))))
  (= (SEQ!LENGTH (HISTORY (SEQ!NTH S 1))) (+ -1 (SEQ!LENGTH S)))))
Starting case 1.2 ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N) (>= (+ -1 N) 1))
 (IF (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N))
  (IMPLIES
   (= (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))
    (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S))))
   (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (+ (* -1 N) (SEQ!LENGTH S))))
  (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (+ (* -1 N) (SEQ!LENGTH S)))))
Starting case 1.2.2 ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N))
  (= (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))
   (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S)))))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (+ (* -1 N) (SEQ!LENGTH S))))
Invoking (SEQ!NTH S N) gives ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N))
  (= (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))
   (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S)))))
 (=
  (SEQ!LENGTH
   (HISTORY (IF (>= N 2) (SEQ!NTH (SEQ!TAIL S) (- N 1)) (SEQ!HEAD S))))
  (+ (* -1 N) (SEQ!LENGTH S))))
Invoking (SEQ!LENGTH S) gives ...
(IMPLIES
 (AND (>= N 1) (>= (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0) 1)
  (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0) N)
  (>= (+ -1 N) 1) (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N))
  (= (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))
   (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S)))))
 (=
  (SEQ!LENGTH
   (HISTORY (IF (>= N 2) (SEQ!NTH (SEQ!TAIL S) (- N 1)) (SEQ!HEAD S))))
  (+ (* -1 N) (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N) (>= (+ -1 N) 1)
  (= (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))
   (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S)))))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S)))))
Applying HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N) (>= (+ -1 N) 1)
  (= (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))
   (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S)))))
 (=
  (SEQ!LENGTH
   (IF
    (AND (IS-GOOD-EVOLUTION S) (>= (+ -1 N) 1)
     (>= (- (SEQ!LENGTH S) 1) (+ -1 N)))
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))
    (HISTORY (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))
  (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N) (>= (+ -1 N) 1)
  (= (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))
   (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S))))
  (NOT (>= (+ -1 (SEQ!LENGTH S)) (+ -1 N))))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S)))))
Invoking (SEQ!LENGTH S) gives ...
(IMPLIES
 (AND (>= N 1) (>= (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0) 1)
  (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) N) (>= (+ -1 N) 1)
  (= (SEQ!LENGTH (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))
   (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S))))
  (NOT
   (>= (+ -1 (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0))
    (+ -1 N))))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (+ 1 (* -1 N) (SEQ!LENGTH (SEQ!TAIL S)))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1.2.1 ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N) (>= (+ -1 N) 1)
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N))))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) (+ (* -1 N) (SEQ!LENGTH S))))
Invoking (SEQ!LENGTH S) gives ...
(IMPLIES
 (AND (>= N 1) (>= (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0) 1)
  (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0) N)
  (>= (+ -1 N) 1) (NOT (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N))))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH S N)))
  (+ (* -1 N) (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N) (NOT (>= (+ -1 N) 1)))
 (= (SEQ!LENGTH (HISTORY (SEQ!NTH S 1))) (+ -1 (SEQ!LENGTH S))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) 1) (SEQ!IS-SEQUENCE S) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N) (NOT (>= (+ -1 N) 1)))
 (=
  (SEQ!LENGTH
   (HISTORY (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S))))
  (+ -1 (SEQ!LENGTH S))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
NTH-HISTORY-NTH-EVOLUTION
Beginning proof of NTH-HISTORY-NTH-EVOLUTION ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N1 1)
  (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S)))) (>= N2 1)
  (<= N2 (SEQ!LENGTH (HISTORY (SEQ!NTH S N1)))))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 N2) 1))))))
Inducting using the following scheme ...
 (AND (IMPLIES (AND (>= N2 2) (*P* (+ N1 1) (- N2 1) S)) (*P* N1 N2 S))
  (IMPLIES (NOT (>= N2 2)) (*P* N1 N2 S)))
 produces ...
(AND
 (IMPLIES
  (AND (>= N2 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION S) (>= (+ N1 1) 1)
     (<= (+ N1 1) (SEQ!LENGTH (HISTORY (SEQ!HEAD S)))) (>= (- N2 1) 1)
     (<= (- N2 1) (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N1 1))))))
    (= (SEQ!NTH (HISTORY (SEQ!NTH S (+ N1 1))) (- N2 1))
     (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 1 (- N2 1)) 1)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N1 1)
    (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S)))) (>= N2 1)
    (<= N2 (SEQ!LENGTH (HISTORY (SEQ!NTH S N1)))))
   (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 N2) 1)))))))
 (IMPLIES (NOT (>= N2 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N1 1)
    (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S)))) (>= N2 1)
    (<= N2 (SEQ!LENGTH (HISTORY (SEQ!NTH S N1)))))
   (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 N2) 1))))))))
Starting case 2 ...
(IMPLIES
 (AND (>= N2 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (+ N1 1) 1)
    (<= (+ N1 1) (SEQ!LENGTH (HISTORY (SEQ!HEAD S)))) (>= (- N2 1) 1)
    (<= (- N2 1) (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N1 1))))))
   (= (SEQ!NTH (HISTORY (SEQ!NTH S (+ N1 1))) (- N2 1))
    (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 1 (- N2 1)) 1))))))
  (IS-GOOD-EVOLUTION S) (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
  (>= N2 1) (<= N2 (SEQ!LENGTH (HISTORY (SEQ!NTH S N1)))))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 N2) 1))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (>= N2 1) (IS-GOOD-EVOLUTION S)
  (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
  (<= N2 (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))))
  (IMPLIES
   (AND (>= (+ N1 1) 1) (>= (- N2 1) 1) (IS-GOOD-EVOLUTION S)
    (<= (+ N1 1) (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
    (<= (- N2 1) (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N1 1))))))
   (= (SEQ!NTH (HISTORY (SEQ!NTH S (+ N1 1))) (- N2 1))
    (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 1 (- N2 1)) 1)))))))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 N2) 1))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))) N2))
 (IF (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (IF (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) (+ -1 N2))
   (IMPLIES
    (= (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) (+ -1 N2))
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2)))))
    (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
   (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
  (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2)))))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))) N2)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)))
 (IF (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) (+ -1 N2))
  (IMPLIES
   (= (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) (+ -1 N2))
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2)))))
   (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
  (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2)))))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))) N2)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) (+ -1 N2))
  (= (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) (+ -1 N2))
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
Invoking (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2) gives ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))) N2)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) (+ -1 N2))
  (= (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) (+ -1 N2))
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
 (=
  (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!NTH S N1))) (- N2 1))
   (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))) N2)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) (+ -1 N2))
  (= (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) (+ -1 N2))
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
 (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!NTH S N1))) (+ -1 N2))
  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
Invoking (SEQ!NTH S (+ 1 N1)) gives ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))) N2)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>=
   (SEQ!LENGTH
    (HISTORY
     (IF (>= (+ 1 N1) 2) (SEQ!NTH (SEQ!TAIL S) (- (+ 1 N1) 1)) (SEQ!HEAD S))))
   (+ -1 N2))
  (=
   (SEQ!NTH
    (HISTORY
     (IF (>= (+ 1 N1) 2) (SEQ!NTH (SEQ!TAIL S) (- (+ 1 N1) 1)) (SEQ!HEAD S)))
    (+ -1 N2))
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
 (= (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!NTH S N1))) (+ -1 N2))
  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
Which simplifies
 when rewriting with HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION-2
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))) N2)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) (+ -1 N2))))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>=
   (IF (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (SEQ!LENGTH S) N1))
    (- (SEQ!LENGTH S) N1) (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))))
   N2)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (NOT
   (>=
    (IF
     (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1)))
     (- (SEQ!LENGTH S) (+ 1 N1)) (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
    (+ -1 N2))))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))) N2)
  (NOT (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND (>= N2 2) (>= N1 1) (IS-GOOD-EVOLUTION S) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (>=
   (IF (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (SEQ!LENGTH S) N1))
    (- (SEQ!LENGTH S) N1) (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))))
   N2)
  (NOT (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N1 N2))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= N2 2)) (IS-GOOD-EVOLUTION S) (>= N1 1)
  (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S)))) (>= N2 1)
  (<= N2 (SEQ!LENGTH (HISTORY (SEQ!NTH S N1)))))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 N2) 1))))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND (NOT (>= N2 2)) (IS-GOOD-EVOLUTION S) (>= N1 1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1) (>= N2 1)
  (>=
   (IF (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (SEQ!LENGTH S) N1))
    (- (SEQ!LENGTH S) N1) (SEQ!LENGTH (HISTORY (SEQ!NTH S N1))))
   N2))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) N2)
  (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N1 N2) 1))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (NOT (>= N2 2)) (IS-GOOD-EVOLUTION S) (>= N1 1)
  (>= (+ -1 (SEQ!LENGTH S)) N1) (>= N2 1))
 (= (SEQ!NTH (HISTORY (SEQ!NTH S N1)) 1) (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
Invoking (SEQ!NTH (HISTORY (SEQ!NTH S N1)) 1) gives ...
(IMPLIES
 (AND (NOT (>= N2 2)) (IS-GOOD-EVOLUTION S) (>= N1 1)
  (>= (+ -1 (SEQ!LENGTH S)) N1) (>= N2 1))
 (=
  (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (HISTORY (SEQ!NTH S N1))) (- 1 1))
   (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
  (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
HEAD-HISTORY-IN-EVENTS
Beginning proof of HEAD-HISTORY-IN-EVENTS ...
(IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (>= (SEQ!LENGTH (HISTORY S)) 1))
 (= (IN (SEQ!HEAD (HISTORY S)) (EVENTS)) (TRUE)))
Splitting on (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) generates ...
(IF (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS)))
 (IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (>= (SEQ!LENGTH (HISTORY S)) 1))
  (= (IN (SEQ!HEAD (HISTORY S)) (EVENTS)) (TRUE)))
 (IMPLIES (AND (IS-GOOD-EVOLUTION-STATE S) (>= (SEQ!LENGTH (HISTORY S)) 1))
  (= (IN (SEQ!HEAD (HISTORY S)) (EVENTS)) (TRUE))))
Starting case 2 ...
(IMPLIES
 (AND (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))) (IS-GOOD-EVOLUTION-STATE S)
  (>= (SEQ!LENGTH (HISTORY S)) 1))
 (= (IN (SEQ!HEAD (HISTORY S)) (EVENTS)) (TRUE)))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY S))
  (SUBSET (SEQ!MEMBERS (HISTORY S)) (EVENTS)) (IS-GOOD-EVOLUTION-STATE S)
  (>= (SEQ!LENGTH (HISTORY S)) 1))
 (IN (SEQ!HEAD (HISTORY S)) (EVENTS)))
Invoking SUBSET gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (E) (IMPLIES (IN E (SEQ!MEMBERS (HISTORY S))) (IN E (EVENTS))))
  (IS-GOOD-EVOLUTION-STATE S) (>= (SEQ!LENGTH (HISTORY S)) 1))
 (IN (SEQ!HEAD (HISTORY S)) (EVENTS)))
Invoking SEQ!MEMBERS gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY S))
  (ALL (E)
   (IMPLIES
    (IN E
     (IF (SEQ!IS-TACK (HISTORY S))
      (SETADD (SEQ!HEAD (HISTORY S)) (SEQ!MEMBERS (SEQ!TAIL (HISTORY S))))
      (NULLSET)))
    (IN E (EVENTS))))
  (IS-GOOD-EVOLUTION-STATE S) (>= (SEQ!LENGTH (HISTORY S)) 1))
 (IN (SEQ!HEAD (HISTORY S)) (EVENTS)))
Instantiating (= E (SEQ!HEAD (HISTORY S))) gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY S))
  (IMPLIES
   (IN (SEQ!HEAD (HISTORY S))
    (IF (SEQ!IS-TACK (HISTORY S))
     (SETADD (SEQ!HEAD (HISTORY S)) (SEQ!MEMBERS (SEQ!TAIL (HISTORY S))))
     (NULLSET)))
   (IN (SEQ!HEAD (HISTORY S)) (EVENTS)))
  (ALL (E)
   (IMPLIES
    (IN E
     (IF (SEQ!IS-TACK (HISTORY S))
      (SETADD (SEQ!HEAD (HISTORY S)) (SEQ!MEMBERS (SEQ!TAIL (HISTORY S))))
      (NULLSET)))
    (IN E (EVENTS))))
  (IS-GOOD-EVOLUTION-STATE S) (>= (SEQ!LENGTH (HISTORY S)) 1))
 (IN (SEQ!HEAD (HISTORY S)) (EVENTS)))
Which simplifies
 when rewriting with SEQ!IN-MEMBERS, NULLSET.DEFINITION, SETADD.DEFINITION,
IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (IN (HISTORY S) (SEQ!SEQUENCE-OF (EVENTS))))
  (IS-GOOD-EVOLUTION-STATE S) (>= (SEQ!LENGTH (HISTORY S)) 1))
 (= (IN (SEQ!HEAD (HISTORY S)) (EVENTS)) (TRUE)))
Which simplifies
 forward chaining using IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
MEMBER-HISTORY-NTH
Beginning proof of MEMBER-HISTORY-NTH ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (<= (+ N1 1) (SEQ!LENGTH S)) (>= N2 1)
  (>= N1 N2) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= N1 2) (*P* E (- N1 1) N2 (SEQ!TAIL S))
    (*P* E (- N1 1) (- N2 1) (SEQ!TAIL S)))
   (*P* E N1 N2 S))
  (IMPLIES (NOT (>= N1 2)) (*P* E N1 N2 S)))
 produces ...
(AND
 (IMPLIES
  (AND (>= N1 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= (- N1 1) 1)
     (<= (+ (- N1 1) 1) (SEQ!LENGTH (SEQ!TAIL S))) (>= N2 1) (>= (- N1 1) N2)
     (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N1 1)))))
    (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) N2))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= (- N1 1) 1)
     (<= (+ (- N1 1) 1) (SEQ!LENGTH (SEQ!TAIL S))) (>= (- N2 1) 1)
     (>= (- N1 1) (- N2 1))
     (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N1 1)))))
    (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N2 1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (<= (+ N1 1) (SEQ!LENGTH S)) (>= N2 1)
    (>= N1 N2) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))))
   (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2)))))
 (IMPLIES (NOT (>= N1 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (<= (+ N1 1) (SEQ!LENGTH S)) (>= N2 1)
    (>= N1 N2) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))))
   (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))))
Starting case 2 ...
(IMPLIES
 (AND (>= N1 2)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= (- N1 1) 1)
    (<= (+ (- N1 1) 1) (SEQ!LENGTH (SEQ!TAIL S))) (>= N2 1) (>= (- N1 1) N2)
    (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N1 1)))))
   (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) N2))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= (- N1 1) 1)
    (<= (+ (- N1 1) 1) (SEQ!LENGTH (SEQ!TAIL S))) (>= (- N2 1) 1)
    (>= (- N1 1) (- N2 1))
    (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N1 1)))))
   (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N2 1)))))
  (IS-GOOD-EVOLUTION S) (>= N1 1) (<= (+ N1 1) (SEQ!LENGTH S)) (>= N2 1)
  (>= N1 N2) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 2) (>= N1 1) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (<= (+ N1 1) (SEQ!LENGTH S)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (IMPLIES
   (AND (>= N2 1) (>= (- N1 1) 1) (>= (- N1 1) N2)
    (IS-GOOD-EVOLUTION (SEQ!TAIL S))
    (<= (+ (- N1 1) 1) (SEQ!LENGTH (SEQ!TAIL S)))
    (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N1 1)))))
   (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) N2))))
  (IMPLIES
   (AND (>= (- N1 1) 1) (>= (- N2 1) 1) (>= (- N1 1) (- N2 1))
    (IS-GOOD-EVOLUTION (SEQ!TAIL S))
    (<= (+ (- N1 1) 1) (SEQ!LENGTH (SEQ!TAIL S)))
    (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N1 1)))))
   (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH (SEQ!TAIL S) (- N2 1))))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Which simplifies
 when rewriting with HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION-2,
IS-GOOD-EVOLUTION-TAIL
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (>= (+ -1 N1) N2))
 (IF (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (IF (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
   (IMPLIES (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S N2))))
    (IF (>= (+ -1 N2) 1)
     (IMPLIES (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N2)))))
      (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
     (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S 1)))))
   (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2)))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1))
 (IF (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
  (IMPLIES (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S N2))))
   (IF (>= (+ -1 N2) 1)
    (IMPLIES (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N2)))))
     (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
    (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S 1)))))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2)))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S N2)))))
 (IF (>= (+ -1 N2) 1)
  (IMPLIES (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N2)))))
   (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S 1)))))
Starting case 2.2.2.2 ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S N2)))) (>= (+ -1 N2) 1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N2))))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Invoking (SEQ!NTH S N2) gives ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
  (SEQ!IS-MEMBER E
   (SEQ!TAIL
    (HISTORY (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL S) (- N2 1)) (SEQ!HEAD S)))))
  (>= (+ -1 N2) 1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N2))))))
 (SEQ!IS-MEMBER E
  (HISTORY (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL S) (- N2 1)) (SEQ!HEAD S)))))
Which simplifies
 when rewriting with HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION-2
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.2.1 ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S N2))))
  (NOT (>= (+ -1 N2) 1)))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S 1))))
Splitting on (= N2 1) generates ...
(IF (= N2 1)
 (IMPLIES
  (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
   (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
   (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
   (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
   (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S N2))))
   (NOT (>= (+ -1 N2) 1)))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S 1))))
 (IMPLIES
  (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
   (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
   (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
   (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
   (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S N2))))
   (NOT (>= (+ -1 N2) 1)))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S 1)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 1) (>= N1 2) (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) (+ 1 N1))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S 1)))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S 1))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND (= N2 1) (>= N1 2) (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) (+ 1 N1))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
  (SEQ!IS-MEMBER E
   (SEQ!TAIL
    (HISTORY (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S))))))
 (SEQ!IS-MEMBER E
  (HISTORY (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N2 1) (>= N1 2) (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) (+ 1 N1))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!HEAD S)))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!HEAD S))))
Invoking (SEQ!IS-MEMBER E (HISTORY (SEQ!HEAD S))) gives ...
(IMPLIES
 (AND (= N2 1) (>= N1 2) (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) (+ 1 N1))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))
  (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!HEAD S)))))
 (AND (SEQ!IS-TACK (HISTORY (SEQ!HEAD S)))
  (OR (= E (SEQ!HEAD (HISTORY (SEQ!HEAD S))))
   (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!HEAD S)))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION,
IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (NOT (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Completing case 2.2 produces ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (NOT (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Invoking (SEQ!NTH S N1) gives ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1))
  (SEQ!IS-MEMBER E
   (HISTORY (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL S) (- N1 1)) (SEQ!HEAD S))))
  (>= (+ -1 N1) N2) (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)
  (NOT (SEQ!IS-MEMBER E (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N1)))))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Which simplifies
 when rewriting with HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION-2
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1)))
  (>= (+ -1 N1) N2) (NOT (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Invoking (SEQ!LENGTH S) gives ...
(IMPLIES
 (AND (>= N1 2) (>= N2 1) (>= N1 N2) (IS-GOOD-EVOLUTION S)
  (>= (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0) (+ 1 N1))
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))) (>= (+ -1 N1) N2)
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL S)) N1)))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (>= N1 2)) (IS-GOOD-EVOLUTION S) (>= N1 1)
  (<= (+ N1 1) (SEQ!LENGTH S)) (>= N2 1) (>= N1 N2)
  (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N1))))
 (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S N2))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
NTH-IN-GOOD-EVOLUTION
Beginning proof of NTH-IN-GOOD-EVOLUTION ...
(IMPLIES (AND (IS-GOOD-EVOLUTION S) (>= N 1) (<= (+ N 1) (SEQ!LENGTH S)))
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N))
  (SEQ!IS-TACK (HISTORY (SEQ!NTH S N)))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N))) (EVENTS))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S N)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N)))
  (IS-GOOD-EVOLUTION S) (>= N 1) (>= (SEQ!LENGTH S) (+ N 1)))
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N))
  (SEQ!IS-TACK (HISTORY (SEQ!NTH S N)))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N))) (EVENTS))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N N) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (SEQ!IS-SEQUENCE S) (>= N 1) (<= N (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S N) S))
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N)))
  (IS-GOOD-EVOLUTION S) (>= N 1) (>= (SEQ!LENGTH S) (+ N 1)))
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N))
  (SEQ!IS-TACK (HISTORY (SEQ!NTH S N)))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N))) (EVENTS))))
Which simplifies
 when rewriting with HEAD-HISTORY-IN-EVENTS, IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HISTORY-IS-SEQUENCE,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE S) (>= N 1) (>= (SEQ!LENGTH S) N)
  (SEQ!IS-MEMBER (SEQ!NTH S N) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N)) (>= (SEQ!LENGTH S) (+ 1 N)))
 (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1))
Splitting on (IN (HISTORY (SEQ!NTH S N)) (SEQ!SEQUENCE-OF (EVENTS))) generates
...
(IF (IN (HISTORY (SEQ!NTH S N)) (SEQ!SEQUENCE-OF (EVENTS)))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE S) (>= N 1) (>= (SEQ!LENGTH S) N)
   (SEQ!IS-MEMBER (SEQ!NTH S N) S) (IS-GOOD-EVOLUTION S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N)) (>= (SEQ!LENGTH S) (+ 1 N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE S) (>= N 1) (>= (SEQ!LENGTH S) N)
   (SEQ!IS-MEMBER (SEQ!NTH S N) S) (IS-GOOD-EVOLUTION S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N)) (>= (SEQ!LENGTH S) (+ 1 N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IN (HISTORY (SEQ!NTH S N)) (SEQ!SEQUENCE-OF (EVENTS)))
  (SEQ!IS-SEQUENCE S) (>= N 1) (>= (SEQ!LENGTH S) N)
  (SEQ!IS-MEMBER (SEQ!NTH S N) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N)) (>= (SEQ!LENGTH S) (+ 1 N)))
 (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N)))
  (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S N))) (EVENTS)) (SEQ!IS-SEQUENCE S)
  (>= N 1) (>= (SEQ!LENGTH S) N) (SEQ!IS-MEMBER (SEQ!NTH S N) S)
  (IS-GOOD-EVOLUTION S) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N))
  (>= (SEQ!LENGTH S) (+ 1 N)))
 (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1))
Splitting on (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1) generates ...
(IF (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1)
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N)))
   (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S N))) (EVENTS)) (SEQ!IS-SEQUENCE S)
   (>= N 1) (>= (SEQ!LENGTH S) N) (SEQ!IS-MEMBER (SEQ!NTH S N) S)
   (IS-GOOD-EVOLUTION S) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N))
   (>= (SEQ!LENGTH S) (+ 1 N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N)))
   (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S N))) (EVENTS)) (SEQ!IS-SEQUENCE S)
   (>= N 1) (>= (SEQ!LENGTH S) N) (SEQ!IS-MEMBER (SEQ!NTH S N) S)
   (IS-GOOD-EVOLUTION S) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N))
   (>= (SEQ!LENGTH S) (+ 1 N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N))) 1))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N)))
  (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S N))) (EVENTS)) (SEQ!IS-SEQUENCE S)
  (>= N 1) (>= (SEQ!LENGTH S) N) (SEQ!IS-MEMBER (SEQ!NTH S N) S)
  (IS-GOOD-EVOLUTION S) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N)))
 (NOT (>= (SEQ!LENGTH S) (+ 1 N))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND
  (NOT
   (>=
    (IF (AND (IS-GOOD-EVOLUTION S) (>= N 1) (>= (SEQ!LENGTH S) N))
     (- (SEQ!LENGTH S) N) (SEQ!LENGTH (HISTORY (SEQ!NTH S N))))
    1))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N)))
  (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S N))) (EVENTS)) (SEQ!IS-SEQUENCE S)
  (>= N 1) (>= (SEQ!LENGTH S) N) (SEQ!IS-MEMBER (SEQ!NTH S N) S)
  (IS-GOOD-EVOLUTION S) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N)))
 (NOT (>= (SEQ!LENGTH S) (+ 1 N))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
ENCRYPTED-MESSAGE-THEOREM-1-A
Beginning proof of ENCRYPTED-MESSAGE-THEOREM-1-A ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)))
 (SOME (N1)
  (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
   (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
    (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
      (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
       (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Assuming ENCRYPTED-MESSAGE-THEOREM-1 with the
instantiations: (= M M) (= K K) (= S (SEQ!HEAD S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD S)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (IS-GENERATED K (SEQ!HEAD S)))
   (ENCRYPTED-PART-OF-SENT M K (SEQ!HEAD S)))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
   (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
    (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N2)
      (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
       (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD S)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (IS-GENERATED K (SEQ!HEAD S)))
   (ENCRYPTED-PART-OF-SENT M K (SEQ!HEAD S))))
 (SOME (N1)
  (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
   (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
    (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N2)
      (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
       (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
SEND-EVENTS-CONTAINING-ENCRYPT.DEFINITION, NTH-HISTORY-HEAD-EVOLUTION,
LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (ENCRYPTED-PART-OF-SENT M K (SEQ!HEAD S)))
 (SOME (N1)
  (AND (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (SEND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2))))
         (NULLSET))))))))))
Assuming ENCRYPTED-PART-OF-SENT-IMPLICATION-3 with the
instantiations: (= M M) (= K K) (= S (SEQ!HEAD S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD S))
    (ENCRYPTED-PART-OF-SENT M K (SEQ!HEAD S)))
   (SOME (N1)
    (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
     (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
      (SEND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
        (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
         (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (ENCRYPTED-PART-OF-SENT M K (SEQ!HEAD S)))
 (SOME (N1$0)
  (AND (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) N1$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1$0))))
      (NULLSET))))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
         (NULLSET))))))))))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (ENCRYPTED-PART-OF-SENT M K (SEQ!HEAD S))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!HEAD S))
    (ENCRYPTED-PART-OF-SENT M K (SEQ!HEAD S)))
   (SOME (N1)
    (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
     (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
      (SEND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
        (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
         (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))))))
 (SOME (N1$0)
  (AND (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) N1$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1$0))))
      (NULLSET))))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
         (NULLSET))))))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
SEND-EVENTS-CONTAINING-ENCRYPT.DEFINITION, NTH-HISTORY-HEAD-EVOLUTION,
LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
ALL-STORAGE-MONOTONIC
Beginning proof of ALL-STORAGE-MONOTONIC ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (<= 1 N2) (<= N2 N1) (<= N1 (SEQ!LENGTH S)))
 (SUBSET (ALL-STORAGE (STORES (SEQ!NTH S N1)))
  (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
Invoking ALL-STORAGE gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1))
 (SUBSET (CUP (REL!RAN (STORES (SEQ!NTH S N1))))
  (CUP (REL!RAN (STORES (SEQ!NTH S N2))))))
Invoking SUBSET gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1))
 (ALL (E)
  (IMPLIES (IN E (CUP (REL!RAN (STORES (SEQ!NTH S N1)))))
   (IN E (CUP (REL!RAN (STORES (SEQ!NTH S N2))))))))
Which simplifies
 when rewriting with CUP.DEFINITION
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1))
 (ALL (E Y)
  (IMPLIES (AND (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
   (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1)
  (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Assuming STORAGE-OF-PRINCIPAL-MONOTONIC with the
instantiations: (= SEQUENCE S) (= N1 N1) (= N2 N2) generates ...
(IMPLIES
 (AND
  (ALL (PRINCIPAL)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION S) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
     (>= N1 N2) (>= (SEQ!LENGTH S) N1))
    (SUBSET (STORAGE-OF PRINCIPAL (SEQ!NTH S N1))
     (STORAGE-OF PRINCIPAL (SEQ!NTH S N2)))))
  (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1) (IN E Y)
  (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Invoking STORAGE-OF gives ...
(IMPLIES
 (AND
  (ALL (PRINCIPAL)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION S) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
     (>= N1 N2) (>= (SEQ!LENGTH S) N1))
    (SUBSET (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL)
     (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))
  (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1) (IN E Y)
  (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Invoking SUBSET gives ...
(IMPLIES
 (AND
  (ALL (PRINCIPAL)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION S) (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1)
     (>= N1 N2) (>= (SEQ!LENGTH S) N1))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1) (IN E Y)
  (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S)
  (ALL (PRINCIPAL)
   (IMPLIES
    (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= N1 N2)
     (>= (SEQ!LENGTH S) N1))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1) (IN E Y)
  (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S N1)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N1) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1)))
  (IS-GOOD-EVOLUTION S)
  (ALL (PRINCIPAL)
   (IMPLIES
    (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= N1 N2)
     (>= (SEQ!LENGTH S) N1))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1) (IN E Y)
  (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S N2)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N2) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)))
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N1) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1)))
  (IS-GOOD-EVOLUTION S)
  (ALL (PRINCIPAL)
   (IMPLIES
    (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= N1 N2)
     (>= (SEQ!LENGTH S) N1))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1) (IN E Y)
  (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N N1) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (SEQ!IS-SEQUENCE S) (>= N1 1) (<= N1 (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S N1) S))
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N2) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)))
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N1) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1)))
  (IS-GOOD-EVOLUTION S)
  (ALL (PRINCIPAL)
   (IMPLIES
    (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= N1 N2)
     (>= (SEQ!LENGTH S) N1))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1) (IN E Y)
  (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N N2) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (SEQ!IS-SEQUENCE S) (>= N2 1) (<= N2 (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S N2) S))
  (IMPLIES (AND (SEQ!IS-SEQUENCE S) (>= N1 1) (>= (SEQ!LENGTH S) N1))
   (SEQ!IS-MEMBER (SEQ!NTH S N1) S))
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N2) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)))
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N1) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1)))
  (IS-GOOD-EVOLUTION S)
  (ALL (PRINCIPAL)
   (IMPLIES
    (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N2 1) (>= N1 N2)
     (>= (SEQ!LENGTH S) N1))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1) (IN E Y)
  (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
  (ALL (PRINCIPAL)
   (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Splitting on (IS-GOOD-STATE (SEQ!NTH S N2)) generates ...
(IF (IS-GOOD-STATE (SEQ!NTH S N2))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
   (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
   (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
   (ALL (PRINCIPAL)
    (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
     (ALL (E$0)
      (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
       (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
   (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
  (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
   (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
   (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
   (ALL (PRINCIPAL$0)
    (IMPLIES (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (>= N1 N2))
     (ALL (E$1)
      (IMPLIES (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL$0))
       (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL$0))))))
   (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
  (SOME (Y$1) (AND (IN E Y$1) (IN Y$1 (REL!RAN (STORES (SEQ!NTH S N2))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-STATE (SEQ!NTH S N2)) (SEQ!IS-SEQUENCE S) (>= N2 1)
  (>= (SEQ!LENGTH S) N2) (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1)
  (>= (SEQ!LENGTH S) N1) (SEQ!IS-MEMBER (SEQ!NTH S N1) S)
  (IS-GOOD-EVOLUTION S) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
  (ALL (PRINCIPAL)
   (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Splitting on (IS-GOOD-STATE (SEQ!NTH S N1)) generates ...
(IF (IS-GOOD-STATE (SEQ!NTH S N1))
 (IMPLIES
  (AND (IS-GOOD-STATE (SEQ!NTH S N2)) (SEQ!IS-SEQUENCE S) (>= N2 1)
   (>= (SEQ!LENGTH S) N2) (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1)
   (>= (SEQ!LENGTH S) N1) (SEQ!IS-MEMBER (SEQ!NTH S N1) S)
   (IS-GOOD-EVOLUTION S) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
   (ALL (PRINCIPAL)
    (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
     (ALL (E$0)
      (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
       (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
   (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
  (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
 (IMPLIES
  (AND (IS-GOOD-STATE (SEQ!NTH S N2)) (SEQ!IS-SEQUENCE S) (>= N2 1)
   (>= (SEQ!LENGTH S) N2) (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1)
   (>= (SEQ!LENGTH S) N1) (SEQ!IS-MEMBER (SEQ!NTH S N1) S)
   (IS-GOOD-EVOLUTION S) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
   (ALL (PRINCIPAL$0)
    (IMPLIES (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (>= N1 N2))
     (ALL (E$1)
      (IMPLIES (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL$0))
       (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL$0))))))
   (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
  (SOME (Y$1) (AND (IN E Y$1) (IN Y$1 (REL!RAN (STORES (SEQ!NTH S N2))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
  (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
  (ALL (PRINCIPAL)
   (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Splitting on (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS)) generates
...
(IF (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
 (IMPLIES
  (AND (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
   (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
   (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
   (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
   (ALL (PRINCIPAL)
    (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
     (ALL (E$0)
      (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
       (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
   (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
  (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
 (IMPLIES
  (AND (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
   (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
   (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
   (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
   (ALL (PRINCIPAL$0)
    (IMPLIES (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (>= N1 N2))
     (ALL (E$1)
      (IMPLIES (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL$0))
       (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL$0))))))
   (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
  (SOME (Y$1) (AND (IN E Y$1) (IN Y$1 (REL!RAN (STORES (SEQ!NTH S N2))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
  (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
  (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
  (ALL (PRINCIPAL)
   (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Splitting on (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS)) generates
...
(IF (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS))
 (IMPLIES
  (AND (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
   (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
   (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
   (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
   (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
   (ALL (PRINCIPAL)
    (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
     (ALL (E$0)
      (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
       (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
   (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
  (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
 (IMPLIES
  (AND (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
   (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
   (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
   (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
   (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
   (ALL (PRINCIPAL$0)
    (IMPLIES (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (>= N1 N2))
     (ALL (E$1)
      (IMPLIES (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL$0))
       (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL$0))))))
   (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
  (SOME (Y$1) (AND (IN E Y$1) (IN Y$1 (REL!RAN (STORES (SEQ!NTH S N2))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS))
  (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
  (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
  (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
  (ALL (PRINCIPAL)
   (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N1 N2) (IN E Y) (IN Y (REL!RAN (STORES (SEQ!NTH S N1)))))
 (SOME (Y$0) (AND (IN E Y$0) (IN Y$0 (REL!RAN (STORES (SEQ!NTH S N2)))))))
Applying FN!IN-RAN-FUNCTION gives ...
(IMPLIES
 (AND (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS))
  (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
  (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
  (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
  (ALL (PRINCIPAL)
   (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N1 N2) (IN E Y)
  (IF (FN!IS-FUNCTION (STORES (SEQ!NTH S N1)))
   (SOME (Y$0)
    (AND (IN Y$0 (REL!DOM (STORES (SEQ!NTH S N1))))
     (= Y (FN!APPLY (STORES (SEQ!NTH S N1)) Y$0))))
   (IN Y (REL!RAN (STORES (SEQ!NTH S N1))))))
 (SOME (Y$1)
  (AND (IN E Y$1)
   (IF (FN!IS-FUNCTION (STORES (SEQ!NTH S N2)))
    (SOME (Y$2)
     (AND (IN Y$2 (REL!DOM (STORES (SEQ!NTH S N2))))
      (= Y$1 (FN!APPLY (STORES (SEQ!NTH S N2)) Y$2))))
    (IN Y$1 (REL!RAN (STORES (SEQ!NTH S N2))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions FN!IS-FUNCTION-BOOL, SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS))
  (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
  (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
  (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
  (ALL (PRINCIPAL)
   (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N1 N2) (IN E Y)
  (SOME (Y$0)
   (AND (IN Y$0 (MS!PRINCIPALS))
    (= Y (FN!APPLY (STORES (SEQ!NTH S N1)) Y$0)))))
 (SOME (Y$1)
  (AND (IN E (FN!APPLY (STORES (SEQ!NTH S N2)) Y$1))
   (IN Y$1 (MS!PRINCIPALS)))))
Prenexing produces ...
(IMPLIES
 (AND (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS))
  (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
  (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
  (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
  (ALL (PRINCIPAL)
   (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
    (ALL (E$0)
     (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N1 N2) (IN E Y) (IN Y$0 (MS!PRINCIPALS))
  (= Y (FN!APPLY (STORES (SEQ!NTH S N1)) Y$0)))
 (SOME (Y$1)
  (AND (IN E (FN!APPLY (STORES (SEQ!NTH S N2)) Y$1))
   (IN Y$1 (MS!PRINCIPALS)))))
Instantiating (= PRINCIPAL Y$0) gives ...
(IMPLIES
 (AND (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS))
  (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
  (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
  (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1))
  (IMPLIES (AND (IN Y$0 (MS!PRINCIPALS)) (>= N1 N2))
   (ALL (E$0)
    (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) Y$0))
     (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) Y$0)))))
  (ALL (PRINCIPAL)
   (IMPLIES (AND (IN PRINCIPAL (MS!PRINCIPALS)) (>= N1 N2))
    (ALL (E$1)
     (IMPLIES (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (>= N1 N2) (IN E Y) (IN Y$0 (MS!PRINCIPALS))
  (= Y (FN!APPLY (STORES (SEQ!NTH S N1)) Y$0)))
 (SOME (Y$1)
  (AND (IN E (FN!APPLY (STORES (SEQ!NTH S N2)) Y$1))
   (IN Y$1 (MS!PRINCIPALS)))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS))
  (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
  (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
  (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1)) (IN Y$0 (MS!PRINCIPALS)) (>= N1 N2)
  (ALL (E$0)
   (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) Y$0))
    (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) Y$0))))
  (ALL (PRINCIPAL)
   (IMPLIES (IN PRINCIPAL (MS!PRINCIPALS))
    (ALL (E$1)
     (IMPLIES (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (IN E Y) (= Y (FN!APPLY (STORES (SEQ!NTH S N1)) Y$0)))
 (SOME (Y$1)
  (AND (IN E (FN!APPLY (STORES (SEQ!NTH S N2)) Y$1))
   (IN Y$1 (MS!PRINCIPALS)))))
Instantiating (= E$0 E) gives ...
(IMPLIES
 (AND (= (REL!DOM (STORES (SEQ!NTH S N2))) (MS!PRINCIPALS))
  (= (REL!DOM (STORES (SEQ!NTH S N1))) (MS!PRINCIPALS))
  (IS-GOOD-STATE (SEQ!NTH S N1)) (IS-GOOD-STATE (SEQ!NTH S N2))
  (SEQ!IS-SEQUENCE S) (>= N2 1) (>= (SEQ!LENGTH S) N2)
  (SEQ!IS-MEMBER (SEQ!NTH S N2) S) (>= N1 1) (>= (SEQ!LENGTH S) N1)
  (SEQ!IS-MEMBER (SEQ!NTH S N1) S) (IS-GOOD-EVOLUTION S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N1)) (IN Y (MS!PRINCIPALS)) (>= N1 N2)
  (IMPLIES (IN E (FN!APPLY (STORES (SEQ!NTH S N1)) Y))
   (IN E (FN!APPLY (STORES (SEQ!NTH S N2)) Y)))
  (ALL (E$0)
   (IMPLIES (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N1)) Y))
    (IN E$0 (FN!APPLY (STORES (SEQ!NTH S N2)) Y))))
  (ALL (PRINCIPAL)
   (IMPLIES (IN PRINCIPAL (MS!PRINCIPALS))
    (ALL (E$1)
     (IMPLIES (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N1)) PRINCIPAL))
      (IN E$1 (FN!APPLY (STORES (SEQ!NTH S N2)) PRINCIPAL))))))
  (IN E Y$0) (= Y$0 (FN!APPLY (STORES (SEQ!NTH S N1)) Y)))
 (SOME (Y$1)
  (AND (IN E (FN!APPLY (STORES (SEQ!NTH S N2)) Y$1))
   (IN Y$1 (MS!PRINCIPALS)))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, MS!SET-OF-PRINCIPALS-NOT-EMPTY
 with the instantiation (= Y$1 Y) to ...
(TRUE)
FRESH-IS-MONOTONIC
Beginning proof of FRESH-IS-MONOTONIC ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (<= 1 N2) (<= N2 N1) (<= N1 (SEQ!LENGTH S))
  (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N2))))
 (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N1))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1)
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N1)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N1))))))
Assuming SEEN-MESSAGES-MONOTONIC with the
instantiations: (= SEQUENCE S) (= N1 N1) (= N2 N2) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH S N1)) (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1)
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N1)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N1))))))
Assuming ALL-STORAGE-MONOTONIC with the
instantiations: (= S S) (= N1 N1) (= N2 N2) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (<= 1 N2) (<= N2 N1) (<= N1 (SEQ!LENGTH S)))
   (SUBSET (ALL-STORAGE (STORES (SEQ!NTH S N1)))
    (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH S N1)) (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1)
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N1)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N1))))))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1)
  (SUBSET (ALL-STORAGE (STORES (SEQ!NTH S N1)))
   (ALL-STORAGE (STORES (SEQ!NTH S N2))))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S N1)) (SEEN-MESSAGES (SEQ!NTH S N2)))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N1)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N1))))))
Assuming MS!IS-FRESH-SUBSET with the
instantiations: (= K K) (= S1 (ALL-STORAGE (STORES (SEQ!NTH S N2))))
                (= S2 (ALL-STORAGE (STORES (SEQ!NTH S N1)))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2))))
    (SUBSET (ALL-STORAGE (STORES (SEQ!NTH S N1)))
     (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N1)))))
  (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1)
  (SUBSET (ALL-STORAGE (STORES (SEQ!NTH S N1)))
   (ALL-STORAGE (STORES (SEQ!NTH S N2))))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S N1)) (SEEN-MESSAGES (SEQ!NTH S N2)))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N1)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N1))))))
Assuming MS!IS-FRESH-SUBSET with the
instantiations: (= K K) (= S1 (SEEN-MESSAGES (SEQ!NTH S N2)))
                (= S2 (SEEN-MESSAGES (SEQ!NTH S N1))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2)))
    (SUBSET (SEEN-MESSAGES (SEQ!NTH S N1)) (SEEN-MESSAGES (SEQ!NTH S N2))))
   (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N1))))
  (IMPLIES
   (AND (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2))))
    (SUBSET (ALL-STORAGE (STORES (SEQ!NTH S N1)))
     (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N1)))))
  (IS-GOOD-EVOLUTION S) (>= N2 1) (>= N1 N2) (>= (SEQ!LENGTH S) N1)
  (SUBSET (ALL-STORAGE (STORES (SEQ!NTH S N1)))
   (ALL-STORAGE (STORES (SEQ!NTH S N2))))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S N1)) (SEEN-MESSAGES (SEQ!NTH S N2)))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2)))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N1)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N1))))))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
IS-GENERATED-CONSEQUENCE
Beginning proof of IS-GENERATED-CONSEQUENCE ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (<= 1 N)
  (<= N (SEQ!LENGTH S)))
 (OR (IS-GENERATED K (SEQ!NTH S N))
  (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N)))))
Inducting using the following scheme ...
 (AND (IMPLIES (NAT!ZEROP N) (*P* K N S))
  (IMPLIES (AND (NOT (NAT!ZEROP N)) (*P* K (- N 1) S)) (*P* K N S)))
 produces ...
(AND
 (IMPLIES (NAT!ZEROP N)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (<= 1 N)
    (<= N (SEQ!LENGTH S)))
   (OR (IS-GENERATED K (SEQ!NTH S N))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N))))))
 (IMPLIES
  (AND (NOT (NAT!ZEROP N))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (<= 1 (- N 1))
     (<= (- N 1) (SEQ!LENGTH S)))
    (OR (IS-GENERATED K (SEQ!NTH S (- N 1)))
     (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (- N 1)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (<= 1 N)
    (<= N (SEQ!LENGTH S)))
   (OR (IS-GENERATED K (SEQ!NTH S N))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N)))))))
Starting case 2 ...
(IMPLIES
 (AND (NAT!ZEROP N) (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (<= 1 N) (<= N (SEQ!LENGTH S)) (NOT (IS-GENERATED K (SEQ!NTH S N))))
 (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N))))
Invoking NAT!ZEROP gives ...
(IMPLIES
 (AND (NOT (>= N 1)) (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (>= N 1) (>= (SEQ!LENGTH S) N) (NOT (IS-GENERATED K (SEQ!NTH S N))))
 (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (NAT!ZEROP N))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (<= 1 (- N 1))
    (<= (- N 1) (SEQ!LENGTH S)))
   (OR (IS-GENERATED K (SEQ!NTH S (- N 1)))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (- N 1))))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (<= 1 N)
  (<= N (SEQ!LENGTH S)) (NOT (IS-GENERATED K (SEQ!NTH S N))))
 (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N))))
Invoking NAT!ZEROP gives ...
(IMPLIES
 (AND (>= N 1)
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (>= (- N 1) 1)
    (>= (SEQ!LENGTH S) (- N 1)) (NOT (IS-GENERATED K (SEQ!NTH S (- N 1)))))
   (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (- N 1)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (>= N 1)
  (>= (SEQ!LENGTH S) N) (NOT (IS-GENERATED K (SEQ!NTH S N))))
 (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N)))
  (IMPLIES
   (AND (>= (- N 1) 1) (>= (SEQ!LENGTH S) (- N 1)) (IS-GOOD-EVOLUTION S)
    (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (- N 1)))))
   (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (- N 1))))))
 (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N))))
 (IF (>= (+ -1 N) 1)
  (IF (IS-GENERATED K (SEQ!NTH S (+ -1 N)))
   (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
    (NOT (IN K (MS!PUBLIC-KEYS)))
    (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N)))))
   (IMPLIES
    (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
     (NOT (IN K (MS!PUBLIC-KEYS)))
     (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))))
     (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ -1 N))))))
    (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
     (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N)))))))
  (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
   (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S 1)))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S 1)))))))
Starting case 1.2 ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N)))
  (>= (+ -1 N) 1))
 (IF (IS-GENERATED K (SEQ!NTH S (+ -1 N)))
  (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
   (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N)))))
  (IMPLIES
   (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
    (NOT (IN K (MS!PUBLIC-KEYS)))
    (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ -1 N))))))
   (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))))
Starting case 1.2.2 ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N)))
  (>= (+ -1 N) 1) (IS-GENERATED K (SEQ!NTH S (+ -1 N))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))
Invoking (IS-GENERATED K (SEQ!NTH S (+ -1 N))) gives ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N)))
  (>= (+ -1 N) 1)
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
     (HISTORY (SEQ!NTH S (+ -1 N)))))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))
Invoking (IS-GENERATED K (SEQ!NTH S N)) gives ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (L T P1)
    (AND (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!NTH S N))))))
  (>= (+ -1 N) 1)
  (SOME (L$0 T$0 P1$0)
   (AND (IN P1$0 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
     (HISTORY (SEQ!NTH S (+ -1 N)))))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))
Prenexing produces ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY (SEQ!NTH S N))))))
  (>= (+ -1 N) 1) (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!NTH S (+ -1 N)))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))
Instantiating (= L$0 L) (= T$0 T) (= P1$0 P1) gives ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (OR
    (AND (IN P1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!NTH S N))))
    (SOME (L$0 T$0 P1$0)
     (AND (IN P1$0 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
       (HISTORY (SEQ!NTH S N)))))))
  (>= (+ -1 N) 1) (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!NTH S (+ -1 N)))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!NTH S N))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY (SEQ!NTH S N))))))
  (>= (+ -1 N) 1)
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!NTH S (+ -1 N)))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))
Invoking (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
          (HISTORY (SEQ!NTH S (+ -1 N)))) gives
...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!NTH S N))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY (SEQ!NTH S N))))))
  (>= (+ -1 N) 1) (SEQ!IS-TACK (HISTORY (SEQ!NTH S (+ -1 N))))
  (OR
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))
Invoking (SEQ!NTH S N) gives ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (HISTORY (IF (>= N 2) (SEQ!NTH (SEQ!TAIL S) (- N 1)) (SEQ!HEAD S)))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (HISTORY (IF (>= N 2) (SEQ!NTH (SEQ!TAIL S) (- N 1)) (SEQ!HEAD S)))))))
  (>= (+ -1 N) 1) (SEQ!IS-TACK (HISTORY (SEQ!NTH S (+ -1 N))))
  (OR
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K
   (SEEN-MESSAGES (IF (>= N 2) (SEQ!NTH (SEQ!TAIL S) (- N 1)) (SEQ!HEAD S))))
  (MS!IS-FRESH K
   (ALL-STORAGE
    (STORES (IF (>= N 2) (SEQ!NTH (SEQ!TAIL S) (- N 1)) (SEQ!HEAD S)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH,
HISTORY-OF-NTH-OF-TAIL-OF-GOOD-EVOLUTION-2
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, HISTORY-IS-SEQUENCE, SEQ!TYPE-OF-IS-TACK,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS)) (>= N 2)
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Assuming GENERATE-EVENT-THEOREM with the
instantiations: (= N (- N 1)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (- N 1) 1) (<= (- N 1) (- (SEQ!LENGTH S) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (- N 1)))) (GENERATE-EVENTS)))
   (AND
    (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (- N 1)))))
     (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ (- N 1) 1))))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (- N 1)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (- N 1)))))
     (SEQ!NTH S (- N 1)))))
  (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS)) (>= N 2)
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= N 2) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (IMPLIES
   (AND (>= (- N 1) 1) (IS-GOOD-EVOLUTION S) (<= (- N 1) (- (SEQ!LENGTH S) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (- N 1)))) (GENERATE-EVENTS)))
   (AND
    (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (- N 1)))))
     (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ (- N 1) 1))))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (- N 1)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (- N 1)))))
     (SEQ!NTH S (- N 1))))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= N 2) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))))))
 (IF (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))) (GENERATE-EVENTS))
  (IMPLIES
   (AND
    (NOT
     (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
      (MS!PRINCIPALS)))
    (NOT
     (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
      (MS!TEXT-MESSAGES)))
    (NOT
     (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
      (MS!PUBLIC-KEYS)))
    (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
     (SEEN-MESSAGES (SEQ!NTH S N)))
    (MS!IS-FRESH (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
     (ALL-STORAGE (STORES (SEQ!NTH S N))))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
     (SEQ!NTH S (+ -1 N))))
   (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
  (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
   (NOT (IN K (MS!PUBLIC-KEYS)))
   (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))))))
Substituting (= (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
              (MAKE-GENERATE-EVENT L T K P1)) produces
...
(IMPLIES
 (AND (>= N 1) (>= N 2) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))))))
 (IF (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))
  (IMPLIES
   (AND
    (NOT
     (IN (MESSAGE-OF-EVENT (MAKE-GENERATE-EVENT L T K P1)) (MS!PRINCIPALS)))
    (NOT
     (IN (MESSAGE-OF-EVENT (MAKE-GENERATE-EVENT L T K P1))
      (MS!TEXT-MESSAGES)))
    (NOT
     (IN (MESSAGE-OF-EVENT (MAKE-GENERATE-EVENT L T K P1)) (MS!PUBLIC-KEYS)))
    (MS!IS-FRESH (MESSAGE-OF-EVENT (MAKE-GENERATE-EVENT L T K P1))
     (SEEN-MESSAGES (SEQ!NTH S N)))
    (MS!IS-FRESH (MESSAGE-OF-EVENT (MAKE-GENERATE-EVENT L T K P1))
     (ALL-STORAGE (STORES (SEQ!NTH S N))))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (MAKE-GENERATE-EVENT L T K P1))
     (PRINCIPAL1-OF-EVENT (MAKE-GENERATE-EVENT L T K P1))
     (SEQ!NTH S (+ -1 N))))
   (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
  (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
   (NOT (IN K (MS!PUBLIC-KEYS)))
   (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))))))
Which simplifies
 forward chaining using KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= N 2) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N)))))))))
 (IF (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))
  (IMPLIES
   (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
    (NOT (IN K (MS!PUBLIC-KEYS)))
    (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))
    (KNOWN-BY-PRINCIPAL K P1 (SEQ!NTH S (+ -1 N))))
   (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
  (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
   (NOT (IN K (MS!PUBLIC-KEYS)))
   (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))))))
Starting case 1.2.2.2 ...
(IMPLIES
 (AND (>= N 1) (>= N 2) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))
  (KNOWN-BY-PRINCIPAL K P1 (SEQ!NTH S (+ -1 N))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Invoking (SEQ!NTH S N) gives ...
(IMPLIES
 (AND (>= N 1) (>= N 2) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K
   (SEEN-MESSAGES (IF (>= N 2) (SEQ!NTH (SEQ!TAIL S) (- N 1)) (SEQ!HEAD S))))
  (MS!IS-FRESH K
   (ALL-STORAGE
    (STORES (IF (>= N 2) (SEQ!NTH (SEQ!TAIL S) (- N 1)) (SEQ!HEAD S)))))
  (KNOWN-BY-PRINCIPAL K P1 (SEQ!NTH S (+ -1 N))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Which simplifies
 forward chaining using KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.2.1 ...
(IMPLIES
 (AND (>= N 1) (>= N 2) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N (- N 1)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (- N 1) 1) (<= (- N 1) (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S (- N 1)) S))
  (>= N 1) (>= N 2) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE S) (>= (+ -1 N) 1) (>= (SEQ!LENGTH S) (+ -1 N))
  (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S (- N 1))) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (- N 1)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (- N 1))))
  (SEQ!IS-SEQUENCE S) (>= (+ -1 N) 1) (>= (SEQ!LENGTH S) (+ -1 N))
  (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT, HISTORY-IS-SEQUENCE,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Splitting on (IS-GOOD-STATE (SEQ!NTH S (+ -1 N))) generates ...
(IF (IS-GOOD-STATE (SEQ!NTH S (+ -1 N)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
   (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
   (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
   (NOT
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
   (NOT
    (SOME (L$0 T$0 P1$0)
     (AND (IN P1$0 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
       (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
   (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
  (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
   (NOT (IN K (MS!PUBLIC-KEYS)))
   (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
   (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
   (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
   (= (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
   (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
   (NOT
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
   (NOT
    (SOME (L$1 T$1 P1$1)
     (AND (IN P1$1 (MS!PRINCIPALS))
      (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1)
       (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
   (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
  (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
   (NOT (IN K (MS!PUBLIC-KEYS)))
   (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))))))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT, HISTORY-IS-SEQUENCE,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-STATE (SEQ!NTH S (+ -1 N))) (IS-GOOD-EVOLUTION S)
  (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Invoking IS-GOOD-STATE gives ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N))))
  (IN (HISTORY (SEQ!NTH S (+ -1 N))) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE,
FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N))))
  (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N)))) (EVENTS))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Invoking (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N)))) (EVENTS)) gives
...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N))))
  (ALL (E)
   (IMPLIES (IN E (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N)))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Instantiating (= E (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))) gives ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N))))
  (IMPLIES
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
    (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N)))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))) (EVENTS)))
  (ALL (E)
   (IMPLIES (IN E (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N)))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Which simplifies
 when rewriting with SEQ!IN-MEMBERS
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE,
FN!FUNCTION-IS-RELATION
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, SEQ!TYPE-OF-IS-TACK,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N)))))
 (IF
  (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
   (HISTORY (SEQ!NTH S (+ -1 N))))
  (IMPLIES
   (AND (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))) (EVENTS))
    (ALL (E)
     (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N))))
      (IN E (EVENTS))))
    (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
    (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
    (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
    (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
    (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
    (NOT
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
    (NOT
     (SOME (L$0 T$0 P1$0)
      (AND (IN P1$0 (MS!PRINCIPALS))
       (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
        (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
    (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
   (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
    (NOT (IN K (MS!PUBLIC-KEYS)))
    (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
  (IMPLIES
   (AND
    (ALL (E$0)
     (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY (SEQ!NTH S (+ -1 N))))
      (IN E$0 (EVENTS))))
    (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
    (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
    (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
    (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
    (= (MAKE-GENERATE-EVENT L T K P1)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
    (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
    (NOT
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
    (NOT
     (SOME (L$1 T$1 P1$1)
      (AND (IN P1$1 (MS!PRINCIPALS))
       (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1)
        (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
    (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
   (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
    (NOT (IN K (MS!PUBLIC-KEYS)))
    (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))))
Starting case 1.2.2.1.2 ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
   (HISTORY (SEQ!NTH S (+ -1 N))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))) (EVENTS))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N)))) (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Invoking (EVENTS) gives ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
   (HISTORY (SEQ!NTH S (+ -1 N))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
   (UNION (SEND-EVENTS)
    (UNION (RECEIVE-EVENTS)
     (UNION (OUT-OF-BAND-EVENTS)
      (UNION (GENERATE-EVENTS)
       (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS)))))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N))))
    (IN E
     (UNION (SEND-EVENTS)
      (UNION (RECEIVE-EVENTS)
       (UNION (OUT-OF-BAND-EVENTS)
        (UNION (GENERATE-EVENTS)
         (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS)))))))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Which simplifies
 when rewriting with UNION.DEFINITION
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE,
FN!FUNCTION-IS-RELATION, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT
 with the assumptions SEQ!TYPE-OF-IS-TACK, HEAD-OF-EVOLUTION-IN-EVOLUTION,
TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT,
MESSAGE-OF-GENERATE-EVENT, PRINCIPAL1-OF-GENERATE-EVENT, HISTORY-IS-SEQUENCE,
SEQ!LENGTH-NON-NEGATIVE, MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
Starting case 1.2.2.1.1 ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N))))
  (NOT
   (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
    (HISTORY (SEQ!NTH S (+ -1 N)))))
  (ALL (E$0)
   (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY (SEQ!NTH S (+ -1 N))))
    (IN E$0 (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$1 T$1 P1$1)
    (AND (IN P1$1 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$1 T$1 K P1$1)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Invoking (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
          (HISTORY (SEQ!NTH S (+ -1 N)))) gives
...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N))))
  (NOT
   (AND (SEQ!IS-TACK (HISTORY (SEQ!NTH S (+ -1 N))))
    (OR
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
      (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
     (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N))))
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N)))) (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N)) S)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N))) (>= (+ -1 N) 1)
  (>= (SEQ!LENGTH S) (+ -1 N)) (>= N 1) (>= (SEQ!LENGTH S) N)
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N)))) 1)
  (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N)))))
  (IS-GENERATED K (SEQ!HEAD S)) (IN P1 (MS!PRINCIPALS))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))
  (NOT
   (SOME (L$0 T$0 P1$0)
    (AND (IN P1$0 (MS!PRINCIPALS))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N))))))))
  (NOT (IN (MAKE-GENERATE-EVENT L T K P1) (GENERATE-EVENTS))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH (SEQ!TAIL S) (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH (SEQ!TAIL S) (+ -1 N)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions HISTORY-IS-SEQUENCE, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
FN!IS-FUNCTION-BOOL, SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
Starting case 1.2.1 ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N)))
  (>= (+ -1 N) 1) (NOT (IS-GENERATED K (SEQ!NTH S (+ -1 N))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ -1 N))))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))
Assuming FRESH-IS-MONOTONIC with the
instantiations: (= K K) (= S S) (= N1 N) (= N2 (- N 1)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (<= 1 (- N 1)) (<= (- N 1) N)
    (<= N (SEQ!LENGTH S))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (- N 1)))))
   (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N))))
  (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N)))
  (>= (+ -1 N) 1) (NOT (IS-GENERATED K (SEQ!NTH S (+ -1 N))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ -1 N))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ -1 N))))))
 (AND (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N)))
  (NOT (>= (+ -1 N) 1)))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S 1)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S 1))))))
Splitting on (= N 1) generates ...
(IF (= N 1)
 (IMPLIES
  (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
   (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N)))
   (NOT (>= (+ -1 N) 1)))
  (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
   (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S 1)))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S 1))))))
 (IMPLIES
  (AND (>= N 1) (>= (SEQ!LENGTH S) N) (IS-GOOD-EVOLUTION S)
   (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S N)))
   (NOT (>= (+ -1 N) 1)))
  (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
   (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S 1)))
   (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S 1)))))))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N 1) (>= (SEQ!LENGTH S) 1) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S 1))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S 1)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S 1))))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND (= N 1) (>= (SEQ!LENGTH S) 1) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (IS-GENERATED K
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S)))))
 (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K
   (SEEN-MESSAGES (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S))))
  (MS!IS-FRESH K
   (ALL-STORAGE
    (STORES (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S)))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
ENCRYPTED-MESSAGE-THEOREM-1-B
Beginning proof of ENCRYPTED-MESSAGE-THEOREM-1-B ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)))
 (SOME (N1)
  (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
   (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
    (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH S))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))))))
Assuming ENCRYPTED-MESSAGE-THEOREM-1-A with the
instantiations: (= M M) (= K K) (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)))
   (SOME (N1)
    (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
     (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
      (SEND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
        (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
         (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)))
 (SOME (N1$0)
  (AND (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1$0)
   (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1$0)
    (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ N1$0 1)) (>= (SEQ!LENGTH S) N2$0)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))))
Which simplifies
 forward chaining using FORGEABLE-IS-MESSAGE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (SOME (N1)
   (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
    (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
     (SEND-EVENTS-CONTAINING-ENCRYPT M K))
    (NOT
     (SOME (N2)
      (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N2)
       (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
        (SEND-EVENTS-CONTAINING-ENCRYPT M K))))))))
 (SOME (N1$0)
  (AND (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1$0)
   (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1$0)
    (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1$0)) (>= (SEQ!LENGTH S) N2$0)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))))
Instantiating (= N1$0 N1) gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
  (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
   (SEND-EVENTS-CONTAINING-ENCRYPT M K))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N2)
     (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
      (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
  (NOT
   (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
    (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
     (SEND-EVENTS-CONTAINING-ENCRYPT M K))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))))
 (SOME (N1$0)
  (AND (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1$0)
   (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1$0)
    (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2$1)
     (AND (>= N2$1 (+ 1 N1$0)) (>= (SEQ!LENGTH S) N2$1)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1))))))))))
Concluding (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
            (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
            (>= N1 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
            (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
             (SEND-EVENTS-CONTAINING-ENCRYPT M K))
            (NOT
             (SOME (N2)
              (AND (>= N2 (+ 1 N1))
               (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N2)
               (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
                (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
            (NOT
             (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
              (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
               (SEND-EVENTS-CONTAINING-ENCRYPT M K))
              (NOT
               (SOME (N2$0)
                (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
                 (IN (MS!ENCRYPT M K)
                  (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0)))))))))) generates
...
(OR
 (NOT
  (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
   (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
    (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N2)
      (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
       (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
   (NOT
    (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
     (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
      (SEND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2$0)
       (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0)))))))))))
 (SOME (N1$0)
  (AND (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1$0)
   (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1$0)
    (SEND-EVENTS-CONTAINING-ENCRYPT M K))
   (NOT
    (SOME (N2$1)
     (AND (>= N2$1 (+ 1 N1$0)) (>= (SEQ!LENGTH S) N2$1)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1))))))))))
Starting case 2 ...
(NOT
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
  (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
   (SEND-EVENTS-CONTAINING-ENCRYPT M K))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N2)
     (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2)
      (SEND-EVENTS-CONTAINING-ENCRYPT M K)))))
  (NOT
   (AND (>= N1 1) (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N1)
    (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
     (SEND-EVENTS-CONTAINING-ENCRYPT M K))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0)))))))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
SEND-EVENTS-CONTAINING-ENCRYPT.DEFINITION, NTH-HISTORY-HEAD-EVOLUTION,
LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2))))
        (NULLSET))))))))
 (NOT
  (SOME (N2$0)
   (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
Splitting
on (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1))
     (AND (<= N2$0 (SEQ!LENGTH S))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))) generates
...
(IF
 (SOME (N2)
  (AND (>= N2 (+ 1 N1)) (<= N2 (SEQ!LENGTH S))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (>= (+ -1 (SEQ!LENGTH S)) N1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
         (NULLSET))))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1))))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (>= (+ -1 (SEQ!LENGTH S)) N1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT
    (SOME (N2$2)
     (AND (>= N2$2 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$2)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2))) (SEND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2))))
         (NULLSET))))))))
  (NOT
   (SOME (N2$3)
    (AND (>= N2$3 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$3)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$3)))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, SEQ!LENGTH-NON-NEGATIVE
 with the instantiation (= N2 N2$3) to ...
(IMPLIES
 (AND
  (SOME (N2)
   (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Prenexing produces ...
(IMPLIES
 (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Splitting on (IS-GENERATED K (SEQ!NTH S N2)) generates ...
(IF (IS-GENERATED K (SEQ!NTH S N2))
 (IMPLIES
  (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
   (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (>= (+ -1 (SEQ!LENGTH S)) N1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET)))))
  (SOME (N2$0)
   (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
       (NULLSET)))))))
 (IMPLIES
  (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
   (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (>= (+ -1 (SEQ!LENGTH S)) N1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET)))))
  (SOME (N2$1)
   (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
       (NULLSET))))))))
Starting case 2.2 ...
(IMPLIES
 (AND (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Assuming ENCRYPTED-MESSAGE-THEOREM-1 with the
instantiations: (= M M) (= K K) (= S (SEQ!NTH S N2)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
    (IS-GENERATED K (SEQ!NTH S N2)))
   (ENCRYPTED-PART-OF-SENT M K (SEQ!NTH S N2)))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
FORGEABLE-IS-MESSAGE, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
SEQ!LENGTH-NON-NEGATIVE, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IF (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
 (IMPLIES (AND (IN M (MS!MESSAGES)) (IN K (MS!KEYS)))
  (IF (FORGEABLE K (SEQ!NTH S N2))
   (IMPLIES
    (AND (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1))
     (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
     (IS-GOOD-EVOLUTION S)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
     (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
        (NULLSET)))))
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
         (NULLSET)))))))
   (IMPLIES
    (AND (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
     (IS-GENERATED K (SEQ!NTH S N2))
     (ENCRYPTED-PART-OF-SENT M K (SEQ!NTH S N2)) (>= N2 (+ 1 N1))
     (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION S)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
     (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
        (NULLSET)))))
    (SOME (N2$1)
     (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
         (NULLSET)))))))))
 (IMPLIES
  (AND (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
   (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET)))))
  (SOME (N2$2)
   (AND (>= N2$2 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$2)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2))))
       (NULLSET))))))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)))
 (IF (FORGEABLE K (SEQ!NTH S N2))
  (IMPLIES
   (AND (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1))
    (>= (SEQ!LENGTH S) N2)
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
    (IS-GOOD-EVOLUTION S)
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET)))))
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
        (NULLSET)))))))
  (IMPLIES
   (AND (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
    (IS-GENERATED K (SEQ!NTH S N2))
    (ENCRYPTED-PART-OF-SENT M K (SEQ!NTH S N2)) (>= N2 (+ 1 N1))
    (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION S)
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET)))))
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
        (NULLSET)))))))))
Starting case 2.2.2.2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (FORGEABLE K (SEQ!NTH S N2))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Assuming FORGEABLE-IS-MONOTONIC with the
instantiations: (= SEQUENCE S) (= MESSAGE K) (= N1 N2) (= N2 1) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= 1 1) (>= N2 1) (>= (SEQ!LENGTH S) N2)
    (FORGEABLE K (SEQ!NTH S N2)))
   (FORGEABLE K (SEQ!NTH S 1)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (FORGEABLE K (SEQ!NTH S N2))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= 1 1) (>= N2 1) (>= (SEQ!LENGTH S) N2)
    (FORGEABLE K (SEQ!NTH S N2)))
   (FORGEABLE K (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (FORGEABLE K (SEQ!NTH S N2))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.2.1 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (ENCRYPTED-PART-OF-SENT M K (SEQ!NTH S N2))
  (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$1)
  (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
      (NULLSET)))))))
Invoking ENCRYPTED-PART-OF-SENT gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2))
  (SOME (L2 T2 M2 P2)
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
  (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M (MAKE-SEND-EVENT L2 T2 M2 P2))
                (= S (HISTORY (SEQ!NTH S N2))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2))))
   (SOME (N)
    (AND (>= N 1)
     (= (MAKE-SEND-EVENT L2 T2 M2 P2) (SEQ!NTH (HISTORY (SEQ!NTH S N2)) N))
     (<= N (SEQ!LENGTH (HISTORY (SEQ!NTH S N2)))))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, HISTORY-IS-SEQUENCE,
MAKE-SEND-EVENT-IS-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (SOME (N)
   (AND (>= N 1)
    (= (MAKE-SEND-EVENT L2 T2 M2 P2) (SEQ!NTH (HISTORY (SEQ!NTH S N2)) N))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N2))) N)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2) (SEQ!NTH (HISTORY (SEQ!NTH S N2)) N))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N2))) N)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Applying NTH-HISTORY-NTH-EVOLUTION gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (IF
    (AND (IS-GOOD-EVOLUTION S) (>= N2 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) N2) (>= N 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N2))) N))
    (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ N2 N) 1))))
    (SEQ!NTH (HISTORY (SEQ!NTH S N2)) N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N2))) N)
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1))
 (IF (>= (+ -1 (SEQ!LENGTH S)) N2)
  (IMPLIES
   (AND (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N2))) N)
    (= (MAKE-SEND-EVENT L2 T2 M2 P2)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
    (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET)))))
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
        (NULLSET)))))))
  (IMPLIES
   (AND (= (MAKE-SEND-EVENT L2 T2 M2 P2) (SEQ!NTH (HISTORY (SEQ!NTH S N2)) N))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S N2))) N)
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
    (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
    (>= (SEQ!LENGTH S) N2)
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET)))))
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
        (NULLSET)))))))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1))
 (IF (>= (+ -1 (SEQ!LENGTH S)) N2)
  (IMPLIES
   (AND
    (>=
     (IF (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (SEQ!LENGTH S) N2))
      (- (SEQ!LENGTH S) N2) (SEQ!LENGTH (HISTORY (SEQ!NTH S N2))))
     N)
    (= (MAKE-SEND-EVENT L2 T2 M2 P2)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
    (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET)))))
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
        (NULLSET)))))))
  (IMPLIES
   (AND (= (MAKE-SEND-EVENT L2 T2 M2 P2) (SEQ!NTH (HISTORY (SEQ!NTH S N2)) N))
    (>=
     (IF (AND (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (SEQ!LENGTH S) N2))
      (- (SEQ!LENGTH S) N2) (SEQ!LENGTH (HISTORY (SEQ!NTH S N2))))
     N)
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
    (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
    (>= (SEQ!LENGTH S) N2)
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET)))))
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
        (NULLSET)))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Instantiating (= N2$0 (+ -1 N N2)) gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (AND (>= (+ -1 N N2) (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) (+ -1 N N2))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
       (NULLSET)))))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Splitting on (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 (+ N N2)))) generates
...
(IF (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
   (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
   (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
   (= (MAKE-SEND-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
   (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
   (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
  (SOME (N2$0)
   (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
       (NULLSET)))))))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
   (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
   (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
   (= (MAKE-SEND-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
   (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
   (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
  (SOME (N2$1)
   (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
       (NULLSET))))))))
Starting case 2.2.2.1.2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Splitting on (IS-GOOD-STATE (SEQ!NTH S (+ -1 (+ N N2)))) generates ...
(IF (IS-GOOD-STATE (SEQ!NTH S (+ -1 N N2)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
   (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
   (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
   (= (MAKE-SEND-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
   (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
   (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
  (SOME (N2$0)
   (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
       (NULLSET)))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
   (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
   (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
   (= (MAKE-SEND-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
   (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
   (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
  (SOME (N2$1)
   (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
       (NULLSET))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT to ...
(IMPLIES
 (AND (IS-GOOD-STATE (SEQ!NTH S (+ -1 N N2)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Invoking (IS-GOOD-STATE (SEQ!NTH S (+ -1 N N2))) gives ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (IN (HISTORY (SEQ!NTH S (+ -1 N N2))) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N N2)))) (EVENTS))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Invoking (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N N2))))
          (EVENTS)) gives
...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (ALL (E)
   (IMPLIES (IN E (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N N2)))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Instantiating (= E (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))) gives ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (IMPLIES
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N N2)))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (EVENTS)))
  (ALL (E)
   (IMPLIES (IN E (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ -1 N N2)))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 when rewriting with SEQ!IN-MEMBERS
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2)))))
 (IF
  (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
   (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (IMPLIES
   (AND (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (EVENTS))
    (ALL (E)
     (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N N2))))
      (IN E (EVENTS))))
    (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
    (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2))))
     (POWERSET (MS!MESSAGES)))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
    (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
    (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
    (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
    (= (MAKE-SEND-EVENT L2 T2 M2 P2)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
    (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
        (NULLSET)))))))
  (IMPLIES
   (AND
    (ALL (E$0)
     (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY (SEQ!NTH S (+ -1 N N2))))
      (IN E$0 (EVENTS))))
    (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
    (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2))))
     (POWERSET (MS!MESSAGES)))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
    (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
    (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
    (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
    (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
    (= (MAKE-SEND-EVENT L2 T2 M2 P2)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
    (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
    (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
        (NULLSET)))))))))
Starting case 2.2.2.1.2.2 ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
   (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (EVENTS))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Invoking (EVENTS) gives ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
   (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
   (UNION (SEND-EVENTS)
    (UNION (RECEIVE-EVENTS)
     (UNION (OUT-OF-BAND-EVENTS)
      (UNION (GENERATE-EVENTS)
       (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS)))))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (IN E
     (UNION (SEND-EVENTS)
      (UNION (RECEIVE-EVENTS)
       (UNION (OUT-OF-BAND-EVENTS)
        (UNION (GENERATE-EVENTS)
         (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS)))))))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 when rewriting with UNION.DEFINITION
 forward chaining using MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, TAG-OF-CONSTRUCT-EVENT,
CONSTRUCT-EVENT-IS-EVENT, TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, TAG-OF-RECEIVE-EVENT,
RECEIVE-EVENT-IS-EVENT, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, HISTORY-IS-SEQUENCE, SEQ!LENGTH-NON-NEGATIVE,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
Starting case 2.2.2.1.2.1 ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (NOT
   (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (ALL (E$0)
   (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (IN E$0 (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$1)
  (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
      (NULLSET)))))))
Invoking (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
          (HISTORY (SEQ!NTH S (+ -1 N N2)))) gives
...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (NOT
   (AND (SEQ!IS-TACK (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (OR
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
      (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
     (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2))))
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ -1 N N2))))))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION, >=.SAME.TYPE,
SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, HISTORY-IS-SEQUENCE, TAG-OF-MAKE-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
SEQ!LENGTH-NON-NEGATIVE, SEQ!TYPE-OF-IS-TACK, MS!SET-OF-MESSAGES-NOT-EMPTY,
IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N N2)))) 1))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Splitting
on (= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 (+ N N2))))) 0) generates ...
(IF (= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N N2)))) 0)
 (IMPLIES
  (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
   (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
   (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N N2)))) 1))
   (ALL (E)
    (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N N2))))
     (IN E (EVENTS))))
   (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
   (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
   (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2))))
    (POWERSET (MS!MESSAGES)))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
   (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
   (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
   (= (MAKE-SEND-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
   (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
   (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
  (SOME (N2$0)
   (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
       (NULLSET)))))))
 (IMPLIES
  (AND (IS-STATE (SEQ!NTH S (+ -1 N N2)))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
   (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
   (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N N2)))) 1))
   (ALL (E$0)
    (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY (SEQ!NTH S (+ -1 N N2))))
     (IN E$0 (EVENTS))))
   (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
   (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
   (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2))))
    (POWERSET (MS!MESSAGES)))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
   (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
   (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
   (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
   (= (MAKE-SEND-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
   (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
   (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
   (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
  (SOME (N2$1)
   (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
       (NULLSET))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, HISTORY-IS-SEQUENCE, TAG-OF-MAKE-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N N2)))) 0)
  (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND
  (=
   (IF
    (AND (IS-GOOD-EVOLUTION S) (>= (+ -1 N N2) 1)
     (>= (SEQ!LENGTH S) (+ -1 N N2)))
    (- (SEQ!LENGTH S) (+ -1 N N2))
    (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ -1 N N2)))))
   0)
  (IS-STATE (SEQ!NTH S (+ -1 N N2)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ -1 N N2))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ -1 N N2))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ -1 N N2))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ -1 N N2))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ -1 N N2)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ -1 N N2)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2)))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.2.1.1 ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$1)
  (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
      (NULLSET)))))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S (+ -1 N N2))) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N N2)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (NOT (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N N2)) S))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N (+ -1 N N2)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (+ -1 N N2) 1)
    (<= (+ -1 N N2) (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N N2)) S))
  (IS-GOOD-EVOLUTION S) (NOT (SEQ!IS-MEMBER (SEQ!NTH S (+ -1 N N2)) S))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ -1 N N2))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S N2)))
  (SEQ!IS-MEMBER (MAKE-SEND-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S N2)))
  (>= N 1) (>= N2 1) (>= (+ -1 (SEQ!LENGTH S)) N2)
  (>= (+ (* -1 N2) (SEQ!LENGTH S)) N)
  (= (MAKE-SEND-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S N2)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES))
  (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ -1 N N2)))) (SEND-EVENTS))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$2)
  (AND (>= N2$2 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$2)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2))))
      (NULLSET)))))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S N2)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S N2) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (NOT (SEQ!IS-MEMBER (SEQ!NTH S N2) S))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N N2) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (SEQ!IS-SEQUENCE S) (>= N2 1) (<= N2 (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S N2) S))
  (IS-GOOD-EVOLUTION S) (NOT (SEQ!IS-MEMBER (SEQ!NTH S N2) S))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S N2)))
  (IS-GENERATED K (SEQ!NTH S N2)) (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using FORGEABLE-IS-MESSAGE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (NOT (IS-GENERATED K (SEQ!NTH S N2))) (>= N2 (+ 1 N1))
  (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$1)
  (AND (>= N2$1 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))))
      (NULLSET)))))))
Assuming IS-GENERATED-CONSEQUENCE with the
instantiations: (= S S) (= K K) (= N N2) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (<= 1 N2)
    (<= N2 (SEQ!LENGTH S)))
   (OR (IS-GENERATED K (SEQ!NTH S N2))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S N2)))))
  (NOT (IS-GENERATED K (SEQ!NTH S N2))) (>= N2 (+ 1 N1))
  (>= (SEQ!LENGTH S) N2)
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)) (>= N1 1)
  (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (>= N2 1)
  (>= (SEQ!LENGTH S) N2) (NOT (IS-GENERATED K (SEQ!NTH S N2)))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))) (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2)))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Invoking (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S N2))) gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (>= N2 1)
  (>= (SEQ!LENGTH S) N2) (NOT (IS-GENERATED K (SEQ!NTH S N2)))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (NOT (IN K (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))
  (NOT
   (SOME (M$0)
    (IN (MS!ENCRYPT M$0 K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))
  (NOT
   (SOME (M$1)
    (IN (MS!ENCRYPT M$1 (MS!INVERSE K))
     (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))
  (ALL (M$2 K2)
   (AND
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 K K2)
      (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE K) K2)
      (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 K2 K)
      (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))
    (NOT
     (IN (MS!SHARE-ENCRYPT M$2 K2 (MS!INVERSE K))
      (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S N2)))) (>= N2 (+ 1 N1))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (>= N1 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (SOME (N2$0)
  (AND (>= N2$0 (+ 1 N1)) (>= (+ -1 (SEQ!LENGTH S)) N2$0)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (SEND-EVENTS))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))))
      (NULLSET)))))))
Which simplifies
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions MS!TAG-OF-SHARE-ENCRYPT, MS!SHENDT-SHARE-ENCRYPT,
MS!SHENKY1-SHARE-ENCRYPT, MS!SHENKY2-SHARE-ENCRYPT, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, HEAD-OF-EVOLUTION-IN-EVOLUTION
 with the instantiation (= M$0 M) to ...
(TRUE)
Completing all cases produces ...
(TRUE)
FORGEABLE-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS
Beginning proof of FORGEABLE-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT (FORGEABLE K S)) (FORGEABLE M2 S)
  (IN (MS!ENCRYPT M K) (MS!PARTS (UNIT M2))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT
   (MS!KNOWN-IN K
    (UNION (SEEN-MESSAGES S)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
  (MS!KNOWN-IN M2
   (UNION (SEEN-MESSAGES S)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (UNIT M2))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD, MS!D2-RULE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT
   (MS!COMP-OF K
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
  (MS!KNOWN-IN M2
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
Assuming MS!ENCRYPTED-MESSAGE-THEOREM with the
instantiations: (= M M) (= K K) (= M2 M2)
                (= S
                 (UNION (MS!PRINCIPALS)
                  (UNION (MS!TEXT-MESSAGES)
                   (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IN M2 (MS!MESSAGES))
    (MS!KNOWN-IN M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))
    (NOT
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))))
    (NOT
     (MS!KNOWN-IN K
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT
   (MS!COMP-OF K
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
  (MS!KNOWN-IN M2
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (NOT
   (MS!COMP-OF K
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S))))))
  (MS!KNOWN-IN M2
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IMPLIES
   (AND (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IN M2 (MS!MESSAGES))
    (MS!KNOWN-IN M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))
    (NOT
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))))
    (NOT
     (MS!KNOWN-IN K
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES S)))))))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES S))))
Which simplifies
 when rewriting with MS!D2-RULE, UNION.DEFINITION, MS!PARTS-ATOMIC,
MS!PARTS-UNION
 forward chaining using MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS,
MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!COMP-OF-IN-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!KNOWN-IN-BOOL, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
IN-SEND-EVENT
Beginning proof of IN-SEND-EVENT ...
(IMPLIES (IN EVENT (SEND-EVENTS))
 (AND
  (= EVENT
   (MAKE-SEND-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
Assuming SEND-EVENT-IS-CONSTRUCTED with the
instantiations: (= E EVENT) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (SEND-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-SEND-EVENT L T M P)))))
  (IN EVENT (SEND-EVENTS)))
 (AND
  (= EVENT
   (MAKE-SEND-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN EVENT (SEND-EVENTS))
  (SOME (L)
   (AND (IN L (NAT!NAT))
    (SOME (T)
     (AND (IN T (NAT!NAT))
      (SOME (M)
       (AND (IN M (MS!MESSAGES))
        (SOME (P)
         (AND (IN P (MS!PRINCIPALS))
          (= EVENT (MAKE-SEND-EVENT L T M P)))))))))))
 (AND
  (= EVENT
   (MAKE-SEND-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
Prenexing produces ...
(IMPLIES
 (AND (IN EVENT (SEND-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= EVENT (MAKE-SEND-EVENT L T M P)))
 (AND
  (= EVENT
   (MAKE-SEND-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT
 with the assumptions TAG-OF-MAKE-SEND-EVENT, MAKE-SEND-EVENT-IS-SEND-EVENT,
LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT,
PRINCIPAL1-OF-SEND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
IN-RECEIVE-EVENT
Beginning proof of IN-RECEIVE-EVENT ...
(IMPLIES (IN EVENT (RECEIVE-EVENTS))
 (AND
  (= EVENT
   (MAKE-RECEIVE-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
Assuming RECEIVE-EVENT-IS-CONSTRUCTED with the
instantiations: (= E EVENT) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (RECEIVE-EVENTS))
   (SOME (L T M P)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN P (MS!PRINCIPALS)) (= EVENT (MAKE-RECEIVE-EVENT L T M P)))))
  (IN EVENT (RECEIVE-EVENTS)))
 (AND
  (= EVENT
   (MAKE-RECEIVE-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN EVENT (RECEIVE-EVENTS))
  (SOME (L)
   (AND (IN L (NAT!NAT))
    (SOME (T)
     (AND (IN T (NAT!NAT))
      (SOME (M)
       (AND (IN M (MS!MESSAGES))
        (SOME (P)
         (AND (IN P (MS!PRINCIPALS))
          (= EVENT (MAKE-RECEIVE-EVENT L T M P)))))))))))
 (AND
  (= EVENT
   (MAKE-RECEIVE-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
Prenexing produces ...
(IMPLIES
 (AND (IN EVENT (RECEIVE-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN P (MS!PRINCIPALS))
  (= EVENT (MAKE-RECEIVE-EVENT L T M P)))
 (AND
  (= EVENT
   (MAKE-RECEIVE-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TAG-OF-RECEIVE-EVENT,
RECEIVE-EVENT-IS-EVENT
 with the assumptions TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
IN-OUT-OF-BAND-EVENT
Beginning proof of IN-OUT-OF-BAND-EVENT ...
(IMPLIES (IN EVENT (OUT-OF-BAND-EVENTS))
 (AND
  (= EVENT
   (MAKE-OUT-OF-BAND-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (PRINCIPAL2-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS))))
Assuming OUT-OF-BAND-EVENT-IS-CONSTRUCTED with the
instantiations: (= E EVENT) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN EVENT (OUT-OF-BAND-EVENTS))
   (SOME (L T M S R)
    (AND (IN L (NAT!NAT)) (IN T (NAT!NAT)) (IN M (MS!MESSAGES))
     (IN S (MS!PRINCIPALS)) (IN R (MS!PRINCIPALS))
     (= EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)))))
  (IN EVENT (OUT-OF-BAND-EVENTS)))
 (AND
  (= EVENT
   (MAKE-OUT-OF-BAND-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (PRINCIPAL2-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS))))
Which simplifies
 forward chaining using >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IN EVENT (OUT-OF-BAND-EVENTS))
  (SOME (L)
   (AND (IN L (NAT!NAT))
    (SOME (T)
     (AND (IN T (NAT!NAT))
      (SOME (M)
       (AND (IN M (MS!MESSAGES))
        (SOME (S)
         (AND (IN S (MS!PRINCIPALS))
          (SOME (R)
           (AND (IN R (MS!PRINCIPALS))
            (= EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)))))))))))))
 (AND
  (= EVENT
   (MAKE-OUT-OF-BAND-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (PRINCIPAL2-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS))))
Prenexing produces ...
(IMPLIES
 (AND (IN EVENT (OUT-OF-BAND-EVENTS)) (IN L (NAT!NAT)) (IN T (NAT!NAT))
  (IN M (MS!MESSAGES)) (IN S (MS!PRINCIPALS)) (IN R (MS!PRINCIPALS))
  (= EVENT (MAKE-OUT-OF-BAND-EVENT L T M S R)))
 (AND
  (= EVENT
   (MAKE-OUT-OF-BAND-EVENT (LABEL-OF-EVENT EVENT) (TIME-OF-EVENT EVENT)
    (MESSAGE-OF-EVENT EVENT) (PRINCIPAL1-OF-EVENT EVENT)
    (PRINCIPAL2-OF-EVENT EVENT)))
  (>= (LABEL-OF-EVENT EVENT) 0) (>= (TIME-OF-EVENT EVENT) 0)
  (IN (MESSAGE-OF-EVENT EVENT) (MS!MESSAGES))
  (IN (PRINCIPAL1-OF-EVENT EVENT) (MS!PRINCIPALS))
  (IN (PRINCIPAL2-OF-EVENT EVENT) (MS!PRINCIPALS))))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
KNOWN-BY-PRINCIPAL-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS
Beginning proof of KNOWN-BY-PRINCIPAL-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN P (MS!PRINCIPALS)) (NOT (KNOWN-BY-PRINCIPAL K P S))
  (KNOWN-BY-PRINCIPAL M2 P S) (IN (MS!ENCRYPT M K) (MS!PARTS (UNIT M2))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
Invoking KNOWN-BY-PRINCIPAL gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN P (MS!PRINCIPALS))
  (NOT
   (MS!KNOWN-IN K
    (UNION (STORAGE-OF P S)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS))))))
  (MS!KNOWN-IN M2
   (UNION (STORAGE-OF P S)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (UNIT M2))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD, MS!D2-RULE, UNION.PERMUTATIVE,
UNION.COMMUTATIVE
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!COMP-OF-IN-MESSAGES, MS!KNOWN-IN-IN-MESSAGES, MS!D1,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!COMP-OF-BOOL,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY, MS!KNOWN-IN-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN P (MS!PRINCIPALS))
  (NOT
   (MS!COMP-OF K
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
  (MS!KNOWN-IN M2
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
Assuming MS!ENCRYPTED-MESSAGE-THEOREM with the
instantiations: (= M M) (= K K) (= M2 M2)
                (= S
                 (UNION (MS!PRINCIPALS)
                  (UNION (MS!TEXT-MESSAGES)
                   (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IN M2 (MS!MESSAGES))
    (MS!KNOWN-IN M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))
    (NOT
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
    (NOT
     (MS!KNOWN-IN K
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
  (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN P (MS!PRINCIPALS))
  (NOT
   (MS!COMP-OF K
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
  (MS!KNOWN-IN M2
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN P (MS!PRINCIPALS))
  (NOT
   (MS!COMP-OF K
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S))))))
  (MS!KNOWN-IN M2
   (UNION (MS!PRINCIPALS)
    (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IMPLIES
   (AND (IN M (MS!MESSAGES)) (IN K (MS!KEYS)) (IN M2 (MS!MESSAGES))
    (MS!KNOWN-IN M2
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))
    (NOT
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (UNION (MS!PRINCIPALS)
        (UNION (MS!TEXT-MESSAGES)
         (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
    (NOT
     (MS!KNOWN-IN K
      (UNION (MS!PRINCIPALS)
       (UNION (MS!TEXT-MESSAGES)
        (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
   (NOT (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
 (IN (MS!ENCRYPT M K) (MS!PARTS (STORAGE-OF P S))))
Which simplifies
 when rewriting with MS!D2-RULE, UNION.DEFINITION, MS!PARTS-ATOMIC,
MS!PARTS-UNION
 forward chaining using MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS,
MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, MS!COMP-OF-IN-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!KNOWN-IN-BOOL, MS!COMP-OF-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
IS-GENERATED-MONOTONIC
Beginning proof of IS-GENERATED-MONOTONIC ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (<= 1 N1) (<= N1 N2) (<= N2 (SEQ!LENGTH S))
  (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S N1)))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= N2 2) (*P* K N1 (- N2 1) (SEQ!TAIL S))
    (*P* K (- N1 1) (- N2 1) (SEQ!TAIL S)))
   (*P* K N1 N2 S))
  (IMPLIES (NOT (>= N2 2)) (*P* K N1 N2 S)))
 produces ...
(AND
 (IMPLIES
  (AND (>= N2 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (<= 1 N1) (<= N1 (- N2 1))
     (<= (- N2 1) (SEQ!LENGTH (SEQ!TAIL S)))
     (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (- N2 1))))
    (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1)))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (<= 1 (- N1 1))
     (<= (- N1 1) (- N2 1)) (<= (- N2 1) (SEQ!LENGTH (SEQ!TAIL S)))
     (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (- N2 1))))
    (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (- N1 1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (<= 1 N1) (<= N1 N2) (<= N2 (SEQ!LENGTH S))
    (IS-GENERATED K (SEQ!NTH S N2)))
   (IS-GENERATED K (SEQ!NTH S N1))))
 (IMPLIES (NOT (>= N2 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (<= 1 N1) (<= N1 N2) (<= N2 (SEQ!LENGTH S))
    (IS-GENERATED K (SEQ!NTH S N2)))
   (IS-GENERATED K (SEQ!NTH S N1)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (>= N2 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (IMPLIES (AND (>= N1 1) (>= (+ -1 N2) N1))
   (IF (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
    (IF (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
     (IMPLIES (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1))
      (IF (>= (+ -1 N1) 1)
       (IMPLIES
        (AND (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
         (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
         (IS-GENERATED K (SEQ!NTH S N2)))
        (IS-GENERATED K (SEQ!NTH S N1)))
       (IMPLIES
        (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
         (IS-GENERATED K (SEQ!NTH S N2)))
        (IS-GENERATED K (SEQ!NTH S 1)))))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
       (IS-GENERATED K (SEQ!NTH S N2)))
      (IS-GENERATED K (SEQ!NTH S N1))))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
      (IS-GENERATED K (SEQ!NTH S N2)))
     (IS-GENERATED K (SEQ!NTH S N1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (>= N2 N1) (>= (SEQ!LENGTH S) N2)
    (IS-GENERATED K (SEQ!NTH S N2)))
   (IS-GENERATED K (SEQ!NTH S N1)))))
Starting case 2 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1))
 (IF (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IF (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
   (IMPLIES (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1))
    (IF (>= (+ -1 N1) 1)
     (IMPLIES
      (AND (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
       (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
       (IS-GENERATED K (SEQ!NTH S N2)))
      (IS-GENERATED K (SEQ!NTH S N1)))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
       (IS-GENERATED K (SEQ!NTH S N2)))
      (IS-GENERATED K (SEQ!NTH S 1)))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
     (IS-GENERATED K (SEQ!NTH S N2)))
    (IS-GENERATED K (SEQ!NTH S N1))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
    (IS-GENERATED K (SEQ!NTH S N2)))
   (IS-GENERATED K (SEQ!NTH S N1)))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2)))
 (IF (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IMPLIES (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1))
   (IF (>= (+ -1 N1) 1)
    (IMPLIES
     (AND (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
      (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
      (IS-GENERATED K (SEQ!NTH S N2)))
     (IS-GENERATED K (SEQ!NTH S N1)))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
      (IS-GENERATED K (SEQ!NTH S N2)))
     (IS-GENERATED K (SEQ!NTH S 1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
    (IS-GENERATED K (SEQ!NTH S N2)))
   (IS-GENERATED K (SEQ!NTH S N1)))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1)))
 (IF (>= (+ -1 N1) 1)
  (IMPLIES
   (AND (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
    (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
    (IS-GENERATED K (SEQ!NTH S N2)))
   (IS-GENERATED K (SEQ!NTH S N1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
    (IS-GENERATED K (SEQ!NTH S N2)))
   (IS-GENERATED K (SEQ!NTH S 1)))))
Starting case 2.2.2.2 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1)) (>= (+ -1 N1) 1)
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1))) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N2) (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S N1)))
Invoking (SEQ!NTH S N1) gives ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1)) (>= (+ -1 N1) 1)
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1))) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N2) (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL S) (- N1 1)) (SEQ!HEAD S))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.2.1 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1)) (NOT (>= (+ -1 N1) 1))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S 1)))
Splitting on (= N1 1) generates ...
(IF (= N1 1)
 (IMPLIES
  (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
   (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
   (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
   (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1)) (NOT (>= (+ -1 N1) 1))
   (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
   (IS-GENERATED K (SEQ!NTH S N2)))
  (IS-GENERATED K (SEQ!NTH S 1)))
 (IMPLIES
  (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
   (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
   (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
   (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) N1)) (NOT (>= (+ -1 N1) 1))
   (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
   (IS-GENERATED K (SEQ!NTH S N2)))
  (IS-GENERATED K (SEQ!NTH S 1))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) 1)) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N2) (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S 1)))
Invoking (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) 1)) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
     (HISTORY (SEQ!NTH (SEQ!TAIL S) 1)))))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S 1)))
Invoking (IS-GENERATED K (SEQ!NTH S 1)) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (SOME (L T P1)
   (AND (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
     (HISTORY (SEQ!NTH (SEQ!TAIL S) 1)))))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (IS-GENERATED K (SEQ!NTH S N2)))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!NTH S 1))))))
Instantiating (= L$0 L) (= T$0 T) (= P1$0 P1) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!NTH (SEQ!TAIL S) 1)))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT
   (AND (IN P1 (MS!PRINCIPALS))
    (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!NTH S 1))))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!NTH S 1))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!NTH (SEQ!TAIL S) 1)))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!NTH S 1)))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!NTH S 1))))))
Invoking (SEQ!NTH (SEQ!TAIL S) 1) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL S)) (- 1 1))
     (SEQ!HEAD (SEQ!TAIL S)))))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!NTH S 1)))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!NTH S 1))))))
Rearranging gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!NTH S 1))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL S)) (- 1 1))
     (SEQ!HEAD (SEQ!TAIL S))))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!NTH S 1))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK, TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!NTH S 1))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S)))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!NTH S 1))))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (HISTORY (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S)))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S)))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S)))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1) (HISTORY (SEQ!HEAD S))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S)))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!HEAD S))))))
Invoking (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
          (HISTORY (SEQ!HEAD S))) gives
...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT
   (AND (SEQ!IS-TACK (HISTORY (SEQ!HEAD S)))
    (OR (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!HEAD S))))
     (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
      (SEQ!TAIL (HISTORY (SEQ!HEAD S)))))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S)))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!HEAD S))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION,
IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SEQ!TYPE-OF-IS-TACK, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!HEAD S)))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!HEAD S)))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S)))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!HEAD S))))))
Applying HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (>= (SEQ!LENGTH S) N2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (IN P1 (MS!PRINCIPALS))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!NTH S N2))
  (NOT (= (MAKE-GENERATE-EVENT L T K P1) (SEQ!HEAD (HISTORY (SEQ!HEAD S)))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
    (SEQ!TAIL (HISTORY (SEQ!HEAD S)))))
  (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L T K P1)
   (IF (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) 2))
    (SEQ!TAIL (HISTORY (SEQ!HEAD S))) (HISTORY (SEQ!HEAD (SEQ!TAIL S))))))
 (SOME (L$0 T$0 P1$0)
  (AND (IN P1$0 (MS!PRINCIPALS))
   (SEQ!IS-MEMBER (MAKE-GENERATE-EVENT L$0 T$0 K P1$0)
    (HISTORY (SEQ!HEAD S))))))
Which simplifies
 forward chaining using MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-GENERATE-EVENT,
LABEL-OF-GENERATE-EVENT, TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (NOT (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S N1)))
Invoking (SEQ!NTH S N2) gives ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (NOT (IS-GENERATED K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (IS-GENERATED K
   (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL S) (- N2 1)) (SEQ!HEAD S))))
 (IS-GENERATED K (SEQ!NTH S N1)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N2) (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S N1)))
Invoking (SEQ!LENGTH S) gives ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))) (IS-GOOD-EVOLUTION S)
  (>= (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0) N2)
  (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S N1)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (>= N2 2) (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL S))) (IS-GOOD-EVOLUTION S)
  (>= N1 1) (>= N2 N1) (>= (SEQ!LENGTH S) N2) (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S N1)))
Invoking (IS-GOOD-EVOLUTION S) gives ...
(IMPLIES
 (AND (>= N2 2) (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL S)))
  (IF (>= (SEQ!LENGTH S) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL S)) (SEQ!HEAD S)))
   (AND (>= (SEQ!LENGTH S) 1) (IS-GOOD-STATE (SEQ!HEAD S))
    (= (HISTORY (SEQ!HEAD S)) (SEQ!EMPTY)) (= (SEQ!TAIL S) (SEQ!EMPTY))))
  (>= N1 1) (>= N2 N1) (>= (SEQ!LENGTH S) N2) (IS-GENERATED K (SEQ!NTH S N2)))
 (IS-GENERATED K (SEQ!NTH S N1)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY to ...
(TRUE)
Completing all cases produces ...
(TRUE)
ENCRYPTED-PART-OF-RECEIVED-MONOTONIC
Beginning proof of ENCRYPTED-PART-OF-RECEIVED-MONOTONIC ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (<= 1 N1) (<= N1 N2) (<= N2 (SEQ!LENGTH S))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
Inducting using the following scheme ...
 (AND
  (IMPLIES
   (AND (>= N2 2) (*P* K M N1 (- N2 1) (SEQ!TAIL S))
    (*P* K M (- N1 1) (- N2 1) (SEQ!TAIL S)))
   (*P* K M N1 N2 S))
  (IMPLIES (NOT (>= N2 2)) (*P* K M N1 N2 S)))
 produces ...
(AND
 (IMPLIES
  (AND (>= N2 2)
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (<= 1 N1) (<= N1 (- N2 1))
     (<= (- N2 1) (SEQ!LENGTH (SEQ!TAIL S)))
     (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (- N2 1))))
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1)))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (<= 1 (- N1 1))
     (<= (- N1 1) (- N2 1)) (<= (- N2 1) (SEQ!LENGTH (SEQ!TAIL S)))
     (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (- N2 1))))
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (- N1 1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (<= 1 N1) (<= N1 N2) (<= N2 (SEQ!LENGTH S))
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1))))
 (IMPLIES (NOT (>= N2 2))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (<= 1 N1) (<= N1 N2) (<= N2 (SEQ!LENGTH S))
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES (>= N2 2)
 (IF (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (IMPLIES (AND (>= N1 1) (>= (+ -1 N2) N1))
   (IF (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
    (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
     (IMPLIES (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1))
      (IF (>= (+ -1 N1) 1)
       (IMPLIES
        (AND (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
         (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
         (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
        (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
       (IMPLIES
        (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
         (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
        (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)))))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
       (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
      (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1))))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
      (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
     (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (>= N2 N1) (>= (SEQ!LENGTH S) N2)
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))))
Starting case 2 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1))
 (IF (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
   (IMPLIES (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1))
    (IF (>= (+ -1 N1) 1)
     (IMPLIES
      (AND (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
       (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
       (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
      (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
     (IMPLIES
      (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
       (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
      (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)))))
   (IMPLIES
    (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
     (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2)))
 (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IMPLIES (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1))
   (IF (>= (+ -1 N1) 1)
    (IMPLIES
     (AND (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
      (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
      (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
     (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
    (IMPLIES
     (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
      (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
     (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))))
Starting case 2.2.2 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1)))
 (IF (>= (+ -1 N1) 1)
  (IMPLIES
   (AND (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
    (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)))))
Starting case 2.2.2.2 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1)) (>= (+ -1 N1) 1)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
Invoking (SEQ!NTH S N1) gives ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1)) (>= (+ -1 N1) 1)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N1)))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K
  (IF (>= N1 2) (SEQ!NTH (SEQ!TAIL S) (- N1 1)) (SEQ!HEAD S))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.2.1 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1))
  (NOT (>= (+ -1 N1) 1)) (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)))
Splitting on (= N1 1) generates ...
(IF (= N1 1)
 (IMPLIES
  (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
   (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1))
   (NOT (>= (+ -1 N1) 1)) (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)))
 (IMPLIES
  (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
   (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) N1))
   (NOT (>= (+ -1 N1) 1)) (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) 1))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)))
Invoking (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) 1)) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (SOME (L2 T2 M2 P2)
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL S) 1))
    (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (HISTORY (SEQ!NTH (SEQ!TAIL S) 1)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)))
Invoking (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S 1)) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (SOME (L2 T2 M2 P2)
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL S) 1))
    (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (HISTORY (SEQ!NTH (SEQ!TAIL S) 1)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (SOME (L2$0 T2$0 M2$0 P2$0)
  (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
   (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S 1))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
    (HISTORY (SEQ!NTH S 1)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))
Instantiating (= L2$0 L2) (= T2$0 T2) (= M2$0 M2) (= P2$0 P2) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (>= L2 0)
  (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL S) 1))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH (SEQ!TAIL S) 1)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N2) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2))
  (NOT
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S 1))
    (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S 1)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
 (SOME (L2$0 T2$0 M2$0 P2$0)
  (AND (>= L2$0 0) (>= T2$0 0) (IN M2$0 (MS!MESSAGES))
   (IN P2$0 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S 1))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
    (HISTORY (SEQ!NTH S 1)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, IN-RECEIVE-EVENT,
MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, HISTORY-IS-SEQUENCE,
TAG-OF-MAKE-RECEIVE-EVENT, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (>= L2 0)
  (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IS-GOOD-EVOLUTION-STATE (SEQ!NTH (SEQ!TAIL S) 1))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH (SEQ!TAIL S) 1)))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N2) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S 1))
  (OR (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S 1)))
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY (SEQ!NTH S 1)))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))))
Invoking (SEQ!NTH (SEQ!TAIL S) 1) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))) (>= L2 0)
  (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS))
  (IS-GOOD-EVOLUTION-STATE
   (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL S)) (- 1 1))
    (SEQ!HEAD (SEQ!TAIL S))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL S)) (- 1 1))
     (SEQ!HEAD (SEQ!TAIL S)))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N2) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S 1))
  (OR (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S 1)))
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY (SEQ!NTH S 1)))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))))
Rearranging gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= L2 0) (>= T2 0)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2)) (>= (SEQ!LENGTH S) N2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IS-GOOD-EVOLUTION S) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2))
  (IS-GOOD-EVOLUTION-STATE
   (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL S)) (- 1 1))
    (SEQ!HEAD (SEQ!TAIL S))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY
    (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL (SEQ!TAIL S)) (- 1 1))
     (SEQ!HEAD (SEQ!TAIL S))))))
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S 1))
  (OR (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S 1)))
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY (SEQ!NTH S 1)))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!TYPE-OF-IS-TACK, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= L2 0) (>= T2 0)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2)) (>= (SEQ!LENGTH S) N2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IS-GOOD-EVOLUTION S) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S)))))
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S 1))
  (OR (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY (SEQ!NTH S 1)))
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY (SEQ!NTH S 1)))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= L2 0) (>= T2 0)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2)) (>= (SEQ!LENGTH S) N2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IS-GOOD-EVOLUTION S) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S)))))
 (AND
  (IS-GOOD-EVOLUTION-STATE
   (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S)))
  (OR
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (HISTORY (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S))))
   (SOME (L2$0)
    (AND (>= L2$0 0)
     (SOME (T2$0)
      (AND (>= T2$0 0)
       (SOME (M2$0)
        (AND (IN M2$0 (MS!MESSAGES))
         (SOME (P2$0)
          (AND (IN P2$0 (MS!PRINCIPALS))
           (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
            (HISTORY
             (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S))))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= L2 0) (>= T2 0)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2)) (>= (SEQ!LENGTH S) N2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IS-GOOD-EVOLUTION S) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (HISTORY (SEQ!HEAD S)))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
          (HISTORY (SEQ!HEAD S)))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Invoking (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
          (HISTORY (SEQ!HEAD S))) gives
...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= L2 0) (>= T2 0)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2)) (>= (SEQ!LENGTH S) N2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IS-GOOD-EVOLUTION S) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S))))
  (NOT
   (AND (SEQ!IS-TACK (HISTORY (SEQ!HEAD S)))
    (OR (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (SEQ!HEAD (HISTORY (SEQ!HEAD S))))
     (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
      (SEQ!TAIL (HISTORY (SEQ!HEAD S))))))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
          (HISTORY (SEQ!HEAD S)))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION,
IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT, IN-RECEIVE-EVENT,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions HISTORY-IS-SEQUENCE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!TYPE-OF-IS-TACK, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= L2 0) (>= T2 0)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2)) (>= (SEQ!LENGTH S) N2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IS-GOOD-EVOLUTION S) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!HEAD (SEQ!TAIL S))))
  (NOT (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (SEQ!HEAD (HISTORY (SEQ!HEAD S)))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!TAIL (HISTORY (SEQ!HEAD S))))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
          (HISTORY (SEQ!HEAD S)))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Applying HISTORY-OF-HEAD-OF-TAIL-OF-GOOD-EVOLUTION gives ...
(IMPLIES
 (AND (= N1 1) (>= N2 2) (>= L2 0) (>= T2 0)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2)) (>= (SEQ!LENGTH S) N2)
  (IS-GOOD-EVOLUTION (SEQ!TAIL S))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2)))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS)) (IN M (MS!MESSAGES))
  (IN K (MS!KEYS)) (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IS-GOOD-EVOLUTION S) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (IF (AND (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) 2))
    (SEQ!TAIL (HISTORY (SEQ!HEAD S))) (HISTORY (SEQ!HEAD (SEQ!TAIL S)))))
  (NOT (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2) (SEQ!HEAD (HISTORY (SEQ!HEAD S)))))
  (NOT
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!TAIL (HISTORY (SEQ!HEAD S))))))
 (SOME (L2$0)
  (AND (>= L2$0 0)
   (SOME (T2$0)
    (AND (>= T2$0 0)
     (SOME (M2$0)
      (AND (IN M2$0 (MS!MESSAGES))
       (SOME (P2$0)
        (AND (IN P2$0 (MS!PRINCIPALS))
         (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2$0 T2$0 M2$0 P2$0)
          (HISTORY (SEQ!HEAD S)))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.2.1 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
Invoking (SEQ!NTH S N2) gives ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH (SEQ!TAIL S) (+ -1 N2))))
  (IS-GOOD-EVOLUTION S) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K
   (IF (>= N2 2) (SEQ!NTH (SEQ!TAIL S) (- N2 1)) (SEQ!HEAD S))))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))) (IS-GOOD-EVOLUTION S)
  (>= (SEQ!LENGTH S) N2) (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
Invoking (SEQ!LENGTH S) gives ...
(IMPLIES
 (AND (>= N2 2) (IS-GOOD-EVOLUTION (SEQ!TAIL S)) (>= N1 1) (>= (+ -1 N2) N1)
  (NOT (>= (SEQ!LENGTH (SEQ!TAIL S)) (+ -1 N2))) (IS-GOOD-EVOLUTION S)
  (>= (IF (SEQ!IS-TACK S) (+ 1 (SEQ!LENGTH (SEQ!TAIL S))) 0) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using SEQ!TACK-HEAD-TAIL, SEQ!NOT-IS-TACK-FACTS,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!TYPE-OF-IS-TACK, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (>= N2 2) (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL S))) (IS-GOOD-EVOLUTION S)
  (>= N1 1) (>= N2 N1) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
Invoking (IS-GOOD-EVOLUTION S) gives ...
(IMPLIES
 (AND (>= N2 2) (NOT (IS-GOOD-EVOLUTION (SEQ!TAIL S)))
  (IF (>= (SEQ!LENGTH S) 2)
   (AND (IS-GOOD-EVOLUTION (SEQ!TAIL S))
    (GOOD-STEP (SEQ!HEAD (SEQ!TAIL S)) (SEQ!HEAD S)))
   (AND (>= (SEQ!LENGTH S) 1) (IS-GOOD-STATE (SEQ!HEAD S))
    (= (HISTORY (SEQ!HEAD S)) (SEQ!EMPTY)) (= (SEQ!TAIL S) (SEQ!EMPTY))))
  (>= N1 1) (>= N2 N1) (>= (SEQ!LENGTH S) N2)
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N2)))
 (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S N1)))
Which simplifies
 forward chaining using SEQ!NOT-IS-TACK-FACTS, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!EMPTYP-EMPTY, SEQ!IS-SEQUENCE-EMPTY to ...
(TRUE)
Completing all cases produces ...
(TRUE)
ENCRYPTED-MESSAGE-THEOREM
Beginning proof of ENCRYPTED-MESSAGE-THEOREM ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)))
 (OR
  (SOME (N2 L2 T2 M2 P2)
   (AND (>= N2 1) (< N2 (SEQ!LENGTH S)) (IN M2 (MS!MESSAGES))
    (IN P2 (MS!PRINCIPALS))
    (= (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2) (MAKE-SEND-EVENT L2 T2 M2 P2))
    (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ N2 1)))
    (NOT
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ N2 1))))))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
  (SOME (N3 L3 T3 M3 P3 P4)
   (AND (>= N3 1) (< N3 (SEQ!LENGTH S)) (IN M3 (MS!MESSAGES))
    (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
    (= (SEQ!NTH (HISTORY (SEQ!HEAD S)) N3)
     (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
    (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ N3 1)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))))
Assuming ENCRYPTED-MESSAGE-THEOREM-1-B with the
instantiations: (= M M) (= K K) (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)))
   (SOME (N1)
    (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
     (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
      (SEND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH S))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (N2$0 L2 T2 M2 P2)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (SUCC N2$0)) (IN M2 (MS!MESSAGES))
     (IN P2 (MS!PRINCIPALS))
     (= (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2$0) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ N2$0 1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ N2$0 1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
 (SOME (N3 L3 T3 M3 P3 P4)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (SUCC N3)) (IN M3 (MS!MESSAGES))
   (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD S)) N3)
    (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
   (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ N3 1)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Rearranging gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (N2$0 L2 T2 M2 P2)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (SUCC N2$0))
     (= (SEQ!NTH (HISTORY (SEQ!HEAD S)) N2$0) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ N2$0 1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ N2$0 1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S)))
   (SOME (N1)
    (AND (>= N1 1) (<= N1 (SEQ!LENGTH (HISTORY (SEQ!HEAD S))))
     (IN (SEQ!NTH (HISTORY (SEQ!HEAD S)) N1)
      (SEND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1 1)) (<= N2 (SEQ!LENGTH S))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))))))
 (SOME (N3 L3 T3 M3 P3 P4)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (SUCC N3))
   (= (SEQ!NTH (HISTORY (SEQ!HEAD S)) N3)
    (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
   (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ N3 1)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
SEND-EVENTS-CONTAINING-ENCRYPT.DEFINITION, NTH-HISTORY-HEAD-EVOLUTION,
LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION, SUCC.INT.RULE
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, IN-SEND-EVENT,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FORGEABLE-IS-MESSAGE,
MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT,
MS!SIZE-ENKY, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, HISTORY-IS-SEQUENCE,
SUCC.INT, SEQ!LENGTH-NON-NEGATIVE, HEAD-OF-EVOLUTION-IN-EVOLUTION,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (SOME (N1)
   (AND (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming SEND-EVENT-THEOREM with the
instantiations: (= N N1) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (<= N1 (- (SEQ!LENGTH S) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS)))
   (AND
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ N1 1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))))
  (IS-GOOD-EVOLUTION S) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Splitting
on (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))) generates
...
(IF
 (KNOWN-BY-PRINCIPAL K
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
  (SEQ!NTH S (+ 1 N1)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
   (NOT
    (SOME (N2)
     (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
      (SOME (L2 T2 M2 P2)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
        (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
  (SOME (N3)
   (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
    (SOME (L3 T3 M3 P3 P4)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
       (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
      (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
   (NOT
    (SOME (N2$1)
     (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
      (SOME (L2$0 T2$0 M2$0 P2$0)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
         (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
        (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$1)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (NOT
    (SOME (N2$2)
     (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))))
  (SOME (N3$0)
   (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
    (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
       (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
      (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
      (IN P4$0 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET))))))))))
Starting case 2 ...
(IMPLIES
 (AND
  (KNOWN-BY-PRINCIPAL K
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Instantiating (= N2 N1)
              (= L2 (LABEL-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
              (= T2 (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
              (= M2 (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
              (= P2
               (PRINCIPAL1-OF-EVENT
                (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))) gives
...
(IMPLIES
 (AND
  (KNOWN-BY-PRINCIPAL K
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (OR
    (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1))
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))
      (MAKE-SEND-EVENT (LABEL-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))))
     (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))) (MS!MESSAGES))
     (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
        (NULLSET)))))
    (SOME (N2 L2 T2 M2 P2)
     (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
      (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
      (NOT
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, KNOWN-BY-PRINCIPAL-IS-MESSAGE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY, TAG-OF-MAKE-SEND-EVENT,
MAKE-SEND-EVENT-IS-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
HEAD-OF-EVOLUTION-IN-EVOLUTION, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE
 with the instantiation (= N2$0 (+ 1 N1)) to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$2)
    (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))))
 (SOME (N3$0)
  (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
   (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
      (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
     (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
     (IN P4$0 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
Assuming IS-GENERATED-CONSEQUENCE with the
instantiations: (= S S) (= K K) (= N (+ N1 1)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (<= 1 (+ N1 1))
    (<= (+ N1 1) (SEQ!LENGTH S)))
   (OR (IS-GENERATED K (SEQ!NTH S (+ N1 1)))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ N1 1))))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S))) (IS-GENERATED K (SEQ!HEAD S))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, IN-SEND-EVENT,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
SEQ!LENGTH-NON-NEGATIVE, HEAD-OF-EVOLUTION-IN-EVOLUTION to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (>= (+ 1 N1) 1)
  (>= (SEQ!LENGTH S) (+ 1 N1)))
 (IF (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (IMPLIES
   (AND
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (>= N1 1) (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (NOT
     (SOME (N2)
      (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
       (SOME (L2 T2 M2 P2)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
         (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (IMPLIES
   (AND (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
    (NOT (IN K (MS!PUBLIC-KEYS)))
    (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
    (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (>= N1 1) (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (NOT
     (SOME (N2$1)
      (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$1)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (NOT
     (SOME (N2$2)
      (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))
Starting case 1.2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (>= (+ 1 N1) 1)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (>= N1 1) (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming ENCRYPTED-MESSAGE-THEOREM-2 with the
instantiations: (= M M)
                (= P
                 (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
                (= K K) (= S (SEQ!NTH S (+ 1 N1))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))) (IN M (MS!MESSAGES))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (MS!PRINCIPALS))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
   (OR (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1)))
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (>= (+ 1 N1) 1)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (>= N1 1) (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))) (IN M (MS!MESSAGES))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (MS!PRINCIPALS))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1)))))
   (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0)))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions STORAGE-OF-IS-SUBSET-MESSAGES,
TAG-OF-MAKE-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (IF (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (IF (FORGEABLE K (SEQ!NTH S (+ 1 N1)))
   (OR
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))
    (SOME (N2$0)
     (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
      (SOME (L2 T2 M2 P2)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
         (MAKE-SEND-EVENT L2 T2 M2 P2))
        (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
    (SOME (N3)
     (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
      (SOME (L3 T3 M3 P3 P4)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
         (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
        (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
   (IF
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1)))
     (OR
      (SOME (N2$1)
       (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1))))))
      (SOME (N2$2)
       (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
        (SOME (L2$0 T2$0 M2$0 P2$0)
         (AND
          (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
           (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
          (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$2)))
          (NOT
           (IN (MS!ENCRYPT M K)
            (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
      (SOME (N3$0)
       (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
        (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
         (AND
          (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
           (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
          (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
          (IN P4$0 (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
     (IMPLIES
      (AND (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
       (NOT
        (SOME (N2$3)
         (AND (>= N2$3 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$3)
          (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$3)))))))
       (NOT
        (SOME (N2$4)
         (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
          (SOME (L2$1 T2$1 M2$1 P2$1)
           (AND
            (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
             (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
            (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
            (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$4)))
            (NOT
             (IN (MS!ENCRYPT M K)
              (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
      (SOME (N3$1)
       (AND (>= N3$1 1) (>= (SEQ!LENGTH S) (+ 1 N3$1))
        (SOME (L3$1 T3$1 M3$1 P3$1 P4$1)
         (AND
          (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$1)))
           (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1))
          (IN M3$1 (MS!MESSAGES)) (IN P3$1 (MS!PRINCIPALS))
          (IN P4$1 (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL K P3$1 (SEQ!NTH S (+ 1 N3$1)))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET))))))))))
    (OR
     (SOME (N2$5)
      (AND (>= N2$5 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$5)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$5))))))
     (SOME (N2$6)
      (AND (>= N2$6 1) (>= (SEQ!LENGTH S) (+ 1 N2$6))
       (SOME (L2$2 T2$2 M2$2 P2$2)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$6)))
          (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2))
         (IN M2$2 (MS!MESSAGES)) (IN P2$2 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$2 (SEQ!NTH S (+ 1 N2$6)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$6))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))
     (SOME (N3$2)
      (AND (>= N3$2 1) (>= (SEQ!LENGTH S) (+ 1 N3$2))
       (SOME (L3$2 T3$2 M3$2 P3$2 P4$2)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$2)))
          (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2))
         (IN M3$2 (MS!MESSAGES)) (IN P3$2 (MS!PRINCIPALS))
         (IN P4$2 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P3$2 (SEQ!NTH S (+ 1 N3$2)))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))
  (OR
   (SOME (N2$7)
    (AND (>= N2$7 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$7)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$7))))))
   (SOME (N2$8)
    (AND (>= N2$8 1) (>= (SEQ!LENGTH S) (+ 1 N2$8))
     (SOME (L2$3 T2$3 M2$3 P2$3)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$8)))
        (MAKE-SEND-EVENT L2$3 T2$3 M2$3 P2$3))
       (IN M2$3 (MS!MESSAGES)) (IN P2$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$3 (SEQ!NTH S (+ 1 N2$8)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$8))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))
   (SOME (N3$3)
    (AND (>= N3$3 1) (>= (SEQ!LENGTH S) (+ 1 N3$3))
     (SOME (L3$3 T3$3 M3$3 P3$3 P4$3)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$3)))
        (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3))
       (IN M3$3 (MS!MESSAGES)) (IN P3$3 (MS!PRINCIPALS))
       (IN P4$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$3 (SEQ!NTH S (+ 1 N3$3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$3 (NULLSET)))))))))))
Starting case 1.2.2 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
 (IF (FORGEABLE K (SEQ!NTH S (+ 1 N1)))
  (OR
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (IF
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1)))
    (OR
     (SOME (N2$1)
      (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1))))))
     (SOME (N2$2)
      (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$2)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
     (SOME (N3$0)
      (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
       (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
          (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
         (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
         (IN P4$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
    (IMPLIES
     (AND (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
      (NOT
       (SOME (N2$3)
        (AND (>= N2$3 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$3)
         (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$3)))))))
      (NOT
       (SOME (N2$4)
        (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
         (SOME (L2$1 T2$1 M2$1 P2$1)
          (AND
           (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
            (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
           (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$4)))
           (NOT
            (IN (MS!ENCRYPT M K)
             (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
           (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
     (SOME (N3$1)
      (AND (>= N3$1 1) (>= (SEQ!LENGTH S) (+ 1 N3$1))
       (SOME (L3$1 T3$1 M3$1 P3$1 P4$1)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$1)))
          (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1))
         (IN M3$1 (MS!MESSAGES)) (IN P3$1 (MS!PRINCIPALS))
         (IN P4$1 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P3$1 (SEQ!NTH S (+ 1 N3$1)))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET))))))))))
   (OR
    (SOME (N2$5)
     (AND (>= N2$5 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$5)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$5))))))
    (SOME (N2$6)
     (AND (>= N2$6 1) (>= (SEQ!LENGTH S) (+ 1 N2$6))
      (SOME (L2$2 T2$2 M2$2 P2$2)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$6)))
         (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2))
        (IN M2$2 (MS!MESSAGES)) (IN P2$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$2 (SEQ!NTH S (+ 1 N2$6)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$6))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))
    (SOME (N3$2)
     (AND (>= N3$2 1) (>= (SEQ!LENGTH S) (+ 1 N3$2))
      (SOME (L3$2 T3$2 M3$2 P3$2 P4$2)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$2)))
         (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2))
        (IN M3$2 (MS!MESSAGES)) (IN P3$2 (MS!PRINCIPALS))
        (IN P4$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P3$2 (SEQ!NTH S (+ 1 N3$2)))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$2 (NULLSET))))))))))))
Starting case 1.2.2.2 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming FORGEABLE-IS-MONOTONIC with the
instantiations: (= SEQUENCE S) (= MESSAGE K) (= N1 (+ 1 N1))
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= 1 1) (>= (+ 1 N1) 1)
    (>= (SEQ!LENGTH S) (+ 1 N1)) (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (FORGEABLE K (SEQ!NTH S 1)))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= 1 1) (>= (+ 1 N1) 1)
    (>= (SEQ!LENGTH S) (+ 1 N1)) (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (FORGEABLE K (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S))))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FORGEABLE-IS-MESSAGE,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.2.1 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1)))))
 (IF
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1)))
   (OR
    (SOME (N2$1)
     (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1))))))
    (SOME (N2$2)
     (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
      (SOME (L2$0 T2$0 M2$0 P2$0)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
         (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
        (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$2)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
    (SOME (N3$0)
     (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
      (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
         (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
        (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
        (IN P4$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
   (IMPLIES
    (AND (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
     (NOT
      (SOME (N2$3)
       (AND (>= N2$3 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$3)
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$3)))))))
     (NOT
      (SOME (N2$4)
       (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
        (SOME (L2$1 T2$1 M2$1 P2$1)
         (AND
          (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
           (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
          (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$4)))
          (NOT
           (IN (MS!ENCRYPT M K)
            (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
          (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
    (SOME (N3$1)
     (AND (>= N3$1 1) (>= (SEQ!LENGTH S) (+ 1 N3$1))
      (SOME (L3$1 T3$1 M3$1 P3$1 P4$1)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$1)))
         (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1))
        (IN M3$1 (MS!MESSAGES)) (IN P3$1 (MS!PRINCIPALS))
        (IN P4$1 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P3$1 (SEQ!NTH S (+ 1 N3$1)))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET))))))))))
  (OR
   (SOME (N2$5)
    (AND (>= N2$5 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$5)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$5))))))
   (SOME (N2$6)
    (AND (>= N2$6 1) (>= (SEQ!LENGTH S) (+ 1 N2$6))
     (SOME (L2$2 T2$2 M2$2 P2$2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$6)))
        (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2))
       (IN M2$2 (MS!MESSAGES)) (IN P2$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$2 (SEQ!NTH S (+ 1 N2$6)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$6))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))
   (SOME (N3$2)
    (AND (>= N3$2 1) (>= (SEQ!LENGTH S) (+ 1 N3$2))
     (SOME (L3$2 T3$2 M3$2 P3$2 P4$2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$2)))
        (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2))
       (IN M3$2 (MS!MESSAGES)) (IN P3$2 (MS!PRINCIPALS))
       (IN P4$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$2 (SEQ!NTH S (+ 1 N3$2)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$2 (NULLSET)))))))))))
Starting case 1.2.2.1.2 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))))
 (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1)))
  (OR
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1))))))
   (SOME (N2$2)
    (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$2)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
  (IMPLIES
   (AND (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (SOME (N2$3)
      (AND (>= N2$3 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$3)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$3)))))))
    (NOT
     (SOME (N2$4)
      (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
       (SOME (L2$1 T2$1 M2$1 P2$1)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
          (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
         (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$4)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
   (SOME (N3$1)
    (AND (>= N3$1 1) (>= (SEQ!LENGTH S) (+ 1 N3$1))
     (SOME (L3$1 T3$1 M3$1 P3$1 P4$1)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$1)))
        (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1))
       (IN M3$1 (MS!MESSAGES)) (IN P3$1 (MS!PRINCIPALS))
       (IN P4$1 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$1 (SEQ!NTH S (+ 1 N3$1)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET)))))))))))
Starting case 1.2.2.1.2.2 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
  (NOT
   (SOME (N2$2)
    (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$2)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3$0)
  (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
   (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
      (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
     (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
     (IN P4$0 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
Invoking ENCRYPTED-PART-OF-RECEIVED gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (SOME (L2 T2 M2 P2)
   (AND (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (HISTORY (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M (MAKE-RECEIVE-EVENT L2 T2 M2 P2))
                (= S (HISTORY (SEQ!NTH S (+ 1 N1)))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
    (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (HISTORY (SEQ!NTH S (+ 1 N1)))))
   (SOME (N)
    (AND (>= N 1)
     (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
      (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N))
     (<= N (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1))))))))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
HISTORY-IS-SEQUENCE, MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SOME (N)
   (AND (>= N 1)
    (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N)))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (>= N 1)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N) (>= N1 1)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Applying NTH-HISTORY-NTH-EVOLUTION gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (>= N 1)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (IF
    (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) (+ 1 N1)) (>= N 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N))
    (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ 1 N1 N) 1))))
    (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N) (>= N1 1)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1))
 (IF (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (IMPLIES
   (AND (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N)
    (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
    (>= N1 1) (IS-GENERATED K (SEQ!HEAD S))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT
     (SOME (N2)
      (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (IMPLIES
   (AND
    (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N) (>= N1 1)
    (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!HEAD S))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT
     (SOME (N2$1)
      (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
    (NOT
     (SOME (N2$2)
      (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
       (SOME (L2$1 T2$1 M2$1 P2$1)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
          (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
         (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1))
 (IF (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (IMPLIES
   (AND
    (>=
     (IF
      (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1)))
      (- (SEQ!LENGTH S) (+ 1 N1)) (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
     N)
    (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
    (>= N1 1) (IS-GENERATED K (SEQ!HEAD S))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT
     (SOME (N2)
      (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (IMPLIES
   (AND
    (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N))
    (>=
     (IF
      (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1)))
      (- (SEQ!LENGTH S) (+ 1 N1)) (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
     N)
    (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!HEAD S))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT
     (SOME (N2$1)
      (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
    (NOT
     (SOME (N2$2)
      (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
       (SOME (L2$1 T2$1 M2$1 P2$1)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
          (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
         (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (>= N1 1) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming RECEIVE-EVENT-THEOREM with the
instantiations: (= N (+ N N1)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (+ N N1) 1)
    (<= (+ N N1) (- (SEQ!LENGTH S) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
   (AND
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (SEQ!NTH S (+ N N1 1)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (>= N1 1) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (>= L2 0) (>= T2 0) (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0) (>= (+ 1 N1) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (IMPLIES
   (AND (>= (+ N N1) 1) (IS-GOOD-EVOLUTION S)
    (<= (+ N N1) (- (SEQ!LENGTH S) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
   (AND
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (SEQ!NTH S (+ N N1 1)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (SEQ!NTH S (+ N N1)))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))))
 (IF (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (IMPLIES
   (AND
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (SEQ!NTH S (+ 1 N N1)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (SEQ!NTH S (+ N N1)))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (OR
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2$1 T2$1 M2$1 P2$1)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
        (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
       (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))
Starting case 1.2.2.1.2.2.2 ...
(IMPLIES
 (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming FORGEABLE-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS with the
instantiations: (= M M) (= K K) (= M2 M2)
                (= S (SEQ!NTH S (+ 1 N N1))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1))) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N N1))))
    (FORGEABLE M2 (SEQ!NTH S (+ 1 N N1)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (UNIT M2))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N N1))))))
  (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1))) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N N1))))
    (FORGEABLE M2 (SEQ!NTH S (+ 1 N N1)))
    (IN (MS!ENCRYPT M K) (MS!PARTS (UNIT M2))))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N N1))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT, SEQ!LENGTH-NON-NEGATIVE
 with the instantiation (= N2 (+ 1 (+ N N1))) to ...
(IMPLIES
 (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1))))
 (IF (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1)))
  (IMPLIES
   (AND (FORGEABLE K (SEQ!NTH S (+ 1 N N1)))
    (NOT
     (SOME (N2)
      (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (OR
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1))))))
   (SOME (N2$2)
    (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
     (SOME (L2$1 T2$1 M2$1 P2$1)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
        (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
       (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))
Starting case 1.2.2.1.2.2.2.2 ...
(IMPLIES
 (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1)))
  (FORGEABLE K (SEQ!NTH S (+ 1 N N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming FORGEABLE-IS-MONOTONIC with the
instantiations: (= SEQUENCE S) (= MESSAGE K) (= N1 (+ 1 N N1))
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= 1 1) (>= (+ 1 N N1) 1)
    (>= (SEQ!LENGTH S) (+ 1 N N1)) (FORGEABLE K (SEQ!NTH S (+ 1 N N1))))
   (FORGEABLE K (SEQ!NTH S 1)))
  (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1)))
  (FORGEABLE K (SEQ!NTH S (+ 1 N N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= 1 1) (>= (+ 1 N N1) 1)
    (>= (SEQ!LENGTH S) (+ 1 N N1)) (FORGEABLE K (SEQ!NTH S (+ 1 N N1))))
   (FORGEABLE K (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S))))
  (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1)))
  (FORGEABLE K (SEQ!NTH S (+ 1 N N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
FORGEABLE-IS-MESSAGE, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.2.1.2.2.2.1 ...
(IMPLIES
 (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
  (NOT
   (SOME (N2$2)
    (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
     (SOME (L2$1 T2$1 M2$1 P2$1)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
        (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
       (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
 (SOME (N3$0)
  (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
   (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
      (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
     (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
     (IN P4$0 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S (+ 1 N N1))) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N N1)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1))))
  (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (NOT (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N N1)) S))
  (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N (+ 1 N N1)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (+ 1 N N1) 1) (<= (+ 1 N N1) (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N N1)) S))
  (IS-GOOD-EVOLUTION S) (NOT (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N N1)) S))
  (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ 1 N N1)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!NTH S (+ N N1)))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N N1))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.2.1.2.2.1 ...
(IMPLIES
 (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2$1 T2$1 M2$1 P2$1)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
        (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
       (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
 (SOME (N3$0)
  (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
   (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
      (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
     (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
     (IN P4$0 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
Splitting on (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) generates ...
(IF (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1)))
 (IMPLIES
  (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0)
   (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
   (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (HISTORY (SEQ!NTH S (+ 1 N1))))
   (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
   (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
      (SOME (L2$0 T2$0 M2$0 P2$0)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
         (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
        (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
  (SOME (N3)
   (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
    (SOME (L3 T3 M3 P3 P4)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
       (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
      (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
 (IMPLIES
  (AND (>= N 1) (>= N1 1) (>= L2 0) (>= T2 0)
   (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
   (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (HISTORY (SEQ!NTH S (+ 1 N1))))
   (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
   (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (SOME (N2$1)
     (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
   (NOT
    (SOME (N2$2)
     (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
      (SOME (L2$1 T2$1 M2$1 P2$1)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
         (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
        (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
  (SOME (N3$0)
   (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
    (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
       (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
      (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
      (IN P4$0 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET))))))))))
Starting case 1.2.2.1.2.2.1.2 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1)
  (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Splitting on (IS-GOOD-STATE (SEQ!NTH S (+ N N1))) generates ...
(IF (IS-GOOD-STATE (SEQ!NTH S (+ N N1)))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1)
   (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
   (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
   (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (HISTORY (SEQ!NTH S (+ 1 N1))))
   (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
   (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
      (SOME (L2$0 T2$0 M2$0 P2$0)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
         (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
        (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
  (SOME (N3)
   (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
    (SOME (L3 T3 M3 P3 P4)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
       (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
      (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
 (IMPLIES
  (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1)
   (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
   (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
   (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (HISTORY (SEQ!NTH S (+ 1 N1))))
   (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
   (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (SOME (N2$1)
     (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
   (NOT
    (SOME (N2$2)
     (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
      (SOME (L2$1 T2$1 M2$1 P2$1)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
         (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
        (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
  (SOME (N3$0)
   (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
    (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
       (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
      (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
      (IN P4$0 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET))))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
HISTORY-IS-SEQUENCE, TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-STATE (SEQ!NTH S (+ N N1)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Invoking (IS-GOOD-STATE (SEQ!NTH S (+ N N1))) gives ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (IN (HISTORY (SEQ!NTH S (+ N N1))) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with SEQ!IN-SEQUENCE-OF
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
FN!FUNCTION-IS-RELATION
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, HISTORY-IS-SEQUENCE,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
SEQ!LENGTH-NON-NEGATIVE, MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ N N1)))) (EVENTS))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Invoking (SUBSET (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ N N1)))) (EVENTS)) gives
...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (ALL (E)
   (IMPLIES (IN E (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ N N1)))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Instantiating (= E (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))) gives ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (IMPLIES
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
    (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ N N1)))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (EVENTS)))
  (ALL (E)
   (IMPLIES (IN E (SEQ!MEMBERS (HISTORY (SEQ!NTH S (+ N N1)))))
    (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with SEQ!IN-MEMBERS
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
FN!FUNCTION-IS-RELATION
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, HISTORY-IS-SEQUENCE,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
SEQ!LENGTH-NON-NEGATIVE, MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1)))))
 (IF
  (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
   (HISTORY (SEQ!NTH S (+ N N1))))
  (IMPLIES
   (AND (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (EVENTS))
    (ALL (E)
     (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ N N1))))
      (IN E (EVENTS))))
    (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
    (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1)
    (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
    (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
    (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
    (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
    (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (HISTORY (SEQ!NTH S (+ 1 N1))))
    (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT
     (SOME (N2)
      (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
    (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (IMPLIES
   (AND
    (ALL (E$0)
     (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY (SEQ!NTH S (+ N N1))))
      (IN E$0 (EVENTS))))
    (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
    (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
    (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1)
    (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
    (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
    (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
    (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
    (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
     (HISTORY (SEQ!NTH S (+ 1 N1))))
    (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
    (NOT
     (SOME (N2$1)
      (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
    (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
    (NOT
     (SOME (N2$2)
      (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
       (SOME (L2$1 T2$1 M2$1 P2$1)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
          (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
         (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))
Starting case 1.2.2.1.2.2.1.2.2 ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
   (HISTORY (SEQ!NTH S (+ N N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (EVENTS))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ N N1)))) (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Invoking (EVENTS) gives ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
   (HISTORY (SEQ!NTH S (+ N N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
   (UNION (SEND-EVENTS)
    (UNION (RECEIVE-EVENTS)
     (UNION (OUT-OF-BAND-EVENTS)
      (UNION (GENERATE-EVENTS)
       (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS)))))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ N N1))))
    (IN E
     (UNION (SEND-EVENTS)
      (UNION (RECEIVE-EVENTS)
       (UNION (OUT-OF-BAND-EVENTS)
        (UNION (GENERATE-EVENTS)
         (UNION (CONSTRUCT-EVENTS) (INTRUDER-EVENTS)))))))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with UNION.DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
FN!FUNCTION-IS-RELATION, TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT,
TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT, TAG-OF-GENERATE-EVENT,
GENERATE-EVENT-IS-EVENT, TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
IN-OUT-OF-BAND-EVENT, TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, IN-SEND-EVENT
 with the assumptions STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, HISTORY-IS-SEQUENCE,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
SEQ!LENGTH-NON-NEGATIVE, MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(TRUE)
Starting case 1.2.2.1.2.2.1.2.1 ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (NOT
   (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
    (HISTORY (SEQ!NTH S (+ N N1)))))
  (ALL (E$0)
   (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY (SEQ!NTH S (+ N N1))))
    (IN E$0 (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$2)
    (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
     (SOME (L2$1 T2$1 M2$1 P2$1)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
        (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
       (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
 (SOME (N3$0)
  (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
   (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
      (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
     (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
     (IN P4$0 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
Invoking (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
          (HISTORY (SEQ!NTH S (+ N N1)))) gives
...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (NOT
   (AND (SEQ!IS-TACK (HISTORY (SEQ!NTH S (+ N N1))))
    (OR
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
      (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
     (SEQ!IS-MEMBER (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1))))
      (SEQ!TAIL (HISTORY (SEQ!NTH S (+ N N1))))))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ N N1)))) (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with IS-TACK-EQUIV-NON-ZERO-LENGTH
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE, SEQ!TACK-HEAD-TAIL,
SEQ!NOT-IS-TACK-FACTS
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, HISTORY-IS-SEQUENCE,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL, SEQ!LENGTH-NON-NEGATIVE,
SEQ!TYPE-OF-IS-TACK, MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL to ...
(IMPLIES
 (AND (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N N1)))) 1))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ N N1)))) (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Splitting on (= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N N1)))) 0) generates ...
(IF (= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N N1)))) 0)
 (IMPLIES
  (AND (IS-STATE (SEQ!NTH S (+ N N1)))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
   (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
   (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N N1)))) 1))
   (ALL (E)
    (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ N N1))))
     (IN E (EVENTS))))
   (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
   (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
   (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
   (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
   (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
   (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (HISTORY (SEQ!NTH S (+ 1 N1))))
   (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
   (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
      (SOME (L2$0 T2$0 M2$0 P2$0)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
         (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
        (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
  (SOME (N3)
   (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
    (SOME (L3 T3 M3 P3 P4)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
       (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
      (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
 (IMPLIES
  (AND (IS-STATE (SEQ!NTH S (+ N N1)))
   (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
   (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
   (NOT (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N N1)))) 1))
   (ALL (E$0)
    (IMPLIES (SEQ!IS-MEMBER E$0 (HISTORY (SEQ!NTH S (+ N N1))))
     (IN E$0 (EVENTS))))
   (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
   (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
   (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
   (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
   (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
   (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
   (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
   (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
    (HISTORY (SEQ!NTH S (+ 1 N1))))
   (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
   (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
   (NOT
    (SOME (N2$1)
     (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
   (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
   (NOT
    (SOME (N2$2)
     (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
      (SOME (L2$1 T2$1 M2$1 P2$1)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
         (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
        (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
  (SOME (N3$0)
   (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
    (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
       (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
      (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
      (IN P4$0 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET))))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, HISTORY-IS-SEQUENCE,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, FN!IS-FUNCTION-BOOL,
MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N N1)))) 0)
  (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ N N1)))) (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND
  (=
   (IF
    (AND (IS-GOOD-EVOLUTION S) (>= (+ N N1) 1) (>= (SEQ!LENGTH S) (+ N N1)))
    (- (SEQ!LENGTH S) (+ N N1)) (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ N N1)))))
   0)
  (IS-STATE (SEQ!NTH S (+ N N1)))
  (SUBSET (SEEN-MESSAGES (SEQ!NTH S (+ N N1))) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY (SEQ!NTH S (+ N N1))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ N N1))))
  (ALL (E)
   (IMPLIES (SEQ!IS-MEMBER E (HISTORY (SEQ!NTH S (+ N N1)))) (IN E (EVENTS))))
  (FN!IS-FUNCTION (STORES (SEQ!NTH S (+ N N1))))
  (= (REL!DOM (STORES (SEQ!NTH S (+ N N1)))) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES (SEQ!NTH S (+ N N1)))) (POWERSET (MS!MESSAGES)))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))) (>= N 1) (>= N1 1) (>= L2 0)
  (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions HISTORY-IS-SEQUENCE, TAG-OF-MAKE-RECEIVE-EVENT,
LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT,
PRINCIPAL1-OF-RECEIVE-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
FN!IS-FUNCTION-BOOL, MS!SET-OF-MESSAGES-NOT-EMPTY, IS-STATE-BOOL,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.2.1.2.2.1.1 ...
(IMPLIES
 (AND (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1)))) (>= N 1) (>= N1 1)
  (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$2)
    (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
     (SOME (L2$1 T2$1 M2$1 P2$1)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
        (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
       (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$2)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
 (SOME (N3$0)
  (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
   (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
      (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
     (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
     (IN P4$0 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S (+ N N1))) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ N N1)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1)))) (>= N 1) (>= N1 1)
  (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using TAG-OF-RECEIVE-EVENT, RECEIVE-EVENT-IS-EVENT,
IN-RECEIVE-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES, MS!ENCRYPT-MESSAGE-IN-MESSAGES,
MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
TAG-OF-MAKE-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT, TIME-OF-RECEIVE-EVENT,
MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (NOT (SEQ!IS-MEMBER (SEQ!NTH S (+ N N1)) S))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1)))) (>= N 1) (>= N1 1)
  (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N (+ N N1)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (+ N N1) 1) (<= (+ N N1) (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ N N1)) S))
  (IS-GOOD-EVOLUTION S) (NOT (SEQ!IS-MEMBER (SEQ!NTH S (+ N N1)) S))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ N N1)))) (>= N 1) (>= N1 1)
  (>= L2 0) (>= T2 0) (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N)
  (= (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))))
  (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1))))
  (SEQ!IS-MEMBER (MAKE-RECEIVE-EVENT L2 T2 M2 P2)
   (HISTORY (SEQ!NTH S (+ 1 N1))))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1)))) (RECEIVE-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.2.1.2.1 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2$3)
    (AND (>= N2$3 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$3)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$3)))))))
  (NOT
   (SOME (N2$4)
    (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
     (SOME (L2$1 T2$1 M2$1 P2$1)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
        (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
       (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$4)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
 (SOME (N3$1)
  (AND (>= N3$1 1) (>= (SEQ!LENGTH S) (+ 1 N3$1))
   (SOME (L3$1 T3$1 M3$1 P3$1 P4$1)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$1)))
      (MAKE-OUT-OF-BAND-EVENT L3$1 T3$1 M3$1 P3$1 P4$1))
     (IN M3$1 (MS!MESSAGES)) (IN P3$1 (MS!PRINCIPALS))
     (IN P4$1 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$1 (SEQ!NTH S (+ 1 N3$1)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$1 (NULLSET)))))))))
Assuming ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND-IMPLICATION-3 with the
instantiations: (= M M) (= K K) (= S (SEQ!NTH S (+ 1 N1))) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1))))
   (SOME (N1$0)
    (AND (>= N1$0 1) (<= N1$0 (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
     (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0)
      (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1$0 1))
        (<= N2 (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
        (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2)
         (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0)))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1))))
   (SOME (N1$0)
    (AND (>= N1$0 1) (<= N1$0 (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
     (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0)
      (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))
     (NOT
      (SOME (N2)
       (AND (>= N2 (+ N1$0 1))
        (<= N2 (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
        (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2)
         (OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT M K))))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD,
OUT-OF-BAND-EVENTS-CONTAINING-ENCRYPT.DEFINITION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
IN-OUT-OF-BAND-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, HISTORY-IS-SEQUENCE,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (SOME (N1$0)
   (AND (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N1$0)
    (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0) (OUT-OF-BAND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0))
       (NULLSET))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1$0))
       (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N2$0)
       (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$0) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$0))
          (NULLSET)))))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N1$0)
  (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0) (OUT-OF-BAND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0))
     (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N2$0)
     (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$0) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD
        (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$0))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Applying NTH-HISTORY-NTH-EVOLUTION gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N1$0)
  (IN
   (IF
    (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) (+ 1 N1)) (>= N1$0 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N1$0))
    (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ 1 N1 N1$0) 1))))
    (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0))
   (OUT-OF-BAND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD
     (MESSAGE-OF-EVENT
      (IF
       (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1)
        (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) (+ 1 N1)) (>= N1$0 1)
        (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N1$0))
       (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ 1 N1 N1$0) 1))))
       (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0)))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0))
     (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N2$0)
     (IN
      (IF
       (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1)
        (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) (+ 1 N1)) (>= N2$0 1)
        (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N2$0))
       (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ 1 N1 N2$0) 1))))
       (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$0))
      (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD
        (MESSAGE-OF-EVENT
         (IF
          (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1)
           (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) (+ 1 N1)) (>= N2$0 1)
           (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N2$0))
          (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ 1 N1 N2$0) 1))))
          (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$0)))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
IN-OUT-OF-BAND-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT, HISTORY-IS-SEQUENCE,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1) (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N1$0))
 (IF (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (IMPLIES
   (AND (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (NULLSET))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1$0))
       (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N2$0)
       (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
          (NULLSET)))))))
    (NOT
     (SOME (N2$1)
      (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
       (SOME (L2 T2 M2 P2)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
          (MAKE-SEND-EVENT L2 T2 M2 P2))
         (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (IMPLIES
   (AND
    (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0) (OUT-OF-BAND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0))
       (NULLSET))))
    (NOT
     (SOME (N2$2)
      (AND (>= N2$2 (+ 1 N1$0))
       (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))) N2$2)
       (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$2) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$2))
          (NULLSET)))))))
    (NOT
     (SOME (N2$3)
      (AND (>= N2$3 1) (>= (SEQ!LENGTH S) (+ 1 N2$3))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$3)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$3)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$3))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1)
  (>=
   (IF
    (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1)))
    (- (SEQ!LENGTH S) (+ 1 N1)) (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
   N1$0))
 (IF (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1))
  (IMPLIES
   (AND (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (NULLSET))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1$0))
       (>=
        (IF
         (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1)
          (>= (SEQ!LENGTH S) (+ 1 N1)))
         (- (SEQ!LENGTH S) (+ 1 N1))
         (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
        N2$0)
       (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
          (NULLSET)))))))
    (NOT
     (SOME (N2$1)
      (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
       (SOME (L2 T2 M2 P2)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
          (MAKE-SEND-EVENT L2 T2 M2 P2))
         (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (IMPLIES
   (AND
    (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0) (OUT-OF-BAND-EVENTS))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N1$0))
       (NULLSET))))
    (NOT
     (SOME (N2$2)
      (AND (>= N2$2 (+ 1 N1$0))
       (>=
        (IF
         (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1) 1)
          (>= (SEQ!LENGTH S) (+ 1 N1)))
         (- (SEQ!LENGTH S) (+ 1 N1))
         (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1)))))
        N2$2)
       (IN (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$2) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1))) N2$2))
          (NULLSET)))))))
    (NOT
     (SOME (N2$3)
      (AND (>= N2$3 1) (>= (SEQ!LENGTH S) (+ 1 N2$3))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$3)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$3)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$3))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))
Which simplifies
 forward chaining using TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT,
IN-OUT-OF-BAND-EVENT, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N1$0)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming OUT-OF-BAND-EVENT-THEOREM with the
instantiations: (= N (+ N1 N1$0)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= (+ N1 N1$0) 1)
    (<= (+ N1 N1$0) (- (SEQ!LENGTH S) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS)))
   (AND
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ N1 N1$0 1)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ N1 N1$0)))))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N1$0)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= (+ N1 N1$0) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Instantiating (= N3 (+ N1 N1$0))
              (= L3
               (LABEL-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
              (= T3
               (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
              (= M3
               (MESSAGE-OF-EVENT
                (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
              (= P3
               (PRINCIPAL1-OF-EVENT
                (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
              (= P4
               (PRINCIPAL2-OF-EVENT
                (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))) gives
...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= (+ N1 N1$0) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (NOT
   (AND (>= (+ N1 N1$0) 1) (>= (SEQ!LENGTH S) (+ 1 N1 N1$0))
    (= (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))
     (MAKE-OUT-OF-BAND-EVENT
      (LABEL-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))))
    (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!MESSAGES))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (IN (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (NULLSET)))))))
 (SOME (N3 L3 T3 M3 P3 P4)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
    (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
   (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Concluding (AND (IS-GOOD-EVOLUTION S) (>= (+ N1 N1$0) 1)
            (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
            (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))
             (OUT-OF-BAND-EVENTS))
            (KNOWN-BY-PRINCIPAL
             (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
             (PRINCIPAL1-OF-EVENT
              (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
             (SEQ!NTH S (+ 1 N1 N1$0)))
            (KNOWN-BY-PRINCIPAL
             (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
             (PRINCIPAL2-OF-EVENT
              (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
             (SEQ!NTH S (+ N1 N1$0)))
            (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1))
            (IS-GENERATED K (SEQ!HEAD S))
            (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
            (NOT
             (KNOWN-BY-PRINCIPAL K
              (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
              (SEQ!NTH S (+ 1 N1))))
            (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
            (KNOWN-BY-PRINCIPAL
             (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
             (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
             (SEQ!NTH S (+ 1 N1)))
            (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
             (SEQ!NTH S N1))
            (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
            (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
            (NOT (FORGEABLE K (SEQ!HEAD S)))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS
              (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
               (NULLSET))))
            (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
            (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
            (IN (MS!ENCRYPT M K)
             (MS!PARTS
              (STORAGE-OF
               (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
               (SEQ!NTH S (+ 1 N1)))))
            (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
            (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
            (NOT
             (SOME (N2)
              (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
               (IN (MS!ENCRYPT M K)
                (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
            (>= N1$0 1)
            (IN (MS!ENCRYPT M K)
             (MS!PARTS
              (SETADD
               (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
               (NULLSET))))
            (NOT
             (SOME (N2$0)
              (AND (>= N2$0 (+ 1 N1$0))
               (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
               (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0))))
                (OUT-OF-BAND-EVENTS))
               (IN (MS!ENCRYPT M K)
                (MS!PARTS
                 (SETADD
                  (MESSAGE-OF-EVENT
                   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
                  (NULLSET)))))))
            (NOT
             (SOME (N2$1)
              (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
               (SOME (L2 T2 M2 P2)
                (AND
                 (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
                  (MAKE-SEND-EVENT L2 T2 M2 P2))
                 (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
                 (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
                 (NOT
                  (IN (MS!ENCRYPT M K)
                   (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
                 (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
            (NOT
             (AND (>= (+ N1 N1$0) 1) (>= (SEQ!LENGTH S) (+ 1 N1 N1$0))
              (= (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))
               (MAKE-OUT-OF-BAND-EVENT
                (LABEL-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
                (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
                (MESSAGE-OF-EVENT
                 (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
                (PRINCIPAL1-OF-EVENT
                 (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
                (PRINCIPAL2-OF-EVENT
                 (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))))
              (IN
               (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
               (MS!MESSAGES))
              (IN
               (PRINCIPAL1-OF-EVENT
                (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
               (MS!PRINCIPALS))
              (IN
               (PRINCIPAL2-OF-EVENT
                (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
               (MS!PRINCIPALS))
              (KNOWN-BY-PRINCIPAL K
               (PRINCIPAL1-OF-EVENT
                (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
               (SEQ!NTH S (+ 1 N1 N1$0)))
              (IN (MS!ENCRYPT M K)
               (MS!PARTS
                (SETADD
                 (MESSAGE-OF-EVENT
                  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
                 (NULLSET))))))) generates
...
(OR
 (NOT
  (AND (IS-GOOD-EVOLUTION S) (>= (+ N1 N1$0) 1)
   (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
   (KNOWN-BY-PRINCIPAL
    (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0)))
   (KNOWN-BY-PRINCIPAL
    (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ N1 N1$0)))
   (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!HEAD S))
   (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
   (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
   (>= N1$0 1)
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (NULLSET))))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD
         (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
         (NULLSET)))))))
   (NOT
    (SOME (N2$1)
     (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
      (SOME (L2 T2 M2 P2)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
         (MAKE-SEND-EVENT L2 T2 M2 P2))
        (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
   (NOT
    (AND (>= (+ N1 N1$0) 1) (>= (SEQ!LENGTH S) (+ 1 N1 N1$0))
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))
      (MAKE-OUT-OF-BAND-EVENT
       (LABEL-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))))
     (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (MS!MESSAGES))
     (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (MS!PRINCIPALS))
     (IN (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0)))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
        (NULLSET))))))))
 (SOME (N3 L3 T3 M3 P3 P4)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
    (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
   (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
   (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))
Starting case 1.2.2.1.2.1.2 ...
(NOT
 (AND (IS-GOOD-EVOLUTION S) (>= (+ N1 N1$0) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (NOT
   (AND (>= (+ N1 N1$0) 1) (>= (SEQ!LENGTH S) (+ 1 N1 N1$0))
    (= (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))
     (MAKE-OUT-OF-BAND-EVENT
      (LABEL-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (TIME-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))))
    (IN (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!MESSAGES))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (IN (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (NULLSET))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= (+ N1 N1$0) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (KNOWN-BY-PRINCIPAL K
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
  (SEQ!NTH S (+ 1 N1 N1$0))))
Assuming KNOWN-BY-PRINCIPAL-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS with the
instantiations: (= M M) (= K K)
                (= P
                 (PRINCIPAL1-OF-EVENT
                  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
                (= M2
                 (MESSAGE-OF-EVENT
                  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
                (= S (SEQ!NTH S (+ 1 N1 N1$0))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (UNIT
       (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))))
  (IS-GOOD-EVOLUTION S) (>= (+ N1 N1$0) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GENERATED K (SEQ!HEAD S))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (>= N1$0 1)
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (KNOWN-BY-PRINCIPAL K
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
  (SEQ!NTH S (+ 1 N1 N1$0))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ N1 N1$0) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0)) (>= (SEQ!LENGTH S) (+ 1 N1))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (UNIT
       (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (KNOWN-BY-PRINCIPAL K
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
  (SEQ!NTH S (+ 1 N1 N1$0))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET)))))
 (IF (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (IMPLIES
   (AND
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF
       (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (SEQ!NTH S (+ 1 N1 N1$0)))))
    (NOT
     (SOME (N2)
      (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
       (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
          (NULLSET))))))))
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (OR
   (SOME (N2$2)
    (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))
   (SOME (N2$3)
    (AND (>= N2$3 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$3)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))))
        (NULLSET))))))
   (SOME (N2$4)
    (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$4)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))))
Starting case 1.2.2.1.2.1.2.2 ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Assuming ENCRYPTED-MESSAGE-THEOREM-2 with the
instantiations: (= M M)
                (= P
                 (PRINCIPAL1-OF-EVENT
                  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
                (= K K) (= S (SEQ!NTH S (+ 1 N1 N1$0))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN M (MS!MESSAGES))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF
       (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (SEQ!NTH S (+ 1 N1 N1$0)))))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0))))
   (OR (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1 N1$0)))))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN M (MS!MESSAGES))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (IN K (MS!KEYS)) (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF
       (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (SEQ!NTH S (+ 1 N1 N1$0)))))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))))
   (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0))))))
 (IF (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0)))
  (OR
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2))))))
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (IF (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
   (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))
    (OR
     (SOME (N2$2)
      (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))
     (SOME (N2$3)
      (AND (>= N2$3 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$3)
       (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))))
          (NULLSET))))))
     (SOME (N2$4)
      (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
       (SOME (L2$0 T2$0 M2$0 P2$0)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
          (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
         (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$4)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))
    (IMPLIES
     (AND
      (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1 N1$0)))
      (NOT
       (SOME (N2$5)
        (AND (>= N2$5 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$5)
         (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$5)))))))
      (NOT
       (SOME (N2$6)
        (AND (>= N2$6 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$6)
         (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$6))))
          (OUT-OF-BAND-EVENTS))
         (IN (MS!ENCRYPT M K)
          (MS!PARTS
           (SETADD
            (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$6)))))
            (NULLSET))))))))
     (SOME (N2$7)
      (AND (>= N2$7 1) (>= (SEQ!LENGTH S) (+ 1 N2$7))
       (SOME (L2$1 T2$1 M2$1 P2$1)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$7)))
          (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
         (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$7)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$7))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
   (OR
    (SOME (N2$8)
     (AND (>= N2$8 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$8)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$8))))))
    (SOME (N2$9)
     (AND (>= N2$9 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$9)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$9)))) (OUT-OF-BAND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD
         (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$9)))))
         (NULLSET))))))
    (SOME (N2$10)
     (AND (>= N2$10 1) (>= (SEQ!LENGTH S) (+ 1 N2$10))
      (SOME (L2$2 T2$2 M2$2 P2$2)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$10)))
         (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2))
        (IN M2$2 (MS!MESSAGES)) (IN P2$2 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$2 (SEQ!NTH S (+ 1 N2$10)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$10))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))))))
Starting case 1.2.2.1.2.1.2.2.2 ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Assuming FORGEABLE-IS-MONOTONIC with the
instantiations: (= SEQUENCE S) (= MESSAGE K) (= N1 (+ 1 N1 N1$0))
                (= N2 1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= 1 1) (>= (+ 1 N1 N1$0) 1)
    (>= (SEQ!LENGTH S) (+ 1 N1 N1$0)) (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
   (FORGEABLE K (SEQ!NTH S 1)))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Invoking (SEQ!NTH S 1) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= 1 1) (>= (+ 1 N1 N1$0) 1)
    (>= (SEQ!LENGTH S) (+ 1 N1 N1$0)) (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
   (FORGEABLE K (IF (>= 1 2) (SEQ!NTH (SEQ!TAIL S) (- 1 1)) (SEQ!HEAD S))))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FORGEABLE-IS-MESSAGE,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.2.1.2.1.2.2.1 ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0)))))
 (IF (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))
   (OR
    (SOME (N2$2)
     (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))
    (SOME (N2$3)
     (AND (>= N2$3 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$3)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))) (OUT-OF-BAND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD
         (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))))
         (NULLSET))))))
    (SOME (N2$4)
     (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
      (SOME (L2$0 T2$0 M2$0 P2$0)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
         (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
        (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$4)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))
   (IMPLIES
    (AND
     (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1 N1$0)))
     (NOT
      (SOME (N2$5)
       (AND (>= N2$5 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$5)
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$5)))))))
     (NOT
      (SOME (N2$6)
       (AND (>= N2$6 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$6)
        (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$6)))) (OUT-OF-BAND-EVENTS))
        (IN (MS!ENCRYPT M K)
         (MS!PARTS
          (SETADD
           (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$6)))))
           (NULLSET))))))))
    (SOME (N2$7)
     (AND (>= N2$7 1) (>= (SEQ!LENGTH S) (+ 1 N2$7))
      (SOME (L2$1 T2$1 M2$1 P2$1)
       (AND
        (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$7)))
         (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
        (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$7)))
        (NOT
         (IN (MS!ENCRYPT M K)
          (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$7))))))
        (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET))))))))))
  (OR
   (SOME (N2$8)
    (AND (>= N2$8 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$8)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$8))))))
   (SOME (N2$9)
    (AND (>= N2$9 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$9)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$9)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$9)))))
        (NULLSET))))))
   (SOME (N2$10)
    (AND (>= N2$10 1) (>= (SEQ!LENGTH S) (+ 1 N2$10))
     (SOME (L2$2 T2$2 M2$2 P2$2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$10)))
        (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2))
       (IN M2$2 (MS!MESSAGES)) (IN P2$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$2 (SEQ!NTH S (+ 1 N2$10)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$10))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))))
Starting case 1.2.2.1.2.1.2.2.1.2 ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0))))
 (IF (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))
  (OR
   (SOME (N2$2)
    (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))
   (SOME (N2$3)
    (AND (>= N2$3 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$3)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))))
        (NULLSET))))))
   (SOME (N2$4)
    (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$4)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))
  (IMPLIES
   (AND (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT
     (SOME (N2$5)
      (AND (>= N2$5 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$5)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$5)))))))
    (NOT
     (SOME (N2$6)
      (AND (>= N2$6 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$6)
       (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$6)))) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$6)))))
          (NULLSET))))))))
   (SOME (N2$7)
    (AND (>= N2$7 1) (>= (SEQ!LENGTH S) (+ 1 N2$7))
     (SOME (L2$1 T2$1 M2$1 P2$1)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$7)))
        (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
       (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$7)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$7))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))))
Starting case 1.2.2.1.2.1.2.2.1.2.2 ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (SOME (N2$2)
    (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2)))))))
  (NOT
   (SOME (N2$3)
    (AND (>= N2$3 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$3)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))))
        (NULLSET))))))))
 (SOME (N2$4)
  (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
   (SOME (L2$0 T2$0 M2$0 P2$0)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
      (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
     (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$4)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))
Assuming ENCRYPTED-PART-OF-RECEIVED-MONOTONIC with the
instantiations: (= M M) (= K K) (= S S) (= N1 (+ 1 N1))
                (= N2 (+ 1 N1 N1$0)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (<= 1 (+ 1 N1)) (<= (+ 1 N1) (+ 1 N1 N1$0))
    (<= (+ 1 N1 N1$0) (SEQ!LENGTH S))
    (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0))))
   (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.2.1.2.1.2.2.1.2.1 ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (SOME (N2$5)
    (AND (>= N2$5 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$5)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$5)))))))
  (NOT
   (SOME (N2$6)
    (AND (>= N2$6 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$6)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$6)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$6)))))
        (NULLSET))))))))
 (SOME (N2$7)
  (AND (>= N2$7 1) (>= (SEQ!LENGTH S) (+ 1 N2$7))
   (SOME (L2$1 T2$1 M2$1 P2$1)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$7)))
      (MAKE-SEND-EVENT L2$1 T2$1 M2$1 P2$1))
     (IN M2$1 (MS!MESSAGES)) (IN P2$1 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2$1 (SEQ!NTH S (+ 1 N2$7)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$7))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$1 (NULLSET)))))))))
Invoking (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K
          (SEQ!NTH S (+ 1 N1 N1$0))) gives
...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0))))
  (SOME (L3 T3 M3 P3 P4)
   (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Prenexing produces ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
  (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Assuming SEQUENCE-MEMBER-CAN-BE-ACCESSED-USING-NTH with the
instantiations: (= M (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
                (= S (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
    (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))))
   (SOME (N)
    (AND (>= N 1)
     (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
      (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))) N))
     (<= N (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))))))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
  (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS)) (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
HISTORY-IS-SEQUENCE, MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (SOME (N)
   (AND (>= N 1)
    (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))) N))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))) N)))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
  (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Prenexing produces ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (>= N 1)
  (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))) N))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))) N) (>= N1 1)
  (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0)) (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
  (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Applying NTH-HISTORY-NTH-EVOLUTION gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (>= N 1)
  (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (IF
    (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!HEAD S))) (+ 1 N1 N1$0)) (>= N 1)
     (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))) N))
    (SEQ!HEAD (HISTORY (SEQ!NTH S (- (+ 1 N1 N1$0 N) 1))))
    (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))) N)))
  (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))) N) (>= N1 1)
  (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0)) (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
  (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 when rewriting with LENGTH-OF-HISTORY-OF-GOOD-EVOLUTION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, SEQ!LENGTH-NON-NEGATIVE, HISTORY-IS-SEQUENCE,
HEAD-OF-EVOLUTION-IN-EVOLUTION, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1))
 (IF (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1 N1$0))
  (IMPLIES
   (AND (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))) N)
    (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))))
    (>= N1 1) (>= N1$0 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ N1 N1$0)))
    (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF
       (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (SEQ!NTH S (+ 1 N1 N1$0)))))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
    (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
    (NOT
     (SOME (N2)
      (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
       (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
          (NULLSET))))))))
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (IMPLIES
   (AND
    (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))) N))
    (>= (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))) N) (>= N1 1)
    (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ N1 N1$0)))
    (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF
       (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (SEQ!NTH S (+ 1 N1 N1$0)))))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
    (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
    (NOT
     (SOME (N2$2)
      (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))))
   (SOME (N2$3)
    (AND (>= N2$3 1) (>= (SEQ!LENGTH S) (+ 1 N2$3))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$3)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$3)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$3))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))
Applying LENGTH-HISTORY-NTH gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1))
 (IF (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1 N1$0))
  (IMPLIES
   (AND
    (>=
     (IF
      (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1)
       (>= (SEQ!LENGTH S) (+ 1 N1 N1$0)))
      (- (SEQ!LENGTH S) (+ 1 N1 N1$0))
      (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))))
     N)
    (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))))
    (>= N1 1) (>= N1$0 1)
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ N1 N1$0)))
    (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF
       (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (SEQ!NTH S (+ 1 N1 N1$0)))))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
    (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
    (NOT
     (SOME (N2)
      (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
       (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
       (IN (MS!ENCRYPT M K)
        (MS!PARTS
         (SETADD
          (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
          (NULLSET))))))))
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (IMPLIES
   (AND
    (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
     (SEQ!NTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))) N))
    (>=
     (IF
      (AND (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1)
       (>= (SEQ!LENGTH S) (+ 1 N1 N1$0)))
      (- (SEQ!LENGTH S) (+ 1 N1 N1$0))
      (SEQ!LENGTH (HISTORY (SEQ!NTH S (+ 1 N1 N1$0)))))
     N)
    (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))
    (KNOWN-BY-PRINCIPAL
     (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ N1 N1$0)))
    (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))
    (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
    (NOT (FORGEABLE K (SEQ!HEAD S)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
    (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (NULLSET))))
    (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0))))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF
       (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
       (SEQ!NTH S (+ 1 N1 N1$0)))))
    (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
    (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
    (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
    (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
    (IN P4 (MS!PRINCIPALS))
    (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
    (NOT
     (SOME (N2$2)
      (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))))
   (SOME (N2$3)
    (AND (>= N2$3 1) (>= (SEQ!LENGTH S) (+ 1 N2$3))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$3)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$3)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$3))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1 N1$0))
  (>= (+ -1 (* -1 N1) (* -1 N1$0) (SEQ!LENGTH S)) N)
  (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))))
  (>= N1 1) (>= N1$0 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
  (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Instantiating (= N2$0 (+ N N1$0)) gives ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1 N1$0))
  (>= (+ -1 (* -1 N1) (* -1 N1$0) (SEQ!LENGTH S)) N)
  (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))))
  (>= N1 1) (>= N1$0 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
  (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (OR
    (AND (>= (+ N N1$0) (+ 1 N1$0))
     (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) (+ N N1$0))
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N N1$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD
        (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N N1$0)))))
        (NULLSET)))))
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD
         (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
         (NULLSET)))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT to ...
(IMPLIES
 (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
  (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1)
  (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1 N1$0))
  (>= (+ -1 (* -1 N1) (* -1 N1$0) (SEQ!LENGTH S)) N)
  (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
   (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))))
  (>= N1 1) (>= N1$0 1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
  (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))) (OUT-OF-BAND-EVENTS)))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Splitting
on (AND (>= L3 0)
    (AND (>= T3 0)
     (AND (IN M3 (MS!MESSAGES))
      (AND (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS)))))) generates
...
(IF
 (AND (>= L3 0) (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
  (IN P4 (MS!PRINCIPALS)))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
   (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1)
   (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1 N1$0))
   (>= (+ -1 (* -1 N1) (* -1 N1$0) (SEQ!LENGTH S)) N)
   (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))))
   (>= N1 1) (>= N1$0 1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
   (KNOWN-BY-PRINCIPAL
    (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0)))
   (KNOWN-BY-PRINCIPAL
    (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ N1 N1$0)))
   (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
   (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0)))))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
   (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
   (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
   (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
   (NOT
    (SOME (N2)
     (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
   (NOT
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))) (OUT-OF-BAND-EVENTS)))
   (NOT
    (SOME (N2$0)
     (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD
         (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
         (NULLSET))))))))
  (SOME (N2$1)
   (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
    (SOME (L2 T2 M2 P2)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
      (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
      (NOT
       (IN (MS!ENCRYPT M K)
        (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
 (IMPLIES
  (AND (SEQ!IS-SEQUENCE (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
   (SEQ!IS-MEMBER (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (HISTORY (SEQ!NTH S (+ 1 N1 N1$0))))
   (>= N 1) (IS-GOOD-EVOLUTION S) (>= (+ 1 N1 N1$0) 1)
   (>= (+ -1 (SEQ!LENGTH S)) (+ 1 N1 N1$0))
   (>= (+ -1 (* -1 N1) (* -1 N1$0) (SEQ!LENGTH S)) N)
   (= (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4)
    (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))))
   (>= N1 1) (>= N1$0 1)
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
   (KNOWN-BY-PRINCIPAL
    (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0)))
   (KNOWN-BY-PRINCIPAL
    (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ N1 N1$0)))
   (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1))))
   (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
   (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1)))
   (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S N1))
   (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
   (NOT (FORGEABLE K (SEQ!HEAD S)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1)))))
   (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
   (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (NULLSET))))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
   (NOT
    (KNOWN-BY-PRINCIPAL K
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
      (SEQ!NTH S (+ 1 N1 N1$0)))))
   (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
   (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
   (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1 N1$0)))) (>= L3 0)
   (>= T3 0) (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS))
   (IN P4 (MS!PRINCIPALS))
   (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET))))
   (NOT
    (SOME (N2$2)
     (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2)))))))
   (NOT
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N N1 N1$0)))) (OUT-OF-BAND-EVENTS)))
   (NOT
    (SOME (N2$3)
     (AND (>= N2$3 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$3)
      (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))) (OUT-OF-BAND-EVENTS))
      (IN (MS!ENCRYPT M K)
       (MS!PARTS
        (SETADD
         (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))))
         (NULLSET))))))))
  (SOME (N2$4)
   (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
    (SOME (L2$0 T2$0 M2$0 P2$0)
     (AND
      (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
       (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
      (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$4)))
      (NOT
       (IN (MS!ENCRYPT M K)
        (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
      (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE,
TAG-OF-OUT-OF-BAND-EVENT, OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE
 with the assumptions STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY to ...
(TRUE)
Starting case 1.2.2.1.2.1.2.2.1.1 ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT
   (SOME (N2$8)
    (AND (>= N2$8 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$8)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$8)))))))
  (NOT
   (SOME (N2$9)
    (AND (>= N2$9 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$9)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$9)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$9)))))
        (NULLSET))))))))
 (SOME (N2$10)
  (AND (>= N2$10 1) (>= (SEQ!LENGTH S) (+ 1 N2$10))
   (SOME (L2$2 T2$2 M2$2 P2$2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$10)))
      (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2))
     (IN M2$2 (MS!MESSAGES)) (IN P2$2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2$2 (SEQ!NTH S (+ 1 N2$10)))
     (NOT
      (IN (MS!ENCRYPT M K)
       (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$10))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET)))))))))
Assuming IS-GENERATED-CONSEQUENCE with the
instantiations: (= S S) (= K K) (= N (+ 1 N1 N1$0)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
    (<= 1 (+ 1 N1 N1$0)) (<= (+ 1 N1 N1$0) (SEQ!LENGTH S)))
   (OR (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ 1 N1 N1$0))))))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
    (<= 1 (+ 1 N1 N1$0)) (<= (+ 1 N1 N1$0) (SEQ!LENGTH S))
    (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0)))))
   (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS,
MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT,
MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1 N1$0))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Assuming FRESH-IN-ALL-MESSAGES-IMPLIES-FRESH-IN-STORAGE-OF-PRINCIPAL with the
instantiations: (= MESSAGE K)
                (= PRINCIPAL
                 (PRINCIPAL1-OF-EVENT
                  (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0))))))
                (= STATE (SEQ!NTH S (+ 1 N1 N1$0))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (IN K (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ 1 N1 N1$0)))))
   (MS!IS-FRESH K
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1 N1$0))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1 N1$0))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1 N1$0)))))
  (IMPLIES
   (AND (IS-GOOD-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (IN K (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ 1 N1 N1$0)))))
   (MS!IS-FRESH K
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Invoking (MS!IS-FRESH K
          (STORAGE-OF
           (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
           (SEQ!NTH S (+ 1 N1 N1$0)))) gives
...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
    (SEQ!NTH S (+ 1 N1 N1$0))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (SEQ!NTH S (+ 1 N1 N1$0)))))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1 N1$0))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1 N1$0)))))
  (IMPLIES
   (AND (IS-GOOD-STATE (SEQ!NTH S (+ 1 N1 N1$0)))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (MS!PRINCIPALS))
    (IN K (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ 1 N1 N1$0)))))
   (AND
    (NOT
     (IN K
      (MS!PARTS
       (STORAGE-OF
        (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
        (SEQ!NTH S (+ 1 N1 N1$0))))))
    (NOT
     (SOME (M$0)
      (IN (MS!ENCRYPT M$0 K)
       (MS!PARTS
        (STORAGE-OF
         (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
         (SEQ!NTH S (+ 1 N1 N1$0)))))))
    (NOT
     (SOME (M$1)
      (IN (MS!ENCRYPT M$1 (MS!INVERSE K))
       (MS!PARTS
        (STORAGE-OF
         (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
         (SEQ!NTH S (+ 1 N1 N1$0)))))))
    (ALL (M$2 K2)
     (AND
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K K2)
        (MS!PARTS
         (STORAGE-OF
          (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
          (SEQ!NTH S (+ 1 N1 N1$0))))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE K) K2)
        (MS!PARTS
         (STORAGE-OF
          (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
          (SEQ!NTH S (+ 1 N1 N1$0))))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K2 K)
        (MS!PARTS
         (STORAGE-OF
          (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
          (SEQ!NTH S (+ 1 N1 N1$0))))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K2 (MS!INVERSE K))
        (MS!PARTS
         (STORAGE-OF
          (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
          (SEQ!NTH S (+ 1 N1 N1$0))))))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET))))))))
 (SOME (N2$1)
  (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
   (SOME (L2 T2 M2 P2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
     (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
     (NOT
      (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE
 with the instantiation (= M$0 M) to ...
(TRUE)
Starting case 1.2.2.1.2.1.2.1 ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT
   (SOME (N2$2)
    (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2)))))))
  (NOT
   (SOME (N2$3)
    (AND (>= N2$3 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$3)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$3)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$4)
    (AND (>= N2$4 1) (>= (SEQ!LENGTH S) (+ 1 N2$4))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$4)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$4)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$4))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (KNOWN-BY-PRINCIPAL K
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
  (SEQ!NTH S (+ 1 N1 N1$0))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N (+ 1 N1 N1$0)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (+ 1 N1 N1$0) 1)
    (<= (+ 1 N1 N1$0) (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1 N1$0)) S))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (KNOWN-BY-PRINCIPAL K
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
  (SEQ!NTH S (+ 1 N1 N1$0))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S (+ 1 N1 N1$0))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1 N1$0)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (+ 1 N1 N1$0) 1)
    (>= (SEQ!LENGTH S) (+ 1 N1 N1$0)))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1 N1$0)) S))
  (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (KNOWN-BY-PRINCIPAL K
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
  (SEQ!NTH S (+ 1 N1 N1$0))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= N1$0 1) (>= (+ -1 (SEQ!LENGTH S)) (+ N1 N1$0))
  (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))) (OUT-OF-BAND-EVENTS))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ 1 N1 N1$0)))
  (KNOWN-BY-PRINCIPAL
   (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (PRINCIPAL2-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
   (SEQ!NTH S (+ N1 N1$0)))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT (ENCRYPTED-PART-OF-RECEIVED M K (SEQ!NTH S (+ 1 N1))))
  (ENCRYPTED-PART-OF-RECEIVED-OUT-OF-BAND M K (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1 N1$0)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1 N1$0))))
  (IMPLIES
   (AND (>= (+ 1 N1 N1$0) 1) (>= (SEQ!LENGTH S) (+ 1 N1 N1$0))
    (SEQ!IS-SEQUENCE S))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1 N1$0)) S))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1$0)) (>= (+ -1 (* -1 N1) (SEQ!LENGTH S)) N2$0)
     (IN (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))) (OUT-OF-BAND-EVENTS))
     (IN (MS!ENCRYPT M K)
      (MS!PARTS
       (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N2$0)))))
        (NULLSET)))))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (KNOWN-BY-PRINCIPAL K
  (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S (+ N1 N1$0)))))
  (SEQ!NTH S (+ 1 N1 N1$0))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT,
SEND-EVENT-IS-EVENT, IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT,
MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES,
MS!SET-OF-KEYS-NOT-EMPTY, MS!SET-OF-MESSAGES-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.2.1.1 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (NOT
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))))
  (NOT
   (SOME (N2$5)
    (AND (>= N2$5 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$5)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$5)))))))
  (NOT
   (SOME (N2$6)
    (AND (>= N2$6 1) (>= (SEQ!LENGTH S) (+ 1 N2$6))
     (SOME (L2$2 T2$2 M2$2 P2$2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$6)))
        (MAKE-SEND-EVENT L2$2 T2$2 M2$2 P2$2))
       (IN M2$2 (MS!MESSAGES)) (IN P2$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$2 (SEQ!NTH S (+ 1 N2$6)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$6))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$2 (NULLSET))))))))))
 (SOME (N3$2)
  (AND (>= N3$2 1) (>= (SEQ!LENGTH S) (+ 1 N3$2))
   (SOME (L3$2 T3$2 M3$2 P3$2 P4$2)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$2)))
      (MAKE-OUT-OF-BAND-EVENT L3$2 T3$2 M3$2 P3$2 P4$2))
     (IN M3$2 (MS!MESSAGES)) (IN P3$2 (MS!PRINCIPALS))
     (IN P4$2 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$2 (SEQ!NTH S (+ 1 N3$2)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$2 (NULLSET)))))))))
Assuming SEND-EVENT-THEOREM with the
instantiations: (= N N1) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (<= N1 (- (SEQ!LENGTH S) 1))
    (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS)))
   (AND
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ N1 1)))
    (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S N1))))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (NOT
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (NOT
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming KNOWN-BY-PRINCIPAL-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS with the
instantiations: (= M M) (= K K)
                (= P
                 (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
                (= M2 (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
                (= S (SEQ!NTH S (+ 1 N1))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (MS!PRINCIPALS))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (UNIT (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))))
  (IS-GOOD-EVOLUTION S) (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (NOT
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= (+ -1 (SEQ!LENGTH S)) N1) (IS-GOOD-EVOLUTION S)
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (NOT (FORGEABLE K (SEQ!NTH S (+ 1 N1))))
  (NOT
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (MS!PRINCIPALS))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (UNIT (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION,
IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE, HEAD-OF-GOOD-EVOLUTION,
GOOD-EVOLUTION-IS-SEQUENCE, HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions MS!SET-OF-PRINCIPALS-NOT-EMPTY,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.2.1 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (NOT
   (SOME (N2$7)
    (AND (>= N2$7 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$7)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$7)))))))
  (NOT
   (SOME (N2$8)
    (AND (>= N2$8 1) (>= (SEQ!LENGTH S) (+ 1 N2$8))
     (SOME (L2$3 T2$3 M2$3 P2$3)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$8)))
        (MAKE-SEND-EVENT L2$3 T2$3 M2$3 P2$3))
       (IN M2$3 (MS!MESSAGES)) (IN P2$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$3 (SEQ!NTH S (+ 1 N2$8)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$8))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$3 (NULLSET))))))))))
 (SOME (N3$3)
  (AND (>= N3$3 1) (>= (SEQ!LENGTH S) (+ 1 N3$3))
   (SOME (L3$3 T3$3 M3$3 P3$3 P4$3)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$3)))
      (MAKE-OUT-OF-BAND-EVENT L3$3 T3$3 M3$3 P3$3 P4$3))
     (IN M3$3 (MS!MESSAGES)) (IN P3$3 (MS!PRINCIPALS))
     (IN P4$3 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$3 (SEQ!NTH S (+ 1 N3$3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$3 (NULLSET)))))))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N (+ 1 N1)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (+ 1 N1) 1) (<= (+ 1 N1) (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S (+ 1 N1))) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1)))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (IMPLIES
   (AND (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-SEQUENCE S))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, FORGEABLE-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT,
IN-SEND-EVENT, KNOWN-BY-PRINCIPAL-IS-MESSAGE, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, HEAD-OF-EVOLUTION-IN-EVOLUTION,
SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (>= (+ 1 N1) 1)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (>= N1 1) (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 1) (>= (SEQ!LENGTH S) (+ 1 N2$1))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$1)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$1)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$1))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET)))))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$2)
    (AND (>= N2$2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$2))))))))
 (SOME (N3$0)
  (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
   (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
      (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
     (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
     (IN P4$0 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
Assuming KNOWN-BY-PRINCIPAL-CONTAINING-ENCRYPTED-IMPLIES-IN-PARTS with the
instantiations: (= M M) (= K K)
                (= P
                 (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
                (= M2 (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
                (= S (SEQ!NTH S (+ 1 N1))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (MS!PRINCIPALS))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (UNIT (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S)) (>= (+ 1 N1) 1)
  (>= (SEQ!LENGTH S) (+ 1 N1)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (>= N1 1) (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET)))))))))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1))
  (IS-GOOD-EVOLUTION S) (IS-GENERATED K (SEQ!HEAD S))
  (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1)))) (NOT (IN K (MS!PRINCIPALS)))
  (NOT (IN K (MS!TEXT-MESSAGES))) (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IMPLIES
   (AND (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))) (IN M (MS!MESSAGES))
    (IN K (MS!KEYS))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (MS!PRINCIPALS))
    (NOT
     (KNOWN-BY-PRINCIPAL K
      (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))
    (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (UNIT (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))))))
   (IN (MS!ENCRYPT M K)
    (MS!PARTS
     (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
      (SEQ!NTH S (+ 1 N1))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$0)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$0)))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 1) (>= (SEQ!LENGTH S) (+ 1 N2))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2)))
       (NOT
        (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, IN-SEND-EVENT,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions TAG-OF-MAKE-OUT-OF-BAND-EVENT,
LABEL-OF-OUT-OF-BAND-EVENT, TIME-OF-OUT-OF-BAND-EVENT,
MESSAGE-OF-OUT-OF-BAND-EVENT, PRINCIPAL1-OF-OUT-OF-BAND-EVENT,
PRINCIPAL2-OF-OUT-OF-BAND-EVENT, TAG-OF-MAKE-SEND-EVENT, LABEL-OF-SEND-EVENT,
TIME-OF-SEND-EVENT, MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
STORAGE-OF-IS-SUBSET-MESSAGES, MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT,
MS!ENKY-ENCRYPT, MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET)))))
 (IF (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (IMPLIES
   (AND
    (IN (MS!ENCRYPT M K)
     (MS!PARTS
      (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
       (SEQ!NTH S (+ 1 N1)))))
    (NOT
     (SOME (N2)
      (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
       (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
    (NOT
     (SOME (N2$0)
      (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
       (SOME (L2 T2 M2 P2)
        (AND
         (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0)))
          (MAKE-SEND-EVENT L2 T2 M2 P2))
         (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
         (NOT
          (IN (MS!ENCRYPT M K)
           (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
         (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
   (SOME (N3)
    (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
     (SOME (L3 T3 M3 P3 P4)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
        (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
       (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
  (OR
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1))))))
   (SOME (N2$2)
    (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$2)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))
   (SOME (N3$0)
    (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
     (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
        (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
       (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
       (IN P4$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))))
Starting case 1.1.2 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming FRESH-IN-ALL-MESSAGES-IMPLIES-FRESH-IN-STORAGE-OF-PRINCIPAL with the
instantiations: (= MESSAGE K)
                (= PRINCIPAL
                 (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1)))))
                (= STATE (SEQ!NTH S (+ 1 N1))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-GOOD-STATE (SEQ!NTH S (+ 1 N1)))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (MS!PRINCIPALS))
    (IN K (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ 1 N1)))))
   (MS!IS-FRESH K
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IMPLIES
   (AND (IS-GOOD-STATE (SEQ!NTH S (+ 1 N1)))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (MS!PRINCIPALS))
    (IN K (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ 1 N1)))))
   (MS!IS-FRESH K
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Invoking (MS!IS-FRESH K
          (STORAGE-OF
           (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
           (SEQ!NTH S (+ 1 N1)))) gives
...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (SEQ!NTH S (+ 1 N1)))))
  (IMPLIES
   (AND (IS-GOOD-STATE (SEQ!NTH S (+ 1 N1)))
    (IN (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (MS!PRINCIPALS))
    (IN K (MS!ATOMIC-MESSAGES))
    (MS!IS-FRESH K (ALL-MESSAGES-IN-STATE (SEQ!NTH S (+ 1 N1)))))
   (AND
    (NOT
     (IN K
      (MS!PARTS
       (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
        (SEQ!NTH S (+ 1 N1))))))
    (NOT
     (SOME (M$0)
      (IN (MS!ENCRYPT M$0 K)
       (MS!PARTS
        (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
         (SEQ!NTH S (+ 1 N1)))))))
    (NOT
     (SOME (M$1)
      (IN (MS!ENCRYPT M$1 (MS!INVERSE K))
       (MS!PARTS
        (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
         (SEQ!NTH S (+ 1 N1)))))))
    (ALL (M$2 K2)
     (AND
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K K2)
        (MS!PARTS
         (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
          (SEQ!NTH S (+ 1 N1))))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 (MS!INVERSE K) K2)
        (MS!PARTS
         (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
          (SEQ!NTH S (+ 1 N1))))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K2 K)
        (MS!PARTS
         (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
          (SEQ!NTH S (+ 1 N1))))))
      (NOT
       (IN (MS!SHARE-ENCRYPT M$2 K2 (MS!INVERSE K))
        (MS!PARTS
         (STORAGE-OF (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
          (SEQ!NTH S (+ 1 N1))))))))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, IN-SEND-EVENT,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE
 with the instantiation (= M$0 M) to ...
(TRUE)
Starting case 1.1.1 ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (NOT
   (SOME (N2$1)
    (AND (>= N2$1 (+ 1 N1)) (>= (SEQ!LENGTH S) N2$1)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2$1)))))))
  (NOT
   (SOME (N2$2)
    (AND (>= N2$2 1) (>= (SEQ!LENGTH S) (+ 1 N2$2))
     (SOME (L2$0 T2$0 M2$0 P2$0)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$2)))
        (MAKE-SEND-EVENT L2$0 T2$0 M2$0 P2$0))
       (IN M2$0 (MS!MESSAGES)) (IN P2$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2$0 (SEQ!NTH S (+ 1 N2$2)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$2))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2$0 (NULLSET))))))))))
 (SOME (N3$0)
  (AND (>= N3$0 1) (>= (SEQ!LENGTH S) (+ 1 N3$0))
   (SOME (L3$0 T3$0 M3$0 P3$0 P4$0)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3$0)))
      (MAKE-OUT-OF-BAND-EVENT L3$0 T3$0 M3$0 P3$0 P4$0))
     (IN M3$0 (MS!MESSAGES)) (IN P3$0 (MS!PRINCIPALS))
     (IN P4$0 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3$0 (SEQ!NTH S (+ 1 N3$0)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3$0 (NULLSET)))))))))
Assuming NTH-IS-MEMBER with the
instantiations: (= N (+ 1 N1)) (= SEQUENCE S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (+ 1 N1) 1) (<= (+ 1 N1) (SEQ!LENGTH S)))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Assuming MEMBER-IS-GOOD-EVOLUTION-STATE with the
instantiations: (= SEQUENCE S) (= STATE (SEQ!NTH S (+ 1 N1))) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (IMPLIES
   (AND (SEQ!IS-SEQUENCE S) (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1)))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
  (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Rearranging gives ...
(IMPLIES
 (AND (>= N1 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (IS-GOOD-EVOLUTION S)
  (IS-GENERATED K (SEQ!HEAD S)) (NOT (IS-GENERATED K (SEQ!NTH S (+ 1 N1))))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS)))
  (MS!IS-FRESH K (SEEN-MESSAGES (SEQ!NTH S (+ 1 N1))))
  (MS!IS-FRESH K (ALL-STORAGE (STORES (SEQ!NTH S (+ 1 N1)))))
  (NOT
   (KNOWN-BY-PRINCIPAL K
    (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
    (SEQ!NTH S (+ 1 N1))))
  (IN (SEQ!HEAD (HISTORY (SEQ!NTH S N1))) (SEND-EVENTS))
  (KNOWN-BY-PRINCIPAL (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (PRINCIPAL1-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S (+ 1 N1)))
  (FORGEABLE (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
   (SEQ!NTH S N1))
  (IN M (MS!MESSAGES)) (IN K (MS!KEYS))
  (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!HEAD S))))
  (NOT (FORGEABLE K (SEQ!HEAD S)))
  (IN (MS!ENCRYPT M K)
   (MS!PARTS
    (SETADD (MESSAGE-OF-EVENT (SEQ!HEAD (HISTORY (SEQ!NTH S N1))))
     (NULLSET))))
  (NOT (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (IMPLIES (AND (IS-GOOD-EVOLUTION S) (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
   (IS-GOOD-EVOLUTION-STATE (SEQ!NTH S (+ 1 N1))))
  (IMPLIES
   (AND (>= (+ 1 N1) 1) (>= (SEQ!LENGTH S) (+ 1 N1)) (SEQ!IS-SEQUENCE S))
   (SEQ!IS-MEMBER (SEQ!NTH S (+ 1 N1)) S))
  (NOT
   (SOME (N2)
    (AND (>= N2 (+ 1 N1)) (>= (SEQ!LENGTH S) N2)
     (IN (MS!ENCRYPT M K) (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S N2)))))))
  (NOT
   (SOME (N2$0)
    (AND (>= N2$0 1) (>= (SEQ!LENGTH S) (+ 1 N2$0))
     (SOME (L2 T2 M2 P2)
      (AND
       (= (SEQ!HEAD (HISTORY (SEQ!NTH S N2$0))) (MAKE-SEND-EVENT L2 T2 M2 P2))
       (IN M2 (MS!MESSAGES)) (IN P2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL K P2 (SEQ!NTH S (+ 1 N2$0)))
       (NOT
        (IN (MS!ENCRYPT M K)
         (MS!PARTS (SEEN-MESSAGES (SEQ!NTH S (+ 1 N2$0))))))
       (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M2 (NULLSET))))))))))
 (SOME (N3)
  (AND (>= N3 1) (>= (SEQ!LENGTH S) (+ 1 N3))
   (SOME (L3 T3 M3 P3 P4)
    (AND
     (= (SEQ!HEAD (HISTORY (SEQ!NTH S N3)))
      (MAKE-OUT-OF-BAND-EVENT L3 T3 M3 P3 P4))
     (IN M3 (MS!MESSAGES)) (IN P3 (MS!PRINCIPALS)) (IN P4 (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL K P3 (SEQ!NTH S (+ 1 N3)))
     (IN (MS!ENCRYPT M K) (MS!PARTS (SETADD M3 (NULLSET)))))))))
Which simplifies
 forward chaining using MS!TAG-OF-ENCRYPT-MESSAGES,
MS!ENCRYPT-MESSAGE-IN-MESSAGES, MS!SIZE-ENDT, MS!SIZE-ENKY,
FORGEABLE-IS-MESSAGE, TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, IN-SEND-EVENT,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE,
HEAD-OF-GOOD-EVOLUTION, GOOD-EVOLUTION-IS-SEQUENCE,
HEAD-IS-GOOD-EVOLUTION-STATE, >=.SAME.TYPE
 with the assumptions MS!TAG-OF-ENCRYPT, MS!ENDT-ENCRYPT, MS!ENKY-ENCRYPT,
MS!ENCRYPT-IN-ENCRYPT-MESSAGES, MS!SET-OF-KEYS-NOT-EMPTY,
MS!SET-OF-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
HEAD-OF-EVOLUTION-IN-EVOLUTION, SEQ!LENGTH-NON-NEGATIVE to ...
(TRUE)
Completing all cases produces ...
(TRUE)
IN-PARTS-ADD-KNOWN-BY-PRINCIPAL
Beginning proof of IN-PARTS-ADD-KNOWN-BY-PRINCIPAL ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN P (MS!PRINCIPALS))
  (KNOWN-BY-PRINCIPAL M P S) (IN K (MS!ATOMIC-MESSAGES))
  (NOT (IN K (MS!PRINCIPALS))) (NOT (IN K (MS!TEXT-MESSAGES)))
  (NOT (IN K (MS!PUBLIC-KEYS))))
 (=
  (IN K
   (MS!PARTS
    (SETADD M
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (IN K (MS!PARTS (STORAGE-OF P S)))))
Invoking (KNOWN-BY-PRINCIPAL M P S) gives ...
(IMPLIES
 (AND (IS-GOOD-EVOLUTION-STATE S) (IN P (MS!PRINCIPALS))
  (MS!KNOWN-IN M
   (UNION (STORAGE-OF P S)
    (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
  (IN K (MS!ATOMIC-MESSAGES)) (NOT (IN K (MS!PRINCIPALS)))
  (NOT (IN K (MS!TEXT-MESSAGES))) (NOT (IN K (MS!PUBLIC-KEYS))))
 (=
  (IN K
   (MS!PARTS
    (SETADD M
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES) (UNION (MS!PUBLIC-KEYS) (STORAGE-OF P S)))))))
  (IN K (MS!PARTS (STORAGE-OF P S)))))
Which simplifies
 when rewriting with UNION.DEFINITION, MS!PUBLIC-KEYS-ARE-ATOMIC-MESSAGES,
MS!TEXT-MESSAGE-ATOMIC, MS!PARTS-ATOMIC, MS!PRINCIPAL-ATOMIC, MS!PARTS-UNION,
MS!ATOMIC-IN-PARTS-ADD-KNOWN-IN, UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, FN!FUNCTION-IS-RELATION,
IS-GOOD-STATE-IMPLICATION, IS-GOOD-EVOLUTION-STATE-IS-GOOD-STATE
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, STORAGE-OF-IS-SUBSET-MESSAGES,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
IN-PARTS-SEEN-IMPLIES-IN-PARTS-FORGEABLE
Beginning proof of IN-PARTS-SEEN-IMPLIES-IN-PARTS-FORGEABLE ...
(IMPLIES
 (AND (IS-GOOD-STATE STATE) (IN K (MS!ATOMIC-MESSAGES))
  (IN K (MS!PARTS (SEEN-MESSAGES STATE))))
 (SOME (MESSAGE)
  (AND (FORGEABLE MESSAGE STATE) (IN K (MS!PARTS (UNIT MESSAGE))))))
Assuming MS!PARTS-IMPLIES-PART-OF-MEMBER with the
instantiations: (= M K) (= S (SEEN-MESSAGES STATE)) generates ...
(IMPLIES
 (AND
  (IMPLIES (IN K (MS!PARTS (SEEN-MESSAGES STATE)))
   (SOME (X) (AND (IN X (SEEN-MESSAGES STATE)) (IN K (MS!PARTS (UNIT X))))))
  (IS-GOOD-STATE STATE) (IN K (MS!ATOMIC-MESSAGES))
  (IN K (MS!PARTS (SEEN-MESSAGES STATE))))
 (SOME (MESSAGE)
  (AND (FORGEABLE MESSAGE STATE) (IN K (MS!PARTS (UNIT MESSAGE))))))
Which simplifies
 when rewriting with SETRULES!UNIT-TO-SETADD
 forward chaining using FORGEABLE-IS-MESSAGE, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION to ...
(IMPLIES
 (AND (IN K (MS!PARTS (SEEN-MESSAGES STATE)))
  (SOME (X)
   (AND (IN X (SEEN-MESSAGES STATE)) (IN K (MS!PARTS (SETADD X (NULLSET))))))
  (IS-GOOD-STATE STATE) (IN K (MS!ATOMIC-MESSAGES)))
 (SOME (MESSAGE)
  (AND (FORGEABLE MESSAGE STATE)
   (IN K (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
Prenexing produces ...
(IMPLIES
 (AND (IN K (MS!PARTS (SEEN-MESSAGES STATE))) (IN X (SEEN-MESSAGES STATE))
  (IN K (MS!PARTS (SETADD X (NULLSET)))) (IS-GOOD-STATE STATE)
  (IN K (MS!ATOMIC-MESSAGES)))
 (SOME (MESSAGE)
  (AND (FORGEABLE MESSAGE STATE)
   (IN K (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
Invoking FORGEABLE gives ...
(IMPLIES
 (AND (IN K (MS!PARTS (SEEN-MESSAGES STATE))) (IN X (SEEN-MESSAGES STATE))
  (IN K (MS!PARTS (SETADD X (NULLSET)))) (IS-GOOD-STATE STATE)
  (IN K (MS!ATOMIC-MESSAGES)))
 (SOME (MESSAGE)
  (AND
   (MS!KNOWN-IN MESSAGE
    (UNION (SEEN-MESSAGES STATE)
     (UNION (MS!PUBLIC-KEYS) (UNION (MS!TEXT-MESSAGES) (MS!PRINCIPALS)))))
   (IN K (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
Which simplifies
 when rewriting with UNION.PERMUTATIVE, UNION.COMMUTATIVE
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN K (MS!PARTS (SEEN-MESSAGES STATE))) (IN X (SEEN-MESSAGES STATE))
  (IN K (MS!PARTS (SETADD X (NULLSET)))) (IS-GOOD-STATE STATE)
  (IN K (MS!ATOMIC-MESSAGES)))
 (SOME (MESSAGE)
  (AND
   (MS!KNOWN-IN MESSAGE
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
   (IN K (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
Instantiating (= MESSAGE X) gives ...
(IMPLIES
 (AND (IN K (MS!PARTS (SEEN-MESSAGES STATE))) (IN X (SEEN-MESSAGES STATE))
  (IN K (MS!PARTS (SETADD X (NULLSET)))) (IS-GOOD-STATE STATE)
  (IN K (MS!ATOMIC-MESSAGES))
  (NOT
   (AND
    (MS!KNOWN-IN X
     (UNION (MS!PRINCIPALS)
      (UNION (MS!TEXT-MESSAGES)
       (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
    (IN K (MS!PARTS (SETADD X (NULLSET)))))))
 (SOME (MESSAGE)
  (AND
   (MS!KNOWN-IN MESSAGE
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
   (IN K (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
Which simplifies
 forward chaining using MS!KNOWN-IN-IN-MESSAGES, MS!D1, >=.SAME.TYPE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(IMPLIES
 (AND (IN K (MS!PARTS (SEEN-MESSAGES STATE))) (IN X (SEEN-MESSAGES STATE))
  (IN K (MS!PARTS (SETADD X (NULLSET)))) (IS-GOOD-STATE STATE)
  (IN K (MS!ATOMIC-MESSAGES))
  (NOT
   (MS!KNOWN-IN X
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
 (SOME (MESSAGE)
  (AND
   (MS!KNOWN-IN MESSAGE
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
   (IN K (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
Invoking (IS-GOOD-STATE STATE) gives ...
(IMPLIES
 (AND (IN K (MS!PARTS (SEEN-MESSAGES STATE))) (IN X (SEEN-MESSAGES STATE))
  (IN K (MS!PARTS (SETADD X (NULLSET)))) (IS-STATE STATE)
  (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN K (MS!ATOMIC-MESSAGES))
  (NOT
   (MS!KNOWN-IN X
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
 (SOME (MESSAGE)
  (AND
   (MS!KNOWN-IN MESSAGE
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
   (IN K (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
Invoking (SUBSET (SEEN-MESSAGES STATE) (MS!MESSAGES)) gives ...
(IMPLIES
 (AND (IN K (MS!PARTS (SEEN-MESSAGES STATE))) (IN X (SEEN-MESSAGES STATE))
  (IN K (MS!PARTS (SETADD X (NULLSET)))) (IS-STATE STATE)
  (ALL (E) (IMPLIES (IN E (SEEN-MESSAGES STATE)) (IN E (MS!MESSAGES))))
  (TIME-STRICTLY-INCREASES (HISTORY STATE))
  (IN (HISTORY STATE) (SEQ!SEQUENCE-OF (EVENTS)))
  (FN!IS-FUNCTION (STORES STATE)) (= (REL!DOM (STORES STATE)) (MS!PRINCIPALS))
  (SUBSET (REL!RAN (STORES STATE)) (POWERSET (MS!MESSAGES)))
  (IN K (MS!ATOMIC-MESSAGES))
  (NOT
   (MS!KNOWN-IN X
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))))
 (SOME (MESSAGE)
  (AND
   (MS!KNOWN-IN MESSAGE
    (UNION (MS!PRINCIPALS)
     (UNION (MS!TEXT-MESSAGES)
      (UNION (MS!PUBLIC-KEYS) (SEEN-MESSAGES STATE)))))
   (IN K (MS!PARTS (SETADD MESSAGE (NULLSET)))))))
Which simplifies
 when rewriting with MS!A7, UNION.DEFINITION, SEQ!IN-SEQUENCE-OF
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!KNOWN-IN-IN-MESSAGES,
MS!D1, >=.SAME.TYPE, MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES,
MS!SIZE-ATOMIC, FN!FUNCTION-IS-RELATION
 with the assumptions MS!KNOWN-IN-BOOL, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
FN!IS-FUNCTION-BOOL, IS-STATE-BOOL
 with the instantiation (= E X) to ...
(TRUE)
SEND-STEP-IS-GOOD-STEP
Beginning proof of SEND-STEP-IS-GOOD-STEP ...
(IMPLIES (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (= (GOOD-STEP STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)) (TRUE)))
Invoking GOOD-STEP gives ...
(IMPLIES (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (AND (IS-GOOD-STATE STATE)
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$0 STATE)
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$1 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER STATE)
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$2 STATE))))
     (SOME (PRINCIPAL$3)
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE))))
     (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
      (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE))))))))
Instantiating (= LABEL$0 LABEL) (= TIME$0 TIME) (= MESSAGE$0 MESSAGE)
              (= PRINCIPAL$0 PRINCIPAL) gives
...
(IMPLIES (NOT (= STATE (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (AND (IN PRINCIPAL (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE)
      (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE)))
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$5 (MS!PRINCIPALS))
        (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (= (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Invoking (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE) gives ...
(IMPLIES
 (NOT
  (= STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (AND (IN PRINCIPAL (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE)
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN PRINCIPAL (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
        (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
          STATE))
        STATE)
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN PRINCIPAL (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
        (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
          STATE))
        STATE)))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
           STATE))
         STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
           STATE))
         STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
           STATE))
         STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
           STATE))
         STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN PRINCIPAL (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
        (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
          STATE))
        STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
           STATE))
         STATE)
        (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE)))
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
          (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
          (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$5 (MS!PRINCIPALS))
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
          (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
          (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-SEND-EVENT LABEL TIME MESSAGE PRINCIPAL)
           STATE))
         STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Which simplifies
 forward chaining using TAG-OF-SEND-EVENT, SEND-EVENT-IS-EVENT, IN-SEND-EVENT,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-SEND-EVENT,
MAKE-SEND-EVENT-IS-SEND-EVENT, LABEL-OF-SEND-EVENT, TIME-OF-SEND-EVENT,
MESSAGE-OF-SEND-EVENT, PRINCIPAL1-OF-SEND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
RECEIVE-STEP-IS-GOOD-STEP
Beginning proof of RECEIVE-STEP-IS-GOOD-STEP ...
(IMPLIES (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (= (GOOD-STEP STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (TRUE)))
Invoking GOOD-STEP gives ...
(IMPLIES (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (AND (IS-GOOD-STATE STATE)
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$0 STATE)
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$1 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER STATE)
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$2 STATE))))
     (SOME (PRINCIPAL$3)
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE))))
     (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
      (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE))))))))
Instantiating (= LABEL$0 LABEL) (= TIME$0 TIME) (= MESSAGE$0 MESSAGE)
              (= PRINCIPAL$1 PRINCIPAL) gives
...
(IMPLIES (NOT (= STATE (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 STATE)
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (AND (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
      (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$4 STATE)
        (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE)))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$5 (MS!PRINCIPALS))
        (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (= (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Invoking (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL STATE) gives ...
(IMPLIES
 (NOT
  (= STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (AND (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
        (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY
          (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
        STATE)
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
        (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY
          (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
        STATE)))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
        (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY
          (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
        STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$4 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
          (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE)))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
          (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$5 (MS!PRINCIPALS))
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
          (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
          (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-RECEIVE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Which simplifies
 forward chaining using KNOWN-BY-PRINCIPAL-IS-MESSAGE, TAG-OF-RECEIVE-EVENT,
RECEIVE-EVENT-IS-EVENT, IN-RECEIVE-EVENT, FORGEABLE-IS-MESSAGE,
MS!TAG-OF-ATOMIC-MESSAGES, MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC,
MS!TAG-OF-BASIC-MESSAGES, MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES,
MS!TAG-OF-PRINCIPAL, MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-RECEIVE-EVENT,
MAKE-RECEIVE-EVENT-IS-RECEIVE-EVENT, LABEL-OF-RECEIVE-EVENT,
TIME-OF-RECEIVE-EVENT, MESSAGE-OF-RECEIVE-EVENT, PRINCIPAL1-OF-RECEIVE-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
OUT-OF-BAND-STEP-IS-GOOD-STEP
Beginning proof of OUT-OF-BAND-STEP-IS-GOOD-STEP ...
(IMPLIES
 (NOT (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)))
 (=
  (GOOD-STEP STATE
   (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))
  (TRUE)))
Invoking GOOD-STEP gives ...
(IMPLIES
 (NOT (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)))
 (AND (IS-GOOD-STATE STATE)
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL STATE)
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE))))
     (SOME (SENDER$0 RECEIVER$0)
      (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
         STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$2 STATE)
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
      (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
       (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE))))))))
Instantiating (= LABEL$0 LABEL) (= TIME$0 TIME) (= MESSAGE$0 MESSAGE)
              (= SENDER$0 SENDER) (= RECEIVER$0 RECEIVER) gives
...
(IMPLIES
 (NOT (= STATE (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE)
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
      (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
       (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$3)
       (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
        (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE))))
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
         STATE)))
      (SOME (PRINCIPAL$5)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$5 (MS!PRINCIPALS))
        (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (= (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Invoking (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE) gives ...
(IMPLIES
 (NOT
  (= STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
    (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY
      (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
    STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
         (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
         STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
         (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
         STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
        (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY
          (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
        STATE)
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
        (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY
          (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
        STATE)))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
         (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
         STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
         (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
         STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
        (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY
          (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
        STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$3)
       (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
          (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
            STATE))
          STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE))))
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
          (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
            STATE))
          STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
         (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
         STATE)
        (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
         STATE)))
      (SOME (PRINCIPAL$5)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$5 (MS!PRINCIPALS))
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
          (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
            STATE))
          STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
          (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER)
            STATE))
          STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE))
         (ADD-TO-STATE-STORAGE RECEIVER (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-OUT-OF-BAND-EVENT LABEL TIME MESSAGE SENDER RECEIVER) STATE))
         STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Which simplifies
 forward chaining using FORGEABLE-IS-MESSAGE, TAG-OF-OUT-OF-BAND-EVENT,
OUT-OF-BAND-EVENT-IS-EVENT, IN-OUT-OF-BAND-EVENT,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-OUT-OF-BAND-EVENT,
MAKE-OUT-OF-BAND-EVENT-IS-OUT-OF-BAND-EVENT, LABEL-OF-OUT-OF-BAND-EVENT,
TIME-OF-OUT-OF-BAND-EVENT, MESSAGE-OF-OUT-OF-BAND-EVENT,
PRINCIPAL1-OF-OUT-OF-BAND-EVENT, PRINCIPAL2-OF-OUT-OF-BAND-EVENT,
MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
GENERATE-STEP-IS-GOOD-STEP
Beginning proof of GENERATE-STEP-IS-GOOD-STEP ...
(IMPLIES (NOT (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (= (GOOD-STEP STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (TRUE)))
Invoking GOOD-STEP gives ...
(IMPLIES (NOT (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (AND (IS-GOOD-STATE STATE)
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$0 STATE)
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$1 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER STATE)
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$2 STATE))))
     (SOME (PRINCIPAL$3)
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE))))
     (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
      (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE))))))))
Instantiating (= LABEL$0 LABEL) (= TIME$0 TIME) (= MESSAGE$0 MESSAGE)
              (= PRINCIPAL$2 PRINCIPAL) gives
...
(IMPLIES (NOT (= STATE (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 STATE)
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (IN PRINCIPAL (MS!PRINCIPALS))
      (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$4 STATE)
        (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN PRINCIPAL$5 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE)))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (= (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Invoking (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL STATE) gives ...
(IMPLIES
 (NOT
  (= STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
     (IN PRINCIPAL (MS!PRINCIPALS)))
    (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL)
      STATE))
    STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
          (IN PRINCIPAL (MS!PRINCIPALS)))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
          (IN PRINCIPAL (MS!PRINCIPALS)))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
          (IN PRINCIPAL (MS!PRINCIPALS)))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (IN PRINCIPAL (MS!PRINCIPALS))
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN MESSAGE (MS!ATOMIC-MESSAGES))
         (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
         (IN PRINCIPAL (MS!PRINCIPALS)))
        (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY
          (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
        STATE)
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN MESSAGE (MS!ATOMIC-MESSAGES))
         (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
         (IN PRINCIPAL (MS!PRINCIPALS)))
        (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY
          (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
        STATE)))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
          (IN PRINCIPAL (MS!PRINCIPALS)))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN MESSAGE (MS!ATOMIC-MESSAGES))
         (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
         (IN PRINCIPAL (MS!PRINCIPALS)))
        (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY
          (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
        STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$4 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN MESSAGE (MS!ATOMIC-MESSAGES))
           (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
           (IN PRINCIPAL (MS!PRINCIPALS)))
          (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN PRINCIPAL$5 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN MESSAGE (MS!ATOMIC-MESSAGES))
           (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
           (IN PRINCIPAL (MS!PRINCIPALS)))
          (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN MESSAGE (MS!ATOMIC-MESSAGES))
           (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
           (IN PRINCIPAL (MS!PRINCIPALS)))
          (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
          (IN PRINCIPAL (MS!PRINCIPALS)))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE)))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN MESSAGE (MS!ATOMIC-MESSAGES))
           (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
           (IN PRINCIPAL (MS!PRINCIPALS)))
          (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY
            (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
          STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
          (IN PRINCIPAL (MS!PRINCIPALS)))
         (ADD-TO-STATE-STORAGE PRINCIPAL (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY
           (MAKE-GENERATE-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE))
         STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using FORGEABLE-IS-MESSAGE, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
TAG-OF-GENERATE-EVENT, GENERATE-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-STORAGE-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-GENERATE-EVENT,
MAKE-GENERATE-EVENT-IS-GENERATE-EVENT, LABEL-OF-GENERATE-EVENT,
TIME-OF-GENERATE-EVENT, MESSAGE-OF-GENERATE-EVENT,
PRINCIPAL1-OF-GENERATE-EVENT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-PRINCIPALS-NOT-EMPTY,
MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY, MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY,
MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
CONSTRUCT-STEP-IS-GOOD-STEP
Beginning proof of CONSTRUCT-STEP-IS-GOOD-STEP ...
(IMPLIES (NOT (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (= (GOOD-STEP STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE))
  (TRUE)))
Invoking GOOD-STEP gives ...
(IMPLIES (NOT (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (AND (IS-GOOD-STATE STATE)
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$0 STATE)
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$1 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER STATE)
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$2 STATE))))
     (SOME (PRINCIPAL$3)
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE))))
     (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
      (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE))))))))
Instantiating (= LABEL$0 LABEL) (= TIME$0 TIME) (= MESSAGE$0 MESSAGE)
              (= PRINCIPAL$3 PRINCIPAL) gives
...
(IMPLIES (NOT (= STATE (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 STATE)
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN PRINCIPAL (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE)
      (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$4 STATE)
        (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN PRINCIPAL$5 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE)))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (= (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Invoking (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL STATE) gives ...
(IMPLIES
 (NOT
  (= STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN PRINCIPAL (MS!PRINCIPALS))
     (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
    (ADD-TO-STATE-HISTORY (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL)
     STATE)
    STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$0 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-HISTORY
          (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
         STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN PRINCIPAL$1 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-HISTORY
          (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
         STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-HISTORY
          (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
         STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-HISTORY
          (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
         STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN PRINCIPAL (MS!PRINCIPALS))
      (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE)
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN PRINCIPAL (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
        (ADD-TO-STATE-HISTORY
         (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
        STATE)
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN PRINCIPAL (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
        (ADD-TO-STATE-HISTORY
         (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
        STATE)))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN PRINCIPAL (MS!PRINCIPALS))
         (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
        (ADD-TO-STATE-HISTORY
         (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
        STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$4 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
          (ADD-TO-STATE-HISTORY
           (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
          STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN PRINCIPAL$5 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
          (ADD-TO-STATE-HISTORY
           (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
          STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
          (ADD-TO-STATE-HISTORY
           (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
          STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN PRINCIPAL (MS!PRINCIPALS))
           (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
          (ADD-TO-STATE-HISTORY
           (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
          STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-HISTORY
          (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
         STATE)
        (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE)))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN PRINCIPAL (MS!PRINCIPALS))
          (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE))
         (ADD-TO-STATE-HISTORY
          (MAKE-CONSTRUCT-EVENT LABEL TIME MESSAGE PRINCIPAL) STATE)
         STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using MS!TAG-OF-KEYS, MS!KEY-IN-ATOMIC-MESSAGES,
MS!TAG-OF-ASYMMETRIC-KEYS, MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY,
MS!PUBLIC-KEY-IS-ASYMMETRIC, MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES,
FORGEABLE-IS-MESSAGE, TAG-OF-CONSTRUCT-EVENT, CONSTRUCT-EVENT-IS-EVENT,
KNOWN-BY-PRINCIPAL-IS-MESSAGE, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, >=.SAME.TYPE, TIME-CONSTRAINT-IMPLIES-NAT,
FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-CONSTRUCT-EVENT,
MAKE-CONSTRUCT-EVENT-IS-CONSTRUCT-EVENT, LABEL-OF-CONSTRUCT-EVENT,
TIME-OF-CONSTRUCT-EVENT, MESSAGE-OF-CONSTRUCT-EVENT,
PRINCIPAL1-OF-CONSTRUCT-EVENT, MS!SET-OF-PRINCIPALS-NOT-EMPTY to ...
(TRUE)
INTRUDER-STEP-IS-GOOD-STEP
Beginning proof of INTRUDER-STEP-IS-GOOD-STEP ...
(IMPLIES (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE)))
 (= (GOOD-STEP STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE)) (TRUE)))
Invoking GOOD-STEP gives ...
(IMPLIES (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE)))
 (AND (IS-GOOD-STATE STATE)
  (SOME (LABEL$0 TIME$0 MESSAGE$0)
   (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL STATE)
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$0 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER STATE)
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$2 STATE)
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
      (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
       (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE))))))))
Instantiating (= LABEL$0 LABEL) (= TIME$0 TIME) (= MESSAGE$0 MESSAGE) gives ...
(IMPLIES (NOT (= STATE (INTRUDER-STEP LABEL TIME MESSAGE STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE)
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
       (INTRUDER-STEP LABEL TIME MESSAGE STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$3)
       (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
        (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE))))
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$5 (MS!PRINCIPALS))
        (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (= (INTRUDER-STEP LABEL TIME MESSAGE STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Invoking (INTRUDER-STEP LABEL TIME MESSAGE STATE) gives ...
(IMPLIES
 (NOT
  (= STATE
   (IF
    (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
     (IN MESSAGE (MS!ATOMIC-MESSAGES))
     (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
    (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
     (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE) STATE))
    STATE)))
 (AND (IS-GOOD-STATE STATE)
  (OR
   (AND (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
    (OR
     (SOME (PRINCIPAL)
      (AND (IN PRINCIPAL (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
           STATE))
         STATE)
        (SEND-STEP LABEL TIME MESSAGE PRINCIPAL STATE))))
     (SOME (PRINCIPAL$0)
      (AND (IN PRINCIPAL$0 (MS!PRINCIPALS)) (FORGEABLE MESSAGE STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
           STATE))
         STATE)
        (RECEIVE-STEP LABEL TIME MESSAGE PRINCIPAL$0 STATE))))
     (SOME (SENDER RECEIVER)
      (AND (IN SENDER (MS!PRINCIPALS)) (IN RECEIVER (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE SENDER STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
           STATE))
         STATE)
        (OUT-OF-BAND-STEP LABEL TIME MESSAGE SENDER RECEIVER STATE))))
     (SOME (PRINCIPAL$1)
      (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
       (IN PRINCIPAL$1 (MS!PRINCIPALS))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
           STATE))
         STATE)
        (GENERATE-STEP LABEL TIME MESSAGE PRINCIPAL$1 STATE))))
     (SOME (PRINCIPAL$2)
      (AND (IN PRINCIPAL$2 (MS!PRINCIPALS))
       (KNOWN-BY-PRINCIPAL MESSAGE PRINCIPAL$2 STATE)
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
           STATE))
         STATE)
        (CONSTRUCT-STEP LABEL TIME MESSAGE PRINCIPAL$2 STATE))))
     (AND (IN MESSAGE (MS!ATOMIC-MESSAGES))
      (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE))
      (=
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN MESSAGE (MS!ATOMIC-MESSAGES))
         (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
        (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
          STATE))
        STATE)
       (IF
        (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
         (IN MESSAGE (MS!ATOMIC-MESSAGES))
         (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
        (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
         (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
          STATE))
        STATE)))))
   (SOME (LABEL$0 TIME$0 MESSAGE$0)
    (AND (TIME-CONSTRAINT TIME$0 STATE) (>= LABEL$0 0)
     (OR
      (SOME (PRINCIPAL$3)
       (AND (IN PRINCIPAL$3 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$3 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN MESSAGE (MS!ATOMIC-MESSAGES))
           (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
          (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
            STATE))
          STATE)
         (SEND-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$3 STATE))))
      (SOME (PRINCIPAL$4)
       (AND (IN PRINCIPAL$4 (MS!PRINCIPALS)) (FORGEABLE MESSAGE$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN MESSAGE (MS!ATOMIC-MESSAGES))
           (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
          (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
            STATE))
          STATE)
         (RECEIVE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$4 STATE))))
      (SOME (SENDER$0 RECEIVER$0)
       (AND (IN SENDER$0 (MS!PRINCIPALS)) (IN RECEIVER$0 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 SENDER$0 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN MESSAGE (MS!ATOMIC-MESSAGES))
           (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
          (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
            STATE))
          STATE)
         (OUT-OF-BAND-STEP LABEL$0 TIME$0 MESSAGE$0 SENDER$0 RECEIVER$0
          STATE))))
      (SOME (PRINCIPAL$5)
       (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
        (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
        (IN PRINCIPAL$5 (MS!PRINCIPALS))
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN MESSAGE (MS!ATOMIC-MESSAGES))
           (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
          (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
            STATE))
          STATE)
         (GENERATE-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$5 STATE))))
      (SOME (PRINCIPAL$6)
       (AND (IN PRINCIPAL$6 (MS!PRINCIPALS))
        (KNOWN-BY-PRINCIPAL MESSAGE$0 PRINCIPAL$6 STATE)
        (=
         (IF
          (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
           (IN MESSAGE (MS!ATOMIC-MESSAGES))
           (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
          (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
           (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
            STATE))
          STATE)
         (CONSTRUCT-STEP LABEL$0 TIME$0 MESSAGE$0 PRINCIPAL$6 STATE))))
      (AND (IN MESSAGE$0 (MS!ATOMIC-MESSAGES))
       (MS!IS-FRESH MESSAGE$0 (ALL-MESSAGES-IN-STATE STATE))
       (=
        (IF
         (AND (IS-GOOD-STATE STATE) (TIME-CONSTRAINT TIME STATE) (>= LABEL 0)
          (IN MESSAGE (MS!ATOMIC-MESSAGES))
          (MS!IS-FRESH MESSAGE (ALL-MESSAGES-IN-STATE STATE)))
         (ADD-TO-STATE-SEEN-MESSAGES (SETADD MESSAGE (NULLSET))
          (ADD-TO-STATE-HISTORY (MAKE-INTRUDER-EVENT LABEL TIME MESSAGE)
           STATE))
         STATE)
        (INTRUDER-STEP LABEL$0 TIME$0 MESSAGE$0 STATE)))))))))
Which simplifies
 when rewriting with MS!IS-FRESH-ATOMIC, MS!IS-FRESH-UNION, UNION.PERMUTATIVE,
ALL-MESSAGES-IN-STATE-DEFINITION
 forward chaining using FORGEABLE-IS-MESSAGE, KNOWN-BY-PRINCIPAL-IS-MESSAGE,
TAG-OF-INTRUDER-EVENT, INTRUDER-EVENT-IS-EVENT, MS!TAG-OF-KEYS,
MS!KEY-IN-ATOMIC-MESSAGES, MS!TAG-OF-ASYMMETRIC-KEYS,
MS!ASYMMETRIC-KEY-IN-KEYS, MS!TAG-OF-PUBKEY, MS!PUBLIC-KEY-IS-ASYMMETRIC,
MS!TAG-OF-TEXT, MS!TEXT-IN-BASIC-MESSAGES, MS!TAG-OF-BASIC-MESSAGES,
MS!BASIC-MESSAGE-IN-ATOMIC-MESSAGES, MS!TAG-OF-PRINCIPAL,
MS!PRINCIPAL-IN-BASIC-MESSAGES, MS!TAG-OF-ATOMIC-MESSAGES,
MS!ATOMIC-MESSAGE-IN-MESSAGES, MS!SIZE-ATOMIC, >=.SAME.TYPE,
TIME-CONSTRAINT-IMPLIES-NAT, FN!FUNCTION-IS-RELATION, IS-GOOD-STATE-IMPLICATION
 with the assumptions ADD-TO-STATE-SEEN-MESSAGES-IS-STATE,
ADD-TO-STATE-HISTORY-IS-STATE, TAG-OF-MAKE-INTRUDER-EVENT,
MAKE-INTRUDER-EVENT-IS-INTRUDER-EVENT, LABEL-OF-INTRUDER-EVENT,
TIME-OF-INTRUDER-EVENT, MESSAGE-OF-INTRUDER-EVENT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
MS!SET-OF-PRINCIPALS-NOT-EMPTY, MS!SET-OF-TEXT-MESSAGES-NOT-EMPTY,
MS!SET-OF-PUBLIC-KEYS-NOT-EMPTY, MS!SET-OF-ATOMIC-MESSAGES-NOT-EMPTY to ...
(TRUE)
Done.