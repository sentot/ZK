
Reading "/home/sentot/zk/version1/ZK/examples/prmodel.ver"
Warning RULE-LOOPS for FN!FUNCTION-EXTENSIONALITY:
 The rule FN!FUNCTION-EXTENSIONALITY loops upon itself.
MAKE-PROCESS
PROCESS-ALPHABET
PROCESS-TRACES
PREFIX-CLOSED
PREFIX-CLOSED-BOOL
Beginning proof of PREFIX-CLOSED-BOOL ...
(= (TYPE-OF (PREFIX-CLOSED TRACES)) (BOOL))
Which simplifies to ...
(TRUE)
IS-PROCESS
IS-PROCESS-BOOL
Beginning proof of IS-PROCESS-BOOL ...
(= (TYPE-OF (IS-PROCESS P)) (BOOL))
Which simplifies to ...
(TRUE)
PROCESS-ALPHABET-MAKE-PROCESS
Beginning proof of PROCESS-ALPHABET-MAKE-PROCESS ...
(= (PROCESS-ALPHABET (MAKE-PROCESS A T)) A)
Which simplifies
 with invocation of PROCESS-ALPHABET, MAKE-PROCESS
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
PROCESS-TRACES-MAKE-PROCESS
Beginning proof of PROCESS-TRACES-MAKE-PROCESS ...
(= (PROCESS-TRACES (MAKE-PROCESS A T)) T)
Which simplifies
 with invocation of PROCESS-TRACES, MAKE-PROCESS
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PROCESS-ALPHABET-MAKE-PROCESS to ...
(TRUE)
PROCESS-COMPOSITION
Beginning proof of PROCESS-COMPOSITION ...
(IMPLIES (IS-PROCESS P)
 (= (MAKE-PROCESS (PROCESS-ALPHABET P) (PROCESS-TRACES P)) P))
Which simplifies
 with invocation of MAKE-PROCESS, SUBSET, PROCESS-ALPHABET, PROCESS-TRACES,
IS-PROCESS
 when rewriting with TR!IN-TRACE-OF
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
PROCESS-ALPHABET-MAKE-PROCESS, PROCESS-TRACES-MAKE-PROCESS,
PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL,
IS-PROCESS-BOOL to ...
(TRUE)
MAKE-PROCESS-IS-PROCESS
Beginning proof of MAKE-PROCESS-IS-PROCESS ...
(= (IS-PROCESS (MAKE-PROCESS A T))
 (AND (SUBSET T (TR!TRACE-OF A)) (IN (TR!EMPTY) T) (PREFIX-CLOSED T)))
Invoking IS-PROCESS gives ...
(=
 (AND (PAIR!IS-PAIR (MAKE-PROCESS A T))
  (SUBSET (PROCESS-TRACES (MAKE-PROCESS A T))
   (TR!TRACE-OF (PROCESS-ALPHABET (MAKE-PROCESS A T))))
  (IN (TR!EMPTY) (PROCESS-TRACES (MAKE-PROCESS A T)))
  (PREFIX-CLOSED (PROCESS-TRACES (MAKE-PROCESS A T))))
 (AND (SUBSET T (TR!TRACE-OF A)) (IN (TR!EMPTY) T) (PREFIX-CLOSED T)))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PAIR!PAIR-COMPOSITION
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS to ...
(IMPLIES
 (AND (NOT (PAIR!IS-PAIR (MAKE-PROCESS A T))) (SUBSET T (TR!TRACE-OF A))
  (IN (TR!EMPTY) T))
 (NOT (PREFIX-CLOSED T)))
Invoking MAKE-PROCESS gives ...
(IMPLIES
 (AND (NOT (PAIR!IS-PAIR (PAIR!PAIR A T))) (SUBSET T (TR!TRACE-OF A))
  (IN (TR!EMPTY) T))
 (NOT (PREFIX-CLOSED T)))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR to ...
(TRUE)
IN-PROCESS-TRACES
Beginning proof of IN-PROCESS-TRACES ...
(IMPLIES (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P)))
 (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)))
Which simplifies
 with invocation of SUBSET, PROCESS-TRACES, IS-PROCESS
 when rewriting with TR!IN-TRACE-OF
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PAIR!PAIR-COMPOSITION, PROCESS-COMPOSITION
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
APPEND-IN-PROCESS-TRACES
Beginning proof of APPEND-IN-PROCESS-TRACES ...
(IMPLIES
 (AND (IS-PROCESS P) (TR!IS-TRACE S1) (TR!IS-TRACE S2)
  (IN (TR!APPEND S1 S2) (PROCESS-TRACES P)))
 (IN S1 (PROCESS-TRACES P)))
Which simplifies
 with invocation of PREFIX-CLOSED, SUBSET, IS-PROCESS
 when rewriting with TR!IN-TRACE-OF
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PAIR!PAIR-COMPOSITION,
PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL,
IS-PROCESS-BOOL to ...
(TRUE)
STOP
RUN
IS-PROCESS-STOP
Beginning proof of IS-PROCESS-STOP ...
(IS-PROCESS (STOP A))
Which simplifies
 with invocation of PREFIX-CLOSED, STOP
 when rewriting with NULLSET.DEFINITION, TR!APPEND-IS-EMPTY,
SETADD.DEFINITION, SUBSET.NULLSET.LEFT, TR!IS-TRACE-OF-EMPTY, TR!IN-TRACE-OF,
SETRULES!SUBSET-SETADD, MAKE-PROCESS-IS-PROCESS, SETRULES!UNIT-TO-SETADD
 forward chaining using TR!TACK-HEAD-TAIL, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ
 with the assumptions TR!APPEND-NOT-EMPTY-LEFT, TR!APPEND-NOT-EMPTY-RIGHT,
TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL, PREFIX-CLOSED-BOOL,
IS-PROCESS-BOOL, PROCESS-ALPHABET-MAKE-PROCESS, PROCESS-TRACES-MAKE-PROCESS,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY to ...
(TRUE)
PROCESS-ALPHABET-STOP
Beginning proof of PROCESS-ALPHABET-STOP ...
(= (PROCESS-ALPHABET (STOP A)) A)
Which simplifies
 with invocation of STOP
 when rewriting with SETRULES!UNIT-TO-SETADD
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
IS-PROCESS-STOP to ...
(TRUE)
PROCESS-TRACES-STOP
Beginning proof of PROCESS-TRACES-STOP ...
(= (PROCESS-TRACES (STOP A)) (UNIT (TR!EMPTY)))
Which simplifies
 with invocation of STOP
 when rewriting with SETRULES!UNIT-TO-SETADD
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
IS-PROCESS-STOP to ...
(TRUE)
IS-PROCESS-RUN
Beginning proof of IS-PROCESS-RUN ...
(IS-PROCESS (RUN A))
Which simplifies
 with invocation of PREFIX-CLOSED, RUN
 when rewriting with TR!IS-TRACE-OF-APPEND, TR!IS-TRACE-OF-EMPTY,
TR!IN-TRACE-OF, SUBSET.SELF, MAKE-PROCESS-IS-PROCESS
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-TRACE-OF-IS-TRACE,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL,
PROCESS-ALPHABET-MAKE-PROCESS, PROCESS-TRACES-MAKE-PROCESS to ...
(TRUE)
PROCESS-ALPHABET-RUN
Beginning proof of PROCESS-ALPHABET-RUN ...
(= (PROCESS-ALPHABET (RUN A)) A)
Which simplifies
 with invocation of RUN
 forward chaining using PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-RUN to ...
(TRUE)
PROCESS-TRACES-RUN
Beginning proof of PROCESS-TRACES-RUN ...
(= (PROCESS-TRACES (RUN A)) (TR!TRACE-OF A))
Which simplifies
 with invocation of RUN
 forward chaining using PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-RUN to ...
(TRUE)
MAP-TACK
PREFIX
PREFIX-IS-PROCESS
Beginning proof of PREFIX-IS-PROCESS ...
(IMPLIES (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)))
 (IS-PROCESS (PREFIX X P)))
Which simplifies
 with invocation of PREFIX-CLOSED, SUBSET, PREFIX
 when rewriting with TR!APPEND-IS-EMPTY, SETADD.DEFINITION,
MAP-TACK.DEFINITION, TR!IS-TRACE-OF-EMPTY, TR!IN-TRACE-OF,
SETRULES!SUBSET-SETADD, MAKE-PROCESS-IS-PROCESS, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!TACK-HEAD-TAIL,
TR!IS-TRACE-OF-IS-TRACE, TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION
 with the assumptions TR!APPEND-NOT-EMPTY-LEFT, TR!APPEND-NOT-EMPTY-RIGHT,
TR!IS-TRACE-APPEND, PREFIX-CLOSED-BOOL, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL,
PROCESS-ALPHABET-MAKE-PROCESS, PROCESS-TRACES-MAKE-PROCESS,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL to ...
(IMPLIES (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)))
 (AND
  (ALL (S)
   (IMPLIES (IN S (PROCESS-TRACES P))
    (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET P))))
  (ALL (S$0 T S$1)
   (IMPLIES
    (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T) (NOT (= S$0 (TR!EMPTY)))
     (IN S$1 (PROCESS-TRACES P)) (= (TR!APPEND S$0 T) (TR!TACK X S$1)))
    (SOME (S$2) (AND (IN S$2 (PROCESS-TRACES P)) (= S$0 (TR!TACK X S$2))))))))
Starting case 2 ...
(IMPLIES (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)))
 (ALL (S)
  (IMPLIES (IN S (PROCESS-TRACES P))
   (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET P)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (IN S (PROCESS-TRACES P)))
 (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET P)))
Assuming IN-PROCESS-TRACES with the instantiations: (= S S) (= P P) generates
...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P)))
   (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)))
  (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (IN S (PROCESS-TRACES P)))
 (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET P)))
Which simplifies
 when rewriting with TR!IS-TRACE-OF-TACK
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)))
 (ALL (S$0 T S$1)
  (IMPLIES
   (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T) (NOT (= S$0 (TR!EMPTY)))
    (IN S$1 (PROCESS-TRACES P)) (= (TR!APPEND S$0 T) (TR!TACK X S$1)))
   (SOME (S$2) (AND (IN S$2 (PROCESS-TRACES P)) (= S$0 (TR!TACK X S$2)))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (NOT (= S (TR!EMPTY))) (IN S$0 (PROCESS-TRACES P))
  (= (TR!APPEND S T) (TR!TACK X S$0)))
 (SOME (S$1) (AND (IN S$1 (PROCESS-TRACES P)) (= S (TR!TACK X S$1)))))
Instantiating (= S$1 (TR!TAIL S)) gives ...
(IMPLIES
 (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (NOT (= S (TR!EMPTY))) (IN S$0 (PROCESS-TRACES P))
  (= (TR!APPEND S T) (TR!TACK X S$0))
  (NOT
   (AND (IN (TR!TAIL S) (PROCESS-TRACES P)) (= S (TR!TACK X (TR!TAIL S))))))
 (SOME (S$1) (AND (IN S$1 (PROCESS-TRACES P)) (= S (TR!TACK X S$1)))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ,
TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY, PROCESS-COMPOSITION
 with the assumptions TR!TAIL-TACK-SEQ, TR!IS-TRACE-TAIL, TR!SIZE-TAIL,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!IS-TRACE-APPEND,
TR!APPEND-NOT-EMPTY-LEFT, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!IS-TRACE-BOOL, IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (NOT (= S (TR!EMPTY))) (IN S$0 (PROCESS-TRACES P))
  (= (TR!APPEND S T) (TR!TACK X S$0)))
 (IF (IN (TR!TAIL S) (PROCESS-TRACES P)) (= S (TR!TACK X (TR!TAIL S)))
  (SOME (S$1) (AND (IN S$1 (PROCESS-TRACES P)) (= S (TR!TACK X S$1))))))
Invoking TR!APPEND gives ...
(IMPLIES
 (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (NOT (= S (TR!EMPTY))) (IN S$0 (PROCESS-TRACES P))
  (= (IF (TR!IS-EMPTY S) T (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)))
   (TR!TACK X S$0)))
 (IF (IN (TR!TAIL S) (PROCESS-TRACES P)) (= S (TR!TACK X (TR!TAIL S)))
  (SOME (S$1) (AND (IN S$1 (PROCESS-TRACES P)) (= S (TR!TACK X S$1))))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ,
TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY, PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-APPEND, TR!IS-TRACE-TAIL, TR!SIZE-TAIL,
TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!IS-TRACE-BOOL,
IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (NOT (= S (TR!EMPTY))) (IN S$0 (PROCESS-TRACES P))
  (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0))
  (NOT (IN (TR!TAIL S) (PROCESS-TRACES P))))
 (SOME (S$1) (AND (IN S$1 (PROCESS-TRACES P)) (= S (TR!TACK X S$1)))))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 (TR!TAIL S)) (= S2 T) (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS P) (TR!IS-TRACE (TR!TAIL S)) (TR!IS-TRACE T)
    (IN (TR!APPEND (TR!TAIL S) T) (PROCESS-TRACES P)))
   (IN (TR!TAIL S) (PROCESS-TRACES P)))
  (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (NOT (= S (TR!EMPTY))) (IN S$0 (PROCESS-TRACES P))
  (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0))
  (NOT (IN (TR!TAIL S) (PROCESS-TRACES P))))
 (SOME (S$1) (AND (IN S$1 (PROCESS-TRACES P)) (= S (TR!TACK X S$1)))))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S S$0) (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P) (IN S$0 (PROCESS-TRACES P)))
   (TR!IS-TRACE-OF S$0 (PROCESS-ALPHABET P)))
  (IMPLIES
   (AND (IS-PROCESS P) (TR!IS-TRACE (TR!TAIL S)) (TR!IS-TRACE T)
    (IN (TR!APPEND (TR!TAIL S) T) (PROCESS-TRACES P)))
   (IN (TR!TAIL S) (PROCESS-TRACES P)))
  (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (NOT (= S (TR!EMPTY))) (IN S$0 (PROCESS-TRACES P))
  (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0))
  (NOT (IN (TR!TAIL S) (PROCESS-TRACES P))))
 (SOME (S$1) (AND (IN S$1 (PROCESS-TRACES P)) (= S (TR!TACK X S$1)))))
Which simplifies
 when rewriting with TR!TACK-SAME
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE,
PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!IS-TRACE-APPEND, TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL,
IS-PROCESS-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
PROCESS-ALPHABET-PREFIX
Beginning proof of PROCESS-ALPHABET-PREFIX ...
(IMPLIES (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)))
 (= (PROCESS-ALPHABET (PREFIX X P)) (PROCESS-ALPHABET P)))
Which simplifies
 with invocation of PREFIX
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
PREFIX-IS-PROCESS, IS-PROCESS-BOOL to ...
(TRUE)
PROCESS-TRACES-PREFIX
Beginning proof of PROCESS-TRACES-PREFIX ...
(IMPLIES (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)))
 (= (PROCESS-TRACES (PREFIX X P))
  (UNION (UNIT (TR!EMPTY)) (MAP-TACK X (PROCESS-TRACES P)))))
Which simplifies
 with invocation of PREFIX
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
PREFIX-IS-PROCESS, IS-PROCESS-BOOL to ...
(TRUE)
AFTER
AFTER-IS-PROCESS
Beginning proof of AFTER-IS-PROCESS ...
(IMPLIES (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P)))
 (IS-PROCESS (AFTER P S)))
Assuming IN-PROCESS-TRACES with the instantiations: (= S S) (= P P) generates
...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P)))
   (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)))
  (IS-PROCESS P) (IN S (PROCESS-TRACES P)))
 (IS-PROCESS (AFTER P S)))
Which simplifies
 forward chaining using TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE,
PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)))
 (IS-PROCESS (AFTER P S)))
Which simplifies
 with invocation of PREFIX-CLOSED, SUBSET, AFTER
 when rewriting with TR!APPEND-EMPTY-RIGHT, TR!IN-TRACE-OF,
TR!DELETE-INITIAL-SUBSEQUENCE-APPEND-LENGTH, TR!BEGIN-WITH.DEFINITION,
TR!SELECT-AFTER.DEFINITION, MAKE-PROCESS-IS-PROCESS
 forward chaining using >=.SAME.TYPE, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE,
PROCESS-COMPOSITION
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!LENGTH-NON-NEGATIVE, TR!IS-TRACE-APPEND,
TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)))
 (AND
  (ALL (E)
   (IMPLIES (AND (IN (TR!APPEND S E) (PROCESS-TRACES P)) (TR!IS-TRACE E))
    (TR!IS-TRACE-OF E (PROCESS-ALPHABET P))))
  (ALL (S$0 T)
   (IMPLIES
    (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T)
     (IN (TR!APPEND S (TR!APPEND S$0 T)) (PROCESS-TRACES P)))
    (IN (TR!APPEND S S$0) (PROCESS-TRACES P))))))
Assuming IN-PROCESS-TRACES with the instantiations: (= S S) (= P P) generates
...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P)))
   (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)))
  (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)))
 (AND
  (ALL (E)
   (IMPLIES (AND (IN (TR!APPEND S E) (PROCESS-TRACES P)) (TR!IS-TRACE E))
    (TR!IS-TRACE-OF E (PROCESS-ALPHABET P))))
  (ALL (S$0 T)
   (IMPLIES
    (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T)
     (IN (TR!APPEND S (TR!APPEND S$0 T)) (PROCESS-TRACES P)))
    (IN (TR!APPEND S S$0) (PROCESS-TRACES P))))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)))
 (AND
  (ALL (E)
   (IMPLIES (AND (IN (TR!APPEND S E) (PROCESS-TRACES P)) (TR!IS-TRACE E))
    (TR!IS-TRACE-OF E (PROCESS-ALPHABET P))))
  (ALL (S$0 T)
   (IMPLIES
    (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T)
     (IN (TR!APPEND S (TR!APPEND S$0 T)) (PROCESS-TRACES P)))
    (IN (TR!APPEND S S$0) (PROCESS-TRACES P))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)))
 (AND
  (IMPLIES (AND (IN (TR!APPEND S E) (PROCESS-TRACES P)) (TR!IS-TRACE E))
   (TR!IS-TRACE-OF E (PROCESS-ALPHABET P)))
  (IMPLIES
   (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T)
    (IN (TR!APPEND S (TR!APPEND S$0 T)) (PROCESS-TRACES P)))
   (IN (TR!APPEND S S$0) (PROCESS-TRACES P)))))
Starting case 2 ...
(IMPLIES
 (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P))
  (IN (TR!APPEND S E) (PROCESS-TRACES P)) (TR!IS-TRACE E))
 (TR!IS-TRACE-OF E (PROCESS-ALPHABET P)))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S (TR!APPEND S E)) (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P) (IN (TR!APPEND S E) (PROCESS-TRACES P)))
   (TR!IS-TRACE-OF (TR!APPEND S E) (PROCESS-ALPHABET P)))
  (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P))
  (IN (TR!APPEND S E) (PROCESS-TRACES P)) (TR!IS-TRACE E))
 (TR!IS-TRACE-OF E (PROCESS-ALPHABET P)))
Rearranging gives ...
(IMPLIES
 (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P))
  (IN (TR!APPEND S E) (PROCESS-TRACES P)) (TR!IS-TRACE E)
  (IMPLIES (AND (IS-PROCESS P) (IN (TR!APPEND S E) (PROCESS-TRACES P)))
   (TR!IS-TRACE-OF (TR!APPEND S E) (PROCESS-ALPHABET P))))
 (TR!IS-TRACE-OF E (PROCESS-ALPHABET P)))
Which simplifies
 when rewriting with TR!IS-TRACE-OF-APPEND
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
IS-PROCESS-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)) (TR!IS-TRACE S$0) (TR!IS-TRACE T)
  (IN (TR!APPEND S (TR!APPEND S$0 T)) (PROCESS-TRACES P)))
 (IN (TR!APPEND S S$0) (PROCESS-TRACES P)))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 (TR!APPEND S S$0)) (= S2 T) (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS P) (TR!IS-TRACE (TR!APPEND S S$0)) (TR!IS-TRACE T)
    (IN (TR!APPEND (TR!APPEND S S$0) T) (PROCESS-TRACES P)))
   (IN (TR!APPEND S S$0) (PROCESS-TRACES P)))
  (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)) (TR!IS-TRACE S$0) (TR!IS-TRACE T)
  (IN (TR!APPEND S (TR!APPEND S$0 T)) (PROCESS-TRACES P)))
 (IN (TR!APPEND S S$0) (PROCESS-TRACES P)))
Rearranging gives ...
(IMPLIES
 (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET P)) (TR!IS-TRACE S$0) (TR!IS-TRACE T)
  (IN (TR!APPEND S (TR!APPEND S$0 T)) (PROCESS-TRACES P))
  (IMPLIES
   (AND (IS-PROCESS P) (TR!IS-TRACE (TR!APPEND S S$0)) (TR!IS-TRACE T)
    (IN (TR!APPEND (TR!APPEND S S$0) T) (PROCESS-TRACES P)))
   (IN (TR!APPEND S S$0) (PROCESS-TRACES P))))
 (IN (TR!APPEND S S$0) (PROCESS-TRACES P)))
Which simplifies
 when rewriting with TR!APPEND-ASSOCIATIVE
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
IS-PROCESS-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
PROCESS-ALPHABET-AFTER
Beginning proof of PROCESS-ALPHABET-AFTER ...
(IMPLIES (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P)))
 (= (PROCESS-ALPHABET (AFTER P S)) (PROCESS-ALPHABET P)))
Which simplifies
 with invocation of AFTER
 forward chaining using PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, AFTER-IS-PROCESS, IS-PROCESS-BOOL to ...
(TRUE)
PROCESS-TRACES-AFTER
Beginning proof of PROCESS-TRACES-AFTER ...
(IMPLIES (AND (IS-PROCESS P) (IN S (PROCESS-TRACES P)))
 (= (PROCESS-TRACES (AFTER P S)) (TR!SELECT-AFTER S (PROCESS-TRACES P))))
Which simplifies
 with invocation of AFTER
 forward chaining using PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, AFTER-IS-PROCESS, IS-PROCESS-BOOL to ...
(TRUE)
SELECT-PARALLEL-TRACES
PARALLEL
PARALLEL-IS-PROCESS
Beginning proof of PARALLEL-IS-PROCESS ...
(IMPLIES (AND (IS-PROCESS P) (IS-PROCESS Q)) (IS-PROCESS (PARALLEL P Q)))
Which simplifies
 with invocation of PREFIX-CLOSED, TR!RESTRICT, SUBSET, PARALLEL
 when rewriting with TR!RESTRICT-APPEND, TR!IS-TRACE-OF-APPEND,
TR!IS-TRACE-OF-EMPTY, TR!IN-TRACE-OF, SELECT-PARALLEL-TRACES.DEFINITION,
MAKE-PROCESS-IS-PROCESS
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, PREFIX-CLOSED-BOOL,
TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!IS-TRACE-RESTRICT,
TR!IS-TRACE-OF-RESTRICT, TR!IS-TRACE-BOOL, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, IS-PROCESS-BOOL to ...
(IMPLIES (AND (IS-PROCESS P) (IS-PROCESS Q))
 (AND (IN (TR!EMPTY) (PROCESS-TRACES P)) (IN (TR!EMPTY) (PROCESS-TRACES Q))
  (ALL (S T)
   (IMPLIES
    (AND (TR!IS-TRACE S) (TR!IS-TRACE T)
     (TR!IS-TRACE-OF S (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
     (TR!IS-TRACE-OF T (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
     (IN
      (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET P))
       (TR!RESTRICT T (PROCESS-ALPHABET P)))
      (PROCESS-TRACES P))
     (IN
      (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET Q))
       (TR!RESTRICT T (PROCESS-ALPHABET Q)))
      (PROCESS-TRACES Q)))
    (AND (IN (TR!RESTRICT S (PROCESS-ALPHABET P)) (PROCESS-TRACES P))
     (IN (TR!RESTRICT S (PROCESS-ALPHABET Q)) (PROCESS-TRACES Q)))))))
Starting case 3 ...
(IMPLIES (AND (IS-PROCESS P) (IS-PROCESS Q))
 (IN (TR!EMPTY) (PROCESS-TRACES P)))
Invoking (IS-PROCESS P) gives ...
(IMPLIES
 (AND (PAIR!IS-PAIR P)
  (SUBSET (PROCESS-TRACES P) (TR!TRACE-OF (PROCESS-ALPHABET P)))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (IS-PROCESS Q))
 (IN (TR!EMPTY) (PROCESS-TRACES P)))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PAIR!PAIR-COMPOSITION
 with the assumptions IS-PROCESS-BOOL, PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL to ...
(TRUE)
Starting case 2 ...
(IMPLIES (AND (IS-PROCESS P) (IS-PROCESS Q))
 (IN (TR!EMPTY) (PROCESS-TRACES Q)))
Invoking (IS-PROCESS Q) gives ...
(IMPLIES
 (AND (IS-PROCESS P) (PAIR!IS-PAIR Q)
  (SUBSET (PROCESS-TRACES Q) (TR!TRACE-OF (PROCESS-ALPHABET Q)))
  (IN (TR!EMPTY) (PROCESS-TRACES Q)) (PREFIX-CLOSED (PROCESS-TRACES Q)))
 (IN (TR!EMPTY) (PROCESS-TRACES Q)))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PAIR!PAIR-COMPOSITION, PROCESS-COMPOSITION
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (IS-PROCESS P) (IS-PROCESS Q))
 (ALL (S T)
  (IMPLIES
   (AND (TR!IS-TRACE S) (TR!IS-TRACE T)
    (TR!IS-TRACE-OF S (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
    (TR!IS-TRACE-OF T (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
    (IN
     (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET P))
      (TR!RESTRICT T (PROCESS-ALPHABET P)))
     (PROCESS-TRACES P))
    (IN
     (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET Q))
      (TR!RESTRICT T (PROCESS-ALPHABET Q)))
     (PROCESS-TRACES Q)))
   (AND (IN (TR!RESTRICT S (PROCESS-ALPHABET P)) (PROCESS-TRACES P))
    (IN (TR!RESTRICT S (PROCESS-ALPHABET Q)) (PROCESS-TRACES Q))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-PROCESS P) (IS-PROCESS Q) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (TR!IS-TRACE-OF S (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
  (TR!IS-TRACE-OF T (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
  (IN
   (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET P))
    (TR!RESTRICT T (PROCESS-ALPHABET P)))
   (PROCESS-TRACES P))
  (IN
   (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET Q))
    (TR!RESTRICT T (PROCESS-ALPHABET Q)))
   (PROCESS-TRACES Q)))
 (AND (IN (TR!RESTRICT S (PROCESS-ALPHABET P)) (PROCESS-TRACES P))
  (IN (TR!RESTRICT S (PROCESS-ALPHABET Q)) (PROCESS-TRACES Q))))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 (TR!RESTRICT S (PROCESS-ALPHABET P)))
                (= S2 (TR!RESTRICT T (PROCESS-ALPHABET P))) (= P P) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS P) (TR!IS-TRACE (TR!RESTRICT S (PROCESS-ALPHABET P)))
    (TR!IS-TRACE (TR!RESTRICT T (PROCESS-ALPHABET P)))
    (IN
     (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET P))
      (TR!RESTRICT T (PROCESS-ALPHABET P)))
     (PROCESS-TRACES P)))
   (IN (TR!RESTRICT S (PROCESS-ALPHABET P)) (PROCESS-TRACES P)))
  (IS-PROCESS P) (IS-PROCESS Q) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (TR!IS-TRACE-OF S (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
  (TR!IS-TRACE-OF T (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
  (IN
   (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET P))
    (TR!RESTRICT T (PROCESS-ALPHABET P)))
   (PROCESS-TRACES P))
  (IN
   (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET Q))
    (TR!RESTRICT T (PROCESS-ALPHABET Q)))
   (PROCESS-TRACES Q)))
 (AND (IN (TR!RESTRICT S (PROCESS-ALPHABET P)) (PROCESS-TRACES P))
  (IN (TR!RESTRICT S (PROCESS-ALPHABET Q)) (PROCESS-TRACES Q))))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 (TR!RESTRICT S (PROCESS-ALPHABET Q)))
                (= S2 (TR!RESTRICT T (PROCESS-ALPHABET Q))) (= P Q) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS Q) (TR!IS-TRACE (TR!RESTRICT S (PROCESS-ALPHABET Q)))
    (TR!IS-TRACE (TR!RESTRICT T (PROCESS-ALPHABET Q)))
    (IN
     (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET Q))
      (TR!RESTRICT T (PROCESS-ALPHABET Q)))
     (PROCESS-TRACES Q)))
   (IN (TR!RESTRICT S (PROCESS-ALPHABET Q)) (PROCESS-TRACES Q)))
  (IMPLIES
   (AND (IS-PROCESS P) (TR!IS-TRACE (TR!RESTRICT S (PROCESS-ALPHABET P)))
    (TR!IS-TRACE (TR!RESTRICT T (PROCESS-ALPHABET P)))
    (IN
     (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET P))
      (TR!RESTRICT T (PROCESS-ALPHABET P)))
     (PROCESS-TRACES P)))
   (IN (TR!RESTRICT S (PROCESS-ALPHABET P)) (PROCESS-TRACES P)))
  (IS-PROCESS P) (IS-PROCESS Q) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (TR!IS-TRACE-OF S (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
  (TR!IS-TRACE-OF T (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
  (IN
   (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET P))
    (TR!RESTRICT T (PROCESS-ALPHABET P)))
   (PROCESS-TRACES P))
  (IN
   (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET Q))
    (TR!RESTRICT T (PROCESS-ALPHABET Q)))
   (PROCESS-TRACES Q)))
 (AND (IN (TR!RESTRICT S (PROCESS-ALPHABET P)) (PROCESS-TRACES P))
  (IN (TR!RESTRICT S (PROCESS-ALPHABET Q)) (PROCESS-TRACES Q))))
Rearranging gives ...
(IMPLIES
 (AND (IS-PROCESS P) (IS-PROCESS Q) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (TR!IS-TRACE-OF S (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
  (TR!IS-TRACE-OF T (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q)))
  (IN
   (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET P))
    (TR!RESTRICT T (PROCESS-ALPHABET P)))
   (PROCESS-TRACES P))
  (IN
   (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET Q))
    (TR!RESTRICT T (PROCESS-ALPHABET Q)))
   (PROCESS-TRACES Q))
  (IMPLIES
   (AND (IS-PROCESS Q) (TR!IS-TRACE (TR!RESTRICT S (PROCESS-ALPHABET Q)))
    (TR!IS-TRACE (TR!RESTRICT T (PROCESS-ALPHABET Q)))
    (IN
     (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET Q))
      (TR!RESTRICT T (PROCESS-ALPHABET Q)))
     (PROCESS-TRACES Q)))
   (IN (TR!RESTRICT S (PROCESS-ALPHABET Q)) (PROCESS-TRACES Q)))
  (IMPLIES
   (AND (IS-PROCESS P) (TR!IS-TRACE (TR!RESTRICT S (PROCESS-ALPHABET P)))
    (TR!IS-TRACE (TR!RESTRICT T (PROCESS-ALPHABET P)))
    (IN
     (TR!APPEND (TR!RESTRICT S (PROCESS-ALPHABET P))
      (TR!RESTRICT T (PROCESS-ALPHABET P)))
     (PROCESS-TRACES P)))
   (IN (TR!RESTRICT S (PROCESS-ALPHABET P)) (PROCESS-TRACES P))))
 (AND (IN (TR!RESTRICT S (PROCESS-ALPHABET P)) (PROCESS-TRACES P))
  (IN (TR!RESTRICT S (PROCESS-ALPHABET Q)) (PROCESS-TRACES Q))))
Which simplifies
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!IS-TRACE-CONSEQ,
TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-RESTRICT, TR!IS-TRACE-OF-RESTRICT,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
TR!IS-TRACE-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
PROCESS-ALPHABET-PARALLEL
Beginning proof of PROCESS-ALPHABET-PARALLEL ...
(IMPLIES (AND (IS-PROCESS P) (IS-PROCESS Q))
 (= (PROCESS-ALPHABET (PARALLEL P Q))
  (UNION (PROCESS-ALPHABET P) (PROCESS-ALPHABET Q))))
Which simplifies
 with invocation of PARALLEL
 forward chaining using PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, PARALLEL-IS-PROCESS, IS-PROCESS-BOOL to ...
(TRUE)
PROCESS-TRACES-PARALLEL
Beginning proof of PROCESS-TRACES-PARALLEL ...
(IMPLIES (AND (IS-PROCESS P) (IS-PROCESS Q))
 (= (PROCESS-TRACES (PARALLEL P Q)) (SELECT-PARALLEL-TRACES P Q)))
Which simplifies
 with invocation of PARALLEL
 forward chaining using PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, PARALLEL-IS-PROCESS, IS-PROCESS-BOOL to ...
(TRUE)
MAP-PREFIX
PROCESS-CHOICE
GOOD-CHOICE
CHOICE-IS-PROCESS
Beginning proof of CHOICE-IS-PROCESS ...
(IMPLIES (GOOD-CHOICE F A) (IS-PROCESS (PROCESS-CHOICE A F)))
Which simplifies
 with invocation of PREFIX-CLOSED, PROCESS-CHOICE, SUBSET, GOOD-CHOICE
 when rewriting with TR!APPEND-EMPTY-LEFT, TR!APPEND-IS-EMPTY,
SETADD.DEFINITION, MAP-TACK.DEFINITION, MAP-PREFIX.DEFINITION, CUP.DEFINITION,
TR!IS-TRACE-OF-EMPTY, TR!IN-TRACE-OF, SETRULES!SUBSET-SETADD,
MAKE-PROCESS-IS-PROCESS, SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!TACK-HEAD-TAIL,
TR!IS-TRACE-OF-IS-TRACE, TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions TR!APPEND-NOT-EMPTY-LEFT, TR!APPEND-NOT-EMPTY-RIGHT,
TR!IS-TRACE-APPEND, PREFIX-CLOSED-BOOL, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL,
PROCESS-ALPHABET-MAKE-PROCESS, PROCESS-TRACES-MAKE-PROCESS,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to
...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X)
   (IMPLIES (IN X A)
    (AND (IS-PROCESS (FN!APPLY F X))
     (= (PROCESS-ALPHABET (FN!APPLY F X))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))))
 (AND
  (ALL (X$0 S)
   (IMPLIES (AND (IN S (PROCESS-TRACES (FN!APPLY F X$0))) (IN X$0 A))
    (TR!IS-TRACE-OF (TR!TACK X$0 S)
     (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (S$0 T X$1)
   (IMPLIES
    (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T) (NOT (= S$0 (TR!EMPTY)))
     (SOME (S$1)
      (AND (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1)))
       (= (TR!APPEND S$0 T) (TR!TACK X$1 S$1))))
     (IN X$1 A))
    (SOME (X$2)
     (AND
      (SOME (S$2)
       (AND (IN S$2 (PROCESS-TRACES (FN!APPLY F X$2)))
        (= S$0 (TR!TACK X$2 S$2))))
      (IN X$2 A)))))))
Prenexing produces ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$1)
   (IMPLIES (IN X$1 A)
    (AND (IS-PROCESS (FN!APPLY F X$1))
     (= (PROCESS-ALPHABET (FN!APPLY F X$1))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))))
 (AND
  (IMPLIES (AND (IN S (PROCESS-TRACES (FN!APPLY F X))) (IN X A))
   (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
  (IMPLIES
   (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T) (NOT (= S$0 (TR!EMPTY)))
    (IN S$1 (PROCESS-TRACES (FN!APPLY F X$0)))
    (= (TR!APPEND S$0 T) (TR!TACK X$0 S$1)) (IN X$0 A))
   (SOME (X$2)
    (AND
     (SOME (S$2)
      (AND (IN S$2 (PROCESS-TRACES (FN!APPLY F X$2)))
       (= S$0 (TR!TACK X$2 S$2))))
     (IN X$2 A))))))
Starting case 2 ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$1)
   (IMPLIES (IN X$1 A)
    (AND (IS-PROCESS (FN!APPLY F X$1))
     (= (PROCESS-ALPHABET (FN!APPLY F X$1))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (IN S (PROCESS-TRACES (FN!APPLY F X))) (IN X A))
 (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
Instantiating (= E X) gives ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (IMPLIES (IN X A) (IN X (REL!DOM F)))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND (IS-PROCESS (FN!APPLY F X$0))
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (IN S (PROCESS-TRACES (FN!APPLY F X))) (IN X A))
 (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
Instantiating (= E$0 X) gives ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (IMPLIES (IN X A) (IN X (REL!DOM F)))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (IMPLIES (IN X (REL!DOM F))
   (IN X (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND (IS-PROCESS (FN!APPLY F X$0))
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (IN S (PROCESS-TRACES (FN!APPLY F X))) (IN X A))
 (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
Which simplifies
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!TACK-HEAD-TAIL,
TR!IS-TRACE-CONSEQ, PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F) (IN X A) (IN X (REL!DOM F))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (IN X (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND (IS-PROCESS (FN!APPLY F X$0))
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (IN S (PROCESS-TRACES (FN!APPLY F X))))
 (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
Invoking (TR!IS-TRACE-OF (TR!TACK X S)
          (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))) gives
...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F) (IN X A) (IN X (REL!DOM F))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (IN X (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND (IS-PROCESS (FN!APPLY F X$0))
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (IN S (PROCESS-TRACES (FN!APPLY F X))))
 (IF (TR!IS-EMPTY (TR!TACK X S)) (= (TR!TACK X S) (TR!EMPTY))
  (AND (IN (TR!HEAD (TR!TACK X S)) (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
   (TR!IS-TRACE-OF (TR!TAIL (TR!TACK X S))
    (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
Which simplifies
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!TACK-HEAD-TAIL,
TR!IS-TRACE-CONSEQ, PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL,
IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F) (IN X A) (IN X (REL!DOM F))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (IN X (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND (IS-PROCESS (FN!APPLY F X$0))
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (IN S (PROCESS-TRACES (FN!APPLY F X))))
 (TR!IS-TRACE-OF (TR!TAIL (TR!TACK X S))
  (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
Instantiating (= X$0 X) gives ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F) (IN X A) (IN X (REL!DOM F))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (IN X (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (IMPLIES (IN X A)
   (AND (IS-PROCESS (FN!APPLY F X))
    (= (PROCESS-ALPHABET (FN!APPLY F X))
     (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND (IS-PROCESS (FN!APPLY F X$0))
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (IN S (PROCESS-TRACES (FN!APPLY F X))))
 (TR!IS-TRACE-OF (TR!TAIL (TR!TACK X S))
  (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S S) (= P (FN!APPLY F X)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS (FN!APPLY F X)) (IN S (PROCESS-TRACES (FN!APPLY F X))))
   (TR!IS-TRACE-OF S (PROCESS-ALPHABET (FN!APPLY F X))))
  (NOT (= A (NULLSET))) (FN!IS-FUNCTION F) (IN X A) (IN X (REL!DOM F))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (IN X (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (IMPLIES (IN X A)
   (AND (IS-PROCESS (FN!APPLY F X))
    (= (PROCESS-ALPHABET (FN!APPLY F X))
     (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND (IS-PROCESS (FN!APPLY F X$0))
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (IN S (PROCESS-TRACES (FN!APPLY F X))))
 (TR!IS-TRACE-OF (TR!TAIL (TR!TACK X S))
  (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, FN!FUNCTION-IS-RELATION,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL,
TR!IS-EMPTY-BOOL, FN!IS-FUNCTION-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$1)
   (IMPLIES (IN X$1 A)
    (AND (IS-PROCESS (FN!APPLY F X$1))
     (= (PROCESS-ALPHABET (FN!APPLY F X$1))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (TR!IS-TRACE S$0) (TR!IS-TRACE T) (NOT (= S$0 (TR!EMPTY)))
  (IN S$1 (PROCESS-TRACES (FN!APPLY F X$0)))
  (= (TR!APPEND S$0 T) (TR!TACK X$0 S$1)) (IN X$0 A))
 (SOME (X$2)
  (AND
   (SOME (S$2)
    (AND (IN S$2 (PROCESS-TRACES (FN!APPLY F X$2)))
     (= S$0 (TR!TACK X$2 S$2))))
   (IN X$2 A))))
Instantiating (= X$1 X$0) gives ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (IMPLIES (IN X A)
   (AND (IS-PROCESS (FN!APPLY F X))
    (= (PROCESS-ALPHABET (FN!APPLY F X))
     (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND (IS-PROCESS (FN!APPLY F X$0))
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (TR!IS-TRACE S) (TR!IS-TRACE T) (NOT (= S (TR!EMPTY)))
  (IN S$0 (PROCESS-TRACES (FN!APPLY F X))) (= (TR!APPEND S T) (TR!TACK X S$0))
  (IN X A))
 (SOME (X$1)
  (AND
   (SOME (S$1)
    (AND (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))) (= S (TR!TACK X$1 S$1))))
   (IN X$1 A))))
Invoking (TR!APPEND S T) gives ...
(IMPLIES
 (AND (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (IMPLIES (IN X A)
   (AND (IS-PROCESS (FN!APPLY F X))
    (= (PROCESS-ALPHABET (FN!APPLY F X))
     (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND (IS-PROCESS (FN!APPLY F X$0))
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
  (TR!IS-TRACE S) (TR!IS-TRACE T) (NOT (= S (TR!EMPTY)))
  (IN S$0 (PROCESS-TRACES (FN!APPLY F X)))
  (= (IF (TR!IS-EMPTY S) T (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)))
   (TR!TACK X S$0))
  (IN X A))
 (SOME (X$1)
  (AND
   (SOME (S$1)
    (AND (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))) (= S (TR!TACK X$1 S$1))))
   (IN X$1 A))))
Rearranging gives ...
(IMPLIES
 (AND
  (= (IF (TR!IS-EMPTY S) T (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)))
   (TR!TACK X S$0))
  (NOT (= A (NULLSET))) (FN!IS-FUNCTION F) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (NOT (= S (TR!EMPTY))) (IN S$0 (PROCESS-TRACES (FN!APPLY F X))) (IN X A)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (IMPLIES (IN X A)
   (AND
    (= (PROCESS-ALPHABET (FN!APPLY F X))
     (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
    (IS-PROCESS (FN!APPLY F X))))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
     (IS-PROCESS (FN!APPLY F X$0))))))
 (SOME (X$1)
  (AND (IN X$1 A)
   (SOME (S$1)
    (AND (= S (TR!TACK X$1 S$1))
     (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))))))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, TR!NOT-IS-TRACE-IS-EMPTY,
FN!FUNCTION-IS-RELATION, TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!TACK-HEAD-TAIL
 with the assumptions IS-PROCESS-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
FN!IS-FUNCTION-BOOL, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!IS-TRACE-BOOL, TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!IS-EMPTY-BOOL to ...
(IMPLIES
 (AND (NOT (TR!IS-EMPTY S))
  (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0))
  (NOT (= A (NULLSET))) (FN!IS-FUNCTION F) (TR!IS-TRACE T)
  (IN S$0 (PROCESS-TRACES (FN!APPLY F X))) (IN X A)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (= (PROCESS-ALPHABET (FN!APPLY F X))
   (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (IS-PROCESS (FN!APPLY F X))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
     (IS-PROCESS (FN!APPLY F X$0))))))
 (SOME (X$1)
  (AND (IN X$1 A)
   (SOME (S$1)
    (AND (= S (TR!TACK X$1 S$1))
     (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))))))))
Applying TR!TACK-SAME gives ...
(IMPLIES
 (AND (NOT (TR!IS-EMPTY S))
  (IF (AND (TR!IS-TRACE (TR!APPEND (TR!TAIL S) T)) (TR!IS-TRACE S$0))
   (AND (= (TR!HEAD S) X) (= (TR!APPEND (TR!TAIL S) T) S$0))
   (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0)))
  (NOT (= A (NULLSET))) (FN!IS-FUNCTION F) (TR!IS-TRACE T)
  (IN S$0 (PROCESS-TRACES (FN!APPLY F X))) (IN X A)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (= (PROCESS-ALPHABET (FN!APPLY F X))
   (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (IS-PROCESS (FN!APPLY F X))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
     (IS-PROCESS (FN!APPLY F X$0))))))
 (SOME (X$1)
  (AND (IN X$1 A)
   (SOME (S$1)
    (AND (= S (TR!TACK X$1 S$1))
     (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))))))))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 (TR!TAIL S)) (= S2 T) (= P (FN!APPLY F X)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS (FN!APPLY F X)) (TR!IS-TRACE (TR!TAIL S)) (TR!IS-TRACE T)
    (IN (TR!APPEND (TR!TAIL S) T) (PROCESS-TRACES (FN!APPLY F X))))
   (IN (TR!TAIL S) (PROCESS-TRACES (FN!APPLY F X))))
  (NOT (TR!IS-EMPTY S))
  (IF (AND (TR!IS-TRACE (TR!APPEND (TR!TAIL S) T)) (TR!IS-TRACE S$0))
   (AND (= (TR!HEAD S) X) (= (TR!APPEND (TR!TAIL S) T) S$0))
   (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0)))
  (NOT (= A (NULLSET))) (FN!IS-FUNCTION F) (TR!IS-TRACE T)
  (IN S$0 (PROCESS-TRACES (FN!APPLY F X))) (IN X A)
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (= (PROCESS-ALPHABET (FN!APPLY F X))
   (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (IS-PROCESS (FN!APPLY F X))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
     (IS-PROCESS (FN!APPLY F X$0))))))
 (SOME (X$1)
  (AND (IN X$1 A)
   (SOME (S$1)
    (AND (= S (TR!TACK X$1 S$1))
     (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))))))))
Rearranging gives ...
(IMPLIES
 (AND
  (= (PROCESS-ALPHABET (FN!APPLY F X))
   (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (NOT (TR!IS-EMPTY S)) (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (TR!IS-TRACE T) (IN S$0 (PROCESS-TRACES (FN!APPLY F X))) (IN X A)
  (IS-PROCESS (FN!APPLY F X))
  (IMPLIES
   (AND (IS-PROCESS (FN!APPLY F X)) (TR!IS-TRACE (TR!TAIL S)) (TR!IS-TRACE T)
    (IN (TR!APPEND (TR!TAIL S) T) (PROCESS-TRACES (FN!APPLY F X))))
   (IN (TR!TAIL S) (PROCESS-TRACES (FN!APPLY F X))))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (IF (AND (TR!IS-TRACE (TR!APPEND (TR!TAIL S) T)) (TR!IS-TRACE S$0))
   (AND (= (TR!HEAD S) X) (= (TR!APPEND (TR!TAIL S) T) S$0))
   (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0)))
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
     (IS-PROCESS (FN!APPLY F X$0))))))
 (SOME (X$1)
  (AND (IN X$1 A)
   (SOME (S$1)
    (AND (= S (TR!TACK X$1 S$1))
     (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))))))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, TR!NOT-IS-TRACE-IS-EMPTY,
FN!FUNCTION-IS-RELATION, TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!TACK-HEAD-TAIL
 with the assumptions TR!TAIL-TACK-EMPTY, TR!TAIL-TACK-SEQ, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!IS-TRACE-APPEND, TR!IS-TRACE-TAIL,
TR!SIZE-TAIL, IS-PROCESS-BOOL, TR!IS-TRACE-BOOL, FN!IS-FUNCTION-BOOL,
TR!IS-EMPTY-BOOL to ...
(IMPLIES
 (AND
  (= (PROCESS-ALPHABET (FN!APPLY F X))
   (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (NOT (TR!IS-EMPTY S)) (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (TR!IS-TRACE T) (IN S$0 (PROCESS-TRACES (FN!APPLY F X))) (IN X A)
  (IS-PROCESS (FN!APPLY F X)))
 (IF (IN (TR!APPEND (TR!TAIL S) T) (PROCESS-TRACES (FN!APPLY F X)))
  (IMPLIES
   (AND (IN (TR!TAIL S) (PROCESS-TRACES (FN!APPLY F X)))
    (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
    (ALL (E$0)
     (IMPLIES (IN E$0 (REL!DOM F))
      (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
   (IF (TR!IS-TRACE S$0)
    (IMPLIES
     (AND (= (TR!HEAD S) X) (= (TR!APPEND (TR!TAIL S) T) S$0)
      (ALL (X$0)
       (IMPLIES (IN X$0 A)
        (AND
         (= (PROCESS-ALPHABET (FN!APPLY F X$0))
          (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
         (IS-PROCESS (FN!APPLY F X$0))))))
     (SOME (X$1)
      (AND (IN X$1 A)
       (SOME (S$1)
        (AND (= S (TR!TACK X$1 S$1))
         (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))))))))
    (IMPLIES
     (AND (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0))
      (ALL (X$2)
       (IMPLIES (IN X$2 A)
        (AND
         (= (PROCESS-ALPHABET (FN!APPLY F X$2))
          (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
         (IS-PROCESS (FN!APPLY F X$2))))))
     (SOME (X$3)
      (AND (IN X$3 A)
       (SOME (S$2)
        (AND (= S (TR!TACK X$3 S$2))
         (IN S$2 (PROCESS-TRACES (FN!APPLY F X$3))))))))))
  (IMPLIES
   (AND (ALL (E$1) (IMPLIES (IN E$1 A) (IN E$1 (REL!DOM F))))
    (ALL (E$2)
     (IMPLIES (IN E$2 (REL!DOM F))
      (IN E$2 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
    (NOT (TR!IS-TRACE S$0))
    (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0))
    (ALL (X$4)
     (IMPLIES (IN X$4 A)
      (AND
       (= (PROCESS-ALPHABET (FN!APPLY F X$4))
        (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
       (IS-PROCESS (FN!APPLY F X$4))))))
   (SOME (X$5)
    (AND (IN X$5 A)
     (SOME (S$3)
      (AND (= S (TR!TACK X$5 S$3))
       (IN S$3 (PROCESS-TRACES (FN!APPLY F X$5))))))))))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S S$0) (= P (FN!APPLY F X)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS (FN!APPLY F X)) (IN S$0 (PROCESS-TRACES (FN!APPLY F X))))
   (TR!IS-TRACE-OF S$0 (PROCESS-ALPHABET (FN!APPLY F X))))
  (= (PROCESS-ALPHABET (FN!APPLY F X))
   (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (NOT (TR!IS-EMPTY S)) (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (TR!IS-TRACE T) (IN S$0 (PROCESS-TRACES (FN!APPLY F X))) (IN X A)
  (IS-PROCESS (FN!APPLY F X)))
 (IF (IN (TR!APPEND (TR!TAIL S) T) (PROCESS-TRACES (FN!APPLY F X)))
  (IMPLIES
   (AND (IN (TR!TAIL S) (PROCESS-TRACES (FN!APPLY F X)))
    (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
    (ALL (E$0)
     (IMPLIES (IN E$0 (REL!DOM F))
      (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))))
   (IF (TR!IS-TRACE S$0)
    (IMPLIES
     (AND (= (TR!HEAD S) X) (= (TR!APPEND (TR!TAIL S) T) S$0)
      (ALL (X$0)
       (IMPLIES (IN X$0 A)
        (AND
         (= (PROCESS-ALPHABET (FN!APPLY F X$0))
          (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
         (IS-PROCESS (FN!APPLY F X$0))))))
     (SOME (X$1)
      (AND (IN X$1 A)
       (SOME (S$1)
        (AND (= S (TR!TACK X$1 S$1))
         (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))))))))
    (IMPLIES
     (AND (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0))
      (ALL (X$2)
       (IMPLIES (IN X$2 A)
        (AND
         (= (PROCESS-ALPHABET (FN!APPLY F X$2))
          (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
         (IS-PROCESS (FN!APPLY F X$2))))))
     (SOME (X$3)
      (AND (IN X$3 A)
       (SOME (S$2)
        (AND (= S (TR!TACK X$3 S$2))
         (IN S$2 (PROCESS-TRACES (FN!APPLY F X$3))))))))))
  (IMPLIES
   (AND (ALL (E$1) (IMPLIES (IN E$1 A) (IN E$1 (REL!DOM F))))
    (ALL (E$2)
     (IMPLIES (IN E$2 (REL!DOM F))
      (IN E$2 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
    (NOT (TR!IS-TRACE S$0))
    (= (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)) (TR!TACK X S$0))
    (ALL (X$4)
     (IMPLIES (IN X$4 A)
      (AND
       (= (PROCESS-ALPHABET (FN!APPLY F X$4))
        (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
       (IS-PROCESS (FN!APPLY F X$4))))))
   (SOME (X$5)
    (AND (IN X$5 A)
     (SOME (S$3)
      (AND (= S (TR!TACK X$5 S$3))
       (IN S$3 (PROCESS-TRACES (FN!APPLY F X$5))))))))))
Which simplifies
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, FN!FUNCTION-IS-RELATION,
TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!IS-TRACE-APPEND, TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!IS-TRACE-BOOL,
FN!IS-FUNCTION-BOOL, TR!IS-EMPTY-BOOL, IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS (FN!APPLY F X)) (IN S$0 (PROCESS-TRACES (FN!APPLY F X)))
  (TR!IS-TRACE-OF S$0 (PROCESS-ALPHABET (FN!APPLY F X)))
  (= (PROCESS-ALPHABET (FN!APPLY F X))
   (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (NOT (TR!IS-EMPTY S)) (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (TR!IS-TRACE T) (IN X A)
  (IN (TR!APPEND (TR!TAIL S) T) (PROCESS-TRACES (FN!APPLY F X)))
  (IN (TR!TAIL S) (PROCESS-TRACES (FN!APPLY F X)))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (= (TR!HEAD S) X) (= (TR!APPEND (TR!TAIL S) T) S$0)
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
     (IS-PROCESS (FN!APPLY F X$0))))))
 (SOME (X$1)
  (AND (IN X$1 A)
   (SOME (S$1)
    (AND (= S (TR!TACK X$1 S$1))
     (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))))))))
Instantiating (= X$1 X) (= S$1 (TR!TAIL S)) gives ...
(IMPLIES
 (AND (IS-PROCESS (FN!APPLY F X)) (IN S (PROCESS-TRACES (FN!APPLY F X)))
  (TR!IS-TRACE-OF S (PROCESS-ALPHABET (FN!APPLY F X)))
  (= (PROCESS-ALPHABET (FN!APPLY F X))
   (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
  (NOT (TR!IS-EMPTY S$0)) (NOT (= A (NULLSET))) (FN!IS-FUNCTION F)
  (TR!IS-TRACE T) (IN X A)
  (IN (TR!APPEND (TR!TAIL S$0) T) (PROCESS-TRACES (FN!APPLY F X)))
  (IN (TR!TAIL S$0) (PROCESS-TRACES (FN!APPLY F X)))
  (ALL (E) (IMPLIES (IN E A) (IN E (REL!DOM F))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!DOM F))
    (IN E$0 (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))))
  (= (TR!HEAD S$0) X) (= (TR!APPEND (TR!TAIL S$0) T) S)
  (ALL (X$0)
   (IMPLIES (IN X$0 A)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY F X$0))
      (PROCESS-ALPHABET (FN!APPLY F (CHOICE A))))
     (IS-PROCESS (FN!APPLY F X$0)))))
  (NOT
   (AND (IN X A) (= S$0 (TR!TACK X (TR!TAIL S$0)))
    (IN (TR!TAIL S$0) (PROCESS-TRACES (FN!APPLY F X))))))
 (SOME (X$1 S$1)
  (AND (IN X$1 A) (= S$0 (TR!TACK X$1 S$1))
   (IN S$1 (PROCESS-TRACES (FN!APPLY F X$1))))))
Which simplifies
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, FN!FUNCTION-IS-RELATION,
TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-APPEND, TR!IS-TRACE-TAIL, TR!SIZE-TAIL,
TR!IS-TRACE-BOOL, FN!IS-FUNCTION-BOOL, TR!IS-EMPTY-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
PROCESS-ALPHABET-CHOICE
Beginning proof of PROCESS-ALPHABET-CHOICE ...
(IMPLIES (GOOD-CHOICE F A)
 (= (PROCESS-ALPHABET (PROCESS-CHOICE A F))
  (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
Which simplifies
 with invocation of PROCESS-CHOICE
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
CHOICE-IS-PROCESS to ...
(TRUE)
PROCESS-TRACES-CHOICE
Beginning proof of PROCESS-TRACES-CHOICE ...
(IMPLIES (GOOD-CHOICE F A)
 (= (PROCESS-TRACES (PROCESS-CHOICE A F))
  (UNION (UNIT (TR!EMPTY)) (CUP (MAP-PREFIX A F)))))
Which simplifies
 with invocation of PROCESS-CHOICE
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
CHOICE-IS-PROCESS to ...
(TRUE)
IS-COMM
MAKE-COMM
CHANNEL
MESSAGE
IS-COMM-BOOL
Beginning proof of IS-COMM-BOOL ...
(= (TYPE-OF (IS-COMM X)) (BOOL))
Which simplifies
 with invocation of IS-COMM
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL to ...
(TRUE)
CHANNEL-COMM
Beginning proof of CHANNEL-COMM ...
(= (CHANNEL (MAKE-COMM X Y)) X)
Which simplifies
 with invocation of CHANNEL, MAKE-COMM
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
MESSAGE-COMM
Beginning proof of MESSAGE-COMM ...
(= (MESSAGE (MAKE-COMM X Y)) Y)
Which simplifies
 with invocation of MESSAGE, MAKE-COMM
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
CHANNEL-COMM to ...
(TRUE)
MAKE-COMM-IS-COMM
Beginning proof of MAKE-COMM-IS-COMM ...
(IS-COMM (MAKE-COMM X Y))
Which simplifies
 with invocation of IS-COMM, MAKE-COMM
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, IS-COMM-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, CHANNEL-COMM, MESSAGE-COMM to ...
(TRUE)
COMM-COMPOSITION
Beginning proof of COMM-COMPOSITION ...
(IMPLIES (IS-COMM X) (= (MAKE-COMM (CHANNEL X) (MESSAGE X)) X))
Which simplifies
 with invocation of MAKE-COMM, MESSAGE, CHANNEL, IS-COMM
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
CHANNEL-COMM, MESSAGE-COMM, MAKE-COMM-IS-COMM, PAIR!IS-PAIR-BOOL,
IS-COMM-BOOL to ...
(TRUE)
SELECT-COMM
PROCESS-MESSAGES
OUTPUT
OUTPUT-IS-PROCESS
Beginning proof of OUTPUT-IS-PROCESS ...
(IMPLIES (AND (IS-PROCESS P) (IN V (PROCESS-MESSAGES C P)))
 (IS-PROCESS (OUTPUT C V P)))
Which simplifies
 with invocation of OUTPUT
 when rewriting with SELECT-COMM.DEFINITION, PROCESS-MESSAGES.DEFINITION
 forward chaining using COMM-COMPOSITION, PROCESS-COMPOSITION
 with the assumptions CHANNEL-COMM, MESSAGE-COMM, MAKE-COMM-IS-COMM,
IS-COMM-BOOL, IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P)
  (SOME (X)
   (AND (IN X (PROCESS-ALPHABET P)) (IS-COMM X) (= (CHANNEL X) C)
    (= V (MESSAGE X)))))
 (IS-PROCESS (PREFIX (MAKE-COMM C V) P)))
Prenexing produces ...
(IMPLIES
 (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (IS-COMM X) (= (CHANNEL X) C)
  (= V (MESSAGE X)))
 (IS-PROCESS (PREFIX (MAKE-COMM C V) P)))
Which simplifies
 forward chaining using COMM-COMPOSITION, PROCESS-COMPOSITION
 with the assumptions PREFIX-IS-PROCESS, CHANNEL-COMM, MESSAGE-COMM,
MAKE-COMM-IS-COMM, IS-COMM-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
PROCESS-ALPHABET-OUTPUT
Beginning proof of PROCESS-ALPHABET-OUTPUT ...
(IMPLIES (AND (IS-PROCESS P) (IN V (PROCESS-MESSAGES C P)))
 (= (PROCESS-ALPHABET (OUTPUT C V P)) (PROCESS-ALPHABET P)))
Which simplifies
 with invocation of OUTPUT
 when rewriting with SELECT-COMM.DEFINITION, PROCESS-MESSAGES.DEFINITION
 forward chaining using COMM-COMPOSITION, PROCESS-COMPOSITION
 with the assumptions CHANNEL-COMM, MESSAGE-COMM, MAKE-COMM-IS-COMM,
IS-COMM-BOOL, IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P)
  (SOME (X)
   (AND (IN X (PROCESS-ALPHABET P)) (IS-COMM X) (= (CHANNEL X) C)
    (= V (MESSAGE X)))))
 (= (PROCESS-ALPHABET (PREFIX (MAKE-COMM C V) P)) (PROCESS-ALPHABET P)))
Prenexing produces ...
(IMPLIES
 (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (IS-COMM X) (= (CHANNEL X) C)
  (= V (MESSAGE X)))
 (= (PROCESS-ALPHABET (PREFIX (MAKE-COMM C V) P)) (PROCESS-ALPHABET P)))
Which simplifies
 when rewriting with PROCESS-ALPHABET-PREFIX
 forward chaining using COMM-COMPOSITION, PROCESS-COMPOSITION
 with the assumptions PREFIX-IS-PROCESS, CHANNEL-COMM, MESSAGE-COMM,
MAKE-COMM-IS-COMM, IS-COMM-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
PROCESS-TRACES-OUTPUT
Beginning proof of PROCESS-TRACES-OUTPUT ...
(IMPLIES (AND (IS-PROCESS P) (IN V (PROCESS-MESSAGES C P)))
 (= (PROCESS-TRACES (OUTPUT C V P))
  (UNION (UNIT (TR!EMPTY)) (MAP-TACK (MAKE-COMM C V) (PROCESS-TRACES P)))))
Which simplifies
 with invocation of OUTPUT
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD, SELECT-COMM.DEFINITION,
PROCESS-MESSAGES.DEFINITION
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
COMM-COMPOSITION, PROCESS-COMPOSITION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
CHANNEL-COMM, MESSAGE-COMM, MAKE-COMM-IS-COMM, IS-COMM-BOOL,
IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P)
  (SOME (X)
   (AND (IN X (PROCESS-ALPHABET P)) (IS-COMM X) (= (CHANNEL X) C)
    (= V (MESSAGE X)))))
 (= (PROCESS-TRACES (PREFIX (MAKE-COMM C V) P))
  (SETADD (TR!EMPTY) (MAP-TACK (MAKE-COMM C V) (PROCESS-TRACES P)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-PROCESS P) (IN X (PROCESS-ALPHABET P)) (IS-COMM X) (= (CHANNEL X) C)
  (= V (MESSAGE X)))
 (= (PROCESS-TRACES (PREFIX (MAKE-COMM C V) P))
  (SETADD (TR!EMPTY) (MAP-TACK (MAKE-COMM C V) (PROCESS-TRACES P)))))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD, PROCESS-TRACES-PREFIX
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
COMM-COMPOSITION, PROCESS-COMPOSITION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
PREFIX-IS-PROCESS, CHANNEL-COMM, MESSAGE-COMM, MAKE-COMM-IS-COMM,
IS-COMM-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
INPUT
INPUT-IS-PROCESS
Beginning proof of INPUT-IS-PROCESS ...
(IMPLIES (GOOD-CHOICE F (SELECT-COMM C (REL!DOM F))) (IS-PROCESS (INPUT C F)))
Which simplifies
 with invocation of INPUT
 forward chaining using PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL, CHOICE-IS-PROCESS to ...
(TRUE)
PROCESS-ALPHABET-INPUT
Beginning proof of PROCESS-ALPHABET-INPUT ...
(IMPLIES (GOOD-CHOICE F (SELECT-COMM C (REL!DOM F)))
 (= (PROCESS-ALPHABET (INPUT C F))
  (PROCESS-ALPHABET (FN!APPLY F (CHOICE (SELECT-COMM C (REL!DOM F)))))))
Which simplifies
 with invocation of INPUT
 when rewriting with PROCESS-ALPHABET-CHOICE
 forward chaining using PROCESS-COMPOSITION
 with the assumptions CHOICE-IS-PROCESS, INPUT-IS-PROCESS to ...
(TRUE)
PROCESS-TRACES-INPUT
Beginning proof of PROCESS-TRACES-INPUT ...
(IMPLIES (GOOD-CHOICE F (SELECT-COMM C (REL!DOM F)))
 (= (PROCESS-TRACES (INPUT C F))
  (UNION (UNIT (TR!EMPTY)) (CUP (MAP-PREFIX (SELECT-COMM C (REL!DOM F)) F)))))
Which simplifies
 with invocation of INPUT
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD, PROCESS-TRACES-CHOICE
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
CHOICE-IS-PROCESS, INPUT-IS-PROCESS to ...
(TRUE)
IS-SEQUENTIAL-PROCESS
SKIP
SKIP-IS-SEQUENTIAL-PROCESS
Beginning proof of SKIP-IS-SEQUENTIAL-PROCESS ...
(IMPLIES (IN E A) (IS-SEQUENTIAL-PROCESS (SKIP A E) E))
Which simplifies
 with invocation of TR!BUT-LAST, TR!OCCURS, IS-SEQUENTIAL-PROCESS, SKIP
 when rewriting with TR!APPEND-EMPTY-LEFT, NULLSET.DEFINITION,
SETADD.DEFINITION, SUBSET.NULLSET.LEFT, TR!IS-TRACE-OF-TACK,
TR!IS-TRACE-OF-EMPTY, TR!IN-TRACE-OF, SETRULES!SUBSET-SETADD,
MAKE-PROCESS-IS-PROCESS
 forward chaining using TR!OCCURS-IMPLIES-NOT-EMPTY, TR!IS-TRACE-OF-IS-TRACE,
PROCESS-COMPOSITION, TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!IS-TRACE-TAIL, TR!SIZE-TAIL, TR!BUT-LAST-IS-TRACE, PREFIX-CLOSED-BOOL,
IS-PROCESS-BOOL, PROCESS-ALPHABET-MAKE-PROCESS, PROCESS-TRACES-MAKE-PROCESS,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY to ...
(IMPLIES (IN E A)
 (PREFIX-CLOSED (SETADD (TR!EMPTY) (SETADD (TR!TACK E (TR!EMPTY)) (NULLSET)))))
Invoking PREFIX-CLOSED gives ...
(IMPLIES (IN E A)
 (ALL (S T)
  (IMPLIES
   (AND (TR!IS-TRACE S) (TR!IS-TRACE T)
    (IN (TR!APPEND S T)
     (SETADD (TR!EMPTY) (SETADD (TR!TACK E (TR!EMPTY)) (NULLSET)))))
   (IN S (SETADD (TR!EMPTY) (SETADD (TR!TACK E (TR!EMPTY)) (NULLSET)))))))
Invoking TR!APPEND gives ...
(IMPLIES (IN E A)
 (ALL (S T)
  (IMPLIES
   (AND (TR!IS-TRACE S) (TR!IS-TRACE T)
    (IN (IF (TR!IS-EMPTY S) T (TR!TACK (TR!HEAD S) (TR!APPEND (TR!TAIL S) T)))
     (SETADD (TR!EMPTY) (SETADD (TR!TACK E (TR!EMPTY)) (NULLSET)))))
   (IN S (SETADD (TR!EMPTY) (SETADD (TR!TACK E (TR!EMPTY)) (NULLSET)))))))
Which simplifies
 when rewriting with TR!APPEND-IS-EMPTY, TR!TACK-SAME, NULLSET.DEFINITION,
SETADD.DEFINITION
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ,
TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY
 with the assumptions TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-APPEND, TR!IS-TRACE-TAIL, TR!SIZE-TAIL,
TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL to ...
(TRUE)
PROCESS-ALPHABET-SKIP
Beginning proof of PROCESS-ALPHABET-SKIP ...
(IMPLIES (IN E A) (= (PROCESS-ALPHABET (SKIP A E)) A))
Which simplifies
 with invocation of SKIP
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
SKIP-IS-SEQUENTIAL-PROCESS to ...
(TRUE)
PROCESS-TRACES-SKIP
Beginning proof of PROCESS-TRACES-SKIP ...
(IMPLIES (IN E A)
 (= (PROCESS-TRACES (SKIP A E))
  (SETADD (TR!EMPTY) (SETADD (TR!TACK E (TR!EMPTY)) (NULLSET)))))
Which simplifies
 with invocation of SKIP
 forward chaining using TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
SKIP-IS-SEQUENTIAL-PROCESS to ...
(TRUE)
IS-SEQUENTIAL-PROCESS-FRULE
Beginning proof of IS-SEQUENTIAL-PROCESS-FRULE ...
(IMPLIES (IS-SEQUENTIAL-PROCESS P E) (IS-PROCESS P))
Which simplifies
 with invocation of IS-SEQUENTIAL-PROCESS
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE, IS-PROCESS-BOOL to ...
(TRUE)
SELECT-TERMINATED-TRACES
MAP-STRIP-TRAILING-EVENT
MAP-APPEND
COMPOSE
TERMINATING-TRACE-LEMMA
Beginning proof of TERMINATING-TRACE-LEMMA ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P E) (IN S (PROCESS-TRACES P)) (TR!OCCURS E S))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST S)))
  (= S (TR!APPEND (TR!BUT-LAST S) (TR!TACK E (TR!EMPTY))))))
Invoking IS-SEQUENTIAL-PROCESS gives ...
(IMPLIES
 (AND (IS-PROCESS P) (IN E (PROCESS-ALPHABET P))
  (ALL (T)
   (IMPLIES (AND (IN T (PROCESS-TRACES P)) (TR!OCCURS E T))
    (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
     (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY)))))))
  (IN S (PROCESS-TRACES P)) (TR!OCCURS E S))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST S)))
  (= S (TR!APPEND (TR!BUT-LAST S) (TR!TACK E (TR!EMPTY))))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE, IS-PROCESS-BOOL
 with the instantiation (= T S) to ...
(TRUE)
APPEND-IN-PROCESS-TRACES-ALPHABET
Beginning proof of APPEND-IN-PROCESS-TRACES-ALPHABET ...
(IMPLIES
 (AND (IS-PROCESS P) (TR!IS-TRACE S1) (TR!IS-TRACE S2)
  (IN (TR!APPEND S1 S2) (PROCESS-TRACES P)))
 (AND (TR!IS-TRACE-OF S1 (PROCESS-ALPHABET P))
  (TR!IS-TRACE-OF S2 (PROCESS-ALPHABET P))))
Invoking IS-PROCESS gives ...
(IMPLIES
 (AND (PAIR!IS-PAIR P)
  (SUBSET (PROCESS-TRACES P) (TR!TRACE-OF (PROCESS-ALPHABET P)))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (TR!IS-TRACE S1) (TR!IS-TRACE S2) (IN (TR!APPEND S1 S2) (PROCESS-TRACES P)))
 (AND (TR!IS-TRACE-OF S1 (PROCESS-ALPHABET P))
  (TR!IS-TRACE-OF S2 (PROCESS-ALPHABET P))))
Which simplifies
 with invocation of SUBSET
 when rewriting with TR!IN-TRACE-OF
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PAIR!PAIR-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL to
...
(IMPLIES
 (AND (PAIR!IS-PAIR P)
  (ALL (E)
   (IMPLIES (IN E (PROCESS-TRACES P))
    (TR!IS-TRACE-OF E (PROCESS-ALPHABET P))))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (TR!IS-TRACE S1) (TR!IS-TRACE S2) (IN (TR!APPEND S1 S2) (PROCESS-TRACES P)))
 (AND (TR!IS-TRACE-OF S1 (PROCESS-ALPHABET P))
  (TR!IS-TRACE-OF S2 (PROCESS-ALPHABET P))))
Instantiating (= E (TR!APPEND S1 S2)) gives ...
(IMPLIES
 (AND (PAIR!IS-PAIR P)
  (IMPLIES (IN (TR!APPEND S1 S2) (PROCESS-TRACES P))
   (TR!IS-TRACE-OF (TR!APPEND S1 S2) (PROCESS-ALPHABET P)))
  (ALL (E)
   (IMPLIES (IN E (PROCESS-TRACES P))
    (TR!IS-TRACE-OF E (PROCESS-ALPHABET P))))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (TR!IS-TRACE S1) (TR!IS-TRACE S2) (IN (TR!APPEND S1 S2) (PROCESS-TRACES P)))
 (AND (TR!IS-TRACE-OF S1 (PROCESS-ALPHABET P))
  (TR!IS-TRACE-OF S2 (PROCESS-ALPHABET P))))
Rearranging gives ...
(IMPLIES
 (AND (PAIR!IS-PAIR P) (IN (TR!EMPTY) (PROCESS-TRACES P))
  (PREFIX-CLOSED (PROCESS-TRACES P)) (TR!IS-TRACE S1) (TR!IS-TRACE S2)
  (IN (TR!APPEND S1 S2) (PROCESS-TRACES P))
  (IMPLIES (IN (TR!APPEND S1 S2) (PROCESS-TRACES P))
   (TR!IS-TRACE-OF (TR!APPEND S1 S2) (PROCESS-ALPHABET P)))
  (ALL (E)
   (IMPLIES (IN E (PROCESS-TRACES P))
    (TR!IS-TRACE-OF E (PROCESS-ALPHABET P)))))
 (AND (TR!IS-TRACE-OF S1 (PROCESS-ALPHABET P))
  (TR!IS-TRACE-OF S2 (PROCESS-ALPHABET P))))
Which simplifies
 when rewriting with TR!IS-TRACE-OF-APPEND
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, PAIR!PAIR-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL to
...
(TRUE)
LEFT-APPEND-TERMINATES
Beginning proof of LEFT-APPEND-TERMINATES ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P E) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P)) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 S) (= S2 T) (= P P) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS P) (TR!IS-TRACE S) (TR!IS-TRACE T)
    (IN (TR!APPEND S T) (PROCESS-TRACES P)))
   (IN S (PROCESS-TRACES P)))
  (IS-SEQUENTIAL-PROCESS P E) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P)) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY, PROCESS-COMPOSITION
 with the assumptions TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL, IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P)) (IN S (PROCESS-TRACES P))
  (IS-SEQUENTIAL-PROCESS P E) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Splitting on (TR!OCCURS E (TR!APPEND S T)) generates ...
(IF (TR!OCCURS E (TR!APPEND S T))
 (IMPLIES
  (AND (IS-PROCESS P) (TR!IS-TRACE S) (TR!IS-TRACE T)
   (IN (TR!APPEND S T) (PROCESS-TRACES P)) (IN S (PROCESS-TRACES P))
   (IS-SEQUENTIAL-PROCESS P E) (TR!OCCURS E S))
  (= T (TR!EMPTY)))
 (IMPLIES
  (AND (IS-PROCESS P) (TR!IS-TRACE S) (TR!IS-TRACE T)
   (IN (TR!APPEND S T) (PROCESS-TRACES P)) (IN S (PROCESS-TRACES P))
   (IS-SEQUENTIAL-PROCESS P E) (TR!OCCURS E S))
  (= T (TR!EMPTY))))
Starting case 2 ...
(IMPLIES
 (AND (TR!OCCURS E (TR!APPEND S T)) (IS-PROCESS P) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (IN (TR!APPEND S T) (PROCESS-TRACES P))
  (IN S (PROCESS-TRACES P)) (IS-SEQUENTIAL-PROCESS P E) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming TERMINATING-TRACE-LEMMA with the
instantiations: (= P P) (= S (TR!APPEND S T)) (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-SEQUENTIAL-PROCESS P E) (IN (TR!APPEND S T) (PROCESS-TRACES P))
    (TR!OCCURS E (TR!APPEND S T)))
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST (TR!APPEND S T))))
    (= (TR!APPEND S T)
     (TR!APPEND (TR!BUT-LAST (TR!APPEND S T)) (TR!TACK E (TR!EMPTY))))))
  (TR!OCCURS E (TR!APPEND S T)) (IS-PROCESS P) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P)) (IN S (PROCESS-TRACES P))
  (IS-SEQUENTIAL-PROCESS P E) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Which simplifies
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions IS-PROCESS-BOOL, TR!IS-TRACE-APPEND,
TR!APPEND-NOT-EMPTY-RIGHT, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!BUT-LAST-IS-TRACE, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P E) (IN (TR!APPEND S T) (PROCESS-TRACES P))
  (TR!OCCURS E (TR!APPEND S T))
  (NOT (TR!OCCURS E (TR!BUT-LAST (TR!APPEND S T))))
  (= (TR!APPEND S T)
   (TR!APPEND (TR!BUT-LAST (TR!APPEND S T)) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE S) (TR!IS-TRACE T) (IN S (PROCESS-TRACES P)) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Splitting on (TR!IS-EMPTY T) generates ...
(IF (TR!IS-EMPTY T)
 (IMPLIES
  (AND (IS-SEQUENTIAL-PROCESS P E) (IN (TR!APPEND S T) (PROCESS-TRACES P))
   (TR!OCCURS E (TR!APPEND S T))
   (NOT (TR!OCCURS E (TR!BUT-LAST (TR!APPEND S T))))
   (= (TR!APPEND S T)
    (TR!APPEND (TR!BUT-LAST (TR!APPEND S T)) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE S) (TR!IS-TRACE T) (IN S (PROCESS-TRACES P)) (TR!OCCURS E S))
  (= T (TR!EMPTY)))
 (IMPLIES
  (AND (IS-SEQUENTIAL-PROCESS P E) (IN (TR!APPEND S T) (PROCESS-TRACES P))
   (TR!OCCURS E (TR!APPEND S T))
   (NOT (TR!OCCURS E (TR!BUT-LAST (TR!APPEND S T))))
   (= (TR!APPEND S T)
    (TR!APPEND (TR!BUT-LAST (TR!APPEND S T)) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE S) (TR!IS-TRACE T) (IN S (PROCESS-TRACES P)) (TR!OCCURS E S))
  (= T (TR!EMPTY))))
Which simplifies
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!OCCURS-IMPLIES-NOT-EMPTY,
PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!TACK-HEAD-TAIL
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!BUT-LAST-IS-TRACE, TR!IS-TRACE-BOOL, TR!IS-EMPTY-BOOL to ...
(IMPLIES
 (AND (NOT (TR!IS-EMPTY T)) (IS-SEQUENTIAL-PROCESS P E)
  (IN (TR!APPEND S T) (PROCESS-TRACES P)) (TR!OCCURS E (TR!APPEND S T))
  (NOT (TR!OCCURS E (TR!BUT-LAST (TR!APPEND S T))))
  (= (TR!APPEND S T)
   (TR!APPEND (TR!BUT-LAST (TR!APPEND S T)) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE S) (IN S (PROCESS-TRACES P)))
 (NOT (TR!OCCURS E S)))
Splitting on (TR!IS-TRACE S) generates ...
(IF (TR!IS-TRACE S)
 (IMPLIES
  (AND (NOT (TR!IS-EMPTY T)) (IS-SEQUENTIAL-PROCESS P E)
   (IN (TR!APPEND S T) (PROCESS-TRACES P)) (TR!OCCURS E (TR!APPEND S T))
   (NOT (TR!OCCURS E (TR!BUT-LAST (TR!APPEND S T))))
   (= (TR!APPEND S T)
    (TR!APPEND (TR!BUT-LAST (TR!APPEND S T)) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE S) (IN S (PROCESS-TRACES P)))
  (NOT (TR!OCCURS E S)))
 (IMPLIES
  (AND (NOT (TR!IS-EMPTY T)) (IS-SEQUENTIAL-PROCESS P E)
   (IN (TR!APPEND S T) (PROCESS-TRACES P)) (TR!OCCURS E (TR!APPEND S T))
   (NOT (TR!OCCURS E (TR!BUT-LAST (TR!APPEND S T))))
   (= (TR!APPEND S T)
    (TR!APPEND (TR!BUT-LAST (TR!APPEND S T)) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE S) (IN S (PROCESS-TRACES P)))
  (NOT (TR!OCCURS E S))))
Which simplifies
 when rewriting with TR!APPEND-LEFT-CANCELLATION, TR!APPEND-ASSOCIATIVE,
TR!BUT-LAST-APPEND, TR!OCCURS-APPEND
 forward chaining using TR!OCCURS-IMPLIES-NOT-EMPTY, PROCESS-COMPOSITION,
IS-SEQUENTIAL-PROCESS-FRULE, TR!TACK-HEAD-TAIL, TR!IS-TRACE-CONSEQ,
TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY
 with the assumptions TR!APPEND-NOT-EMPTY-LEFT, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE,
TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (TR!OCCURS E (TR!APPEND S T))) (IS-PROCESS P) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (IN (TR!APPEND S T) (PROCESS-TRACES P))
  (IN S (PROCESS-TRACES P)) (IS-SEQUENTIAL-PROCESS P E) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Applying TR!OCCURS-APPEND gives ...
(IMPLIES
 (AND
  (NOT
   (IF (AND (TR!IS-TRACE S) (TR!IS-TRACE T))
    (OR (TR!OCCURS E S) (TR!OCCURS E T)) (TR!OCCURS E (TR!APPEND S T))))
  (IS-PROCESS P) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P)) (IN S (PROCESS-TRACES P))
  (IS-SEQUENTIAL-PROCESS P E) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Which simplifies
 forward chaining using IS-SEQUENTIAL-PROCESS-FRULE, PROCESS-COMPOSITION,
TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY, TR!IS-TRACE-CONSEQ,
TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, IS-PROCESS-BOOL,
TR!IS-TRACE-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
LEMMA-FOR-COMPOSE-1
Beginning proof of LEMMA-FOR-COMPOSE-1 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (IN T2 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2)) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S T1) (= P P1) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P1) (IN T1 (PROCESS-TRACES P1)))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (IN T2 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2)) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S T2) (= P P2) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2)))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)))
  (IMPLIES (AND (IS-PROCESS P1) (IN T1 (PROCESS-TRACES P1)))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (IN T2 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2)) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming TERMINATING-TRACE-LEMMA with the
instantiations: (= P P1) (= S T1) (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1))
    (TR!OCCURS E T1))
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
    (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))))
  (IMPLIES (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2)))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)))
  (IMPLIES (AND (IS-PROCESS P1) (IN T1 (PROCESS-TRACES P1)))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (IN T2 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2)) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming TR!OCCURS-APPEND with the
instantiations: (= E E) (= S1 (TR!BUT-LAST T1)) (= S2 T2) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (TR!IS-TRACE (TR!BUT-LAST T1)) (TR!IS-TRACE T2))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2))
    (OR (TR!OCCURS E (TR!BUT-LAST T1)) (TR!OCCURS E T2))))
  (IMPLIES
   (AND (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1))
    (TR!OCCURS E T1))
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
    (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))))
  (IMPLIES (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2)))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)))
  (IMPLIES (AND (IS-PROCESS P1) (IN T1 (PROCESS-TRACES P1)))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (IN T2 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2)) (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Which simplifies
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION,
IS-SEQUENTIAL-PROCESS-FRULE, TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-TRACE-CONSEQ
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!APPEND-NOT-EMPTY-RIGHT, IS-PROCESS-BOOL, TR!APPEND-NOT-EMPTY-LEFT,
TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
TR!BUT-LAST-IS-TRACE to ...
(IMPLIES
 (AND (TR!IS-TRACE T2) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IF (TR!OCCURS E T2)
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (FALSE)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY)))) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Splitting on (TR!OCCURS E (TR!APPEND S T)) generates ...
(IF (TR!OCCURS E (TR!APPEND S T))
 (IMPLIES
  (AND (TR!IS-TRACE T2) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IF (TR!OCCURS E T2)
    (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
    (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (FALSE)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY)))) (IS-PROCESS P2)
   (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)) (IS-SEQUENTIAL-PROCESS P2 E)
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY)))
 (IMPLIES
  (AND (TR!IS-TRACE T2) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IF (TR!OCCURS E T2)
    (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
    (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (FALSE)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY)))) (IS-PROCESS P2)
   (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)) (IS-SEQUENTIAL-PROCESS P2 E)
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY))))
Starting case 2 ...
(IMPLIES
 (AND (TR!OCCURS E (TR!APPEND S T)) (TR!IS-TRACE T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IF (TR!OCCURS E T2)
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (FALSE)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY)))) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming TR!OCCURS-APPEND with the
instantiations: (= E E) (= S1 (TR!BUT-LAST T1)) (= S2 T2) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (TR!IS-TRACE (TR!BUT-LAST T1)) (TR!IS-TRACE T2))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2))
    (OR (TR!OCCURS E (TR!BUT-LAST T1)) (TR!OCCURS E T2))))
  (TR!OCCURS E (TR!APPEND S T)) (TR!IS-TRACE T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IF (TR!OCCURS E T2) (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (FALSE)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY)))) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming TERMINATING-TRACE-LEMMA with the
instantiations: (= P P2) (= S T2) (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2))
    (TR!OCCURS E T2))
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
    (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))))
  (IMPLIES (AND (TR!IS-TRACE (TR!BUT-LAST T1)) (TR!IS-TRACE T2))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2))
    (OR (TR!OCCURS E (TR!BUT-LAST T1)) (TR!OCCURS E T2))))
  (TR!OCCURS E (TR!APPEND S T)) (TR!IS-TRACE T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IF (TR!OCCURS E T2) (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (FALSE)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY)))) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Which simplifies
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-TRACE-OF-IS-TRACE,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, TR!TACK-HEAD-TAIL,
TR!OCCURS-IMPLIES-NOT-EMPTY, PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions TR!APPEND-NOT-EMPTY-LEFT, IS-PROCESS-BOOL,
TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL,
TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!BUT-LAST-IS-TRACE to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2))
  (TR!OCCURS E T2) (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
  (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
  (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
  (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Splitting
on (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))) generates ...
(IF (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2)))
 (IMPLIES
  (AND (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2))
   (TR!OCCURS E T2) (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
   (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
   (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY)))
 (IMPLIES
  (AND (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2))
   (TR!OCCURS E T2) (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
   (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
   (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY))))
Starting case 2.2 ...
(IMPLIES
 (AND (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2)))
  (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
  (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
  (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
  (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming TR!OCCURS-APPEND with the
instantiations: (= E E) (= S1 (TR!BUT-LAST T1))
                (= S2 (TR!BUT-LAST T2)) generates
...
(IMPLIES
 (AND
  (IMPLIES (AND (TR!IS-TRACE (TR!BUT-LAST T1)) (TR!IS-TRACE (TR!BUT-LAST T2)))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2)))
    (OR (TR!OCCURS E (TR!BUT-LAST T1)) (TR!OCCURS E (TR!BUT-LAST T2)))))
  (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2)))
  (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
  (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
  (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TR!OCCURS E (TR!APPEND S T))
  (NOT (TR!OCCURS E (TR!BUT-LAST T1))) (IS-SEQUENTIAL-PROCESS P1 E)
  (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, PROCESS-COMPOSITION,
IS-SEQUENTIAL-PROCESS-FRULE, TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!IS-TRACE-CONSEQ
 with the assumptions TR!APPEND-NOT-EMPTY-RIGHT, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!APPEND-NOT-EMPTY-LEFT,
TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
TR!BUT-LAST-IS-TRACE to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
  (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
  (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
  (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
  (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Splitting on (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T))) generates ...
(IF (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T)))
 (IMPLIES
  (AND (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
   (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
   (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
   (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
   (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY)))
 (IMPLIES
  (AND (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
   (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
   (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
   (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
   (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY))))
Starting case 2.1.2 ...
(IMPLIES
 (AND (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T)))
  (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
  (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
  (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
  (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
  (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming TR!OCCURS-APPEND with the
instantiations: (= E E) (= S1 S) (= S2 (TR!BUT-LAST T)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (TR!IS-TRACE S) (TR!IS-TRACE (TR!BUT-LAST T)))
   (= (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T)))
    (OR (TR!OCCURS E S) (TR!OCCURS E (TR!BUT-LAST T)))))
  (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T)))
  (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
  (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
  (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
  (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TR!OCCURS E (TR!APPEND S T))
  (NOT (TR!OCCURS E (TR!BUT-LAST T1))) (IS-SEQUENTIAL-PROCESS P1 E)
  (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming TR!BUT-LAST-APPEND with the instantiations: (= S S) (= T T) generates
...
(IMPLIES
 (AND
  (IMPLIES (AND (TR!IS-TRACE S) (NOT (TR!IS-EMPTY T)))
   (= (TR!BUT-LAST (TR!APPEND S T)) (TR!APPEND S (TR!BUT-LAST T))))
  (IMPLIES (AND (TR!IS-TRACE S) (TR!IS-TRACE (TR!BUT-LAST T)))
   (= (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T)))
    (OR (TR!OCCURS E S) (TR!OCCURS E (TR!BUT-LAST T)))))
  (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T)))
  (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
  (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
  (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
  (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TR!OCCURS E (TR!APPEND S T))
  (NOT (TR!OCCURS E (TR!BUT-LAST T1))) (IS-SEQUENTIAL-PROCESS P1 E)
  (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Assuming TR!BUT-LAST-APPEND with the
instantiations: (= S (TR!BUT-LAST T1)) (= T T2) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (TR!IS-TRACE (TR!BUT-LAST T1)) (NOT (TR!IS-EMPTY T2)))
   (= (TR!BUT-LAST (TR!APPEND (TR!BUT-LAST T1) T2))
    (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
  (IMPLIES (AND (TR!IS-TRACE S) (NOT (TR!IS-EMPTY T)))
   (= (TR!BUT-LAST (TR!APPEND S T)) (TR!APPEND S (TR!BUT-LAST T))))
  (IMPLIES (AND (TR!IS-TRACE S) (TR!IS-TRACE (TR!BUT-LAST T)))
   (= (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T)))
    (OR (TR!OCCURS E S) (TR!OCCURS E (TR!BUT-LAST T)))))
  (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T)))
  (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
  (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
  (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
  (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TR!OCCURS E (TR!APPEND S T))
  (NOT (TR!OCCURS E (TR!BUT-LAST T1))) (IS-SEQUENTIAL-PROCESS P1 E)
  (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Which simplifies
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION,
IS-SEQUENTIAL-PROCESS-FRULE, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL,
TR!IS-TRACE-CONSEQ
 with the assumptions TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!APPEND-NOT-EMPTY-RIGHT, TR!APPEND-NOT-EMPTY-LEFT, TR!IS-TRACE-APPEND,
TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL, TR!BUT-LAST-IS-TRACE to ...
(TRUE)
Starting case 2.1.1 ...
(IMPLIES
 (AND (NOT (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T))))
  (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
  (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
  (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
  (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
  (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Splitting
on (AND (TR!IS-TRACE S) (AND (TR!IS-TRACE T) (TR!OCCURS E S))) generates ...
(IF (AND (TR!IS-TRACE S) (TR!IS-TRACE T) (TR!OCCURS E S))
 (IMPLIES
  (AND (NOT (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T))))
   (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
   (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
   (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
   (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
   (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY)))
 (IMPLIES
  (AND (NOT (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T))))
   (NOT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
   (IS-SEQUENTIAL-PROCESS P2 E) (IN T2 (PROCESS-TRACES P2)) (TR!OCCURS E T2)
   (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
   (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
   (TR!OCCURS E (TR!APPEND S T)) (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY))))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1))
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY))))
Which simplifies
 when rewriting with TR!OCCURS-APPEND
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION,
IS-SEQUENTIAL-PROCESS-FRULE, TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY
 with the assumptions TR!APPEND-NOT-EMPTY-RIGHT, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!IS-TRACE-APPEND,
TR!APPEND-NOT-EMPTY-LEFT, TR!IS-EMPTY-BOOL, TR!BUT-LAST-IS-TRACE,
TR!IS-TRACE-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (NOT (TR!OCCURS E (TR!APPEND S T))) (TR!IS-TRACE T2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
  (IF (TR!OCCURS E T2)
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
   (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (FALSE)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
  (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY)))) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
  (TR!OCCURS E S))
 (= T (TR!EMPTY)))
Splitting
on (AND (TR!IS-TRACE S) (AND (TR!IS-TRACE T) (TR!OCCURS E S))) generates ...
(IF (AND (TR!IS-TRACE S) (TR!IS-TRACE T) (TR!OCCURS E S))
 (IMPLIES
  (AND (NOT (TR!OCCURS E (TR!APPEND S T))) (TR!IS-TRACE T2)
   (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IF (TR!OCCURS E T2)
    (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
    (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (FALSE)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY)))) (IS-PROCESS P2)
   (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)) (IS-SEQUENTIAL-PROCESS P2 E)
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY)))
 (IMPLIES
  (AND (NOT (TR!OCCURS E (TR!APPEND S T))) (TR!IS-TRACE T2)
   (NOT (TR!OCCURS E (TR!BUT-LAST T1)))
   (IF (TR!OCCURS E T2)
    (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (TRUE))
    (= (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) T2)) (FALSE)))
   (IS-SEQUENTIAL-PROCESS P1 E) (IN T1 (PROCESS-TRACES P1)) (TR!OCCURS E T1)
   (= T1 (TR!APPEND (TR!BUT-LAST T1) (TR!TACK E (TR!EMPTY)))) (IS-PROCESS P2)
   (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
   (TR!IS-TRACE-OF T1 (PROCESS-ALPHABET P1)) (IS-SEQUENTIAL-PROCESS P2 E)
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T1) T2))
   (TR!OCCURS E S))
  (= T (TR!EMPTY))))
Which simplifies
 when rewriting with TR!OCCURS-APPEND
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION,
IS-SEQUENTIAL-PROCESS-FRULE, TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY
 with the assumptions IS-PROCESS-BOOL, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK,
TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!APPEND-NOT-EMPTY-RIGHT, TR!BUT-LAST-IS-TRACE,
TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-LEFT, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
COMPOSE-IS-SEQUENTIAL-PROCESS
Beginning proof of COMPOSE-IS-SEQUENTIAL-PROCESS ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IS-SEQUENTIAL-PROCESS (COMPOSE P1 P2 E) E))
Invoking (IS-SEQUENTIAL-PROCESS (COMPOSE P1 P2 E) E) gives ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (AND (IS-PROCESS (COMPOSE P1 P2 E))
  (IN E (PROCESS-ALPHABET (COMPOSE P1 P2 E)))
  (ALL (T)
   (IMPLIES (AND (IN T (PROCESS-TRACES (COMPOSE P1 P2 E))) (TR!OCCURS E T))
    (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
     (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY)))))))))
Starting case 3 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IS-PROCESS (COMPOSE P1 P2 E)))
Which simplifies
 with invocation of SUBSET, COMPOSE
 when rewriting with DIFF.DEFINITION, SELECT-TERMINATED-TRACES.DEFINITION,
TR!IN-TRACE-OF, UNION.DEFINITION, UNION.COMMUTATIVE,
SETRULES!SUBSET-DIFF-LEFT, SETRULES!SUBSET-UNION-LEFT, MAKE-PROCESS-IS-PROCESS
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL,
TR!OCCURS-IMPLIES-NOT-EMPTY, TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE,
PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-DIFF-RELATION to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (AND
  (ALL (E$0)
   (IMPLIES
    (AND (IN E$0 (PROCESS-TRACES P1))
     (NOT (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1))))
    (TR!OCCURS E E$0)))
  (ALL (E$1)
   (IMPLIES
    (IN E$1
     (MAP-APPEND
      (MAP-STRIP-TRAILING-EVENT
       (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
      (PROCESS-TRACES P2)))
    (TR!IS-TRACE-OF E$1 (PROCESS-ALPHABET P1))))
  (IF (IN (TR!EMPTY) (PROCESS-TRACES P1))
   (PREFIX-CLOSED
    (UNION
     (DIFF (PROCESS-TRACES P1)
      (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
     (MAP-APPEND
      (MAP-STRIP-TRAILING-EVENT
       (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
      (PROCESS-TRACES P2))))
   (AND
    (IN (TR!EMPTY)
     (MAP-APPEND
      (MAP-STRIP-TRAILING-EVENT
       (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
      (PROCESS-TRACES P2)))
    (PREFIX-CLOSED
     (UNION
      (DIFF (PROCESS-TRACES P1)
       (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
      (MAP-APPEND
       (MAP-STRIP-TRAILING-EVENT
        (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
       (PROCESS-TRACES P2))))))))
Starting case 3.3 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (ALL (E$0)
  (IMPLIES
   (AND (IN E$0 (PROCESS-TRACES P1))
    (NOT (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1))))
   (TR!OCCURS E E$0))))
Prenexing produces ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (IN E$0 (PROCESS-TRACES P1))
  (NOT (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1))))
 (TR!OCCURS E E$0))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S E$0) (= P P1) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P1) (IN E$0 (PROCESS-TRACES P1)))
   (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (IN E$0 (PROCESS-TRACES P1))
  (NOT (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1))))
 (TR!OCCURS E E$0))
Which simplifies
 forward chaining using IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL to ...
(TRUE)
Starting case 3.2 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (ALL (E$1)
  (IMPLIES
   (IN E$1
    (MAP-APPEND
     (MAP-STRIP-TRAILING-EVENT
      (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
     (PROCESS-TRACES P2)))
   (TR!IS-TRACE-OF E$1 (PROCESS-ALPHABET P1)))))
Prenexing produces ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN E$0
   (MAP-APPEND
    (MAP-STRIP-TRAILING-EVENT
     (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
    (PROCESS-TRACES P2))))
 (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1)))
Which simplifies
 when rewriting with SELECT-TERMINATED-TRACES.DEFINITION,
MAP-STRIP-TRAILING-EVENT.DEFINITION, MAP-APPEND.DEFINITION
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!IS-TRACE-CONSEQ,
TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY, PROCESS-COMPOSITION,
IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
TR!BUT-LAST-IS-TRACE to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (SOME (T)
   (AND (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T)
    (SOME (T2)
     (AND (IN T2 (PROCESS-TRACES P2))
      (= E$0 (TR!APPEND (TR!BUT-LAST T) T2)))))))
 (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1)))
Prenexing produces ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (IN T (PROCESS-TRACES P1))
  (TR!OCCURS E T) (IN T2 (PROCESS-TRACES P2))
  (= E$0 (TR!APPEND (TR!BUT-LAST T) T2)))
 (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1)))
Assuming TERMINATING-TRACE-LEMMA with the
instantiations: (= P P1) (= S T) (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-SEQUENTIAL-PROCESS P1 E) (IN T (PROCESS-TRACES P1))
    (TR!OCCURS E T))
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
    (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (IN T (PROCESS-TRACES P1))
  (TR!OCCURS E T) (IN T2 (PROCESS-TRACES P2))
  (= E$0 (TR!APPEND (TR!BUT-LAST T) T2)))
 (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1)))
Which simplifies
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T)
  (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN T2 (PROCESS-TRACES P2)) (= E$0 (TR!APPEND (TR!BUT-LAST T) T2)))
 (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P1)))
Substituting (= E$0 (TR!APPEND (TR!BUT-LAST T) T2)) produces ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T)
  (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN T2 (PROCESS-TRACES P2)) (= E$0 (TR!APPEND (TR!BUT-LAST T) T2)))
 (TR!IS-TRACE-OF (TR!APPEND (TR!BUT-LAST T) T2) (PROCESS-ALPHABET P1)))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S T2) (= P P2) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2)))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T)
  (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN T2 (PROCESS-TRACES P2)) (= E$0 (TR!APPEND (TR!BUT-LAST T) T2)))
 (TR!IS-TRACE-OF (TR!APPEND (TR!BUT-LAST T) T2) (PROCESS-ALPHABET P1)))
Which simplifies
 when rewriting with TR!IS-TRACE-OF-APPEND
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL,
TR!OCCURS-IMPLIES-NOT-EMPTY, IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE, IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)) (IS-SEQUENTIAL-PROCESS P1 E)
  (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T)
  (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (= E$0 (TR!APPEND (TR!BUT-LAST T) T2)))
 (TR!IS-TRACE-OF (TR!BUT-LAST T) (PROCESS-ALPHABET P1)))
Assuming APPEND-IN-PROCESS-TRACES-ALPHABET with the
instantiations: (= S1 (TR!BUT-LAST T)) (= S2 (TR!TACK E (TR!EMPTY)))
                (= P P1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS P1) (TR!IS-TRACE (TR!BUT-LAST T))
    (TR!IS-TRACE (TR!TACK E (TR!EMPTY)))
    (IN (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY)))
     (PROCESS-TRACES P1)))
   (AND (TR!IS-TRACE-OF (TR!BUT-LAST T) (PROCESS-ALPHABET P1))
    (TR!IS-TRACE-OF (TR!TACK E (TR!EMPTY)) (PROCESS-ALPHABET P1))))
  (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)) (IS-SEQUENTIAL-PROCESS P1 E)
  (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T)
  (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (= E$0 (TR!APPEND (TR!BUT-LAST T) T2)))
 (TR!IS-TRACE-OF (TR!BUT-LAST T) (PROCESS-ALPHABET P1)))
Which simplifies
 forward chaining using TR!OCCURS-IMPLIES-NOT-EMPTY,
IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-TRACE-OF-IS-TRACE, TR!TACK-HEAD-TAIL,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!IS-TRACE-BOOL, TR!BUT-LAST-IS-TRACE, IS-PROCESS-BOOL to ...
(TRUE)
Starting case 3.1 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IF (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (PREFIX-CLOSED
   (UNION
    (DIFF (PROCESS-TRACES P1)
     (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
    (MAP-APPEND
     (MAP-STRIP-TRAILING-EVENT
      (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
     (PROCESS-TRACES P2))))
  (AND
   (IN (TR!EMPTY)
    (MAP-APPEND
     (MAP-STRIP-TRAILING-EVENT
      (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
     (PROCESS-TRACES P2)))
   (PREFIX-CLOSED
    (UNION
     (DIFF (PROCESS-TRACES P1)
      (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
     (MAP-APPEND
      (MAP-STRIP-TRAILING-EVENT
       (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
      (PROCESS-TRACES P2)))))))
Invoking PREFIX-CLOSED gives ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IF (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (ALL (S T)
   (IMPLIES
    (AND (TR!IS-TRACE S) (TR!IS-TRACE T)
     (IN (TR!APPEND S T)
      (UNION
       (DIFF (PROCESS-TRACES P1)
        (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
       (MAP-APPEND
        (MAP-STRIP-TRAILING-EVENT
         (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
        (PROCESS-TRACES P2)))))
    (IN S
     (UNION
      (DIFF (PROCESS-TRACES P1)
       (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
      (MAP-APPEND
       (MAP-STRIP-TRAILING-EVENT
        (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
       (PROCESS-TRACES P2))))))
  (AND
   (IN (TR!EMPTY)
    (MAP-APPEND
     (MAP-STRIP-TRAILING-EVENT
      (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
     (PROCESS-TRACES P2)))
   (ALL (S$0 T$0)
    (IMPLIES
     (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T$0)
      (IN (TR!APPEND S$0 T$0)
       (UNION
        (DIFF (PROCESS-TRACES P1)
         (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
        (MAP-APPEND
         (MAP-STRIP-TRAILING-EVENT
          (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
         (PROCESS-TRACES P2)))))
     (IN S$0
      (UNION
       (DIFF (PROCESS-TRACES P1)
        (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
       (MAP-APPEND
        (MAP-STRIP-TRAILING-EVENT
         (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
        (PROCESS-TRACES P2)))))))))
Which simplifies
 when rewriting with MAP-STRIP-TRAILING-EVENT.DEFINITION,
MAP-APPEND.DEFINITION, TR!OCCURS-APPEND, SELECT-TERMINATED-TRACES.DEFINITION,
DIFF.DEFINITION, UNION.DEFINITION
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions TR!APPEND-NOT-EMPTY-LEFT, TR!BUT-LAST-IS-TRACE,
TR!APPEND-NOT-EMPTY-RIGHT, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-DIFF-RELATION,
TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IF (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (ALL (S T T$0 T$1 T$2)
   (IMPLIES (AND (TR!IS-TRACE S) (TR!IS-TRACE T))
    (IF (IN (TR!APPEND S T) (PROCESS-TRACES P1))
     (IF (TR!OCCURS E S)
      (IMPLIES
       (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
        (SOME (T2)
         (AND (IN T2 (PROCESS-TRACES P2))
          (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)))))
       (SOME (T$3)
        (AND (IN T$3 (PROCESS-TRACES P1)) (TR!OCCURS E T$3)
         (SOME (T2$0)
          (AND (IN T2$0 (PROCESS-TRACES P2))
           (= S (TR!APPEND (TR!BUT-LAST T$3) T2$0)))))))
      (IF (TR!OCCURS E T)
       (IMPLIES
        (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
         (SOME (T2$1)
          (AND (IN T2$1 (PROCESS-TRACES P2))
           (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$1) T2$1))))
         (NOT (IN S (PROCESS-TRACES P1))))
        (SOME (T$4)
         (AND (IN T$4 (PROCESS-TRACES P1)) (TR!OCCURS E T$4)
          (SOME (T2$2)
           (AND (IN T2$2 (PROCESS-TRACES P2))
            (= S (TR!APPEND (TR!BUT-LAST T$4) T2$2)))))))
       (OR (IN S (PROCESS-TRACES P1))
        (SOME (T$5)
         (AND (IN T$5 (PROCESS-TRACES P1)) (TR!OCCURS E T$5)
          (SOME (T2$3)
           (AND (IN T2$3 (PROCESS-TRACES P2))
            (= S (TR!APPEND (TR!BUT-LAST T$5) T2$3)))))))))
     (IMPLIES
      (AND (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
       (SOME (T2$4)
        (AND (IN T2$4 (PROCESS-TRACES P2))
         (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$4)))))
      (IF (IN S (PROCESS-TRACES P1))
       (IMPLIES (TR!OCCURS E S)
        (SOME (T$6)
         (AND (IN T$6 (PROCESS-TRACES P1)) (TR!OCCURS E T$6)
          (SOME (T2$5)
           (AND (IN T2$5 (PROCESS-TRACES P2))
            (= S (TR!APPEND (TR!BUT-LAST T$6) T2$5)))))))
       (SOME (T$7)
        (AND (IN T$7 (PROCESS-TRACES P1)) (TR!OCCURS E T$7)
         (SOME (T2$6)
          (AND (IN T2$6 (PROCESS-TRACES P2))
           (= S (TR!APPEND (TR!BUT-LAST T$7) T2$6)))))))))))
  (AND
   (SOME (T$8)
    (AND (IN T$8 (PROCESS-TRACES P1)) (TR!OCCURS E T$8)
     (SOME (T2$7)
      (AND (IN T2$7 (PROCESS-TRACES P2))
       (= (TR!EMPTY) (TR!APPEND (TR!BUT-LAST T$8) T2$7))))))
   (ALL (S$0 T$9 T$10 T$11 T$12)
    (IMPLIES (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T$9))
     (IF (IN (TR!APPEND S$0 T$9) (PROCESS-TRACES P1))
      (IF (TR!OCCURS E S$0)
       (IMPLIES
        (AND (IN T$10 (PROCESS-TRACES P1)) (TR!OCCURS E T$10)
         (SOME (T2$8)
          (AND (IN T2$8 (PROCESS-TRACES P2))
           (= (TR!APPEND S$0 T$9) (TR!APPEND (TR!BUT-LAST T$10) T2$8)))))
        (SOME (T$13)
         (AND (IN T$13 (PROCESS-TRACES P1)) (TR!OCCURS E T$13)
          (SOME (T2$9)
           (AND (IN T2$9 (PROCESS-TRACES P2))
            (= S$0 (TR!APPEND (TR!BUT-LAST T$13) T2$9)))))))
       (IF (TR!OCCURS E T$9)
        (IMPLIES
         (AND (IN T$11 (PROCESS-TRACES P1)) (TR!OCCURS E T$11)
          (SOME (T2$10)
           (AND (IN T2$10 (PROCESS-TRACES P2))
            (= (TR!APPEND S$0 T$9) (TR!APPEND (TR!BUT-LAST T$11) T2$10))))
          (NOT (IN S$0 (PROCESS-TRACES P1))))
         (SOME (T$14)
          (AND (IN T$14 (PROCESS-TRACES P1)) (TR!OCCURS E T$14)
           (SOME (T2$11)
            (AND (IN T2$11 (PROCESS-TRACES P2))
             (= S$0 (TR!APPEND (TR!BUT-LAST T$14) T2$11)))))))
        (OR (IN S$0 (PROCESS-TRACES P1))
         (SOME (T$15)
          (AND (IN T$15 (PROCESS-TRACES P1)) (TR!OCCURS E T$15)
           (SOME (T2$12)
            (AND (IN T2$12 (PROCESS-TRACES P2))
             (= S$0 (TR!APPEND (TR!BUT-LAST T$15) T2$12)))))))))
      (IMPLIES
       (AND (IN T$12 (PROCESS-TRACES P1)) (TR!OCCURS E T$12)
        (SOME (T2$13)
         (AND (IN T2$13 (PROCESS-TRACES P2))
          (= (TR!APPEND S$0 T$9) (TR!APPEND (TR!BUT-LAST T$12) T2$13)))))
       (IF (IN S$0 (PROCESS-TRACES P1))
        (IMPLIES (TR!OCCURS E S$0)
         (SOME (T$16)
          (AND (IN T$16 (PROCESS-TRACES P1)) (TR!OCCURS E T$16)
           (SOME (T2$14)
            (AND (IN T2$14 (PROCESS-TRACES P2))
             (= S$0 (TR!APPEND (TR!BUT-LAST T$16) T2$14)))))))
        (SOME (T$17)
         (AND (IN T$17 (PROCESS-TRACES P1)) (TR!OCCURS E T$17)
          (SOME (T2$15)
           (AND (IN T2$15 (PROCESS-TRACES P2))
            (= S$0 (TR!APPEND (TR!BUT-LAST T$17) T2$15))))))))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IF (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (IMPLIES (AND (TR!IS-TRACE S) (TR!IS-TRACE T))
   (IF (IN (TR!APPEND S T) (PROCESS-TRACES P1))
    (IF (TR!OCCURS E S)
     (IMPLIES
      (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
       (IN T2 (PROCESS-TRACES P2))
       (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)))
      (SOME (T$7)
       (AND (IN T$7 (PROCESS-TRACES P1)) (TR!OCCURS E T$7)
        (SOME (T2$5)
         (AND (IN T2$5 (PROCESS-TRACES P2))
          (= S (TR!APPEND (TR!BUT-LAST T$7) T2$5)))))))
     (IF (TR!OCCURS E T)
      (IMPLIES
       (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
        (IN T2$0 (PROCESS-TRACES P2))
        (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$1) T2$0))
        (NOT (IN S (PROCESS-TRACES P1))))
       (SOME (T$8)
        (AND (IN T$8 (PROCESS-TRACES P1)) (TR!OCCURS E T$8)
         (SOME (T2$6)
          (AND (IN T2$6 (PROCESS-TRACES P2))
           (= S (TR!APPEND (TR!BUT-LAST T$8) T2$6)))))))
      (OR (IN S (PROCESS-TRACES P1))
       (SOME (T$9)
        (AND (IN T$9 (PROCESS-TRACES P1)) (TR!OCCURS E T$9)
         (SOME (T2$7)
          (AND (IN T2$7 (PROCESS-TRACES P2))
           (= S (TR!APPEND (TR!BUT-LAST T$9) T2$7)))))))))
    (IMPLIES
     (AND (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
      (IN T2$1 (PROCESS-TRACES P2))
      (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1)))
     (IF (IN S (PROCESS-TRACES P1))
      (IMPLIES (TR!OCCURS E S)
       (SOME (T$10)
        (AND (IN T$10 (PROCESS-TRACES P1)) (TR!OCCURS E T$10)
         (SOME (T2$8)
          (AND (IN T2$8 (PROCESS-TRACES P2))
           (= S (TR!APPEND (TR!BUT-LAST T$10) T2$8)))))))
      (SOME (T$11)
       (AND (IN T$11 (PROCESS-TRACES P1)) (TR!OCCURS E T$11)
        (SOME (T2$9)
         (AND (IN T2$9 (PROCESS-TRACES P2))
          (= S (TR!APPEND (TR!BUT-LAST T$11) T2$9))))))))))
  (AND
   (SOME (T$12)
    (AND (IN T$12 (PROCESS-TRACES P1)) (TR!OCCURS E T$12)
     (SOME (T2$10)
      (AND (IN T2$10 (PROCESS-TRACES P2))
       (= (TR!EMPTY) (TR!APPEND (TR!BUT-LAST T$12) T2$10))))))
   (IMPLIES (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T$3))
    (IF (IN (TR!APPEND S$0 T$3) (PROCESS-TRACES P1))
     (IF (TR!OCCURS E S$0)
      (IMPLIES
       (AND (IN T$4 (PROCESS-TRACES P1)) (TR!OCCURS E T$4)
        (IN T2$2 (PROCESS-TRACES P2))
        (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$4) T2$2)))
       (SOME (T$13)
        (AND (IN T$13 (PROCESS-TRACES P1)) (TR!OCCURS E T$13)
         (SOME (T2$11)
          (AND (IN T2$11 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$13) T2$11)))))))
      (IF (TR!OCCURS E T$3)
       (IMPLIES
        (AND (IN T$5 (PROCESS-TRACES P1)) (TR!OCCURS E T$5)
         (IN T2$3 (PROCESS-TRACES P2))
         (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$5) T2$3))
         (NOT (IN S$0 (PROCESS-TRACES P1))))
        (SOME (T$14)
         (AND (IN T$14 (PROCESS-TRACES P1)) (TR!OCCURS E T$14)
          (SOME (T2$12)
           (AND (IN T2$12 (PROCESS-TRACES P2))
            (= S$0 (TR!APPEND (TR!BUT-LAST T$14) T2$12)))))))
       (OR (IN S$0 (PROCESS-TRACES P1))
        (SOME (T$15)
         (AND (IN T$15 (PROCESS-TRACES P1)) (TR!OCCURS E T$15)
          (SOME (T2$13)
           (AND (IN T2$13 (PROCESS-TRACES P2))
            (= S$0 (TR!APPEND (TR!BUT-LAST T$15) T2$13)))))))))
     (IMPLIES
      (AND (IN T$6 (PROCESS-TRACES P1)) (TR!OCCURS E T$6)
       (IN T2$4 (PROCESS-TRACES P2))
       (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$6) T2$4)))
      (IF (IN S$0 (PROCESS-TRACES P1))
       (IMPLIES (TR!OCCURS E S$0)
        (SOME (T$16)
         (AND (IN T$16 (PROCESS-TRACES P1)) (TR!OCCURS E T$16)
          (SOME (T2$14)
           (AND (IN T2$14 (PROCESS-TRACES P2))
            (= S$0 (TR!APPEND (TR!BUT-LAST T$16) T2$14)))))))
       (SOME (T$17)
        (AND (IN T$17 (PROCESS-TRACES P1)) (TR!OCCURS E T$17)
         (SOME (T2$15)
          (AND (IN T2$15 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$17) T2$15)))))))))))))
Starting case 3.1.2 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T))
 (IF (IN (TR!APPEND S T) (PROCESS-TRACES P1))
  (IF (TR!OCCURS E S)
   (IMPLIES
    (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
     (IN T2 (PROCESS-TRACES P2))
     (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)))
    (SOME (T$7)
     (AND (IN T$7 (PROCESS-TRACES P1)) (TR!OCCURS E T$7)
      (SOME (T2$5)
       (AND (IN T2$5 (PROCESS-TRACES P2))
        (= S (TR!APPEND (TR!BUT-LAST T$7) T2$5)))))))
   (IF (TR!OCCURS E T)
    (IMPLIES
     (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
      (IN T2$0 (PROCESS-TRACES P2))
      (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$1) T2$0))
      (NOT (IN S (PROCESS-TRACES P1))))
     (SOME (T$8)
      (AND (IN T$8 (PROCESS-TRACES P1)) (TR!OCCURS E T$8)
       (SOME (T2$6)
        (AND (IN T2$6 (PROCESS-TRACES P2))
         (= S (TR!APPEND (TR!BUT-LAST T$8) T2$6)))))))
    (OR (IN S (PROCESS-TRACES P1))
     (SOME (T$9)
      (AND (IN T$9 (PROCESS-TRACES P1)) (TR!OCCURS E T$9)
       (SOME (T2$7)
        (AND (IN T2$7 (PROCESS-TRACES P2))
         (= S (TR!APPEND (TR!BUT-LAST T$9) T2$7)))))))))
  (IMPLIES
   (AND (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
    (IN T2$1 (PROCESS-TRACES P2))
    (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1)))
   (IF (IN S (PROCESS-TRACES P1))
    (IMPLIES (TR!OCCURS E S)
     (SOME (T$10)
      (AND (IN T$10 (PROCESS-TRACES P1)) (TR!OCCURS E T$10)
       (SOME (T2$8)
        (AND (IN T2$8 (PROCESS-TRACES P2))
         (= S (TR!APPEND (TR!BUT-LAST T$10) T2$8)))))))
    (SOME (T$11)
     (AND (IN T$11 (PROCESS-TRACES P1)) (TR!OCCURS E T$11)
      (SOME (T2$9)
       (AND (IN T2$9 (PROCESS-TRACES P2))
        (= S (TR!APPEND (TR!BUT-LAST T$11) T2$9))))))))))
Starting case 3.1.2.2 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
 (IF (TR!OCCURS E S)
  (IMPLIES
   (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
    (IN T2 (PROCESS-TRACES P2))
    (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)))
   (SOME (T$7)
    (AND (IN T$7 (PROCESS-TRACES P1)) (TR!OCCURS E T$7)
     (SOME (T2$5)
      (AND (IN T2$5 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$7) T2$5)))))))
  (IF (TR!OCCURS E T)
   (IMPLIES
    (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
     (IN T2$0 (PROCESS-TRACES P2))
     (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$1) T2$0))
     (NOT (IN S (PROCESS-TRACES P1))))
    (SOME (T$8)
     (AND (IN T$8 (PROCESS-TRACES P1)) (TR!OCCURS E T$8)
      (SOME (T2$6)
       (AND (IN T2$6 (PROCESS-TRACES P2))
        (= S (TR!APPEND (TR!BUT-LAST T$8) T2$6)))))))
   (OR (IN S (PROCESS-TRACES P1))
    (SOME (T$9)
     (AND (IN T$9 (PROCESS-TRACES P1)) (TR!OCCURS E T$9)
      (SOME (T2$7)
       (AND (IN T2$7 (PROCESS-TRACES P2))
        (= S (TR!APPEND (TR!BUT-LAST T$9) T2$7))))))))))
Starting case 3.1.2.2.2 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P1)) (TR!OCCURS E S)
  (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0) (IN T2 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (SOME (T$7)
  (AND (IN T$7 (PROCESS-TRACES P1)) (TR!OCCURS E T$7)
   (SOME (T2$5)
    (AND (IN T2$5 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$7) T2$5)))))))
Assuming LEFT-APPEND-TERMINATES with the
instantiations: (= P P1) (= E E) (= S S) (= T T) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-SEQUENTIAL-PROCESS P1 E) (TR!IS-TRACE S) (TR!IS-TRACE T)
    (IN (TR!APPEND S T) (PROCESS-TRACES P1)) (TR!OCCURS E S))
   (= T (TR!EMPTY)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P1)) (TR!OCCURS E S)
  (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0) (IN T2 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (SOME (T$1)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (SOME (T2$0)
    (AND (IN T2$0 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
Which simplifies
 when rewriting with TR!APPEND-EMPTY-RIGHT
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions TR!BUT-LAST-IS-TRACE, TR!APPEND-NOT-EMPTY-LEFT,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-BOOL to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P1)) (TR!OCCURS E S) (= T (TR!EMPTY))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (IN S (PROCESS-TRACES P1))
  (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0) (IN T2 (PROCESS-TRACES P2))
  (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (SOME (T$1)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (SOME (T2$0)
    (AND (IN T2$0 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
Instantiating (= T$1 T$0) (= T2$0 T2) gives ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P1)) (TR!OCCURS E S) (= T (TR!EMPTY))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (IN S (PROCESS-TRACES P1))
  (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0) (IN T2 (PROCESS-TRACES P2))
  (= S (TR!APPEND (TR!BUT-LAST T$0) T2))
  (NOT
   (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
    (IN T2 (PROCESS-TRACES P2)) (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))
 (SOME (T$1 T2$0)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (IN T2$0 (PROCESS-TRACES P2)) (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions TR!BUT-LAST-IS-TRACE, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL to
...
(TRUE)
Starting case 3.1.2.2.1 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P1)) (NOT (TR!OCCURS E S)))
 (IF (TR!OCCURS E T)
  (IMPLIES
   (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
    (IN T2$0 (PROCESS-TRACES P2))
    (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$1) T2$0))
    (NOT (IN S (PROCESS-TRACES P1))))
   (SOME (T$8)
    (AND (IN T$8 (PROCESS-TRACES P1)) (TR!OCCURS E T$8)
     (SOME (T2$6)
      (AND (IN T2$6 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$8) T2$6)))))))
  (OR (IN S (PROCESS-TRACES P1))
   (SOME (T$9)
    (AND (IN T$9 (PROCESS-TRACES P1)) (TR!OCCURS E T$9)
     (SOME (T2$7)
      (AND (IN T2$7 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$9) T2$7)))))))))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 S) (= S2 T) (= P P1) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS P1) (TR!IS-TRACE S) (TR!IS-TRACE T)
    (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
   (IN S (PROCESS-TRACES P1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES P1)) (NOT (TR!OCCURS E S)))
 (IF (TR!OCCURS E T)
  (IMPLIES
   (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
    (IN T2$0 (PROCESS-TRACES P2))
    (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$1) T2$0))
    (NOT (IN S (PROCESS-TRACES P1))))
   (SOME (T$0)
    (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
     (SOME (T2)
      (AND (IN T2 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
  (OR (IN S (PROCESS-TRACES P1))
   (SOME (T$2)
    (AND (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
     (SOME (T2$1)
      (AND (IN T2$1 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$2) T2$1)))))))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY, PROCESS-COMPOSITION
 with the assumptions TR!BUT-LAST-IS-TRACE, TR!APPEND-NOT-EMPTY-RIGHT,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
Starting case 3.1.2.1 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (IN T2$1 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1)))
 (IF (IN S (PROCESS-TRACES P1))
  (IMPLIES (TR!OCCURS E S)
   (SOME (T$10)
    (AND (IN T$10 (PROCESS-TRACES P1)) (TR!OCCURS E T$10)
     (SOME (T2$8)
      (AND (IN T2$8 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$10) T2$8)))))))
  (SOME (T$11)
   (AND (IN T$11 (PROCESS-TRACES P1)) (TR!OCCURS E T$11)
    (SOME (T2$9)
     (AND (IN T2$9 (PROCESS-TRACES P2))
      (= S (TR!APPEND (TR!BUT-LAST T$11) T2$9))))))))
Starting case 3.1.2.1.2 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (IN T2$1 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (IN S (PROCESS-TRACES P1)) (TR!OCCURS E S))
 (SOME (T$10)
  (AND (IN T$10 (PROCESS-TRACES P1)) (TR!OCCURS E T$10)
   (SOME (T2$8)
    (AND (IN T2$8 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$10) T2$8)))))))
Assuming LEMMA-FOR-COMPOSE-1 with the
instantiations: (= P1 P1) (= P2 P2) (= E E) (= S S) (= T T) (= T1 T$2)
                (= T2 T2$1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
    (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
    (TR!IS-TRACE T) (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
    (IN T2$1 (PROCESS-TRACES P2))
    (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1)) (TR!OCCURS E S))
   (= T (TR!EMPTY)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (IN T2$1 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (IN S (PROCESS-TRACES P1)) (TR!OCCURS E S))
 (SOME (T$0)
  (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
   (SOME (T2)
    (AND (IN T2 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions TR!APPEND-NOT-EMPTY-LEFT, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE, TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-BOOL to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
  (TR!IS-TRACE T) (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
  (IN T2$1 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1)) (TR!OCCURS E S)
  (= T (TR!EMPTY)) (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT (IN (TR!APPEND S (TR!EMPTY)) (PROCESS-TRACES P1)))
  (IN S (PROCESS-TRACES P1)))
 (SOME (T$0)
  (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
   (SOME (T2)
    (AND (IN T2 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
Splitting on (= T (TR!EMPTY)) generates ...
(IF (= T (TR!EMPTY))
 (IMPLIES
  (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
   (IN T2$1 (PROCESS-TRACES P2))
   (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1)) (TR!OCCURS E S)
   (= T (TR!EMPTY)) (IN (TR!EMPTY) (PROCESS-TRACES P1))
   (NOT (IN (TR!APPEND S (TR!EMPTY)) (PROCESS-TRACES P1)))
   (IN S (PROCESS-TRACES P1)))
  (SOME (T$0)
   (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
    (SOME (T2)
     (AND (IN T2 (PROCESS-TRACES P2))
      (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
 (IMPLIES
  (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
   (TR!IS-TRACE T) (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
   (IN T2$1 (PROCESS-TRACES P2))
   (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1)) (TR!OCCURS E S)
   (= T (TR!EMPTY)) (IN (TR!EMPTY) (PROCESS-TRACES P1))
   (NOT (IN (TR!APPEND S (TR!EMPTY)) (PROCESS-TRACES P1)))
   (IN S (PROCESS-TRACES P1)))
  (SOME (T$1)
   (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
    (SOME (T2$0)
     (AND (IN T2$0 (PROCESS-TRACES P2))
      (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0))))))))
Which simplifies
 when rewriting with TR!APPEND-EMPTY-RIGHT
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
TR!NOT-IS-TRACE-IS-EMPTY, PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ
 with the assumptions TR!APPEND-NOT-EMPTY-RIGHT, TR!APPEND-NOT-EMPTY-LEFT,
TR!BUT-LAST-IS-TRACE, TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY to ...
(TRUE)
Starting case 3.1.2.1.1 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (IN T2$1 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (NOT (IN S (PROCESS-TRACES P1))))
 (SOME (T$11)
  (AND (IN T$11 (PROCESS-TRACES P1)) (TR!OCCURS E T$11)
   (SOME (T2$9)
    (AND (IN T2$9 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$11) T2$9)))))))
Assuming TR!APPEND-EQUALITY-LEMMA with the
instantiations: (= S1 S) (= S2 T) (= T1 (TR!BUT-LAST T$2))
                (= T2 T2$1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (TR!IS-TRACE S) (TR!IS-TRACE T) (TR!IS-TRACE (TR!BUT-LAST T$2))
    (TR!IS-TRACE T2$1) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1)))
   (OR
    (SOME (U1) (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1))))
    (SOME (U2)
     (AND (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))))))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (IN T2$1 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (NOT (IN S (PROCESS-TRACES P1))))
 (SOME (T$0)
  (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
   (SOME (T2)
    (AND (IN T2 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S T2$1) (= P P2) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P2) (IN T2$1 (PROCESS-TRACES P2)))
   (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2)))
  (IMPLIES
   (AND (TR!IS-TRACE S) (TR!IS-TRACE T) (TR!IS-TRACE (TR!BUT-LAST T$2))
    (TR!IS-TRACE T2$1) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
    (NOT
     (SOME (U1)
      (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1))))))
   (SOME (U2) (AND (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2)))))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (IN T2$1 (PROCESS-TRACES P2))
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (NOT (IN S (PROCESS-TRACES P1))))
 (SOME (T$0)
  (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
   (SOME (T2)
    (AND (IN T2 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!BUT-LAST-IS-TRACE, TR!IS-TRACE-BOOL,
IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P2) (IN T2$1 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1)))
 (IF (SOME (U1) (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1))))
  (IMPLIES
   (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
    (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
    (IN (TR!EMPTY) (PROCESS-TRACES P1))
    (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
    (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
    (NOT (IN S (PROCESS-TRACES P1))))
   (SOME (T$0)
    (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
     (SOME (T2)
      (AND (IN T2 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
  (IMPLIES
   (AND
    (SOME (U2) (AND (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))))
    (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
    (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
    (IN (TR!EMPTY) (PROCESS-TRACES P1))
    (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
    (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
    (NOT (IN S (PROCESS-TRACES P1))))
   (SOME (T$1)
    (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
     (SOME (T2$0)
      (AND (IN T2$0 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))))
Starting case 3.1.2.1.1.2 ...
(IMPLIES
 (AND (IS-PROCESS P2) (IN T2$1 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (SOME (U1) (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1))))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (NOT (IN S (PROCESS-TRACES P1))))
 (SOME (T$0)
  (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
   (SOME (T2)
    (AND (IN T2 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
Instantiating (= T$0 T$2) (= T2 U1) gives ...
(IMPLIES
 (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)) (TR!IS-TRACE U1)
  (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) (IS-SEQUENTIAL-PROCESS P1 E)
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
  (TR!OCCURS E T$0) (NOT (IN S (PROCESS-TRACES P1)))
  (NOT
   (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
    (IN U1 (PROCESS-TRACES P2)) (= S (TR!APPEND (TR!BUT-LAST T$0) U1)))))
 (SOME (T$1 T2$0)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (IN T2$0 (PROCESS-TRACES P2)) (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!BUT-LAST-IS-TRACE, TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)) (TR!IS-TRACE U1)
  (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) (IS-SEQUENTIAL-PROCESS P1 E)
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
  (TR!OCCURS E T$0) (NOT (IN S (PROCESS-TRACES P1)))
  (NOT (IN U1 (PROCESS-TRACES P2))))
 (SOME (T$1)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (SOME (T2$0)
    (AND (IN T2$0 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
Splitting on (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) generates ...
(IF (= S (TR!APPEND (TR!BUT-LAST T$0) U1))
 (IMPLIES
  (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S) (TR!IS-TRACE T)
   (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)) (TR!IS-TRACE U1)
   (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) (IS-SEQUENTIAL-PROCESS P1 E)
   (IS-SEQUENTIAL-PROCESS P2 E)
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
   (IN (TR!EMPTY) (PROCESS-TRACES P1))
   (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
   (TR!OCCURS E T$0) (NOT (IN S (PROCESS-TRACES P1)))
   (NOT (IN U1 (PROCESS-TRACES P2))))
  (SOME (T$1)
   (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
    (SOME (T2$0)
     (AND (IN T2$0 (PROCESS-TRACES P2))
      (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
 (IMPLIES
  (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S) (TR!IS-TRACE T)
   (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$0) T2)) (TR!IS-TRACE U1)
   (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) (IS-SEQUENTIAL-PROCESS P1 E)
   (IS-SEQUENTIAL-PROCESS P2 E)
   (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
   (IN (TR!EMPTY) (PROCESS-TRACES P1))
   (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
   (TR!OCCURS E T$0) (NOT (IN S (PROCESS-TRACES P1)))
   (NOT (IN U1 (PROCESS-TRACES P2))))
  (SOME (T$2)
   (AND (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
    (SOME (T2$1)
     (AND (IN T2$1 (PROCESS-TRACES P2))
      (= S (TR!APPEND (TR!BUT-LAST T$2) T2$1))))))))
Substituting (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) produces ...
(IMPLIES
 (AND (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE (TR!APPEND (TR!BUT-LAST T$0) U1)) (TR!IS-TRACE T)
  (= (TR!APPEND (TR!APPEND (TR!BUT-LAST T$0) U1) T)
   (TR!APPEND (TR!BUT-LAST T$0) T2))
  (TR!IS-TRACE U1) (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT
   (IN (TR!APPEND (TR!APPEND (TR!BUT-LAST T$0) U1) T) (PROCESS-TRACES P1)))
  (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
  (NOT (IN (TR!APPEND (TR!BUT-LAST T$0) U1) (PROCESS-TRACES P1)))
  (NOT (IN U1 (PROCESS-TRACES P2))))
 (SOME (T$1)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (SOME (T2$0)
    (AND (IN T2$0 (PROCESS-TRACES P2))
     (= (TR!APPEND (TR!BUT-LAST T$0) U1)
      (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
Applying TR!APPEND-ASSOCIATIVE gives ...
(IMPLIES
 (AND (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE (TR!APPEND (TR!BUT-LAST T$0) U1)) (TR!IS-TRACE T)
  (=
   (IF (AND (TR!IS-TRACE (TR!BUT-LAST T$0)) (TR!IS-TRACE U1) (TR!IS-TRACE T))
    (TR!APPEND (TR!BUT-LAST T$0) (TR!APPEND U1 T))
    (TR!APPEND (TR!APPEND (TR!BUT-LAST T$0) U1) T))
   (TR!APPEND (TR!BUT-LAST T$0) T2))
  (TR!IS-TRACE U1) (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT
   (IN
    (IF (AND (TR!IS-TRACE (TR!BUT-LAST T$0)) (TR!IS-TRACE U1) (TR!IS-TRACE T))
     (TR!APPEND (TR!BUT-LAST T$0) (TR!APPEND U1 T))
     (TR!APPEND (TR!APPEND (TR!BUT-LAST T$0) U1) T))
    (PROCESS-TRACES P1)))
  (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
  (NOT (IN (TR!APPEND (TR!BUT-LAST T$0) U1) (PROCESS-TRACES P1)))
  (NOT (IN U1 (PROCESS-TRACES P2))))
 (SOME (T$1)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (SOME (T2$0)
    (AND (IN T2$0 (PROCESS-TRACES P2))
     (= (TR!APPEND (TR!BUT-LAST T$0) U1)
      (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION, TR!IS-TRACE-CONSEQ
 with the assumptions TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!IS-TRACE-APPEND, IS-PROCESS-BOOL, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
TR!BUT-LAST-IS-TRACE to ...
(IMPLIES
 (AND (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE (TR!APPEND (TR!BUT-LAST T$0) U1)) (TR!IS-TRACE T)
  (TR!IS-TRACE U1)
  (= (TR!APPEND (TR!BUT-LAST T$0) (TR!APPEND U1 T))
   (TR!APPEND (TR!BUT-LAST T$0) T2))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT
   (IN (TR!APPEND (TR!BUT-LAST T$0) (TR!APPEND U1 T)) (PROCESS-TRACES P1)))
  (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
  (NOT (IN (TR!APPEND (TR!BUT-LAST T$0) U1) (PROCESS-TRACES P1)))
  (NOT (IN U1 (PROCESS-TRACES P2))))
 (SOME (T$1)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (SOME (T2$0)
    (AND (IN T2$0 (PROCESS-TRACES P2))
     (= (TR!APPEND (TR!BUT-LAST T$0) U1)
      (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
Which simplifies
 when rewriting with TR!APPEND-LEFT-CANCELLATION
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION, TR!IS-TRACE-CONSEQ
 with the assumptions TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!IS-TRACE-APPEND, IS-PROCESS-BOOL, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
TR!BUT-LAST-IS-TRACE to ...
(IMPLIES
 (AND (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE (TR!APPEND (TR!BUT-LAST T$0) U1)) (TR!IS-TRACE T)
  (TR!IS-TRACE U1) (= (TR!APPEND U1 T) T2) (IS-SEQUENTIAL-PROCESS P1 E)
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT
   (IN (TR!APPEND (TR!BUT-LAST T$0) (TR!APPEND U1 T)) (PROCESS-TRACES P1)))
  (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
  (NOT (IN (TR!APPEND (TR!BUT-LAST T$0) U1) (PROCESS-TRACES P1)))
  (NOT (IN U1 (PROCESS-TRACES P2))))
 (SOME (T$1)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (SOME (T2$0)
    (AND (IN T2$0 (PROCESS-TRACES P2))
     (= (TR!APPEND (TR!BUT-LAST T$0) U1)
      (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 U1) (= S2 T) (= P P2) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS P2) (TR!IS-TRACE U1) (TR!IS-TRACE T)
    (IN (TR!APPEND U1 T) (PROCESS-TRACES P2)))
   (IN U1 (PROCESS-TRACES P2)))
  (= S (TR!APPEND (TR!BUT-LAST T$0) U1)) (IS-PROCESS P2)
  (IN T2 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE (TR!APPEND (TR!BUT-LAST T$0) U1)) (TR!IS-TRACE T)
  (TR!IS-TRACE U1) (= (TR!APPEND U1 T) T2) (IS-SEQUENTIAL-PROCESS P1 E)
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT
   (IN (TR!APPEND (TR!BUT-LAST T$0) (TR!APPEND U1 T)) (PROCESS-TRACES P1)))
  (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
  (NOT (IN (TR!APPEND (TR!BUT-LAST T$0) U1) (PROCESS-TRACES P1)))
  (NOT (IN U1 (PROCESS-TRACES P2))))
 (SOME (T$1)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (SOME (T2$0)
    (AND (IN T2$0 (PROCESS-TRACES P2))
     (= (TR!APPEND (TR!BUT-LAST T$0) U1)
      (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
Which simplifies
 forward chaining using TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-TRACE-OF-IS-TRACE, TR!IS-TRACE-CONSEQ,
TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY, PROCESS-COMPOSITION
 with the assumptions TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!BUT-LAST-IS-TRACE, TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
IS-PROCESS-BOOL to ...
(TRUE)
Starting case 3.1.2.1.1.1 ...
(IMPLIES
 (AND (IS-PROCESS P2) (IN T2$1 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (NOT
   (SOME (U1) (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1)))))
  (SOME (U2) (AND (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (NOT (IN S (PROCESS-TRACES P1))))
 (SOME (T$1)
  (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
   (SOME (T2$0)
    (AND (IN T2$0 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-PROCESS P2) (IN T2$1 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (NOT
   (SOME (U1) (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1)))))
  (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (NOT (IN S (PROCESS-TRACES P1))))
 (SOME (T$0)
  (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
   (SOME (T2)
    (AND (IN T2 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 (TR!BUT-LAST T$2)) (= S2 (TR!TACK E (TR!EMPTY)))
                (= P P1) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS P1) (TR!IS-TRACE (TR!BUT-LAST T$2))
    (TR!IS-TRACE (TR!TACK E (TR!EMPTY)))
    (IN (TR!APPEND (TR!BUT-LAST T$2) (TR!TACK E (TR!EMPTY)))
     (PROCESS-TRACES P1)))
   (IN (TR!BUT-LAST T$2) (PROCESS-TRACES P1)))
  (IS-PROCESS P2) (IN T2$1 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (NOT
   (SOME (U1) (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1)))))
  (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1))) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (NOT (IN S (PROCESS-TRACES P1))))
 (SOME (T$0)
  (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
   (SOME (T2)
    (AND (IN T2 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
Which simplifies
 forward chaining using TR!OCCURS-IMPLIES-NOT-EMPTY,
IS-SEQUENTIAL-PROCESS-FRULE, TR!NOT-IS-TRACE-IS-EMPTY,
TR!IS-TRACE-OF-IS-TRACE, TR!TACK-HEAD-TAIL, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY,
TR!IS-TRACE-BOOL, TR!BUT-LAST-IS-TRACE, IS-PROCESS-BOOL to ...
(IMPLIES (IS-PROCESS P1)
 (IF
  (IN (TR!APPEND (TR!BUT-LAST T$2) (TR!TACK E (TR!EMPTY)))
   (PROCESS-TRACES P1))
  (IMPLIES
   (AND (IN (TR!BUT-LAST T$2) (PROCESS-TRACES P1)) (IS-PROCESS P2)
    (IN T2$1 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2))
    (TR!IS-TRACE S) (TR!IS-TRACE T)
    (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
    (NOT
     (SOME (U1)
      (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1)))))
    (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))
    (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
    (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
    (IN (TR!EMPTY) (PROCESS-TRACES P1))
    (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
    (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
    (NOT (IN S (PROCESS-TRACES P1))))
   (SOME (T$0)
    (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
     (SOME (T2)
      (AND (IN T2 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
  (IMPLIES
   (AND (IS-PROCESS P2) (IN T2$1 (PROCESS-TRACES P2))
    (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
    (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
    (NOT
     (SOME (U1$0)
      (AND (TR!IS-TRACE U1$0) (= S (TR!APPEND (TR!BUT-LAST T$2) U1$0)))))
    (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))
    (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
    (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
    (IN (TR!EMPTY) (PROCESS-TRACES P1))
    (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
    (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
    (NOT (IN S (PROCESS-TRACES P1))))
   (SOME (T$1)
    (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
     (SOME (T2$0)
      (AND (IN T2$0 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))))
Assuming TERMINATING-TRACE-LEMMA with the
instantiations: (= P P1) (= S T$2) (= E E) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-SEQUENTIAL-PROCESS P1 E) (IN T$2 (PROCESS-TRACES P1))
    (TR!OCCURS E T$2))
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T$2)))
    (= T$2 (TR!APPEND (TR!BUT-LAST T$2) (TR!TACK E (TR!EMPTY))))))
  (IS-PROCESS P1))
 (IF
  (IN (TR!APPEND (TR!BUT-LAST T$2) (TR!TACK E (TR!EMPTY)))
   (PROCESS-TRACES P1))
  (IMPLIES
   (AND (IN (TR!BUT-LAST T$2) (PROCESS-TRACES P1)) (IS-PROCESS P2)
    (IN T2$1 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2))
    (TR!IS-TRACE S) (TR!IS-TRACE T)
    (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
    (NOT
     (SOME (U1)
      (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1)))))
    (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))
    (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
    (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
    (IN (TR!EMPTY) (PROCESS-TRACES P1))
    (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
    (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
    (NOT (IN S (PROCESS-TRACES P1))))
   (SOME (T$0)
    (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
     (SOME (T2)
      (AND (IN T2 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
  (IMPLIES
   (AND (IS-PROCESS P2) (IN T2$1 (PROCESS-TRACES P2))
    (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2)) (TR!IS-TRACE S)
    (TR!IS-TRACE T) (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
    (NOT
     (SOME (U1$0)
      (AND (TR!IS-TRACE U1$0) (= S (TR!APPEND (TR!BUT-LAST T$2) U1$0)))))
    (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))
    (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
    (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
    (IN (TR!EMPTY) (PROCESS-TRACES P1))
    (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
    (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
    (NOT (IN S (PROCESS-TRACES P1))))
   (SOME (T$1)
    (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
     (SOME (T2$0)
      (AND (IN T2$0 (PROCESS-TRACES P2))
       (= S (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))))
Which simplifies
 forward chaining using TR!NOT-IS-TRACE-IS-EMPTY, TR!IS-TRACE-OF-IS-TRACE,
TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ, TR!TACK-HEAD-TAIL,
TR!OCCURS-IMPLIES-NOT-EMPTY, PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions IS-PROCESS-BOOL, TR!IS-TRACE-APPEND,
TR!APPEND-NOT-EMPTY-RIGHT, TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK,
TR!TAIL-TACK-SEQ, TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IN T$2 (PROCESS-TRACES P1))
  (TR!OCCURS E T$2) (NOT (TR!OCCURS E (TR!BUT-LAST T$2)))
  (= T$2 (TR!APPEND (TR!BUT-LAST T$2) (TR!TACK E (TR!EMPTY))))
  (IN (TR!BUT-LAST T$2) (PROCESS-TRACES P1)) (IS-PROCESS P2)
  (IN T2$1 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE S) (TR!IS-TRACE T)
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (NOT
   (SOME (U1) (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1)))))
  (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
  (NOT (IN S (PROCESS-TRACES P1))))
 (SOME (T$0)
  (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
   (SOME (T2)
    (AND (IN T2 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 S) (= S2 U2) (= P P1) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS P1) (TR!IS-TRACE S) (TR!IS-TRACE U2)
    (IN (TR!APPEND S U2) (PROCESS-TRACES P1)))
   (IN S (PROCESS-TRACES P1)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
  (NOT (TR!OCCURS E (TR!BUT-LAST T$2)))
  (= T$2 (TR!APPEND (TR!BUT-LAST T$2) (TR!TACK E (TR!EMPTY))))
  (IN (TR!BUT-LAST T$2) (PROCESS-TRACES P1)) (IS-PROCESS P2)
  (IN T2$1 (PROCESS-TRACES P2)) (TR!IS-TRACE-OF T2$1 (PROCESS-ALPHABET P2))
  (TR!IS-TRACE S) (TR!IS-TRACE T)
  (= (TR!APPEND S T) (TR!APPEND (TR!BUT-LAST T$2) T2$1))
  (NOT
   (SOME (U1) (AND (TR!IS-TRACE U1) (= S (TR!APPEND (TR!BUT-LAST T$2) U1)))))
  (TR!IS-TRACE U2) (= (TR!BUT-LAST T$2) (TR!APPEND S U2))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN (TR!EMPTY) (PROCESS-TRACES P1))
  (NOT (IN (TR!APPEND S T) (PROCESS-TRACES P1)))
  (NOT (IN S (PROCESS-TRACES P1))))
 (SOME (T$0)
  (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
   (SOME (T2)
    (AND (IN T2 (PROCESS-TRACES P2))
     (= S (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
Which simplifies
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!TACK-HEAD-TAIL,
TR!OCCURS-IMPLIES-NOT-EMPTY, IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-TRACE-CONSEQ,
TR!IS-EMPTY-CONSEQ, TR!NOT-IS-TRACE-IS-EMPTY, PROCESS-COMPOSITION
 with the assumptions TR!APPEND-NOT-EMPTY-RIGHT, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE,
TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL, IS-PROCESS-BOOL to ...
(TRUE)
Starting case 3.1.1 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN (TR!EMPTY) (PROCESS-TRACES P1))))
 (AND
  (SOME (T$12)
   (AND (IN T$12 (PROCESS-TRACES P1)) (TR!OCCURS E T$12)
    (SOME (T2$10)
     (AND (IN T2$10 (PROCESS-TRACES P2))
      (= (TR!EMPTY) (TR!APPEND (TR!BUT-LAST T$12) T2$10))))))
  (IMPLIES (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T$3))
   (IF (IN (TR!APPEND S$0 T$3) (PROCESS-TRACES P1))
    (IF (TR!OCCURS E S$0)
     (IMPLIES
      (AND (IN T$4 (PROCESS-TRACES P1)) (TR!OCCURS E T$4)
       (IN T2$2 (PROCESS-TRACES P2))
       (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$4) T2$2)))
      (SOME (T$13)
       (AND (IN T$13 (PROCESS-TRACES P1)) (TR!OCCURS E T$13)
        (SOME (T2$11)
         (AND (IN T2$11 (PROCESS-TRACES P2))
          (= S$0 (TR!APPEND (TR!BUT-LAST T$13) T2$11)))))))
     (IF (TR!OCCURS E T$3)
      (IMPLIES
       (AND (IN T$5 (PROCESS-TRACES P1)) (TR!OCCURS E T$5)
        (IN T2$3 (PROCESS-TRACES P2))
        (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$5) T2$3))
        (NOT (IN S$0 (PROCESS-TRACES P1))))
       (SOME (T$14)
        (AND (IN T$14 (PROCESS-TRACES P1)) (TR!OCCURS E T$14)
         (SOME (T2$12)
          (AND (IN T2$12 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$14) T2$12)))))))
      (OR (IN S$0 (PROCESS-TRACES P1))
       (SOME (T$15)
        (AND (IN T$15 (PROCESS-TRACES P1)) (TR!OCCURS E T$15)
         (SOME (T2$13)
          (AND (IN T2$13 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$15) T2$13)))))))))
    (IMPLIES
     (AND (IN T$6 (PROCESS-TRACES P1)) (TR!OCCURS E T$6)
      (IN T2$4 (PROCESS-TRACES P2))
      (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$6) T2$4)))
     (IF (IN S$0 (PROCESS-TRACES P1))
      (IMPLIES (TR!OCCURS E S$0)
       (SOME (T$16)
        (AND (IN T$16 (PROCESS-TRACES P1)) (TR!OCCURS E T$16)
         (SOME (T2$14)
          (AND (IN T2$14 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$16) T2$14)))))))
      (SOME (T$17)
       (AND (IN T$17 (PROCESS-TRACES P1)) (TR!OCCURS E T$17)
        (SOME (T2$15)
         (AND (IN T2$15 (PROCESS-TRACES P2))
          (= S$0 (TR!APPEND (TR!BUT-LAST T$17) T2$15))))))))))))
Invoking (IS-SEQUENTIAL-PROCESS P1 E) gives ...
(IMPLIES
 (AND (IS-PROCESS P1) (IN E (PROCESS-ALPHABET P1))
  (ALL (T)
   (IMPLIES (AND (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T))
    (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
     (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY)))))))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN (TR!EMPTY) (PROCESS-TRACES P1))))
 (AND
  (SOME (T$0)
   (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
    (SOME (T2)
     (AND (IN T2 (PROCESS-TRACES P2))
      (= (TR!EMPTY) (TR!APPEND (TR!BUT-LAST T$0) T2))))))
  (IMPLIES (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T$3))
   (IF (IN (TR!APPEND S$0 T$3) (PROCESS-TRACES P1))
    (IF (TR!OCCURS E S$0)
     (IMPLIES
      (AND (IN T$4 (PROCESS-TRACES P1)) (TR!OCCURS E T$4)
       (IN T2$2 (PROCESS-TRACES P2))
       (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$4) T2$2)))
      (SOME (T$1)
       (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
        (SOME (T2$0)
         (AND (IN T2$0 (PROCESS-TRACES P2))
          (= S$0 (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
     (IF (TR!OCCURS E T$3)
      (IMPLIES
       (AND (IN T$5 (PROCESS-TRACES P1)) (TR!OCCURS E T$5)
        (IN T2$3 (PROCESS-TRACES P2))
        (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$5) T2$3))
        (NOT (IN S$0 (PROCESS-TRACES P1))))
       (SOME (T$2)
        (AND (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
         (SOME (T2$1)
          (AND (IN T2$1 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$2) T2$1)))))))
      (OR (IN S$0 (PROCESS-TRACES P1))
       (SOME (T$7)
        (AND (IN T$7 (PROCESS-TRACES P1)) (TR!OCCURS E T$7)
         (SOME (T2$5)
          (AND (IN T2$5 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$7) T2$5)))))))))
    (IMPLIES
     (AND (IN T$6 (PROCESS-TRACES P1)) (TR!OCCURS E T$6)
      (IN T2$4 (PROCESS-TRACES P2))
      (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$6) T2$4)))
     (IF (IN S$0 (PROCESS-TRACES P1))
      (IMPLIES (TR!OCCURS E S$0)
       (SOME (T$8)
        (AND (IN T$8 (PROCESS-TRACES P1)) (TR!OCCURS E T$8)
         (SOME (T2$6)
          (AND (IN T2$6 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$8) T2$6)))))))
      (SOME (T$9)
       (AND (IN T$9 (PROCESS-TRACES P1)) (TR!OCCURS E T$9)
        (SOME (T2$7)
         (AND (IN T2$7 (PROCESS-TRACES P2))
          (= S$0 (TR!APPEND (TR!BUT-LAST T$9) T2$7))))))))))))
Invoking IS-PROCESS gives ...
(IMPLIES
 (AND (PAIR!IS-PAIR P1)
  (SUBSET (PROCESS-TRACES P1) (TR!TRACE-OF (PROCESS-ALPHABET P1)))
  (IN (TR!EMPTY) (PROCESS-TRACES P1)) (PREFIX-CLOSED (PROCESS-TRACES P1))
  (IN E (PROCESS-ALPHABET P1))
  (ALL (T)
   (IMPLIES (AND (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T))
    (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
     (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY)))))))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN (TR!EMPTY) (PROCESS-TRACES P1))))
 (AND
  (SOME (T$0)
   (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
    (SOME (T2)
     (AND (IN T2 (PROCESS-TRACES P2))
      (= (TR!EMPTY) (TR!APPEND (TR!BUT-LAST T$0) T2))))))
  (IMPLIES (AND (TR!IS-TRACE S$0) (TR!IS-TRACE T$3))
   (IF (IN (TR!APPEND S$0 T$3) (PROCESS-TRACES P1))
    (IF (TR!OCCURS E S$0)
     (IMPLIES
      (AND (IN T$4 (PROCESS-TRACES P1)) (TR!OCCURS E T$4)
       (IN T2$2 (PROCESS-TRACES P2))
       (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$4) T2$2)))
      (SOME (T$1)
       (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
        (SOME (T2$0)
         (AND (IN T2$0 (PROCESS-TRACES P2))
          (= S$0 (TR!APPEND (TR!BUT-LAST T$1) T2$0)))))))
     (IF (TR!OCCURS E T$3)
      (IMPLIES
       (AND (IN T$5 (PROCESS-TRACES P1)) (TR!OCCURS E T$5)
        (IN T2$3 (PROCESS-TRACES P2))
        (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$5) T2$3))
        (NOT (IN S$0 (PROCESS-TRACES P1))))
       (SOME (T$2)
        (AND (IN T$2 (PROCESS-TRACES P1)) (TR!OCCURS E T$2)
         (SOME (T2$1)
          (AND (IN T2$1 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$2) T2$1)))))))
      (OR (IN S$0 (PROCESS-TRACES P1))
       (SOME (T$7)
        (AND (IN T$7 (PROCESS-TRACES P1)) (TR!OCCURS E T$7)
         (SOME (T2$5)
          (AND (IN T2$5 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$7) T2$5)))))))))
    (IMPLIES
     (AND (IN T$6 (PROCESS-TRACES P1)) (TR!OCCURS E T$6)
      (IN T2$4 (PROCESS-TRACES P2))
      (= (TR!APPEND S$0 T$3) (TR!APPEND (TR!BUT-LAST T$6) T2$4)))
     (IF (IN S$0 (PROCESS-TRACES P1))
      (IMPLIES (TR!OCCURS E S$0)
       (SOME (T$8)
        (AND (IN T$8 (PROCESS-TRACES P1)) (TR!OCCURS E T$8)
         (SOME (T2$6)
          (AND (IN T2$6 (PROCESS-TRACES P2))
           (= S$0 (TR!APPEND (TR!BUT-LAST T$8) T2$6)))))))
      (SOME (T$9)
       (AND (IN T$9 (PROCESS-TRACES P1)) (TR!OCCURS E T$9)
        (SOME (T2$7)
         (AND (IN T2$7 (PROCESS-TRACES P2))
          (= S$0 (TR!APPEND (TR!BUT-LAST T$9) T2$7))))))))))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE,
TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PAIR!PAIR-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!BUT-LAST-IS-TRACE,
PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL to
...
(TRUE)
Starting case 2 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IN E (PROCESS-ALPHABET (COMPOSE P1 P2 E))))
Invoking COMPOSE gives ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IN E
  (PROCESS-ALPHABET
   (IF
    (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
     (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
    (MAKE-PROCESS (PROCESS-ALPHABET P1)
     (UNION
      (DIFF (PROCESS-TRACES P1)
       (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
      (MAP-APPEND
       (MAP-STRIP-TRAILING-EVENT
        (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
       (PROCESS-TRACES P2))))
    (FALSE)))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-DIFF-RELATION to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IN E (PROCESS-ALPHABET P1)))
Invoking (IS-SEQUENTIAL-PROCESS P1 E) gives ...
(IMPLIES
 (AND (IS-PROCESS P1) (IN E (PROCESS-ALPHABET P1))
  (ALL (T)
   (IMPLIES (AND (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T))
    (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
     (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY)))))))
  (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IN E (PROCESS-ALPHABET P1)))
Which simplifies
 forward chaining using IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE, IS-PROCESS-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (ALL (T)
  (IMPLIES (AND (IN T (PROCESS-TRACES (COMPOSE P1 P2 E))) (TR!OCCURS E T))
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
    (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN T (PROCESS-TRACES (COMPOSE P1 P2 E))) (TR!OCCURS E T))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))
Invoking COMPOSE gives ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN T
   (PROCESS-TRACES
    (IF
     (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
      (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
     (MAKE-PROCESS (PROCESS-ALPHABET P1)
      (UNION
       (DIFF (PROCESS-TRACES P1)
        (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
       (MAP-APPEND
        (MAP-STRIP-TRAILING-EVENT
         (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
        (PROCESS-TRACES P2))))
     (FALSE))))
  (TR!OCCURS E T))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))
Which simplifies
 when rewriting with MAP-STRIP-TRAILING-EVENT.DEFINITION,
MAP-APPEND.DEFINITION, SELECT-TERMINATED-TRACES.DEFINITION, DIFF.DEFINITION,
UNION.DEFINITION
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY, PROCESS-COMPOSITION,
IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-BOOL, TR!BUT-LAST-IS-TRACE, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-DIFF-RELATION to ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (IF (IN T (PROCESS-TRACES P1))
  (IMPLIES
   (AND (TR!OCCURS E T)
    (SOME (T$0)
     (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
      (SOME (T2)
       (AND (IN T2 (PROCESS-TRACES P2))
        (= T (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
    (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))
  (IMPLIES
   (AND
    (SOME (T$1)
     (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
      (SOME (T2$0)
       (AND (IN T2$0 (PROCESS-TRACES P2))
        (= T (TR!APPEND (TR!BUT-LAST T$1) T2$0))))))
    (TR!OCCURS E T))
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
    (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))))
Starting case 1.2 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (IN T (PROCESS-TRACES P1))
  (TR!OCCURS E T)
  (SOME (T$0)
   (AND (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
    (SOME (T2)
     (AND (IN T2 (PROCESS-TRACES P2))
      (= T (TR!APPEND (TR!BUT-LAST T$0) T2)))))))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (IN T (PROCESS-TRACES P1))
  (TR!OCCURS E T) (IN T$0 (PROCESS-TRACES P1)) (TR!OCCURS E T$0)
  (IN T2 (PROCESS-TRACES P2)) (= T (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))
Invoking (IS-SEQUENTIAL-PROCESS P1 E) gives ...
(IMPLIES
 (AND (IS-PROCESS P1) (IN E (PROCESS-ALPHABET P1))
  (ALL (T$1)
   (IMPLIES (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1))
    (AND (NOT (TR!OCCURS E (TR!BUT-LAST T$1)))
     (= T$1 (TR!APPEND (TR!BUT-LAST T$1) (TR!TACK E (TR!EMPTY)))))))
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IN T (PROCESS-TRACES P1)) (TR!OCCURS E T) (IN T$0 (PROCESS-TRACES P1))
  (TR!OCCURS E T$0) (IN T2 (PROCESS-TRACES P2))
  (= T (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))
Which simplifies
 forward chaining using IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!TACK-HEAD-TAIL, TR!OCCURS-IMPLIES-NOT-EMPTY,
PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE, IS-PROCESS-BOOL
 with the instantiation (= T$1 T) to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN T (PROCESS-TRACES P1)))
  (SOME (T$1)
   (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1)
    (SOME (T2$0)
     (AND (IN T2$0 (PROCESS-TRACES P2))
      (= T (TR!APPEND (TR!BUT-LAST T$1) T2$0))))))
  (TR!OCCURS E T))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))
Prenexing produces ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN T (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
  (TR!OCCURS E T$0) (IN T2 (PROCESS-TRACES P2))
  (= T (TR!APPEND (TR!BUT-LAST T$0) T2)) (TR!OCCURS E T))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST T)))
  (= T (TR!APPEND (TR!BUT-LAST T) (TR!TACK E (TR!EMPTY))))))
Substituting (= T (TR!APPEND (TR!BUT-LAST T$0) T2)) produces ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN T (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
  (TR!OCCURS E T$0) (IN T2 (PROCESS-TRACES P2))
  (= T (TR!APPEND (TR!BUT-LAST T$0) T2))
  (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (AND (NOT (TR!OCCURS E (TR!BUT-LAST (TR!APPEND (TR!BUT-LAST T$0) T2))))
  (= (TR!APPEND (TR!BUT-LAST T$0) T2)
   (TR!APPEND (TR!BUT-LAST (TR!APPEND (TR!BUT-LAST T$0) T2))
    (TR!TACK E (TR!EMPTY))))))
Applying TR!BUT-LAST-APPEND gives ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN T (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
  (TR!OCCURS E T$0) (IN T2 (PROCESS-TRACES P2))
  (= T (TR!APPEND (TR!BUT-LAST T$0) T2))
  (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (AND
  (NOT
   (TR!OCCURS E
    (IF (AND (TR!IS-TRACE (TR!BUT-LAST T$0)) (NOT (TR!IS-EMPTY T2)))
     (TR!APPEND (TR!BUT-LAST T$0) (TR!BUT-LAST T2))
     (TR!BUT-LAST (TR!APPEND (TR!BUT-LAST T$0) T2)))))
  (= (TR!APPEND (TR!BUT-LAST T$0) T2)
   (TR!APPEND
    (IF (AND (TR!IS-TRACE (TR!BUT-LAST T$0)) (NOT (TR!IS-EMPTY T2)))
     (TR!APPEND (TR!BUT-LAST T$0) (TR!BUT-LAST T2))
     (TR!BUT-LAST (TR!APPEND (TR!BUT-LAST T$0) T2)))
    (TR!TACK E (TR!EMPTY))))))
Assuming IN-PROCESS-TRACES with the
instantiations: (= S T2) (= P P2) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2)))
   (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)))
  (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN T (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
  (TR!OCCURS E T$0) (IN T2 (PROCESS-TRACES P2))
  (= T (TR!APPEND (TR!BUT-LAST T$0) T2))
  (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (AND
  (NOT
   (TR!OCCURS E
    (IF (AND (TR!IS-TRACE (TR!BUT-LAST T$0)) (NOT (TR!IS-EMPTY T2)))
     (TR!APPEND (TR!BUT-LAST T$0) (TR!BUT-LAST T2))
     (TR!BUT-LAST (TR!APPEND (TR!BUT-LAST T$0) T2)))))
  (= (TR!APPEND (TR!BUT-LAST T$0) T2)
   (TR!APPEND
    (IF (AND (TR!IS-TRACE (TR!BUT-LAST T$0)) (NOT (TR!IS-EMPTY T2)))
     (TR!APPEND (TR!BUT-LAST T$0) (TR!BUT-LAST T2))
     (TR!BUT-LAST (TR!APPEND (TR!BUT-LAST T$0) T2)))
    (TR!TACK E (TR!EMPTY))))))
Which simplifies
 when rewriting with TR!APPEND-EMPTY-RIGHT, TR!APPEND-LEFT-CANCELLATION,
TR!APPEND-ASSOCIATIVE, TR!OCCURS-APPEND
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL,
TR!OCCURS-IMPLIES-NOT-EMPTY, IS-SEQUENTIAL-PROCESS-FRULE, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions TR!APPEND-NOT-EMPTY-LEFT, TR!TACK-NOT-EMPTY,
TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ, TR!TAIL-TACK-EMPTY,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, TR!APPEND-NOT-EMPTY-RIGHT,
TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL, TR!BUT-LAST-IS-TRACE,
IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)) (IS-SEQUENTIAL-PROCESS P1 E)
  (IS-SEQUENTIAL-PROCESS P2 E) (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN T (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
  (TR!OCCURS E T$0) (= T (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (IF (TR!OCCURS E (TR!BUT-LAST T$0))
  (AND (TR!IS-EMPTY T2) (NOT (TR!OCCURS E (TR!BUT-LAST (TR!BUT-LAST T$0))))
   (= (TR!BUT-LAST T$0)
    (TR!APPEND (TR!BUT-LAST (TR!BUT-LAST T$0)) (TR!TACK E (TR!EMPTY)))))
  (IMPLIES (TR!OCCURS E T2)
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
    (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))))))
Invoking IS-SEQUENTIAL-PROCESS gives ...
(IMPLIES
 (AND (IS-PROCESS P2) (IN T2 (PROCESS-TRACES P2))
  (TR!IS-TRACE-OF T2 (PROCESS-ALPHABET P2)) (IS-PROCESS P1)
  (IN E (PROCESS-ALPHABET P1))
  (ALL (T$1)
   (IMPLIES (AND (IN T$1 (PROCESS-TRACES P1)) (TR!OCCURS E T$1))
    (AND (NOT (TR!OCCURS E (TR!BUT-LAST T$1)))
     (= T$1 (TR!APPEND (TR!BUT-LAST T$1) (TR!TACK E (TR!EMPTY)))))))
  (IS-PROCESS P2) (IN E (PROCESS-ALPHABET P2))
  (ALL (T$2)
   (IMPLIES (AND (IN T$2 (PROCESS-TRACES P2)) (TR!OCCURS E T$2))
    (AND (NOT (TR!OCCURS E (TR!BUT-LAST T$2)))
     (= T$2 (TR!APPEND (TR!BUT-LAST T$2) (TR!TACK E (TR!EMPTY)))))))
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (NOT (IN T (PROCESS-TRACES P1))) (IN T$0 (PROCESS-TRACES P1))
  (TR!OCCURS E T$0) (= T (TR!APPEND (TR!BUT-LAST T$0) T2)))
 (IF (TR!OCCURS E (TR!BUT-LAST T$0))
  (AND (TR!IS-EMPTY T2) (NOT (TR!OCCURS E (TR!BUT-LAST (TR!BUT-LAST T$0))))
   (= (TR!BUT-LAST T$0)
    (TR!APPEND (TR!BUT-LAST (TR!BUT-LAST T$0)) (TR!TACK E (TR!EMPTY)))))
  (IMPLIES (TR!OCCURS E T2)
   (AND (NOT (TR!OCCURS E (TR!BUT-LAST T2)))
    (= T2 (TR!APPEND (TR!BUT-LAST T2) (TR!TACK E (TR!EMPTY))))))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!TACK-HEAD-TAIL,
TR!OCCURS-IMPLIES-NOT-EMPTY, TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE,
PROCESS-COMPOSITION
 with the assumptions TR!IS-TRACE-APPEND, TR!APPEND-NOT-EMPTY-RIGHT,
TR!TACK-NOT-EMPTY, TR!IS-TRACE-TACK, TR!HEAD-TACK, TR!TAIL-TACK-SEQ,
TR!IS-TRACE-BOOL, TR!TAIL-TACK-EMPTY, TR!IS-EMPTY-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, TR!BUT-LAST-IS-TRACE, IS-PROCESS-BOOL
 with the instantiations (= T$1 T$0) (= T$2 T2) to ...
(TRUE)
Completing all cases produces ...
(TRUE)
PROCESS-ALPHABET-COMPOSE
Beginning proof of PROCESS-ALPHABET-COMPOSE ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (= (PROCESS-ALPHABET (COMPOSE P1 P2 E)) (PROCESS-ALPHABET P1)))
Which simplifies
 with invocation of COMPOSE
 forward chaining using PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-DIFF-RELATION,
COMPOSE-IS-SEQUENTIAL-PROCESS to ...
(TRUE)
PROCESS-TRACES-COMPOSE
Beginning proof of PROCESS-TRACES-COMPOSE ...
(IMPLIES
 (AND (IS-SEQUENTIAL-PROCESS P1 E) (IS-SEQUENTIAL-PROCESS P2 E)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)))
 (= (PROCESS-TRACES (COMPOSE P1 P2 E))
  (UNION
   (DIFF (PROCESS-TRACES P1) (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
   (MAP-APPEND
    (MAP-STRIP-TRAILING-EVENT
     (SELECT-TERMINATED-TRACES (PROCESS-TRACES P1) E))
    (PROCESS-TRACES P2)))))
Which simplifies
 with invocation of COMPOSE
 forward chaining using PROCESS-COMPOSITION, IS-SEQUENTIAL-PROCESS-FRULE
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-DIFF-RELATION,
COMPOSE-IS-SEQUENTIAL-PROCESS to ...
(TRUE)
PROCESS-INCLUDED
PROCESS-INCLUDED-REFLEXIVE
Beginning proof of PROCESS-INCLUDED-REFLEXIVE ...
(PROCESS-INCLUDED P P)
Which simplifies
 with invocation of PROCESS-INCLUDED
 when rewriting with SUBSET.SELF to ...
(TRUE)
PROCESS-INCLUDED-TRANSITIVE
Beginning proof of PROCESS-INCLUDED-TRANSITIVE ...
(IMPLIES (AND (PROCESS-INCLUDED P1 P2) (PROCESS-INCLUDED P2 P3))
 (PROCESS-INCLUDED P1 P3))
Which simplifies
 with invocation of SUBSET, PROCESS-INCLUDED to ...
(IMPLIES
 (AND (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (ALL (E) (IMPLIES (IN E (PROCESS-TRACES P1)) (IN E (PROCESS-TRACES P2))))
  (= (PROCESS-ALPHABET P2) (PROCESS-ALPHABET P3))
  (ALL (E$0)
   (IMPLIES (IN E$0 (PROCESS-TRACES P2)) (IN E$0 (PROCESS-TRACES P3)))))
 (ALL (E$1)
  (IMPLIES (IN E$1 (PROCESS-TRACES P1)) (IN E$1 (PROCESS-TRACES P3)))))
Instantiating (= E E$1) gives ...
(IMPLIES
 (AND (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (IMPLIES (IN E (PROCESS-TRACES P1)) (IN E (PROCESS-TRACES P2)))
  (ALL (E$0)
   (IMPLIES (IN E$0 (PROCESS-TRACES P1)) (IN E$0 (PROCESS-TRACES P2))))
  (= (PROCESS-ALPHABET P2) (PROCESS-ALPHABET P3))
  (ALL (E$1)
   (IMPLIES (IN E$1 (PROCESS-TRACES P2)) (IN E$1 (PROCESS-TRACES P3))))
  (IN E (PROCESS-TRACES P1)))
 (IN E (PROCESS-TRACES P3)))
Which simplifies
 with the instantiation (= E$1 E) to ...
(TRUE)
PROCESS-INCLUDED-ANTI-SYMMETRIC
Beginning proof of PROCESS-INCLUDED-ANTI-SYMMETRIC ...
(IMPLIES
 (AND (IS-PROCESS P1) (IS-PROCESS P2) (PROCESS-INCLUDED P1 P2)
  (PROCESS-INCLUDED P2 P1))
 (= P1 P2))
Which simplifies
 with invocation of SUBSET, PROCESS-INCLUDED
 forward chaining using PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (IS-PROCESS P1) (IS-PROCESS P2)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (ALL (E) (IMPLIES (IN E (PROCESS-TRACES P1)) (IN E (PROCESS-TRACES P2))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (PROCESS-TRACES P2)) (IN E$0 (PROCESS-TRACES P1)))))
 (= P1 P2))
Assuming =.EXTENSIONAL.SUBSET with the
instantiations: (= X (PROCESS-TRACES P1)) (= Y (PROCESS-TRACES P2)) generates
...
(IMPLIES
 (AND
  (= (= (PROCESS-TRACES P1) (PROCESS-TRACES P2))
   (AND (SUBSET (PROCESS-TRACES P1) (PROCESS-TRACES P2))
    (SUBSET (PROCESS-TRACES P2) (PROCESS-TRACES P1))))
  (IS-PROCESS P1) (IS-PROCESS P2)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (ALL (E) (IMPLIES (IN E (PROCESS-TRACES P1)) (IN E (PROCESS-TRACES P2))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (PROCESS-TRACES P2)) (IN E$0 (PROCESS-TRACES P1)))))
 (= P1 P2))
Invoking SUBSET gives ...
(IMPLIES
 (AND
  (= (= (PROCESS-TRACES P1) (PROCESS-TRACES P2))
   (AND
    (ALL (E) (IMPLIES (IN E (PROCESS-TRACES P1)) (IN E (PROCESS-TRACES P2))))
    (ALL (E$0)
     (IMPLIES (IN E$0 (PROCESS-TRACES P2)) (IN E$0 (PROCESS-TRACES P1))))))
  (IS-PROCESS P1) (IS-PROCESS P2)
  (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2))
  (ALL (E$1)
   (IMPLIES (IN E$1 (PROCESS-TRACES P1)) (IN E$1 (PROCESS-TRACES P2))))
  (ALL (E$2)
   (IMPLIES (IN E$2 (PROCESS-TRACES P2)) (IN E$2 (PROCESS-TRACES P1)))))
 (= P1 P2))
Rearranging gives ...
(IMPLIES
 (AND (= (PROCESS-ALPHABET P1) (PROCESS-ALPHABET P2)) (IS-PROCESS P1)
  (IS-PROCESS P2)
  (ALL (E$1)
   (IMPLIES (IN E$1 (PROCESS-TRACES P1)) (IN E$1 (PROCESS-TRACES P2))))
  (ALL (E$2)
   (IMPLIES (IN E$2 (PROCESS-TRACES P2)) (IN E$2 (PROCESS-TRACES P1))))
  (= (= (PROCESS-TRACES P1) (PROCESS-TRACES P2))
   (AND
    (ALL (E) (IMPLIES (IN E (PROCESS-TRACES P1)) (IN E (PROCESS-TRACES P2))))
    (ALL (E$0)
     (IMPLIES (IN E$0 (PROCESS-TRACES P2)) (IN E$0 (PROCESS-TRACES P1)))))))
 (= P1 P2))
Which simplifies
 forward chaining using PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL
 with the instantiations (= E$1 E) (= E$2 E$0) to ...
(TRUE)
STOP-IS-LEAST
Beginning proof of STOP-IS-LEAST ...
(IMPLIES (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A))
 (= (PROCESS-INCLUDED (STOP A) P) (TRUE)))
Which simplifies
 with invocation of PROCESS-INCLUDED
 when rewriting with SUBSET.NULLSET.LEFT, SETRULES!SUBSET-SETADD,
SETRULES!UNIT-TO-SETADD, PROCESS-TRACES-STOP, PROCESS-ALPHABET-STOP
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PROCESS-COMPOSITION
 with the assumptions TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, IS-PROCESS-STOP,
IS-PROCESS-BOOL to ...
(IMPLIES (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A))
 (IN (TR!EMPTY) (PROCESS-TRACES P)))
Invoking IS-PROCESS gives ...
(IMPLIES
 (AND (PAIR!IS-PAIR P)
  (SUBSET (PROCESS-TRACES P) (TR!TRACE-OF (PROCESS-ALPHABET P)))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (= (PROCESS-ALPHABET P) A))
 (IN (TR!EMPTY) (PROCESS-TRACES P)))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
PAIR!PAIR-COMPOSITION
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, PAIR!IS-PAIR-BOOL to ...
(TRUE)
IS-PROCESS-CHAIN
COLLECT-TRACES
PROCESS-CHAIN-LIMIT
ALPHABET-PROCESS-CHAIN-ELEMENT
Beginning proof of ALPHABET-PROCESS-CHAIN-ELEMENT ...
(IMPLIES (AND (> I 0) (IS-PROCESS-CHAIN PC))
 (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0))))
Inducting using the following scheme ...
 (AND (IMPLIES (NAT!ZEROP I) (*P* I PC))
  (IMPLIES (AND (NOT (NAT!ZEROP I)) (*P* (- I 1) PC)) (*P* I PC)))
 produces ...
(AND
 (IMPLIES (NAT!ZEROP I)
  (IMPLIES (AND (> I 0) (IS-PROCESS-CHAIN PC))
   (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0)))))
 (IMPLIES
  (AND (NOT (NAT!ZEROP I))
   (IMPLIES (AND (> (- I 1) 0) (IS-PROCESS-CHAIN PC))
    (= (PROCESS-ALPHABET (FN!APPLY PC (- I 1)))
     (PROCESS-ALPHABET (FN!APPLY PC 0)))))
  (IMPLIES (AND (> I 0) (IS-PROCESS-CHAIN PC))
   (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0))))))
Which simplifies
 with invocation of SUBSET, PROCESS-INCLUDED, IS-PROCESS-CHAIN, NAT!ZEROP
 when rewriting with NAT!IN-NAT
 forward chaining using FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL, SUCC.INT to ...
(IMPLIES (>= I 1)
 (IF (>= (+ -1 I) 1)
  (IMPLIES
   (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
    (ALL (N)
     (IMPLIES (>= N 0)
      (AND
       (= (PROCESS-ALPHABET (FN!APPLY PC N))
        (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
       (ALL (E)
        (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC N)))
         (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
    (= (PROCESS-ALPHABET (FN!APPLY PC (+ -1 I)))
     (PROCESS-ALPHABET (FN!APPLY PC 0))))
   (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0))))
  (IMPLIES
   (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
    (ALL (N$0)
     (IMPLIES (>= N$0 0)
      (AND
       (= (PROCESS-ALPHABET (FN!APPLY PC N$0))
        (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N$0))))
       (ALL (E$0)
        (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N$0)))
         (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N$0))))))))))
   (= (PROCESS-ALPHABET (FN!APPLY PC 1)) (PROCESS-ALPHABET (FN!APPLY PC 0))))))
Starting case 2 ...
(IMPLIES
 (AND (>= I 1) (>= (+ -1 I) 1) (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E)
      (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (= (PROCESS-ALPHABET (FN!APPLY PC (+ -1 I)))
   (PROCESS-ALPHABET (FN!APPLY PC 0))))
 (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0))))
Instantiating (= N (- I 1)) gives ...
(IMPLIES
 (AND (>= I 1) (>= (+ -1 I) 1) (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (IMPLIES (>= (- I 1) 0)
   (AND
    (= (PROCESS-ALPHABET (FN!APPLY PC (- I 1)))
     (PROCESS-ALPHABET (FN!APPLY PC (+ 1 (- I 1)))))
    (ALL (E)
     (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC (- I 1))))
      (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 (- I 1)))))))))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (= (PROCESS-ALPHABET (FN!APPLY PC (+ -1 I)))
   (PROCESS-ALPHABET (FN!APPLY PC 0))))
 (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (>= I 1) (NOT (>= (+ -1 I) 1)) (FN!IS-FUNCTION PC)
  (= (REL!DOM PC) (NAT!NAT))
  (ALL (N$0)
   (IMPLIES (>= N$0 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N$0))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N$0))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N$0)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N$0))))))))))
 (= (PROCESS-ALPHABET (FN!APPLY PC 1)) (PROCESS-ALPHABET (FN!APPLY PC 0))))
Instantiating (= N$0 0) gives ...
(IMPLIES
 (AND (>= I 1) (NOT (>= (+ -1 I) 1)) (FN!IS-FUNCTION PC)
  (= (REL!DOM PC) (NAT!NAT))
  (IMPLIES (>= 0 0)
   (AND
    (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET (FN!APPLY PC 1)))
    (ALL (E)
     (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC 0)))
      (IN E (PROCESS-TRACES (FN!APPLY PC 1)))))))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N))))))))))
 (= (PROCESS-ALPHABET (FN!APPLY PC 1)) (PROCESS-ALPHABET (FN!APPLY PC 0))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
ELEMENT-INCLUDED-IN-LIMIT
Beginning proof of ELEMENT-INCLUDED-IN-LIMIT ...
(IMPLIES (AND (IN I (NAT!NAT)) (IS-PROCESS-CHAIN PC))
 (PROCESS-INCLUDED (FN!APPLY PC I) (PROCESS-CHAIN-LIMIT PC)))
Which simplifies
 with invocation of SUBSET, PROCESS-INCLUDED, PROCESS-CHAIN-LIMIT
 when rewriting with CUP.DEFINITION, NAT!IN-NAT
 forward chaining using >=.SAME.TYPE
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS to ...
(IMPLIES (AND (>= I 0) (IS-PROCESS-CHAIN PC))
 (AND
  (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0)))
  (ALL (E)
   (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC I)))
    (SOME (Y) (AND (IN E Y) (IN Y (COLLECT-TRACES PC))))))))
Starting case 2 ...
(IMPLIES (AND (>= I 0) (IS-PROCESS-CHAIN PC))
 (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0))))
Splitting on (= I 0) generates ...
(IF (= I 0)
 (IMPLIES (AND (>= I 0) (IS-PROCESS-CHAIN PC))
  (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0))))
 (IMPLIES (AND (>= I 0) (IS-PROCESS-CHAIN PC))
  (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET (FN!APPLY PC 0)))))
Which simplifies
 when rewriting with ALPHABET-PROCESS-CHAIN-ELEMENT
 forward chaining using >=.SAME.TYPE
 with the assumptions SUCC.INT to ...
(TRUE)
Starting case 1 ...
(IMPLIES (AND (>= I 0) (IS-PROCESS-CHAIN PC))
 (ALL (E)
  (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC I)))
   (SOME (Y) (AND (IN E Y) (IN Y (COLLECT-TRACES PC)))))))
Which simplifies
 with invocation of SUBSET, PROCESS-INCLUDED, IS-PROCESS-CHAIN
 when rewriting with NAT!IN-NAT
 forward chaining using FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (>= I 0) (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E)
      (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 N))))))))))
 (ALL (E$0)
  (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC I)))
   (SOME (Y) (AND (IN E$0 Y) (IN Y (COLLECT-TRACES PC)))))))
Instantiating (= N I) (= E E$0) gives ...
(IMPLIES
 (AND (>= I 0) (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (IMPLIES (>= I 0)
   (AND
    (= (PROCESS-ALPHABET (FN!APPLY PC I))
     (PROCESS-ALPHABET (FN!APPLY PC (+ 1 I))))
    (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC I)))
     (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 I)))))))
  (ALL (N E$0)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
      (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N))))))))
  (IN E (PROCESS-TRACES (FN!APPLY PC I))))
 (SOME (Y) (AND (IN E Y) (IN Y (COLLECT-TRACES PC)))))
Which simplifies
 forward chaining using FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (>= I 0) (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (= (PROCESS-ALPHABET (FN!APPLY PC I))
   (PROCESS-ALPHABET (FN!APPLY PC (+ 1 I))))
  (IN E (PROCESS-TRACES (FN!APPLY PC I)))
  (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 I))))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N))))))))))
 (SOME (Y) (AND (IN E Y) (IN Y (COLLECT-TRACES PC)))))
Which simplifies
 when rewriting with COLLECT-TRACES.DEFINITION
 forward chaining using FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (>= I 0) (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (= (PROCESS-ALPHABET (FN!APPLY PC I))
   (PROCESS-ALPHABET (FN!APPLY PC (+ 1 I))))
  (IN E (PROCESS-TRACES (FN!APPLY PC I)))
  (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 I))))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N))))))))))
 (SOME (X) (AND (IN E (PROCESS-TRACES X)) (IN X (REL!RAN PC)))))
Which simplifies
 when rewriting with NAT!IN-NAT, FN!IN-RAN-FUNCTION
 forward chaining using FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
UPPER-BOUND-AXIOM
Beginning proof of UPPER-BOUND-AXIOM ...
(IMPLIES
 (AND (IS-PROCESS-CHAIN PC) (IS-PROCESS Q)
  (ALL (I) (IMPLIES (IN I (NAT!NAT)) (PROCESS-INCLUDED (FN!APPLY PC I) Q))))
 (PROCESS-INCLUDED (PROCESS-CHAIN-LIMIT PC) Q))
Which simplifies
 with invocation of PROCESS-CHAIN-LIMIT, SUBSET, PROCESS-INCLUDED,
IS-PROCESS-CHAIN
 when rewriting with CUP.DEFINITION, NAT!IN-NAT
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E)
      (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (ALL (I)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC I)))
       (IN E$0 (PROCESS-TRACES Q))))))))
 (AND (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET Q))
  (ALL (E$1 Y)
   (IMPLIES (AND (IN E$1 Y) (IN Y (COLLECT-TRACES PC)))
    (IN E$1 (PROCESS-TRACES Q))))))
Applying COLLECT-TRACES.DEFINITION gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E)
      (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (ALL (I)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC I)))
       (IN E$0 (PROCESS-TRACES Q))))))))
 (AND (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET Q))
  (ALL (E$1 Y)
   (IMPLIES
    (AND (IN E$1 Y)
     (SOME (X) (AND (IN X (REL!RAN PC)) (= Y (PROCESS-TRACES X)))))
    (IN E$1 (PROCESS-TRACES Q))))))
Prenexing produces ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (ALL (I)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (ALL (E$1)
      (IMPLIES (IN E$1 (PROCESS-TRACES (FN!APPLY PC I)))
       (IN E$1 (PROCESS-TRACES Q))))))))
 (AND (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET Q))
  (IMPLIES (AND (IN E Y) (IN X (REL!RAN PC)) (= Y (PROCESS-TRACES X)))
   (IN E (PROCESS-TRACES Q)))))
Applying FN!IN-RAN-FUNCTION gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (ALL (I)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (ALL (E$1)
      (IMPLIES (IN E$1 (PROCESS-TRACES (FN!APPLY PC I)))
       (IN E$1 (PROCESS-TRACES Q))))))))
 (AND (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET Q))
  (IMPLIES
   (AND (IN E Y)
    (IF (FN!IS-FUNCTION PC)
     (SOME (Y$0) (AND (IN Y$0 (REL!DOM PC)) (= X (FN!APPLY PC Y$0))))
     (IN X (REL!RAN PC)))
    (= Y (PROCESS-TRACES X)))
   (IN E (PROCESS-TRACES Q)))))
Prenexing produces ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (ALL (I)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (ALL (E$1)
      (IMPLIES (IN E$1 (PROCESS-TRACES (FN!APPLY PC I)))
       (IN E$1 (PROCESS-TRACES Q))))))))
 (AND (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET Q))
  (IMPLIES
   (AND (IN E Y)
    (IF (FN!IS-FUNCTION PC)
     (AND (IN Y$0 (REL!DOM PC)) (= X (FN!APPLY PC Y$0))) (IN X (REL!RAN PC)))
    (= Y (PROCESS-TRACES X)))
   (IN E (PROCESS-TRACES Q)))))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (ALL (I)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (ALL (E$1)
      (IMPLIES (IN E$1 (PROCESS-TRACES (FN!APPLY PC I)))
       (IN E$1 (PROCESS-TRACES Q))))))))
 (AND (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET Q))
  (IMPLIES
   (AND (IN E Y) (>= Y$0 0) (= X (FN!APPLY PC Y$0)) (= Y (PROCESS-TRACES X)))
   (IN E (PROCESS-TRACES Q)))))
Starting case 2 ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (ALL (I)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (ALL (E$1)
      (IMPLIES (IN E$1 (PROCESS-TRACES (FN!APPLY PC I)))
       (IN E$1 (PROCESS-TRACES Q))))))))
 (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET Q)))
Instantiating (= I 0) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E)
      (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (IMPLIES (>= 0 0)
   (AND (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET Q))
    (ALL (E$0)
     (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC 0)))
      (IN E$0 (PROCESS-TRACES Q))))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (ALL (E$1)
      (IMPLIES (IN E$1 (PROCESS-TRACES (FN!APPLY PC I)))
       (IN E$1 (PROCESS-TRACES Q))))))))
 (= (PROCESS-ALPHABET (FN!APPLY PC 0)) (PROCESS-ALPHABET Q)))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (ALL (I)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (ALL (E$1)
      (IMPLIES (IN E$1 (PROCESS-TRACES (FN!APPLY PC I)))
       (IN E$1 (PROCESS-TRACES Q)))))))
  (IN E Y) (>= Y$0 0) (= X (FN!APPLY PC Y$0)) (= Y (PROCESS-TRACES X)))
 (IN E (PROCESS-TRACES Q)))
Instantiating (= I Y$0) (= E$1 E) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION PC) (= (REL!DOM PC) (NAT!NAT))
  (ALL (N)
   (IMPLIES (>= N 0)
    (AND
     (= (PROCESS-ALPHABET (FN!APPLY PC N))
      (PROCESS-ALPHABET (FN!APPLY PC (+ 1 N))))
     (ALL (E$0)
      (IMPLIES (IN E$0 (PROCESS-TRACES (FN!APPLY PC N)))
       (IN E$0 (PROCESS-TRACES (FN!APPLY PC (+ 1 N)))))))))
  (IS-PROCESS Q)
  (IMPLIES (>= Y$0 0)
   (AND (= (PROCESS-ALPHABET (FN!APPLY PC Y$0)) (PROCESS-ALPHABET Q))
    (IMPLIES (IN E (PROCESS-TRACES (FN!APPLY PC Y$0)))
     (IN E (PROCESS-TRACES Q)))))
  (ALL (I E$1)
   (IMPLIES (>= I 0)
    (AND (= (PROCESS-ALPHABET (FN!APPLY PC I)) (PROCESS-ALPHABET Q))
     (IMPLIES (IN E$1 (PROCESS-TRACES (FN!APPLY PC I)))
      (IN E$1 (PROCESS-TRACES Q))))))
  (IN E Y) (>= Y$0 0) (= X (FN!APPLY PC Y$0)) (= Y (PROCESS-TRACES X)))
 (IN E (PROCESS-TRACES Q)))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
IS-CONTINUOUS
ITERATE
Beginning proof of ITERATE ...
(IF (>= N 1) (M< (- N 1) N) (TRUE))
Which simplifies
 when rewriting with M<.NAT
 forward chaining using >=.SAME.TYPE
 with the assumptions SUCC.INT to ...
(TRUE)
COLLECT-PROCESS-ITERATIONS
IN-COLLECT-PROCESS-ITERATIONS
Beginning proof of IN-COLLECT-PROCESS-ITERATIONS ...
(= (IN P (COLLECT-PROCESS-ITERATIONS A F))
 (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) (NAT!NAT))
  (= (PAIR!SND P) (ITERATE (PAIR!FST P) F (STOP A)))))
Splitting on (IN P (COLLECT-PROCESS-ITERATIONS A F)) generates ...
(IF (IN P (COLLECT-PROCESS-ITERATIONS A F))
 (= (IN P (COLLECT-PROCESS-ITERATIONS A F))
  (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) (NAT!NAT))
   (= (PAIR!SND P) (ITERATE (PAIR!FST P) F (STOP A)))))
 (= (IN P (COLLECT-PROCESS-ITERATIONS A F))
  (AND (PAIR!IS-PAIR P) (IN (PAIR!FST P) (NAT!NAT))
   (= (PAIR!SND P) (ITERATE (PAIR!FST P) F (STOP A))))))
Which simplifies
 when rewriting with NAT!IN-NAT, COLLECT-PROCESS-ITERATIONS.DEFINITION
 forward chaining using PAIR!PAIR-COMPOSITION, PROCESS-COMPOSITION,
>=.SAME.TYPE
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP to ...
(IF (SOME (N) (AND (>= N 0) (= P (PAIR!PAIR N (ITERATE N F (STOP A))))))
 (AND (PAIR!IS-PAIR P) (>= (PAIR!FST P) 0)
  (= (PAIR!SND P) (ITERATE (PAIR!FST P) F (STOP A))))
 (IMPLIES (AND (PAIR!IS-PAIR P) (>= (PAIR!FST P) 0))
  (NOT (= (PAIR!SND P) (ITERATE (PAIR!FST P) F (STOP A))))))
Starting case 2 ...
(IMPLIES (SOME (N) (AND (>= N 0) (= P (PAIR!PAIR N (ITERATE N F (STOP A))))))
 (AND (PAIR!IS-PAIR P) (>= (PAIR!FST P) 0)
  (= (PAIR!SND P) (ITERATE (PAIR!FST P) F (STOP A)))))
Prenexing produces ...
(IMPLIES (AND (>= N 0) (= P (PAIR!PAIR N (ITERATE N F (STOP A)))))
 (AND (PAIR!IS-PAIR P) (>= (PAIR!FST P) 0)
  (= (PAIR!SND P) (ITERATE (PAIR!FST P) F (STOP A)))))
Substituting (= P (PAIR!PAIR N (ITERATE N F (STOP A)))) produces ...
(IMPLIES (AND (>= N 0) (= P (PAIR!PAIR N (ITERATE N F (STOP A)))))
 (AND (PAIR!IS-PAIR (PAIR!PAIR N (ITERATE N F (STOP A))))
  (>= (PAIR!FST (PAIR!PAIR N (ITERATE N F (STOP A)))) 0)
  (= (PAIR!SND (PAIR!PAIR N (ITERATE N F (STOP A))))
   (ITERATE (PAIR!FST (PAIR!PAIR N (ITERATE N F (STOP A)))) F (STOP A)))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION, PROCESS-COMPOSITION,
>=.SAME.TYPE
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND
  (NOT (SOME (N) (AND (>= N 0) (= P (PAIR!PAIR N (ITERATE N F (STOP A)))))))
  (PAIR!IS-PAIR P) (>= (PAIR!FST P) 0))
 (NOT (= (PAIR!SND P) (ITERATE (PAIR!FST P) F (STOP A)))))
Instantiating (= N (PAIR!FST P)) gives ...
(IMPLIES
 (AND
  (NOT
   (OR
    (AND (>= (PAIR!FST P) 0)
     (= P (PAIR!PAIR (PAIR!FST P) (ITERATE (PAIR!FST P) F (STOP A)))))
    (SOME (N) (AND (>= N 0) (= P (PAIR!PAIR N (ITERATE N F (STOP A))))))))
  (PAIR!IS-PAIR P) (>= (PAIR!FST P) 0))
 (NOT (= (PAIR!SND P) (ITERATE (PAIR!FST P) F (STOP A)))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION, PROCESS-COMPOSITION,
>=.SAME.TYPE
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP to ...
(TRUE)
Completing all cases produces ...
(TRUE)
DOM-COLLECT-PROCESS-ITERATIONS
Beginning proof of DOM-COLLECT-PROCESS-ITERATIONS ...
(= (REL!DOM (COLLECT-PROCESS-ITERATIONS A F)) (NAT!NAT))
Applying SETRULES!EXTENSIONALITY gives ...
(IF (IN E (REL!DOM (COLLECT-PROCESS-ITERATIONS A F))) (IN E (NAT!NAT))
 (NOT (IN E (NAT!NAT))))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using >=.SAME.TYPE to ...
(IF (IN E (REL!DOM (COLLECT-PROCESS-ITERATIONS A F))) (>= E 0) (NOT (>= E 0)))
Applying REL!IN-DOM gives ...
(IF (SOME (B) (IN (PAIR!PAIR E B) (COLLECT-PROCESS-ITERATIONS A F))) (>= E 0)
 (NOT (>= E 0)))
Which simplifies
 when rewriting with NAT!IN-NAT, IN-COLLECT-PROCESS-ITERATIONS
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
PAIR!PAIR-COMPOSITION
 with the assumptions IS-PROCESS-STOP, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR
 with the instantiation (= B (ITERATE E F (STOP A))) to ...
(TRUE)
COLLECT-PROCESS-ITERATIONS-IS-FUNCTION
Beginning proof of COLLECT-PROCESS-ITERATIONS-IS-FUNCTION ...
(= (FN!IS-FUNCTION (COLLECT-PROCESS-ITERATIONS A F)) (TRUE))
Which simplifies
 with invocation of REL!IS-RELATION, FN!IS-FUNCTION
 when rewriting with NAT!IN-NAT, IN-COLLECT-PROCESS-ITERATIONS
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
IS-PROCESS-STOP, PAIR!IS-PAIR-BOOL, FN!IS-FUNCTION-BOOL to ...
(TRUE)
APPLY-COLLECT-PROCESS-ITERATIONS
Beginning proof of APPLY-COLLECT-PROCESS-ITERATIONS ...
(IMPLIES (IN X (NAT!NAT))
 (= (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) X) (ITERATE X F (STOP A))))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F (COLLECT-PROCESS-ITERATIONS A F)) (= X X) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (COLLECT-PROCESS-ITERATIONS A F))
    (IN X (REL!DOM (COLLECT-PROCESS-ITERATIONS A F))))
   (IN (PAIR!PAIR X (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) X))
    (COLLECT-PROCESS-ITERATIONS A F)))
  (IN X (NAT!NAT)))
 (= (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) X) (ITERATE X F (STOP A))))
Which simplifies
 when rewriting with IN-COLLECT-PROCESS-ITERATIONS, NAT!IN-NAT,
DOM-COLLECT-PROCESS-ITERATIONS, COLLECT-PROCESS-ITERATIONS-IS-FUNCTION
 forward chaining using PROCESS-COMPOSITION, PAIR!PAIR-COMPOSITION,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-STOP, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL to ...
(TRUE)
MAKE-RECURSIVE-PROCESS
RECURSIVE-PROCESS-LEMMA
Beginning proof of RECURSIVE-PROCESS-LEMMA ...
(= (IN T (PROCESS-TRACES (MAKE-RECURSIVE-PROCESS A F)))
 (SOME (N) (AND (>= N 0) (IN T (PROCESS-TRACES (ITERATE N F (STOP A)))))))
Which simplifies
 with invocation of ITERATE, PROCESS-CHAIN-LIMIT, MAKE-RECURSIVE-PROCESS
 when rewriting with IN-COLLECT-PROCESS-ITERATIONS, REL!IN-RAN,
COLLECT-TRACES.DEFINITION, CUP.DEFINITION, PROCESS-ALPHABET-STOP,
APPLY-COLLECT-PROCESS-ITERATIONS, NAT!IN-NAT
 forward chaining using PAIR!PAIR-COMPOSITION, PROCESS-COMPOSITION,
>=.SAME.TYPE
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, PROCESS-ALPHABET-MAKE-PROCESS, PROCESS-TRACES-MAKE-PROCESS,
IS-PROCESS-STOP to ...
(=
 (SOME (A$0)
  (AND (IN T (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0)))
 (SOME (N) (AND (>= N 0) (IN T (PROCESS-TRACES (ITERATE N F (STOP A)))))))
Splitting
on (SOME (N)
    (AND (>= N 0) (IN T (PROCESS-TRACES (ITERATE N F (STOP A)))))) generates
...
(IF (SOME (N) (AND (>= N 0) (IN T (PROCESS-TRACES (ITERATE N F (STOP A))))))
 (=
  (SOME (A$0)
   (AND (IN T (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0)))
  (SOME (N$0)
   (AND (>= N$0 0) (IN T (PROCESS-TRACES (ITERATE N$0 F (STOP A)))))))
 (=
  (SOME (A$1)
   (AND (IN T (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0)))
  (SOME (N$1)
   (AND (>= N$1 0) (IN T (PROCESS-TRACES (ITERATE N$1 F (STOP A))))))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions IS-PROCESS-STOP
 with the instantiation (= N N$1) to ...
(IF (SOME (N) (AND (>= N 0) (IN T (PROCESS-TRACES (ITERATE N F (STOP A))))))
 (=
  (SOME (A$0)
   (AND (IN T (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0)))
  (TRUE))
 (=
  (SOME (A$1)
   (AND (IN T (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0)))
  (FALSE)))
Starting case 2 ...
(IMPLIES
 (SOME (N) (AND (>= N 0) (IN T (PROCESS-TRACES (ITERATE N F (STOP A))))))
 (=
  (SOME (A$0)
   (AND (IN T (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0)))
  (TRUE)))
Instantiating (= A$0 N) gives ...
(IMPLIES
 (AND (>= N 0) (IN T (PROCESS-TRACES (ITERATE N F (STOP A))))
  (NOT (AND (IN T (PROCESS-TRACES (ITERATE N F (STOP A)))) (>= N 0))))
 (SOME (A$0)
  (AND (IN T (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions IS-PROCESS-STOP to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (NOT
  (SOME (N) (AND (>= N 0) (IN T (PROCESS-TRACES (ITERATE N F (STOP A)))))))
 (=
  (SOME (A$1)
   (AND (IN T (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0)))
  (FALSE)))
Instantiating (= N A$1) gives ...
(IMPLIES
 (NOT
  (OR (AND (>= A$0 0) (IN T (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))
   (SOME (N) (AND (>= N 0) (IN T (PROCESS-TRACES (ITERATE N F (STOP A))))))))
 (NOT (AND (IN T (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions IS-PROCESS-STOP to ...
(TRUE)
Completing all cases produces ...
(TRUE)
SELECT-GOOD-TRACE-SETS
PROCESS-OF
IN-PROCESS-OF
Beginning proof of IN-PROCESS-OF ...
(= (IN P (PROCESS-OF A)) (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)))
Splitting on (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)) generates ...
(IF (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A))
 (= (IN P (PROCESS-OF A)) (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)))
 (= (IN P (PROCESS-OF A)) (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL to ...
(IF (IS-PROCESS P)
 (IF (= (PROCESS-ALPHABET P) A) (= (IN P (PROCESS-OF A)) (TRUE))
  (= (IN P (PROCESS-OF A)) (FALSE)))
 (= (IN P (PROCESS-OF A)) (FALSE)))
Applying PROCESS-OF.DEFINITION gives ...
(IF (IS-PROCESS P)
 (IF (= (PROCESS-ALPHABET P) A)
  (SOME (T)
   (AND (IN T (SELECT-GOOD-TRACE-SETS (POWERSET (TR!TRACE-OF A))))
    (= P (MAKE-PROCESS A T))))
  (NOT
   (SOME (T$0)
    (AND (IN T$0 (SELECT-GOOD-TRACE-SETS (POWERSET (TR!TRACE-OF A))))
     (= P (MAKE-PROCESS A T$0))))))
 (NOT
  (SOME (T$1)
   (AND (IN T$1 (SELECT-GOOD-TRACE-SETS (POWERSET (TR!TRACE-OF A))))
    (= P (MAKE-PROCESS A T$1))))))
Which simplifies
 with invocation of SUBSET
 when rewriting with TR!IN-TRACE-OF, POWERSET.DEFINITION,
SELECT-GOOD-TRACE-SETS.DEFINITION
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL to ...
(IF (IS-PROCESS P)
 (IMPLIES (= (PROCESS-ALPHABET P) A)
  (SOME (T)
   (AND (ALL (E) (IMPLIES (IN E T) (TR!IS-TRACE-OF E A))) (IN (TR!EMPTY) T)
    (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
 (NOT
  (SOME (T$0)
   (AND (ALL (E$0) (IMPLIES (IN E$0 T$0) (TR!IS-TRACE-OF E$0 A)))
    (IN (TR!EMPTY) T$0) (PREFIX-CLOSED T$0) (= P (MAKE-PROCESS A T$0))))))
Starting case 2 ...
(IMPLIES (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A))
 (SOME (T)
  (AND (ALL (E) (IMPLIES (IN E T) (TR!IS-TRACE-OF E A))) (IN (TR!EMPTY) T)
   (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
Instantiating (= T (PROCESS-TRACES P)) gives ...
(IMPLIES
 (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)
  (NOT
   (AND (ALL (E) (IMPLIES (IN E (PROCESS-TRACES P)) (TR!IS-TRACE-OF E A)))
    (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
    (= P (MAKE-PROCESS A (PROCESS-TRACES P))))))
 (SOME (T)
  (AND (ALL (E$0) (IMPLIES (IN E$0 T) (TR!IS-TRACE-OF E$0 A)))
   (IN (TR!EMPTY) T) (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL to ...
(IMPLIES (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A))
 (IF (ALL (E) (IMPLIES (IN E (PROCESS-TRACES P)) (TR!IS-TRACE-OF E A)))
  (AND (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P)))
  (SOME (T)
   (AND (ALL (E$0) (IMPLIES (IN E$0 T) (TR!IS-TRACE-OF E$0 A)))
    (IN (TR!EMPTY) T) (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T))))))
Assuming MAKE-PROCESS-IS-PROCESS with the
instantiations: (= A (PROCESS-ALPHABET P)) (= T (PROCESS-TRACES P)) generates
...
(IMPLIES
 (AND
  (= (IS-PROCESS (MAKE-PROCESS (PROCESS-ALPHABET P) (PROCESS-TRACES P)))
   (AND (SUBSET (PROCESS-TRACES P) (TR!TRACE-OF (PROCESS-ALPHABET P)))
    (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))))
  (IS-PROCESS P) (= (PROCESS-ALPHABET P) A))
 (IF (ALL (E) (IMPLIES (IN E (PROCESS-TRACES P)) (TR!IS-TRACE-OF E A)))
  (AND (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P)))
  (SOME (T)
   (AND (ALL (E$0) (IMPLIES (IN E$0 T) (TR!IS-TRACE-OF E$0 A)))
    (IN (TR!EMPTY) T) (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T))))))
Which simplifies
 forward chaining using TR!IS-TRACE-OF-IS-TRACE, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, PROCESS-COMPOSITION
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS to ...
(IMPLIES
 (AND (SUBSET (PROCESS-TRACES P) (TR!TRACE-OF (PROCESS-ALPHABET P)))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (= (IS-PROCESS (MAKE-PROCESS (PROCESS-ALPHABET P) (PROCESS-TRACES P)))
   (TRUE))
  (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)
  (NOT (ALL (E) (IMPLIES (IN E (PROCESS-TRACES P)) (TR!IS-TRACE-OF E A)))))
 (SOME (T)
  (AND (ALL (E$0) (IMPLIES (IN E$0 T) (TR!IS-TRACE-OF E$0 A)))
   (IN (TR!EMPTY) T) (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
Which simplifies
 with invocation of SUBSET
 when rewriting with MAKE-PROCESS-IS-PROCESS, TR!IN-TRACE-OF
 forward chaining using PROCESS-COMPOSITION, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE
 with the assumptions IS-PROCESS-BOOL, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY to ...
(IMPLIES
 (AND
  (ALL (E)
   (IMPLIES (IN E (PROCESS-TRACES P))
    (TR!IS-TRACE-OF E (PROCESS-ALPHABET P))))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)
  (NOT
   (ALL (E$0) (IMPLIES (IN E$0 (PROCESS-TRACES P)) (TR!IS-TRACE-OF E$0 A)))))
 (SOME (T)
  (AND (ALL (E$1) (IMPLIES (IN E$1 T) (TR!IS-TRACE-OF E$1 A)))
   (IN (TR!EMPTY) T) (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
Instantiating (= T (PROCESS-TRACES P)) gives ...
(IMPLIES
 (AND
  (ALL (E)
   (IMPLIES (IN E (PROCESS-TRACES P))
    (TR!IS-TRACE-OF E (PROCESS-ALPHABET P))))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)
  (NOT
   (ALL (E$0) (IMPLIES (IN E$0 (PROCESS-TRACES P)) (TR!IS-TRACE-OF E$0 A))))
  (NOT
   (AND
    (ALL (E$1) (IMPLIES (IN E$1 (PROCESS-TRACES P)) (TR!IS-TRACE-OF E$1 A)))
    (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
    (= P (MAKE-PROCESS A (PROCESS-TRACES P))))))
 (SOME (T)
  (AND (ALL (E$2) (IMPLIES (IN E$2 T) (TR!IS-TRACE-OF E$2 A)))
   (IN (TR!EMPTY) T) (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-BOOL, PREFIX-CLOSED-BOOL,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY to ...
(IMPLIES
 (AND
  (ALL (E)
   (IMPLIES (IN E (PROCESS-TRACES P))
    (TR!IS-TRACE-OF E (PROCESS-ALPHABET P))))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)
  (NOT
   (ALL (E$0) (IMPLIES (IN E$0 (PROCESS-TRACES P)) (TR!IS-TRACE-OF E$0 A)))))
 (SOME (T)
  (AND (ALL (E$1) (IMPLIES (IN E$1 T) (TR!IS-TRACE-OF E$1 A)))
   (IN (TR!EMPTY) T) (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
Prenexing produces ...
(IMPLIES
 (AND
  (ALL (E$0)
   (IMPLIES (IN E$0 (PROCESS-TRACES P))
    (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P))))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)
  (NOT (IMPLIES (IN E (PROCESS-TRACES P)) (TR!IS-TRACE-OF E A))))
 (SOME (T)
  (AND (ALL (E$1) (IMPLIES (IN E$1 T) (TR!IS-TRACE-OF E$1 A)))
   (IN (TR!EMPTY) T) (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
Assuming IN-PROCESS-TRACES with the instantiations: (= S E) (= P P) generates
...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-PROCESS P) (IN E (PROCESS-TRACES P)))
   (TR!IS-TRACE-OF E (PROCESS-ALPHABET P)))
  (ALL (E$0)
   (IMPLIES (IN E$0 (PROCESS-TRACES P))
    (TR!IS-TRACE-OF E$0 (PROCESS-ALPHABET P))))
  (IN (TR!EMPTY) (PROCESS-TRACES P)) (PREFIX-CLOSED (PROCESS-TRACES P))
  (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)
  (NOT (IMPLIES (IN E (PROCESS-TRACES P)) (TR!IS-TRACE-OF E A))))
 (SOME (T)
  (AND (ALL (E$1) (IMPLIES (IN E$1 T) (TR!IS-TRACE-OF E$1 A)))
   (IN (TR!EMPTY) T) (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL to ...
(TRUE)
Starting case 1 ...
(IMPLIES (NOT (IS-PROCESS P))
 (NOT
  (SOME (T$0)
   (AND (ALL (E$0) (IMPLIES (IN E$0 T$0) (TR!IS-TRACE-OF E$0 A)))
    (IN (TR!EMPTY) T$0) (PREFIX-CLOSED T$0) (= P (MAKE-PROCESS A T$0))))))
Prenexing produces ...
(IMPLIES (NOT (IS-PROCESS P))
 (NOT
  (AND (ALL (E) (IMPLIES (IN E T) (TR!IS-TRACE-OF E A))) (IN (TR!EMPTY) T)
   (PREFIX-CLOSED T) (= P (MAKE-PROCESS A T)))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL to ...
(IMPLIES
 (AND (NOT (IS-PROCESS P)) (ALL (E) (IMPLIES (IN E T) (TR!IS-TRACE-OF E A)))
  (IN (TR!EMPTY) T) (PREFIX-CLOSED T))
 (NOT (= P (MAKE-PROCESS A T))))
Splitting on (IS-PROCESS (MAKE-PROCESS A T)) generates ...
(IF (IS-PROCESS (MAKE-PROCESS A T))
 (IMPLIES
  (AND (NOT (IS-PROCESS P)) (ALL (E) (IMPLIES (IN E T) (TR!IS-TRACE-OF E A)))
   (IN (TR!EMPTY) T) (PREFIX-CLOSED T))
  (NOT (= P (MAKE-PROCESS A T))))
 (IMPLIES
  (AND (NOT (IS-PROCESS P))
   (ALL (E$0) (IMPLIES (IN E$0 T) (TR!IS-TRACE-OF E$0 A))) (IN (TR!EMPTY) T)
   (PREFIX-CLOSED T))
  (NOT (= P (MAKE-PROCESS A T)))))
Which simplifies
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS to ...
(IMPLIES
 (AND (NOT (IS-PROCESS (MAKE-PROCESS A T))) (NOT (IS-PROCESS P))
  (ALL (E) (IMPLIES (IN E T) (TR!IS-TRACE-OF E A))) (IN (TR!EMPTY) T)
  (PREFIX-CLOSED T))
 (NOT (= P (MAKE-PROCESS A T))))
Which simplifies
 with invocation of SUBSET
 when rewriting with TR!IN-TRACE-OF, MAKE-PROCESS-IS-PROCESS
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS to ...
(TRUE)
Completing all cases produces ...
(TRUE)
STOP-IN-PROCESS-OF
Beginning proof of STOP-IN-PROCESS-OF ...
(= (IN (STOP A) (PROCESS-OF A)) (TRUE))
Which simplifies
 when rewriting with PROCESS-ALPHABET-STOP, IN-PROCESS-OF
 forward chaining using PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL, IS-PROCESS-STOP to ...
(TRUE)
IS-PROCESS-CHAIN-COLLECT-PROCESS-ITERATIONS
Beginning proof of IS-PROCESS-CHAIN-COLLECT-PROCESS-ITERATIONS ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A))))))
 (IS-PROCESS-CHAIN (COLLECT-PROCESS-ITERATIONS A F)))
Invoking IS-PROCESS-CHAIN gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A))))))
 (AND (FN!IS-FUNCTION (COLLECT-PROCESS-ITERATIONS A F))
  (= (REL!DOM (COLLECT-PROCESS-ITERATIONS A F)) (NAT!NAT))
  (ALL (N)
   (IMPLIES (IN N (NAT!NAT))
    (PROCESS-INCLUDED (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) N)
     (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) (+ N 1)))))))
Which simplifies
 when rewriting with APPLY-COLLECT-PROCESS-ITERATIONS,
DOM-COLLECT-PROCESS-ITERATIONS, COLLECT-PROCESS-ITERATIONS-IS-FUNCTION,
NAT!IN-NAT
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL
 with the instantiation (= I N) to ...
(TRUE)
ITERATE-PRODUCES-PROCESS
Beginning proof of ITERATE-PRODUCES-PROCESS ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A)))
 (IN (ITERATE N F (STOP A)) (PROCESS-OF A)))
Inducting using the following scheme ...
 (AND (IMPLIES (NAT!ZEROP N) (*P* A F N))
  (IMPLIES (AND (NOT (NAT!ZEROP N)) (*P* A F (- N 1))) (*P* A F N)))
 produces ...
(AND
 (IMPLIES (NAT!ZEROP N)
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (ITERATE N F (STOP A)) (PROCESS-OF A))))
 (IMPLIES
  (AND (NOT (NAT!ZEROP N))
   (IMPLIES
    (AND (FN!IS-FUNCTION F) (>= (- N 1) 0) (= (REL!DOM F) (PROCESS-OF A))
     (SUBSET (REL!RAN F) (PROCESS-OF A)))
    (IN (ITERATE (- N 1) F (STOP A)) (PROCESS-OF A))))
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (ITERATE N F (STOP A)) (PROCESS-OF A)))))
Which simplifies
 with invocation of ITERATE, SUBSET, NAT!ZEROP
 when rewriting with STOP-IN-PROCESS-OF, IN-PROCESS-OF
 forward chaining using PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION,
>=.SAME.TYPE
 with the assumptions IS-PROCESS-STOP, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to
...
(IMPLIES
 (AND (>= N 1) (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (IS-PROCESS (ITERATE (+ -1 N) F (STOP A)))
  (= (PROCESS-ALPHABET (ITERATE (+ -1 N) F (STOP A))) A))
 (AND (IS-PROCESS (FN!APPLY F (ITERATE (+ -1 N) F (STOP A))))
  (= (PROCESS-ALPHABET (FN!APPLY F (ITERATE (+ -1 N) F (STOP A)))) A)))
Assuming FN!APPLY-IN-RAN with the
instantiations: (= F F) (= X (ITERATE (- N 1) F (STOP A))) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (IN (ITERATE (- N 1) F (STOP A)) (REL!DOM F)))
   (IN (FN!APPLY F (ITERATE (- N 1) F (STOP A))) (REL!RAN F)))
  (>= N 1) (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (IS-PROCESS (ITERATE (+ -1 N) F (STOP A)))
  (= (PROCESS-ALPHABET (ITERATE (+ -1 N) F (STOP A))) A))
 (AND (IS-PROCESS (FN!APPLY F (ITERATE (+ -1 N) F (STOP A))))
  (= (PROCESS-ALPHABET (FN!APPLY F (ITERATE (+ -1 N) F (STOP A)))) A)))
Instantiating (= E (FN!APPLY F (ITERATE (- N 1) F (STOP A)))) gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (IN (ITERATE (- N 1) F (STOP A)) (REL!DOM F)))
   (IN (FN!APPLY F (ITERATE (- N 1) F (STOP A))) (REL!RAN F)))
  (>= N 1) (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (IMPLIES (IN (FN!APPLY F (ITERATE (- N 1) F (STOP A))) (REL!RAN F))
   (AND (IS-PROCESS (FN!APPLY F (ITERATE (- N 1) F (STOP A))))
    (= (PROCESS-ALPHABET (FN!APPLY F (ITERATE (- N 1) F (STOP A)))) A)))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (IS-PROCESS (ITERATE (+ -1 N) F (STOP A)))
  (= (PROCESS-ALPHABET (ITERATE (+ -1 N) F (STOP A))) A))
 (AND (IS-PROCESS (FN!APPLY F (ITERATE (+ -1 N) F (STOP A))))
  (= (PROCESS-ALPHABET (FN!APPLY F (ITERATE (+ -1 N) F (STOP A)))) A)))
Which simplifies
 forward chaining using >=.SAME.TYPE, PROCESS-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-BOOL, IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL to
...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (NOT (IN (ITERATE (+ -1 N) F (STOP A)) (REL!DOM F)))
  (>= N 1) (= (REL!DOM F) (PROCESS-OF A))
  (NOT (IN (FN!APPLY F (ITERATE (+ -1 N) F (STOP A))) (REL!RAN F)))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (IS-PROCESS (ITERATE (+ -1 N) F (STOP A)))
  (= (PROCESS-ALPHABET (ITERATE (+ -1 N) F (STOP A))) A))
 (AND (IS-PROCESS (FN!APPLY F (ITERATE (+ -1 N) F (STOP A))))
  (= (PROCESS-ALPHABET (FN!APPLY F (ITERATE (+ -1 N) F (STOP A)))) A)))
Rearranging gives ...
(IMPLIES
 (AND (>= N 1) (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (ITERATE (+ -1 N) F (STOP A))) A) (FN!IS-FUNCTION F)
  (NOT (IN (ITERATE (+ -1 N) F (STOP A)) (REL!DOM F)))
  (NOT (IN (FN!APPLY F (ITERATE (+ -1 N) F (STOP A))) (REL!RAN F)))
  (IS-PROCESS (ITERATE (+ -1 N) F (STOP A)))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (AND (= (PROCESS-ALPHABET (FN!APPLY F (ITERATE (+ -1 N) F (STOP A)))) A)
  (IS-PROCESS (FN!APPLY F (ITERATE (+ -1 N) F (STOP A))))))
Substituting (= (REL!DOM F) (PROCESS-OF A)) produces ...
(IMPLIES
 (AND (>= N 1) (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (ITERATE (+ -1 N) F (STOP A))) A) (FN!IS-FUNCTION F)
  (NOT (IN (ITERATE (+ -1 N) F (STOP A)) (PROCESS-OF A)))
  (NOT (IN (FN!APPLY F (ITERATE (+ -1 N) F (STOP A))) (REL!RAN F)))
  (IS-PROCESS (ITERATE (+ -1 N) F (STOP A)))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (AND (= (PROCESS-ALPHABET (FN!APPLY F (ITERATE (+ -1 N) F (STOP A)))) A)
  (IS-PROCESS (FN!APPLY F (ITERATE (+ -1 N) F (STOP A))))))
Which simplifies
 when rewriting with IN-PROCESS-OF
 forward chaining using FN!FUNCTION-IS-RELATION, PROCESS-COMPOSITION,
>=.SAME.TYPE
 with the assumptions IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL, IS-PROCESS-STOP to
...
(TRUE)
BETWEEN-ITERATIONS
Beginning proof of BETWEEN-ITERATIONS ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A)))
 (IN (PAIR!PAIR (ITERATE N F (STOP A)) (ITERATE (+ N 1) F (STOP A))) F))
Invoking (ITERATE (+ N 1) F (STOP A)) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A)))
 (IN
  (PAIR!PAIR (ITERATE N F (STOP A))
   (IF (>= (+ N 1) 1) (FN!APPLY F (ITERATE (- (+ N 1) 1) F (STOP A)))
    (STOP A)))
  F))
Which simplifies
 with invocation of SUBSET
 when rewriting with IN-PROCESS-OF
 forward chaining using PAIR!PAIR-COMPOSITION, PROCESS-COMPOSITION,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
IS-PROCESS-STOP, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A)))))
 (IN (PAIR!PAIR (ITERATE N F (STOP A)) (FN!APPLY F (ITERATE N F (STOP A)))) F))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F F) (= X (ITERATE N F (STOP A))) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION F) (IN (ITERATE N F (STOP A)) (REL!DOM F)))
   (IN (PAIR!PAIR (ITERATE N F (STOP A)) (FN!APPLY F (ITERATE N F (STOP A))))
    F))
  (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A)))))
 (IN (PAIR!PAIR (ITERATE N F (STOP A)) (FN!APPLY F (ITERATE N F (STOP A)))) F))
Assuming ITERATE-PRODUCES-PROCESS with the
instantiations: (= N N) (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (ITERATE N F (STOP A)) (PROCESS-OF A)))
  (IMPLIES (AND (FN!IS-FUNCTION F) (IN (ITERATE N F (STOP A)) (REL!DOM F)))
   (IN (PAIR!PAIR (ITERATE N F (STOP A)) (FN!APPLY F (ITERATE N F (STOP A))))
    F))
  (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A)))))
 (IN (PAIR!PAIR (ITERATE N F (STOP A)) (FN!APPLY F (ITERATE N F (STOP A)))) F))
Which simplifies
 with invocation of ITERATE, SUBSET
 when rewriting with IN-PROCESS-OF
 forward chaining using PAIR!PAIR-COMPOSITION, PROCESS-COMPOSITION,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR,
IS-PROCESS-STOP, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (IS-PROCESS (ITERATE N F (STOP A)))
  (= (PROCESS-ALPHABET (ITERATE N F (STOP A))) A)
  (NOT (IN (ITERATE N F (STOP A)) (REL!DOM F))))
 (IN (PAIR!PAIR (ITERATE N F (STOP A)) (FN!APPLY F (ITERATE N F (STOP A)))) F))
Substituting (= (REL!DOM F) (PROCESS-OF A)) produces ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= N 0) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (IS-PROCESS (ITERATE N F (STOP A)))
  (= (PROCESS-ALPHABET (ITERATE N F (STOP A))) A)
  (NOT (IN (ITERATE N F (STOP A)) (PROCESS-OF A))))
 (IN (PAIR!PAIR (ITERATE N F (STOP A)) (FN!APPLY F (ITERATE N F (STOP A)))) F))
Which simplifies
 when rewriting with IN-PROCESS-OF
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-STOP, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to
...
(TRUE)
PROCESS-TRACES-ITERATE-LEMMA
Beginning proof of PROCESS-TRACES-ITERATE-LEMMA ...
(IMPLIES
 (AND (>= N 0)
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A)))))
  (IN E (PROCESS-TRACES (ITERATE N F (STOP A)))))
 (IN E (PROCESS-TRACES (ITERATE (+ N 1) F (STOP A)))))
Instantiating (= I N) gives ...
(IMPLIES
 (AND (>= N 0)
  (IMPLIES (IN N (NAT!NAT))
   (PROCESS-INCLUDED (ITERATE N F (STOP A)) (ITERATE (+ N 1) F (STOP A))))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A)))))
  (IN E (PROCESS-TRACES (ITERATE N F (STOP A)))))
 (IN E (PROCESS-TRACES (ITERATE (+ N 1) F (STOP A)))))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions IS-PROCESS-STOP to ...
(IMPLIES
 (AND (>= N 0)
  (PROCESS-INCLUDED (ITERATE N F (STOP A)) (ITERATE (+ 1 N) F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (IN E (PROCESS-TRACES (ITERATE N F (STOP A)))))
 (IN E (PROCESS-TRACES (ITERATE (+ 1 N) F (STOP A)))))
Invoking (PROCESS-INCLUDED (ITERATE N F (STOP A))
          (ITERATE (+ 1 N) F (STOP A))) gives
...
(IMPLIES
 (AND (>= N 0)
  (= (PROCESS-ALPHABET (ITERATE N F (STOP A)))
   (PROCESS-ALPHABET (ITERATE (+ 1 N) F (STOP A))))
  (SUBSET (PROCESS-TRACES (ITERATE N F (STOP A)))
   (PROCESS-TRACES (ITERATE (+ 1 N) F (STOP A))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (IN E (PROCESS-TRACES (ITERATE N F (STOP A)))))
 (IN E (PROCESS-TRACES (ITERATE (+ 1 N) F (STOP A)))))
Invoking SUBSET gives ...
(IMPLIES
 (AND (>= N 0)
  (= (PROCESS-ALPHABET (ITERATE N F (STOP A)))
   (PROCESS-ALPHABET (ITERATE (+ 1 N) F (STOP A))))
  (ALL (E$0)
   (IMPLIES (IN E$0 (PROCESS-TRACES (ITERATE N F (STOP A))))
    (IN E$0 (PROCESS-TRACES (ITERATE (+ 1 N) F (STOP A))))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (IN E (PROCESS-TRACES (ITERATE N F (STOP A)))))
 (IN E (PROCESS-TRACES (ITERATE (+ 1 N) F (STOP A)))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions IS-PROCESS-STOP
 with the instantiation (= E$0 E) to ...
(TRUE)
FIXPOINT-LEMMA-1
Beginning proof of FIXPOINT-LEMMA-1 ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A))))))
 (= (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))
  (PROCESS-CHAIN-LIMIT (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))
Invoking PROCESS-CHAIN-LIMIT gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A))))))
 (=
  (MAKE-PROCESS
   (PROCESS-ALPHABET (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) 0))
   (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS
   (PROCESS-ALPHABET
    (FN!APPLY (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F) 0))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Which simplifies
 with invocation of ITERATE, SUBSET
 when rewriting with PROCESS-ALPHABET-STOP, APPLY-COLLECT-PROCESS-ITERATIONS,
NAT!IN-NAT, IN-PROCESS-OF
 forward chaining using >=.SAME.TYPE, PROCESS-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-STOP, IS-PROCESS-BOOL,
FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A)))))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS
   (PROCESS-ALPHABET
    (FN!APPLY (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F) 0))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
                (= X 0) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
    (IN 0 (REL!DOM (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))
   (IN
    (PAIR!PAIR 0 (FN!APPLY (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F) 0))
    (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
  (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A)))))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS
   (PROCESS-ALPHABET
    (FN!APPLY (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F) 0))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Rearranging gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IMPLIES
   (AND (FN!IS-FUNCTION (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
    (IN 0 (REL!DOM (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))
   (IN
    (PAIR!PAIR 0 (FN!APPLY (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F) 0))
    (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS
   (PROCESS-ALPHABET
    (FN!APPLY (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F) 0))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Which simplifies
 with invocation of ITERATE
 when rewriting with FN!APPLY-COMP, APPLY-COLLECT-PROCESS-ITERATIONS,
NAT!IN-NAT, DOM-COLLECT-PROCESS-ITERATIONS, FN!IN-PRE-IMAGE-OF-FUNCTION,
REL!DOM-COMP, FN!IS-FUNCTION-COMP-FUNCTIONS,
COLLECT-PROCESS-ITERATIONS-IS-FUNCTION
 forward chaining using PAIR!PAIR-COMPOSITION, PROCESS-COMPOSITION,
>=.SAME.TYPE, FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP, REL!INVERSE-INVERSE,
FN!IS-FUNCTION-BOOL to ...
(IMPLIES (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F))
 (IF (IN (STOP A) (REL!DOM F))
  (IMPLIES
   (AND
    (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
     (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
    (ALL (I)
     (IMPLIES (>= I 0)
      (PROCESS-INCLUDED (ITERATE I F (STOP A))
       (FN!APPLY F (ITERATE I F (STOP A))))))
    (ALL (E)
     (IMPLIES (IN E (REL!RAN F))
      (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
   (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
    (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
     (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
  (IMPLIES
   (AND
    (ALL (I$0)
     (IMPLIES (>= I$0 0)
      (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
       (FN!APPLY F (ITERATE I$0 F (STOP A))))))
    (ALL (E$0)
     (IMPLIES (IN E$0 (REL!RAN F))
      (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0)))))
   (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
    (MAKE-PROCESS
     (PROCESS-ALPHABET
      (FN!APPLY (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F) 0))
     (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))))
Substituting (= (REL!DOM F) (PROCESS-OF A)) produces ...
(IMPLIES (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F))
 (IF (IN (STOP A) (PROCESS-OF A))
  (IMPLIES
   (AND
    (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
     (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
    (ALL (I)
     (IMPLIES (>= I 0)
      (PROCESS-INCLUDED (ITERATE I F (STOP A))
       (FN!APPLY F (ITERATE I F (STOP A))))))
    (ALL (E)
     (IMPLIES (IN E (REL!RAN F))
      (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
   (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
    (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
     (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
  (IMPLIES
   (AND
    (ALL (I$0)
     (IMPLIES (>= I$0 0)
      (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
       (FN!APPLY F (ITERATE I$0 F (STOP A))))))
    (ALL (E$0)
     (IMPLIES (IN E$0 (REL!RAN F))
      (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0)))))
   (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
    (MAKE-PROCESS
     (PROCESS-ALPHABET
      (FN!APPLY (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F) 0))
     (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))))
Which simplifies
 when rewriting with STOP-IN-PROCESS-OF
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F F) (= X (STOP A)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION F) (IN (STOP A) (REL!DOM F)))
   (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F))
  (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Rearranging gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IMPLIES (AND (FN!IS-FUNCTION F) (IN (STOP A) (REL!DOM F)))
   (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Substituting (= (REL!DOM F) (PROCESS-OF A)) produces ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
 (IF (IN (STOP A) (PROCESS-OF A))
  (IMPLIES
   (AND (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
    (ALL (I)
     (IMPLIES (>= I 0)
      (PROCESS-INCLUDED (ITERATE I F (STOP A))
       (FN!APPLY F (ITERATE I F (STOP A))))))
    (ALL (E)
     (IMPLIES (IN E (REL!RAN F))
      (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
   (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
    (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
     (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
  (IMPLIES
   (AND
    (ALL (I$0)
     (IMPLIES (>= I$0 0)
      (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
       (FN!APPLY F (ITERATE I$0 F (STOP A))))))
    (ALL (E$0)
     (IMPLIES (IN E$0 (REL!RAN F))
      (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0)))))
   (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
    (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
     (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))))
Which simplifies
 when rewriting with STOP-IN-PROCESS-OF
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Instantiating (= E (FN!APPLY F (STOP A))) gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (IMPLIES (IN (FN!APPLY F (STOP A)) (REL!RAN F))
   (AND (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
    (IS-PROCESS (FN!APPLY F (STOP A)))))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Applying REL!IN-RAN to
 (IN (FN!APPLY F (STOP A)) (REL!RAN F)) gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (IMPLIES (SOME (A$0) (IN (PAIR!PAIR A$0 (FN!APPLY F (STOP A))) F))
   (AND (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
    (IS-PROCESS (FN!APPLY F (STOP A)))))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS (PROCESS-ALPHABET (FN!APPLY F (STOP A)))
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL
 with the instantiation (= A$0 (STOP A)) to ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
 (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
  (MAKE-PROCESS A
   (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
Splitting
on (= (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))
    (CUP
     (COLLECT-TRACES
      (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))) generates
...
(IF
 (= (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))
  (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))
 (IMPLIES
  (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
   (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
    (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
   (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
   (ALL (I)
    (IMPLIES (>= I 0)
     (PROCESS-INCLUDED (ITERATE I F (STOP A))
      (FN!APPLY F (ITERATE I F (STOP A))))))
   (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
   (IS-PROCESS (FN!APPLY F (STOP A)))
   (ALL (E)
    (IMPLIES (IN E (REL!RAN F))
     (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E)))))
  (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
   (MAKE-PROCESS A
    (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
 (IMPLIES
  (AND (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
   (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
    (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
   (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
   (ALL (I$0)
    (IMPLIES (>= I$0 0)
     (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
      (FN!APPLY F (ITERATE I$0 F (STOP A))))))
   (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
   (IS-PROCESS (FN!APPLY F (STOP A)))
   (ALL (E$0)
    (IMPLIES (IN E$0 (REL!RAN F))
     (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0)))))
  (= (MAKE-PROCESS A (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
   (MAKE-PROCESS A
    (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND
  (NOT
   (= (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))
    (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))))
  (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
  (IS-PROCESS (FN!APPLY F (STOP A))))
 (NOT
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E) A) (IS-PROCESS E))))))
Applying SETRULES!EXTENSIONALITY to
 (= (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))
  (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))) gives
...
(IMPLIES
 (AND
  (NOT
   (ALL (E)
    (IF (IN E (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
     (IN E
      (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))
     (NOT
      (IN E
       (CUP
        (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))))
  (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
  (IS-PROCESS (FN!APPLY F (STOP A))))
 (NOT
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Rearranging gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (ALL (E)
    (IF (IN E (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
     (IN E
      (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))
     (NOT
      (IN E
       (CUP
        (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))))))))
 (NOT
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Prenexing produces ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (IF (IN E (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
    (IN E
     (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))
    (NOT
     (IN E
      (CUP
       (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))))
 (NOT
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Which simplifies
 when rewriting with CUP.DEFINITION
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION, PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IS-PROCESS-STOP to ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A)))))))
 (IF
  (SOME (Y)
   (AND (IN E Y) (IN Y (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
  (OR
   (SOME (Y$0)
    (AND (IN E Y$0)
     (IN Y$0 (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))))
   (NOT
    (ALL (E$0)
     (IMPLIES (IN E$0 (REL!RAN F))
      (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
  (IMPLIES
   (SOME (Y$1)
    (AND (IN E Y$1)
     (IN Y$1 (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))))
   (NOT
    (ALL (E$1)
     (IMPLIES (IN E$1 (REL!RAN F))
      (AND (= (PROCESS-ALPHABET E$1) A) (IS-PROCESS E$1))))))))
Starting case 2 ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (SOME (Y)
   (AND (IN E Y) (IN Y (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
  (NOT
   (SOME (Y$0)
    (AND (IN E Y$0)
     (IN Y$0
      (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))))))
 (NOT
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Applying COLLECT-TRACES.DEFINITION gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (SOME (Y)
   (AND (IN E Y)
    (SOME (X)
     (AND (IN X (REL!RAN (COLLECT-PROCESS-ITERATIONS A F)))
      (= Y (PROCESS-TRACES X))))))
  (NOT
   (SOME (Y$0)
    (AND (IN E Y$0)
     (SOME (X$0)
      (AND (IN X$0 (REL!RAN (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
       (= Y$0 (PROCESS-TRACES X$0))))))))
 (NOT
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Applying REL!IN-RAN gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (SOME (Y)
   (AND (IN E Y)
    (SOME (X)
     (AND (SOME (A$0) (IN (PAIR!PAIR A$0 X) (COLLECT-PROCESS-ITERATIONS A F)))
      (= Y (PROCESS-TRACES X))))))
  (NOT
   (SOME (Y$0)
    (AND (IN E Y$0)
     (SOME (X$0)
      (AND
       (SOME (A$1)
        (IN (PAIR!PAIR A$1 X$0)
         (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
       (= Y$0 (PROCESS-TRACES X$0))))))))
 (NOT
  (ALL (E$0)
   (IMPLIES (SOME (A$2) (IN (PAIR!PAIR A$2 E$0) F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Prenexing produces ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (IN E Y) (IN (PAIR!PAIR A$0 X) (COLLECT-PROCESS-ITERATIONS A F))
  (= Y (PROCESS-TRACES X))
  (NOT
   (SOME (Y$0)
    (AND (IN E Y$0)
     (SOME (X$0)
      (AND
       (SOME (A$1)
        (IN (PAIR!PAIR A$1 X$0)
         (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
       (= Y$0 (PROCESS-TRACES X$0))))))))
 (NOT
  (ALL (E$0)
   (IMPLIES (SOME (A$2) (IN (PAIR!PAIR A$2 E$0) F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Applying REL!IN-COMP gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (PAIR!IS-PAIR (PAIR!PAIR 0 (FN!APPLY F (STOP A))))
  (SOME (Y$0)
   (AND
    (IN (PAIR!PAIR (PAIR!FST (PAIR!PAIR 0 (FN!APPLY F (STOP A)))) Y$0)
     (COLLECT-PROCESS-ITERATIONS A F))
    (IN (PAIR!PAIR Y$0 (PAIR!SND (PAIR!PAIR 0 (FN!APPLY F (STOP A))))) F)))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (IN E Y) (IN (PAIR!PAIR A$0 X) (COLLECT-PROCESS-ITERATIONS A F))
  (= Y (PROCESS-TRACES X))
  (NOT
   (SOME (Y$1)
    (AND (IN E Y$1)
     (SOME (X$0)
      (AND
       (SOME (A$1)
        (AND (PAIR!IS-PAIR (PAIR!PAIR A$1 X$0))
         (SOME (Y$2)
          (AND
           (IN (PAIR!PAIR (PAIR!FST (PAIR!PAIR A$1 X$0)) Y$2)
            (COLLECT-PROCESS-ITERATIONS A F))
           (IN (PAIR!PAIR Y$2 (PAIR!SND (PAIR!PAIR A$1 X$0))) F)))))
       (= Y$1 (PROCESS-TRACES X$0))))))))
 (NOT
  (ALL (E$0)
   (IMPLIES (SOME (A$2) (IN (PAIR!PAIR A$2 E$0) F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Which simplifies
 with invocation of ITERATE
 when rewriting with NAT!IN-NAT, IN-COLLECT-PROCESS-ITERATIONS
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION, PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IS-PROCESS-STOP
 with the instantiations (= Y$0 (STOP A)) (= Y$2 (ITERATE A$1 F (STOP A))) to
...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (IN E Y) (>= A$0 0) (= X (ITERATE A$0 F (STOP A))) (= Y (PROCESS-TRACES X))
  (NOT
   (SOME (X$0)
    (AND (IN E (PROCESS-TRACES X$0))
     (SOME (A$1)
      (AND (>= A$1 0) (IN (PAIR!PAIR (ITERATE A$1 F (STOP A)) X$0) F)))))))
 (NOT
  (ALL (E$0 A$2)
   (IMPLIES (IN (PAIR!PAIR A$2 E$0) F)
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Assuming PROCESS-TRACES-ITERATE-LEMMA with the
instantiations: (= N A$0) (= E E) (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (>= A$0 0)
    (ALL (I)
     (IMPLIES (IN I (NAT!NAT))
      (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A)))))
    (IN E (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))
   (IN E (PROCESS-TRACES (ITERATE (+ A$0 1) F (STOP A)))))
  (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I$0)
   (IMPLIES (>= I$0 0)
    (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
     (FN!APPLY F (ITERATE I$0 F (STOP A))))))
  (IN E Y) (>= A$0 0) (= X (ITERATE A$0 F (STOP A))) (= Y (PROCESS-TRACES X))
  (NOT
   (SOME (X$0)
    (AND (IN E (PROCESS-TRACES X$0))
     (SOME (A$1)
      (AND (>= A$1 0) (IN (PAIR!PAIR (ITERATE A$1 F (STOP A)) X$0) F)))))))
 (NOT
  (ALL (E$0 A$2)
   (IMPLIES (IN (PAIR!PAIR A$2 E$0) F)
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Assuming BETWEEN-ITERATIONS with the
instantiations: (= N A$0) (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) (ITERATE (+ A$0 1) F (STOP A))) F))
  (IMPLIES
   (AND (>= A$0 0)
    (ALL (I)
     (IMPLIES (IN I (NAT!NAT))
      (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A)))))
    (IN E (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))
   (IN E (PROCESS-TRACES (ITERATE (+ A$0 1) F (STOP A)))))
  (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I$0)
   (IMPLIES (>= I$0 0)
    (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
     (FN!APPLY F (ITERATE I$0 F (STOP A))))))
  (IN E Y) (>= A$0 0) (= X (ITERATE A$0 F (STOP A))) (= Y (PROCESS-TRACES X))
  (NOT
   (SOME (X$0)
    (AND (IN E (PROCESS-TRACES X$0))
     (SOME (A$1)
      (AND (>= A$1 0) (IN (PAIR!PAIR (ITERATE A$1 F (STOP A)) X$0) F)))))))
 (NOT
  (ALL (E$0 A$2)
   (IMPLIES (IN (PAIR!PAIR A$2 E$0) F)
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Rearranging gives ...
(IMPLIES
 (AND (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
  (= X (ITERATE A$0 F (STOP A))) (= Y (PROCESS-TRACES X)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y)
  (IMPLIES
   (AND (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) (ITERATE (+ A$0 1) F (STOP A))) F))
  (ALL (I$0)
   (IMPLIES (>= I$0 0)
    (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
     (FN!APPLY F (ITERATE I$0 F (STOP A))))))
  (IMPLIES
   (AND (>= A$0 0) (IN E (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
    (ALL (I)
     (IMPLIES (IN I (NAT!NAT))
      (PROCESS-INCLUDED (ITERATE I F (STOP A))
       (ITERATE (+ I 1) F (STOP A))))))
   (IN E (PROCESS-TRACES (ITERATE (+ A$0 1) F (STOP A)))))
  (NOT
   (SOME (X$0)
    (AND (IN E (PROCESS-TRACES X$0))
     (SOME (A$1)
      (AND (>= A$1 0) (IN (PAIR!PAIR (ITERATE A$1 F (STOP A)) X$0) F)))))))
 (NOT
  (ALL (E$0 A$2)
   (IMPLIES (IN (PAIR!PAIR A$2 E$0) F)
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Which simplifies
 with invocation of ITERATE, SUBSET
 when rewriting with NAT!IN-NAT, IN-PROCESS-OF, REL!IN-RAN
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IS-PROCESS-STOP
 with the instantiation (= I$0 I) to ...
(IMPLIES
 (AND (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
  (= X (ITERATE A$0 F (STOP A))) (= Y (PROCESS-TRACES X)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y))
 (IF
  (ALL (E$0 A$1)
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A))))
  (IMPLIES
   (AND
    (IN
     (PAIR!PAIR (ITERATE A$0 F (STOP A))
      (FN!APPLY F (ITERATE A$0 F (STOP A))))
     F)
    (ALL (I)
     (IMPLIES (>= I 0)
      (PROCESS-INCLUDED (ITERATE I F (STOP A))
       (FN!APPLY F (ITERATE I F (STOP A))))))
    (IN E (PROCESS-TRACES (FN!APPLY F (ITERATE A$0 F (STOP A))))))
   (SOME (X$0)
    (AND (IN E (PROCESS-TRACES X$0))
     (SOME (A$2)
      (AND (>= A$2 0) (IN (PAIR!PAIR (ITERATE A$2 F (STOP A)) X$0) F))))))
  (IMPLIES
   (AND
    (ALL (I$0)
     (IMPLIES (>= I$0 0)
      (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
       (FN!APPLY F (ITERATE I$0 F (STOP A))))))
    (IN E (PROCESS-TRACES (FN!APPLY F (ITERATE A$0 F (STOP A)))))
    (NOT
     (SOME (X$1)
      (AND (IN E (PROCESS-TRACES X$1))
       (SOME (A$3)
        (AND (>= A$3 0) (IN (PAIR!PAIR (ITERATE A$3 F (STOP A)) X$1) F)))))))
   (NOT
    (ALL (E$1 A$4)
     (IMPLIES (IN (PAIR!PAIR A$4 E$1) F)
      (AND (= (PROCESS-ALPHABET E$1) A) (IS-PROCESS E$1))))))))
Starting case 2.2 ...
(IMPLIES
 (AND (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
  (= X (ITERATE A$0 F (STOP A))) (= Y (PROCESS-TRACES X)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y)
  (ALL (E$0 A$1)
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A))))
  (IN
   (PAIR!PAIR (ITERATE A$0 F (STOP A)) (FN!APPLY F (ITERATE A$0 F (STOP A))))
   F)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (IN E (PROCESS-TRACES (FN!APPLY F (ITERATE A$0 F (STOP A))))))
 (SOME (X$0)
  (AND (IN E (PROCESS-TRACES X$0))
   (SOME (A$2)
    (AND (>= A$2 0) (IN (PAIR!PAIR (ITERATE A$2 F (STOP A)) X$0) F))))))
Instantiating (= X$0 (FN!APPLY F (ITERATE A$0 F (STOP A)))) (= A$2 A$0) gives
...
(IMPLIES
 (AND (>= A 0) (= (REL!DOM F) (PROCESS-OF A$0))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A$0))) A$0)
  (= X (ITERATE A F (STOP A$0))) (= Y (PROCESS-TRACES X)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A$0) (FN!APPLY F (STOP A$0))) F)
  (IS-PROCESS (FN!APPLY F (STOP A$0))) (IN E Y)
  (ALL (E$0 A$1)
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A$0))))
  (IN
   (PAIR!PAIR (ITERATE A F (STOP A$0)) (FN!APPLY F (ITERATE A F (STOP A$0))))
   F)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A$0))
     (FN!APPLY F (ITERATE I F (STOP A$0))))))
  (IN E (PROCESS-TRACES (FN!APPLY F (ITERATE A F (STOP A$0)))))
  (NOT
   (AND (IN E (PROCESS-TRACES (FN!APPLY F (ITERATE A F (STOP A$0))))) (>= A 0)
    (IN
     (PAIR!PAIR (ITERATE A F (STOP A$0))
      (FN!APPLY F (ITERATE A F (STOP A$0))))
     F))))
 (SOME (X$0 A$2)
  (AND (IN E (PROCESS-TRACES X$0)) (>= A$2 0)
   (IN (PAIR!PAIR (ITERATE A$2 F (STOP A$0)) X$0) F))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IS-PROCESS-STOP to ...
(TRUE)
Starting case 2.1 ...
(IMPLIES
 (AND (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A)
  (= X (ITERATE A$0 F (STOP A))) (= Y (PROCESS-TRACES X)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y)
  (NOT
   (ALL (E$0 A$1)
    (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
     (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A)))))
  (ALL (I$0)
   (IMPLIES (>= I$0 0)
    (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
     (FN!APPLY F (ITERATE I$0 F (STOP A))))))
  (IN E (PROCESS-TRACES (FN!APPLY F (ITERATE A$0 F (STOP A)))))
  (NOT
   (SOME (X$1)
    (AND (IN E (PROCESS-TRACES X$1))
     (SOME (A$3)
      (AND (>= A$3 0) (IN (PAIR!PAIR (ITERATE A$3 F (STOP A)) X$1) F)))))))
 (NOT
  (ALL (E$1 A$4)
   (IMPLIES (IN (PAIR!PAIR A$4 E$1) F)
    (AND (= (PROCESS-ALPHABET E$1) A) (IS-PROCESS E$1))))))
Instantiating (= E$1 E$0) (= A$4 A$1) gives ...
(IMPLIES
 (AND (>= A 0) (= (REL!DOM F) (PROCESS-OF A$0))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A$0))) A$0)
  (= X (ITERATE A F (STOP A$0))) (= Y (PROCESS-TRACES X)) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A$0) (FN!APPLY F (STOP A$0))) F)
  (IS-PROCESS (FN!APPLY F (STOP A$0))) (IN E Y)
  (NOT
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A$0))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A$0))
     (FN!APPLY F (ITERATE I F (STOP A$0))))))
  (IN E (PROCESS-TRACES (FN!APPLY F (ITERATE A F (STOP A$0)))))
  (NOT
   (SOME (X$0)
    (AND (IN E (PROCESS-TRACES X$0))
     (SOME (A$2)
      (AND (>= A$2 0) (IN (PAIR!PAIR (ITERATE A$2 F (STOP A$0)) X$0) F)))))))
 (NOT
  (AND
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (= (PROCESS-ALPHABET E$0) A$0) (IS-PROCESS E$0)))
   (ALL (E$1 A$3)
    (IMPLIES (IN (PAIR!PAIR A$3 E$1) F)
     (AND (= (PROCESS-ALPHABET E$1) A$0) (IS-PROCESS E$1)))))))
Which simplifies
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IS-PROCESS-STOP to ...
(TRUE)
Starting case 1 ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (SOME (Y)
    (AND (IN E Y) (IN Y (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))))
  (SOME (Y$1)
   (AND (IN E Y$1)
    (IN Y$1 (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))))
 (NOT
  (ALL (E$1)
   (IMPLIES (IN E$1 (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E$1) A) (IS-PROCESS E$1))))))
Applying COLLECT-TRACES.DEFINITION gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (SOME (Y)
    (AND (IN E Y)
     (SOME (X)
      (AND (IN X (REL!RAN (COLLECT-PROCESS-ITERATIONS A F)))
       (= Y (PROCESS-TRACES X)))))))
  (SOME (Y$0)
   (AND (IN E Y$0)
    (SOME (X$0)
     (AND (IN X$0 (REL!RAN (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
      (= Y$0 (PROCESS-TRACES X$0)))))))
 (NOT
  (ALL (E$0)
   (IMPLIES (IN E$0 (REL!RAN F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Applying REL!IN-RAN gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (SOME (Y)
    (AND (IN E Y)
     (SOME (X)
      (AND
       (SOME (A$0) (IN (PAIR!PAIR A$0 X) (COLLECT-PROCESS-ITERATIONS A F)))
       (= Y (PROCESS-TRACES X)))))))
  (SOME (Y$0)
   (AND (IN E Y$0)
    (SOME (X$0)
     (AND
      (SOME (A$1)
       (IN (PAIR!PAIR A$1 X$0) (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
      (= Y$0 (PROCESS-TRACES X$0)))))))
 (NOT
  (ALL (E$0)
   (IMPLIES (SOME (A$2) (IN (PAIR!PAIR A$2 E$0) F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Prenexing produces ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR 0 (FN!APPLY F (STOP A)))
   (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (SOME (Y$0)
    (AND (IN E Y$0)
     (SOME (X$0)
      (AND
       (SOME (A$1) (IN (PAIR!PAIR A$1 X$0) (COLLECT-PROCESS-ITERATIONS A F)))
       (= Y$0 (PROCESS-TRACES X$0)))))))
  (IN E Y)
  (IN (PAIR!PAIR A$0 X) (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))
  (= Y (PROCESS-TRACES X)))
 (NOT
  (ALL (E$0)
   (IMPLIES (SOME (A$2) (IN (PAIR!PAIR A$2 E$0) F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Applying REL!IN-COMP gives ...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (PAIR!IS-PAIR (PAIR!PAIR 0 (FN!APPLY F (STOP A))))
  (SOME (Y$0)
   (AND
    (IN (PAIR!PAIR (PAIR!FST (PAIR!PAIR 0 (FN!APPLY F (STOP A)))) Y$0)
     (COLLECT-PROCESS-ITERATIONS A F))
    (IN (PAIR!PAIR Y$0 (PAIR!SND (PAIR!PAIR 0 (FN!APPLY F (STOP A))))) F)))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (SOME (Y$1)
    (AND (IN E Y$1)
     (SOME (X$0)
      (AND
       (SOME (A$1) (IN (PAIR!PAIR A$1 X$0) (COLLECT-PROCESS-ITERATIONS A F)))
       (= Y$1 (PROCESS-TRACES X$0)))))))
  (IN E Y) (PAIR!IS-PAIR (PAIR!PAIR A$0 X))
  (SOME (Y$2)
   (AND
    (IN (PAIR!PAIR (PAIR!FST (PAIR!PAIR A$0 X)) Y$2)
     (COLLECT-PROCESS-ITERATIONS A F))
    (IN (PAIR!PAIR Y$2 (PAIR!SND (PAIR!PAIR A$0 X))) F)))
  (= Y (PROCESS-TRACES X)))
 (NOT
  (ALL (E$0)
   (IMPLIES (SOME (A$2) (IN (PAIR!PAIR A$2 E$0) F))
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Which simplifies
 with invocation of ITERATE
 when rewriting with NAT!IN-NAT, IN-COLLECT-PROCESS-ITERATIONS
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
FN!FUNCTION-IS-RELATION, PROCESS-COMPOSITION
 with the assumptions IS-PROCESS-BOOL, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IS-PROCESS-STOP
 with the instantiations (= Y$0 (STOP A)) (= Y$2 (ITERATE A$0 F (STOP A))) to
...
(IMPLIES
 (AND (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (SOME (A$1)
    (AND (IN E (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
  (IN E Y) (>= A$0 0) (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) X) F)
  (= Y (PROCESS-TRACES X)))
 (NOT
  (ALL (E$0 A$2)
   (IMPLIES (IN (PAIR!PAIR A$2 E$0) F)
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Assuming BETWEEN-ITERATIONS with the
instantiations: (= N A$0) (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) (ITERATE (+ A$0 1) F (STOP A))) F))
  (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (FN!IS-FUNCTION F)
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A)))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (SOME (A$1)
    (AND (IN E (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
  (IN E Y) (>= A$0 0) (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) X) F)
  (= Y (PROCESS-TRACES X)))
 (NOT
  (ALL (E$0 A$2)
   (IMPLIES (IN (PAIR!PAIR A$2 E$0) F)
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Rearranging gives ...
(IMPLIES
 (AND (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (= Y (PROCESS-TRACES X))
  (FN!IS-FUNCTION F) (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y)
  (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) X) F)
  (IMPLIES
   (AND (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A)) (FN!IS-FUNCTION F)
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) (ITERATE (+ A$0 1) F (STOP A))) F))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (NOT
   (SOME (A$1)
    (AND (>= A$1 0) (IN E (PROCESS-TRACES (ITERATE A$1 F (STOP A))))))))
 (NOT
  (ALL (E$0 A$2)
   (IMPLIES (IN (PAIR!PAIR A$2 E$0) F)
    (AND (= (PROCESS-ALPHABET E$0) A) (IS-PROCESS E$0))))))
Which simplifies
 with invocation of ITERATE, SUBSET
 when rewriting with IN-PROCESS-OF, REL!IN-RAN
 forward chaining using PAIR!PAIR-COMPOSITION, FN!FUNCTION-IS-RELATION,
PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, FN!IS-FUNCTION-BOOL, IS-PROCESS-STOP to ...
(IMPLIES
 (AND (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (= Y (PROCESS-TRACES X))
  (FN!IS-FUNCTION F) (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y)
  (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) X) F))
 (IF
  (ALL (E$0 A$1)
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A))))
  (IMPLIES
   (AND
    (IN
     (PAIR!PAIR (ITERATE A$0 F (STOP A))
      (FN!APPLY F (ITERATE A$0 F (STOP A))))
     F)
    (ALL (I)
     (IMPLIES (>= I 0)
      (PROCESS-INCLUDED (ITERATE I F (STOP A))
       (FN!APPLY F (ITERATE I F (STOP A)))))))
   (SOME (A$2)
    (AND (>= A$2 0) (IN E (PROCESS-TRACES (ITERATE A$2 F (STOP A)))))))
  (IMPLIES
   (AND
    (ALL (I$0)
     (IMPLIES (>= I$0 0)
      (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
       (FN!APPLY F (ITERATE I$0 F (STOP A))))))
    (NOT
     (SOME (A$3)
      (AND (>= A$3 0) (IN E (PROCESS-TRACES (ITERATE A$3 F (STOP A))))))))
   (NOT
    (ALL (E$1 A$4)
     (IMPLIES (IN (PAIR!PAIR A$4 E$1) F)
      (AND (= (PROCESS-ALPHABET E$1) A) (IS-PROCESS E$1))))))))
Assuming FN!APPLY-UNIQUE with the
instantiations: (= F F) (= X (ITERATE A$0 F (STOP A))) (= Y X) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) X) F))
   (= X (FN!APPLY F (ITERATE A$0 F (STOP A)))))
  (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (= Y (PROCESS-TRACES X))
  (FN!IS-FUNCTION F) (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y)
  (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) X) F))
 (IF
  (ALL (E$0 A$1)
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A))))
  (IMPLIES
   (AND
    (IN
     (PAIR!PAIR (ITERATE A$0 F (STOP A))
      (FN!APPLY F (ITERATE A$0 F (STOP A))))
     F)
    (ALL (I)
     (IMPLIES (>= I 0)
      (PROCESS-INCLUDED (ITERATE I F (STOP A))
       (FN!APPLY F (ITERATE I F (STOP A)))))))
   (SOME (A$2)
    (AND (>= A$2 0) (IN E (PROCESS-TRACES (ITERATE A$2 F (STOP A)))))))
  (IMPLIES
   (AND
    (ALL (I$0)
     (IMPLIES (>= I$0 0)
      (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
       (FN!APPLY F (ITERATE I$0 F (STOP A))))))
    (NOT
     (SOME (A$3)
      (AND (>= A$3 0) (IN E (PROCESS-TRACES (ITERATE A$3 F (STOP A))))))))
   (NOT
    (ALL (E$1 A$4)
     (IMPLIES (IN (PAIR!PAIR A$4 E$1) F)
      (AND (= (PROCESS-ALPHABET E$1) A) (IS-PROCESS E$1))))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) X) F)
  (= X (FN!APPLY F (ITERATE A$0 F (STOP A)))) (>= A$0 0)
  (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (= Y (PROCESS-TRACES X))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y))
 (IF
  (ALL (E$0 A$1)
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A))))
  (IMPLIES
   (ALL (I)
    (IMPLIES (>= I 0)
     (PROCESS-INCLUDED (ITERATE I F (STOP A))
      (FN!APPLY F (ITERATE I F (STOP A))))))
   (SOME (A$2)
    (AND (>= A$2 0) (IN E (PROCESS-TRACES (ITERATE A$2 F (STOP A)))))))
  (IMPLIES
   (AND
    (ALL (I$0)
     (IMPLIES (>= I$0 0)
      (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
       (FN!APPLY F (ITERATE I$0 F (STOP A))))))
    (NOT
     (SOME (A$3)
      (AND (>= A$3 0) (IN E (PROCESS-TRACES (ITERATE A$3 F (STOP A))))))))
   (NOT
    (ALL (E$1 A$4)
     (IMPLIES (IN (PAIR!PAIR A$4 E$1) F)
      (AND (= (PROCESS-ALPHABET E$1) A) (IS-PROCESS E$1))))))))
Starting case 1.2 ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) X) F)
  (= X (FN!APPLY F (ITERATE A$0 F (STOP A)))) (>= A$0 0)
  (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (= Y (PROCESS-TRACES X))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y)
  (ALL (E$0 A$1)
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A)))))))
 (SOME (A$2)
  (AND (>= A$2 0) (IN E (PROCESS-TRACES (ITERATE A$2 F (STOP A)))))))
Instantiating (= A$2 (+ A$0 1)) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (IN (PAIR!PAIR (ITERATE A F (STOP A$0)) X) F)
  (= X (FN!APPLY F (ITERATE A F (STOP A$0)))) (>= A 0)
  (= (REL!DOM F) (PROCESS-OF A$0))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A$0))) A$0) (= Y (PROCESS-TRACES X))
  (IN (PAIR!PAIR (STOP A$0) (FN!APPLY F (STOP A$0))) F)
  (IS-PROCESS (FN!APPLY F (STOP A$0))) (IN E Y)
  (ALL (E$0 A$1)
   (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
    (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A$0))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A$0))
     (FN!APPLY F (ITERATE I F (STOP A$0))))))
  (NOT
   (AND (>= (+ A 1) 0)
    (IN E (PROCESS-TRACES (ITERATE (+ A 1) F (STOP A$0)))))))
 (SOME (A$2)
  (AND (>= A$2 0) (IN E (PROCESS-TRACES (ITERATE A$2 F (STOP A$0)))))))
Which simplifies
 with invocation of ITERATE
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL to ...
(TRUE)
Starting case 1.1 ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (IN (PAIR!PAIR (ITERATE A$0 F (STOP A)) X) F)
  (= X (FN!APPLY F (ITERATE A$0 F (STOP A)))) (>= A$0 0)
  (= (REL!DOM F) (PROCESS-OF A))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A))) A) (= Y (PROCESS-TRACES X))
  (IN (PAIR!PAIR (STOP A) (FN!APPLY F (STOP A))) F)
  (IS-PROCESS (FN!APPLY F (STOP A))) (IN E Y)
  (NOT
   (ALL (E$0 A$1)
    (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
     (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A)))))
  (ALL (I$0)
   (IMPLIES (>= I$0 0)
    (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
     (FN!APPLY F (ITERATE I$0 F (STOP A))))))
  (NOT
   (SOME (A$3)
    (AND (>= A$3 0) (IN E (PROCESS-TRACES (ITERATE A$3 F (STOP A))))))))
 (NOT
  (ALL (E$1 A$4)
   (IMPLIES (IN (PAIR!PAIR A$4 E$1) F)
    (AND (= (PROCESS-ALPHABET E$1) A) (IS-PROCESS E$1))))))
Instantiating (= A$3 (+ A$0 1)) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (IN (PAIR!PAIR (ITERATE A F (STOP A$0)) X) F)
  (= X (FN!APPLY F (ITERATE A F (STOP A$0)))) (>= A 0)
  (= (REL!DOM F) (PROCESS-OF A$0))
  (= (PROCESS-ALPHABET (FN!APPLY F (STOP A$0))) A$0) (= Y (PROCESS-TRACES X))
  (IN (PAIR!PAIR (STOP A$0) (FN!APPLY F (STOP A$0))) F)
  (IS-PROCESS (FN!APPLY F (STOP A$0))) (IN E Y)
  (NOT
   (ALL (E$0 A$1)
    (IMPLIES (IN (PAIR!PAIR A$1 E$0) F)
     (AND (IS-PROCESS E$0) (= (PROCESS-ALPHABET E$0) A$0)))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A$0))
     (FN!APPLY F (ITERATE I F (STOP A$0))))))
  (NOT
   (OR
    (AND (>= (+ A 1) 0)
     (IN E (PROCESS-TRACES (ITERATE (+ A 1) F (STOP A$0)))))
    (SOME (A$2)
     (AND (>= A$2 0) (IN E (PROCESS-TRACES (ITERATE A$2 F (STOP A$0)))))))))
 (NOT
  (ALL (E$1 A$3)
   (IMPLIES (IN (PAIR!PAIR A$3 E$1) F)
    (AND (= (PROCESS-ALPHABET E$1) A$0) (IS-PROCESS E$1))))))
Which simplifies
 with invocation of ITERATE
 forward chaining using >=.SAME.TYPE, PAIR!PAIR-COMPOSITION,
PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR, IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
PRODUCES-CHAIN
FIXED-POINT-THEOREM
Beginning proof of FIXED-POINT-THEOREM ...
(IMPLIES (AND (PRODUCES-CHAIN A F) (IS-CONTINUOUS A F))
 (= (FN!APPLY F (MAKE-RECURSIVE-PROCESS A F)) (MAKE-RECURSIVE-PROCESS A F)))
Invoking MAKE-RECURSIVE-PROCESS gives ...
(IMPLIES (AND (PRODUCES-CHAIN A F) (IS-CONTINUOUS A F))
 (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))))
Invoking PRODUCES-CHAIN gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A)))))
  (IS-CONTINUOUS A F))
 (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))))
Invoking IS-CONTINUOUS gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A)))))
  (ALL (P)
   (IMPLIES (AND (IS-PROCESS-CHAIN P) (= (PROCESS-ALPHABET (FN!APPLY P 0)) A))
    (= (FN!APPLY F (PROCESS-CHAIN-LIMIT P))
     (PROCESS-CHAIN-LIMIT (REL!COMP P F))))))
 (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))))
Assuming IS-PROCESS-CHAIN-COLLECT-PROCESS-ITERATIONS with the
instantiations: (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A))
    (ALL (I)
     (IMPLIES (IN I (NAT!NAT))
      (PROCESS-INCLUDED (ITERATE I F (STOP A))
       (ITERATE (+ I 1) F (STOP A))))))
   (IS-PROCESS-CHAIN (COLLECT-PROCESS-ITERATIONS A F)))
  (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I$0)
   (IMPLIES (IN I$0 (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
     (ITERATE (+ I$0 1) F (STOP A)))))
  (ALL (P)
   (IMPLIES (AND (IS-PROCESS-CHAIN P) (= (PROCESS-ALPHABET (FN!APPLY P 0)) A))
    (= (FN!APPLY F (PROCESS-CHAIN-LIMIT P))
     (PROCESS-CHAIN-LIMIT (REL!COMP P F))))))
 (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))))
Which simplifies
 forward chaining using PROCESS-COMPOSITION, FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL
 with the instantiation (= I I$0) to ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (IS-PROCESS-CHAIN (COLLECT-PROCESS-ITERATIONS A F))
  (ALL (P)
   (IMPLIES (AND (IS-PROCESS-CHAIN P) (= (PROCESS-ALPHABET (FN!APPLY P 0)) A))
    (= (FN!APPLY F (PROCESS-CHAIN-LIMIT P))
     (PROCESS-CHAIN-LIMIT (REL!COMP P F))))))
 (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))))
Instantiating (= P (COLLECT-PROCESS-ITERATIONS A F)) gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (IS-PROCESS-CHAIN (COLLECT-PROCESS-ITERATIONS A F))
  (IMPLIES
   (AND (IS-PROCESS-CHAIN (COLLECT-PROCESS-ITERATIONS A F))
    (= (PROCESS-ALPHABET (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) 0)) A))
   (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
    (PROCESS-CHAIN-LIMIT (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))
  (ALL (P)
   (IMPLIES (AND (IS-PROCESS-CHAIN P) (= (PROCESS-ALPHABET (FN!APPLY P 0)) A))
    (= (FN!APPLY F (PROCESS-CHAIN-LIMIT P))
     (PROCESS-CHAIN-LIMIT (REL!COMP P F))))))
 (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))))
Which simplifies
 with invocation of ITERATE, SUBSET
 when rewriting with PROCESS-ALPHABET-STOP, APPLY-COLLECT-PROCESS-ITERATIONS,
NAT!IN-NAT, IN-PROCESS-OF
 forward chaining using >=.SAME.TYPE, PROCESS-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-STOP, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to
...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A))
     (FN!APPLY F (ITERATE I F (STOP A))))))
  (IS-PROCESS-CHAIN (COLLECT-PROCESS-ITERATIONS A F))
  (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
   (PROCESS-CHAIN-LIMIT (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
  (ALL (P)
   (IMPLIES (AND (IS-PROCESS-CHAIN P) (= (PROCESS-ALPHABET (FN!APPLY P 0)) A))
    (= (FN!APPLY F (PROCESS-CHAIN-LIMIT P))
     (PROCESS-CHAIN-LIMIT (REL!COMP P F))))))
 (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))))
Assuming FIXPOINT-LEMMA-1 with the instantiations: (= F F) (= A A) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A))
    (ALL (I)
     (IMPLIES (IN I (NAT!NAT))
      (PROCESS-INCLUDED (ITERATE I F (STOP A))
       (ITERATE (+ I 1) F (STOP A))))))
   (= (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))
    (PROCESS-CHAIN-LIMIT (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F))))
  (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (ALL (E)
   (IMPLIES (IN E (REL!RAN F))
    (AND (IS-PROCESS E) (= (PROCESS-ALPHABET E) A))))
  (ALL (I$0)
   (IMPLIES (>= I$0 0)
    (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
     (FN!APPLY F (ITERATE I$0 F (STOP A))))))
  (IS-PROCESS-CHAIN (COLLECT-PROCESS-ITERATIONS A F))
  (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
   (PROCESS-CHAIN-LIMIT (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))
  (ALL (P)
   (IMPLIES (AND (IS-PROCESS-CHAIN P) (= (PROCESS-ALPHABET (FN!APPLY P 0)) A))
    (= (FN!APPLY F (PROCESS-CHAIN-LIMIT P))
     (PROCESS-CHAIN-LIMIT (REL!COMP P F))))))
 (= (FN!APPLY F (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))))
Which simplifies
 with invocation of ITERATE, SUBSET
 when rewriting with NAT!IN-NAT, IN-PROCESS-OF
 forward chaining using >=.SAME.TYPE, PROCESS-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-STOP, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL
 with the instantiation (= I I$0) to ...
(TRUE)
PROCESS-ALPHABET-MAKE-RECURSIVE
Beginning proof of PROCESS-ALPHABET-MAKE-RECURSIVE ...
(IMPLIES (PRODUCES-CHAIN A F)
 (= (PROCESS-ALPHABET (MAKE-RECURSIVE-PROCESS A F)) A))
Invoking MAKE-RECURSIVE-PROCESS gives ...
(IMPLIES (PRODUCES-CHAIN A F)
 (= (PROCESS-ALPHABET (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  A))
Invoking PROCESS-CHAIN-LIMIT gives ...
(IMPLIES (PRODUCES-CHAIN A F)
 (=
  (PROCESS-ALPHABET
   (MAKE-PROCESS
    (PROCESS-ALPHABET (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) 0))
    (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
  A))
Invoking PRODUCES-CHAIN gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A))))))
 (=
  (PROCESS-ALPHABET
   (MAKE-PROCESS
    (PROCESS-ALPHABET (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) 0))
    (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
  A))
Which simplifies
 with invocation of ITERATE, SUBSET
 when rewriting with PROCESS-ALPHABET-STOP, APPLY-COLLECT-PROCESS-ITERATIONS,
NAT!IN-NAT, IN-PROCESS-OF
 forward chaining using >=.SAME.TYPE, PROCESS-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-STOP, IS-PROCESS-BOOL,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
PROCESS-TRACES-MAKE-RECURSIVE
Beginning proof of PROCESS-TRACES-MAKE-RECURSIVE ...
(IMPLIES (PRODUCES-CHAIN A F)
 (= (PROCESS-TRACES (MAKE-RECURSIVE-PROCESS A F))
  (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
Invoking MAKE-RECURSIVE-PROCESS gives ...
(IMPLIES (PRODUCES-CHAIN A F)
 (= (PROCESS-TRACES (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F)))
  (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
Invoking PROCESS-CHAIN-LIMIT gives ...
(IMPLIES (PRODUCES-CHAIN A F)
 (=
  (PROCESS-TRACES
   (MAKE-PROCESS
    (PROCESS-ALPHABET (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) 0))
    (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
  (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
Invoking PRODUCES-CHAIN gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A))))))
 (=
  (PROCESS-TRACES
   (MAKE-PROCESS
    (PROCESS-ALPHABET (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) 0))
    (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
  (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
Which simplifies
 with invocation of ITERATE, SUBSET
 when rewriting with PROCESS-ALPHABET-STOP, APPLY-COLLECT-PROCESS-ITERATIONS,
NAT!IN-NAT, IN-PROCESS-OF
 forward chaining using >=.SAME.TYPE, PROCESS-COMPOSITION,
FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-STOP, IS-PROCESS-BOOL,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-PROCESS-MAKE-RECURSIVE
Beginning proof of IS-PROCESS-MAKE-RECURSIVE ...
(IMPLIES (PRODUCES-CHAIN A F) (IS-PROCESS (MAKE-RECURSIVE-PROCESS A F)))
Invoking MAKE-RECURSIVE-PROCESS gives ...
(IMPLIES (PRODUCES-CHAIN A F)
 (IS-PROCESS (PROCESS-CHAIN-LIMIT (COLLECT-PROCESS-ITERATIONS A F))))
Invoking PROCESS-CHAIN-LIMIT gives ...
(IMPLIES (PRODUCES-CHAIN A F)
 (IS-PROCESS
  (MAKE-PROCESS
   (PROCESS-ALPHABET (FN!APPLY (COLLECT-PROCESS-ITERATIONS A F) 0))
   (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))))
Which simplifies
 with invocation of SUBSET, ITERATE
 when rewriting with TR!IN-TRACE-OF, CUP.DEFINITION, MAKE-PROCESS-IS-PROCESS,
PROCESS-ALPHABET-STOP, APPLY-COLLECT-PROCESS-ITERATIONS, NAT!IN-NAT
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION, >=.SAME.TYPE
 with the assumptions PREFIX-CLOSED-BOOL, TR!IS-EMPTY-EMPTY,
TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL, PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-STOP to ...
(IMPLIES (PRODUCES-CHAIN A F)
 (AND
  (ALL (E Y)
   (IMPLIES
    (AND (IN E Y) (IN Y (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
    (TR!IS-TRACE-OF E A)))
  (SOME (Y$0)
   (AND (IN (TR!EMPTY) Y$0)
    (IN Y$0 (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
  (PREFIX-CLOSED (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))))
Invoking PREFIX-CLOSED gives ...
(IMPLIES (PRODUCES-CHAIN A F)
 (AND
  (ALL (E Y)
   (IMPLIES
    (AND (IN E Y) (IN Y (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
    (TR!IS-TRACE-OF E A)))
  (SOME (Y$0)
   (AND (IN (TR!EMPTY) Y$0)
    (IN Y$0 (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
  (ALL (S T)
   (IMPLIES
    (AND (TR!IS-TRACE S) (TR!IS-TRACE T)
     (IN (TR!APPEND S T)
      (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
    (IN S (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))))))
Starting case 3 ...
(IMPLIES (PRODUCES-CHAIN A F)
 (ALL (E Y)
  (IMPLIES
   (AND (IN E Y) (IN Y (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
   (TR!IS-TRACE-OF E A))))
Prenexing produces ...
(IMPLIES
 (AND (PRODUCES-CHAIN A F) (IN E Y)
  (IN Y (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))
 (TR!IS-TRACE-OF E A))
Which simplifies
 when rewriting with NAT!IN-NAT, IN-COLLECT-PROCESS-ITERATIONS, REL!IN-RAN,
COLLECT-TRACES.DEFINITION
 forward chaining using TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE,
PROCESS-COMPOSITION, >=.SAME.TYPE, PAIR!PAIR-COMPOSITION
 with the assumptions IS-PROCESS-STOP, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(IMPLIES
 (AND (PRODUCES-CHAIN A F) (IN E Y)
  (SOME (A$0)
   (AND (>= A$0 0) (= Y (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))))
 (TR!IS-TRACE-OF E A))
Prenexing produces ...
(IMPLIES
 (AND (PRODUCES-CHAIN A F) (IN E Y) (>= A$0 0)
  (= Y (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))
 (TR!IS-TRACE-OF E A))
Rearranging gives ...
(IMPLIES
 (AND (>= A$0 0) (= Y (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (PRODUCES-CHAIN A F) (IN E Y))
 (TR!IS-TRACE-OF E A))
Assuming ITERATE-PRODUCES-PROCESS with the
instantiations: (= N A$0) (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (ITERATE A$0 F (STOP A)) (PROCESS-OF A)))
  (>= A$0 0) (= Y (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (PRODUCES-CHAIN A F) (IN E Y))
 (TR!IS-TRACE-OF E A))
Invoking PRODUCES-CHAIN gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (ITERATE A$0 F (STOP A)) (PROCESS-OF A)))
  (>= A$0 0) (= Y (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A)))))
  (IN E Y))
 (TR!IS-TRACE-OF E A))
Which simplifies
 forward chaining using TR!IS-TRACE-CONSEQ, TR!IS-TRACE-OF-IS-TRACE,
PROCESS-COMPOSITION, >=.SAME.TYPE, FN!FUNCTION-IS-RELATION
 with the assumptions IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (IN (ITERATE A$0 F (STOP A)) (PROCESS-OF A))
  (= Y (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (IN E Y))
 (TR!IS-TRACE-OF E A))
Applying PROCESS-OF.DEFINITION gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (SOME (T)
   (AND (IN T (SELECT-GOOD-TRACE-SETS (POWERSET (TR!TRACE-OF A))))
    (= (ITERATE A$0 F (STOP A)) (MAKE-PROCESS A T))))
  (= Y (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (IN E Y))
 (TR!IS-TRACE-OF E A))
Applying SELECT-GOOD-TRACE-SETS.DEFINITION gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (SOME (T)
   (AND (IN T (POWERSET (TR!TRACE-OF A))) (IN (TR!EMPTY) T) (PREFIX-CLOSED T)
    (= (ITERATE A$0 F (STOP A)) (MAKE-PROCESS A T))))
  (= Y (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (IN E Y))
 (TR!IS-TRACE-OF E A))
Prenexing produces ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A)) (IN T (POWERSET (TR!TRACE-OF A)))
  (IN (TR!EMPTY) T) (PREFIX-CLOSED T)
  (= (ITERATE A$0 F (STOP A)) (MAKE-PROCESS A T))
  (= Y (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (IN E Y))
 (TR!IS-TRACE-OF E A))
Which simplifies
 with invocation of ITERATE, SUBSET
 when rewriting with NAT!IN-NAT, TR!IN-TRACE-OF, POWERSET.DEFINITION,
IN-PROCESS-OF
 forward chaining using TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ,
TR!IS-TRACE-OF-IS-TRACE, PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION
 with the assumptions PROCESS-ALPHABET-MAKE-PROCESS,
PROCESS-TRACES-MAKE-PROCESS, IS-PROCESS-STOP, PREFIX-CLOSED-BOOL,
TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY, IS-PROCESS-BOOL, FN!IS-FUNCTION-BOOL to
...
(TRUE)
Starting case 2 ...
(IMPLIES (PRODUCES-CHAIN A F)
 (SOME (Y$0)
  (AND (IN (TR!EMPTY) Y$0)
   (IN Y$0 (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F))))))
Which simplifies
 when rewriting with NAT!IN-NAT, IN-COLLECT-PROCESS-ITERATIONS, REL!IN-RAN,
COLLECT-TRACES.DEFINITION
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
PAIR!PAIR-COMPOSITION, TR!IS-EMPTY-CONSEQ, TR!IS-TRACE-CONSEQ
 with the assumptions IS-PROCESS-STOP, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY to ...
(IMPLIES (PRODUCES-CHAIN A F)
 (SOME (A$0)
  (AND (IN (TR!EMPTY) (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0))))
Instantiating (= A$0 0) gives ...
(IMPLIES
 (AND (PRODUCES-CHAIN A F)
  (NOT
   (AND (IN (TR!EMPTY) (PROCESS-TRACES (ITERATE 0 F (STOP A)))) (>= 0 0))))
 (SOME (A$0)
  (AND (IN (TR!EMPTY) (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0))))
Which simplifies
 with invocation of ITERATE
 when rewriting with SETADD.DEFINITION, SETRULES!UNIT-TO-SETADD,
PROCESS-TRACES-STOP
 forward chaining using >=.SAME.TYPE, PROCESS-COMPOSITION, TR!IS-EMPTY-CONSEQ,
TR!IS-TRACE-CONSEQ
 with the assumptions IS-PROCESS-STOP, TR!IS-EMPTY-EMPTY, TR!IS-TRACE-EMPTY to
...
(TRUE)
Starting case 1 ...
(IMPLIES (PRODUCES-CHAIN A F)
 (ALL (S T)
  (IMPLIES
   (AND (TR!IS-TRACE S) (TR!IS-TRACE T)
    (IN (TR!APPEND S T)
     (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
   (IN S (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))))
Prenexing produces ...
(IMPLIES
 (AND (PRODUCES-CHAIN A F) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T)
   (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
 (IN S (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))))
Which simplifies
 when rewriting with NAT!IN-NAT, IN-COLLECT-PROCESS-ITERATIONS, REL!IN-RAN,
COLLECT-TRACES.DEFINITION, CUP.DEFINITION
 forward chaining using PROCESS-COMPOSITION, >=.SAME.TYPE,
PAIR!PAIR-COMPOSITION, TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY
 with the assumptions IS-PROCESS-STOP, PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR, TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL,
TR!IS-TRACE-BOOL to ...
(IMPLIES
 (AND (PRODUCES-CHAIN A F) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (SOME (A$0)
   (AND (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
    (>= A$0 0))))
 (SOME (A$1)
  (AND (IN S (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
Prenexing produces ...
(IMPLIES
 (AND (PRODUCES-CHAIN A F) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0))
 (SOME (A$1)
  (AND (IN S (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
Instantiating (= A$1 (+ A$0 1)) gives ...
(IMPLIES
 (AND (PRODUCES-CHAIN A F) (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0)
  (NOT
   (AND (IN S (PROCESS-TRACES (ITERATE (+ A$0 1) F (STOP A))))
    (>= (+ A$0 1) 0))))
 (SOME (A$1)
  (AND (IN S (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
Invoking PRODUCES-CHAIN gives ...
(IMPLIES
 (AND (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I)
   (IMPLIES (IN I (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A)))))
  (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0)
  (NOT
   (AND (IN S (PROCESS-TRACES (ITERATE (+ A$0 1) F (STOP A))))
    (>= (+ A$0 1) 0))))
 (SOME (A$1)
  (AND (IN S (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
Assuming PROCESS-TRACES-ITERATE-LEMMA with the
instantiations: (= N A$0) (= E S) (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (>= A$0 0)
    (ALL (I)
     (IMPLIES (IN I (NAT!NAT))
      (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ I 1) F (STOP A)))))
    (IN S (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))
   (IN S (PROCESS-TRACES (ITERATE (+ A$0 1) F (STOP A)))))
  (FN!IS-FUNCTION F) (= (REL!DOM F) (PROCESS-OF A))
  (SUBSET (REL!RAN F) (PROCESS-OF A))
  (ALL (I$0)
   (IMPLIES (IN I$0 (NAT!NAT))
    (PROCESS-INCLUDED (ITERATE I$0 F (STOP A))
     (ITERATE (+ I$0 1) F (STOP A)))))
  (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A)))) (>= A$0 0)
  (NOT
   (AND (IN S (PROCESS-TRACES (ITERATE (+ A$0 1) F (STOP A))))
    (>= (+ A$0 1) 0))))
 (SOME (A$1)
  (AND (IN S (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
Which simplifies
 when rewriting with NAT!IN-NAT
 forward chaining using TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY, FN!FUNCTION-IS-RELATION, PROCESS-COMPOSITION,
>=.SAME.TYPE
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
FN!IS-FUNCTION-BOOL, IS-PROCESS-STOP
 with the instantiation (= I I$0) to ...
(IMPLIES
 (AND (>= A$0 0)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (NOT (IN S (PROCESS-TRACES (ITERATE A$0 F (STOP A))))) (FN!IS-FUNCTION F)
  (= (REL!DOM F) (PROCESS-OF A)) (SUBSET (REL!RAN F) (PROCESS-OF A))
  (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (NOT (IN S (PROCESS-TRACES (ITERATE (+ 1 A$0) F (STOP A))))))
 (SOME (A$1)
  (AND (IN S (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
Assuming APPEND-IN-PROCESS-TRACES with the
instantiations: (= S1 S) (= S2 T) (= P (ITERATE A$0 F (STOP A))) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IS-PROCESS (ITERATE A$0 F (STOP A))) (TR!IS-TRACE S) (TR!IS-TRACE T)
    (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))
   (IN S (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))
  (>= A$0 0)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (NOT (IN S (PROCESS-TRACES (ITERATE A$0 F (STOP A))))) (FN!IS-FUNCTION F)
  (= (REL!DOM F) (PROCESS-OF A)) (SUBSET (REL!RAN F) (PROCESS-OF A))
  (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (NOT (IN S (PROCESS-TRACES (ITERATE (+ 1 A$0) F (STOP A))))))
 (SOME (A$1)
  (AND (IN S (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
Assuming ITERATE-PRODUCES-PROCESS with the
instantiations: (= N A$0) (= F F) (= A A) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION F) (>= A$0 0) (= (REL!DOM F) (PROCESS-OF A))
    (SUBSET (REL!RAN F) (PROCESS-OF A)))
   (IN (ITERATE A$0 F (STOP A)) (PROCESS-OF A)))
  (IMPLIES
   (AND (IS-PROCESS (ITERATE A$0 F (STOP A))) (TR!IS-TRACE S) (TR!IS-TRACE T)
    (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))
   (IN S (PROCESS-TRACES (ITERATE A$0 F (STOP A)))))
  (>= A$0 0)
  (ALL (I)
   (IMPLIES (>= I 0)
    (PROCESS-INCLUDED (ITERATE I F (STOP A)) (ITERATE (+ 1 I) F (STOP A)))))
  (NOT (IN S (PROCESS-TRACES (ITERATE A$0 F (STOP A))))) (FN!IS-FUNCTION F)
  (= (REL!DOM F) (PROCESS-OF A)) (SUBSET (REL!RAN F) (PROCESS-OF A))
  (TR!IS-TRACE S) (TR!IS-TRACE T)
  (IN (TR!APPEND S T) (PROCESS-TRACES (ITERATE A$0 F (STOP A))))
  (NOT (IN S (PROCESS-TRACES (ITERATE (+ 1 A$0) F (STOP A))))))
 (SOME (A$1)
  (AND (IN S (PROCESS-TRACES (ITERATE A$1 F (STOP A)))) (>= A$1 0))))
Which simplifies
 when rewriting with IN-PROCESS-OF
 forward chaining using TR!IS-TRACE-CONSEQ, TR!IS-EMPTY-CONSEQ,
TR!NOT-IS-TRACE-IS-EMPTY, PROCESS-COMPOSITION, >=.SAME.TYPE,
FN!FUNCTION-IS-RELATION
 with the assumptions TR!IS-TRACE-APPEND, TR!IS-EMPTY-BOOL, TR!IS-TRACE-BOOL,
IS-PROCESS-BOOL, IS-PROCESS-STOP, FN!IS-FUNCTION-BOOL to ...
(TRUE)
Completing all cases produces ...
(TRUE)
Done.