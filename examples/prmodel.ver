(load setrules)
(load pair)
(load tr)
(load fn)
(load nat)

;;; =========== Processes ============

(disabled (function make-process (a t) ()
             (pair!pair a t)))

(disabled (function process-alphabet (p) ()
             (pair!fst p)))

(disabled (function process-traces (p) ()
             (pair!snd p)))

(disabled (function prefix-closed (traces) ()
            (all (s t) (implies (and (tr!is-trace s)
                                     (tr!is-trace t)
                                     (in (tr!append s t) traces))
                                (in s traces)))))

(grule prefix-closed-bool (traces)
  (= (type-of (prefix-closed traces)) (bool)))
(SIMPLIFY)

(disabled (function is-process (p) ()
             (and (pair!is-pair p)
                  (subset (process-traces p)
                          (tr!trace-of (process-alphabet p)))
                  (in (tr!empty) (process-traces p))
                  (prefix-closed (process-traces p)))))

(grule is-process-bool (p)
  (= (type-of (is-process p)) (bool)))
(SIMPLIFY)

(grule process-alphabet-make-process (a t)
  (= (process-alphabet (make-process a t)) a))
(WITH-ENABLED (PROCESS-ALPHABET MAKE-PROCESS) (REDUCE))

(grule process-traces-make-process (a t)
  (= (process-traces (make-process a t)) t))
(WITH-ENABLED (PROCESS-TRACES MAKE-PROCESS) (REDUCE))

(frule process-composition (p)
  (implies (is-process p)
           (= (make-process (process-alphabet p)
                            (process-traces p))
              p)))
(WITH-ENABLED (IS-PROCESS MAKE-PROCESS PROCESS-ALPHABET PROCESS-TRACES)
  (REDUCE))

(rule make-process-is-process (a t)
  (= (is-process (make-process a t))
     (and (subset t (tr!trace-of a))
          (in (tr!empty) t)
          (prefix-closed t))))
(INVOKE IS-PROCESS)
(REWRITE)
(INVOKE MAKE-PROCESS)
(SIMPLIFY)

(axiom in-process-traces (s p)
  (implies (and (is-process p)
                (in s (process-traces p)))
           (tr!is-trace-of s (process-alphabet p))))
(WITH-ENABLED (IS-PROCESS PROCESS-TRACES) (REDUCE))

(axiom append-in-process-traces (s1 s2 p)
  (implies (and (is-process p)
                (tr!is-trace s1)
                (tr!is-trace s2)
                (in (tr!append s1 s2) (process-traces p)))
           (in s1 (process-traces p))))
(WITH-ENABLED (IS-PROCESS PREFIX-CLOSED) (REDUCE))

;;; =========== process operators STOP and RUN ============

(disabled (function stop (a) ()
            (make-process a (unit (tr!empty)))))

(disabled (function run (a) ()
            (make-process a (tr!trace-of a))))

(grule is-process-stop (a)
  (is-process (stop a)))
(WITH-ENABLED (PREFIX-CLOSED STOP) (REDUCE))

(rule process-alphabet-stop (a)
  (= (process-alphabet (stop a)) a))
(WITH-ENABLED (STOP) (REDUCE))

(rule process-traces-stop (a)
  (= (process-traces (stop a))
     (unit (tr!empty))))
(WITH-ENABLED (STOP) (REDUCE))

(grule is-process-run (a)
  (is-process (run a)))
(WITH-ENABLED (PREFIX-CLOSED RUN) (REDUCE))

(rule process-alphabet-run (a)
  (= (process-alphabet (run a)) a))
(WITH-ENABLED (RUN) (REDUCE))

(rule process-traces-run (a)
  (= (process-traces (run a)) (tr!trace-of a)))
(WITH-ENABLED (RUN) (REDUCE))


;;; ========== process operator PREFIX ===========

(zf-function map-tack (x a)
  (map (tr!tack x s) ((s) a)))

(disabled
  (function prefix (x p) ()
    (if (and (is-process p) (in x (process-alphabet p)))
        (make-process (process-alphabet p)
                      (union (unit (tr!empty))
                             (map-tack x (process-traces p))))
        p)))

(grule prefix-is-process (x p)
  (implies (and (is-process p)
                (in x (process-alphabet p)))
           (is-process (prefix x p))))
(WITH-ENABLED (PREFIX PREFIX-CLOSED MAP-TACK.DEFINITION)
 (WITHOUT-INSTANTIATION
  (REDUCE)))
(CASES)
(PRENEX)
(USE IN-PROCESS-TRACES (S S) (P P))
(REWRITE)
(NEXT)
(PRENEX)
(INSTANTIATE (S$1 (TR!TAIL S)))
(REWRITE)
(INVOKE TR!APPEND)
(REWRITE)
(USE APPEND-IN-PROCESS-TRACES (S1 (TR!TAIL S)) (S2 T) (P P))
(USE IN-PROCESS-TRACES (S S$0) (P P))
(REWRITE)
(NEXT)

(rule process-alphabet-prefix (x p)
  (implies (and (is-process p)
                (in x (process-alphabet p)))
           (= (process-alphabet (prefix x p))
              (process-alphabet p))))
(WITH-ENABLED (PREFIX) (REDUCE))

(rule process-traces-prefix (x p)
  (implies (and (is-process p)
                (in x (process-alphabet p)))
           (= (process-traces (prefix x p))
              (union (unit (tr!empty))
                     (map-tack x (process-traces p))))))
(WITH-ENABLED (PREFIX) (REDUCE))


;;; ============ process operator AFTER =============

(disabled
  (function after (p s) ()
    (if (and (is-process p) (in s (process-traces p)))
        (make-process (process-alphabet p)
                      (tr!select-after s (process-traces p)))
        p)))

(grule after-is-process (p s)
  (implies (and (is-process p)
                (in s (process-traces p)))
           (is-process (after p s))))
(USE IN-PROCESS-TRACES (S S) (P P))
(SIMPLIFY)
(WITH-ENABLED (PREFIX-CLOSED AFTER
                             TR!BEGIN-WITH.DEFINITION
                             TR!SELECT-AFTER.DEFINITION)
              (WITHOUT-INSTANTIATION (REDUCE)))
(USE IN-PROCESS-TRACES (S S) (P P))
(SIMPLIFY)
(WITH-ENABLED
   (PREFIX-CLOSED AFTER TR!BEGIN-WITH.DEFINITION TR!SELECT-AFTER.DEFINITION)
 (WITHOUT-INSTANTIATION
  (REDUCE)))
(PRENEX)
(CASES)
(USE IN-PROCESS-TRACES (S (TR!APPEND S E)) (P P))
(REARRANGE)
(REWRITE)
(NEXT)
(USE APPEND-IN-PROCESS-TRACES (S1 (TR!APPEND S S$0)) (S2 T) (P P))
(REARRANGE)
(REWRITE)
(NEXT)

(rule process-alphabet-after (p s)
  (implies (and (is-process p)
                (in s (process-traces p)))
           (= (process-alphabet (after p s))
              (process-alphabet p))))
(WITH-ENABLED (AFTER) (REDUCE))

(rule process-traces-after (p s)
  (implies (and (is-process p)
                (in s (process-traces p)))
           (= (process-traces (after p s))
              (tr!select-after s (process-traces p)))))
(WITH-ENABLED (AFTER) (REDUCE))


;;; =========== process operator PARALLEL ============

(zf-function select-parallel-traces (p q)
  (select (s (tr!trace-of (union (process-alphabet p)
                                 (process-alphabet q))))
          (and (in (tr!restrict s (process-alphabet p))
                   (process-traces p))
               (in (tr!restrict s (process-alphabet q))
                   (process-traces q)))))

(disabled (function parallel (p q) ()
  (make-process (union (process-alphabet p) (process-alphabet q))
                (select-parallel-traces p q))))

(grule parallel-is-process (p q)
  (implies (and (is-process p) (is-process q))
           (is-process (parallel p q))))
(WITH-ENABLED (PREFIX-CLOSED PARALLEL SELECT-PARALLEL-TRACES.DEFINITION)
              (WITHOUT-INSTANTIATION (REDUCE)))
(CASES)
(INVOKE (IS-PROCESS P))
(SIMPLIFY)
(NEXT)
(INVOKE (IS-PROCESS Q))
(SIMPLIFY)
(NEXT)
(PRENEX)
(USE APPEND-IN-PROCESS-TRACES
     (S1 (TR!RESTRICT S (PROCESS-ALPHABET P)))
     (S2 (TR!RESTRICT T (PROCESS-ALPHABET P)))
     (P P))
(USE APPEND-IN-PROCESS-TRACES
     (S1 (TR!RESTRICT S (PROCESS-ALPHABET Q)))
     (S2 (TR!RESTRICT T (PROCESS-ALPHABET Q)))
     (P Q))
(REARRANGE)
(REWRITE)
(NEXT)

(rule process-alphabet-parallel (p q)
  (implies (and (is-process p) (is-process q))
           (= (process-alphabet (parallel p q))
              (union (process-alphabet p) (process-alphabet q)))))
(WITH-ENABLED (PARALLEL) (REDUCE))

(rule process-traces-parallel (p q)
  (implies (and (is-process p) (is-process q))
           (= (process-traces (parallel p q))
              (select-parallel-traces p q))))
(WITH-ENABLED (PARALLEL) (REDUCE))


;;; ========= process operator CHOICE ==========

(zf-function map-prefix (a f)
  (map (map-tack x (process-traces (fn!apply f x))) ((x) a)))

(disabled
  (function process-choice (a f) ()
     (make-process (process-alphabet (fn!apply f (choice a)))
                   (union (unit (tr!empty))
                          (cup (map-prefix a f))))))

(disabled
  (function good-choice (f a) ()
  (and (not (= a (nullset)))
       (fn!is-function f)
       (subset a (rel!dom f))
       (subset (rel!dom f) (process-alphabet (fn!apply f (choice a))))
       (all (x) (implies (in x a)
                         (and (is-process (fn!apply f x))
                              (= (process-alphabet (fn!apply f x))
                                 (process-alphabet
                                   (fn!apply f (choice a))))))))))

(grule choice-is-process (a f)
  (implies (good-choice f a)
           (is-process (process-choice a f))))
(WITH-ENABLED
   (GOOD-CHOICE PREFIX-CLOSED PROCESS-CHOICE MAP-PREFIX.DEFINITION
    MAP-TACK.DEFINITION)
 (REDUCE))
(PRENEX)
(CASES)
(INSTANTIATE (E X))
(INSTANTIATE (E$0 X))
(REWRITE)
(INVOKE
  (TR!IS-TRACE-OF (TR!TACK X S) (PROCESS-ALPHABET (FN!APPLY F (CHOICE A)))))
(REWRITE)
(INSTANTIATE (X$0 X))
(USE IN-PROCESS-TRACES (S S) (P (FN!APPLY F X)))
(REWRITE)
(NEXT)
(INSTANTIATE (X$1 X$0))
(INVOKE (TR!APPEND S T))
(REARRANGE)
(SIMPLIFY)
(APPLY TR!TACK-SAME)
(USE APPEND-IN-PROCESS-TRACES (S1 (TR!TAIL S)) (S2 T) (P (FN!APPLY F X)))
(REARRANGE)
(SIMPLIFY)
(USE IN-PROCESS-TRACES (S S$0) (P (FN!APPLY F X)))
(SIMPLIFY)
(INSTANTIATE (X$1 X) (S$1 (TR!TAIL S)))
(SIMPLIFY)
(NEXT)

(rule process-alphabet-choice (a f)
  (implies (good-choice f a)
           (= (process-alphabet (process-choice a f))
              (process-alphabet (fn!apply f (choice a))))))
(WITH-ENABLED (PROCESS-CHOICE) (REDUCE))

(rule process-traces-choice (a f)
  (implies (good-choice f a)
           (= (process-traces (process-choice a f))
              (union (unit (tr!empty))
                     (cup (map-prefix a f))))))
(WITH-ENABLED (PROCESS-CHOICE) (REDUCE))


;;; ============ Communication ==============

(disabled
  (function is-comm (x) () (pair!is-pair x)))

(disabled
  (function make-comm (x y) () (pair!pair x y)))

(disabled
  (function channel (x) () (pair!fst x)))

(disabled
  (function message (x) () (pair!snd x)))

(grule is-comm-bool (x) (= (type-of (is-comm x)) (bool)))
(WITH-ENABLED (IS-COMM) (REDUCE))

(grule channel-comm (x y) (= (channel (make-comm x y)) x))
(WITH-ENABLED (CHANNEL MAKE-COMM) (REDUCE))

(grule message-comm (x y) (= (message (make-comm x y)) y))
(WITH-ENABLED (MESSAGE MAKE-COMM) (REDUCE))

(grule make-comm-is-comm (x y) (is-comm (make-comm x y)))
(WITH-ENABLED (IS-COMM MAKE-COMM) (reduce))

(frule comm-composition (x)
  (implies (is-comm x)
           (= (make-comm (channel x) (message x)) x)))
(WITH-ENABLED (IS-COMM MAKE-COMM CHANNEL MESSAGE) (REDUCE))

;;; select events in alphabet of p that are communications on channel c

(zf-function select-comm (c a)
  (select (e a) (and (is-comm e) (= (channel e) c))))

;;; get all possible messages that are in the alphabet of p

(zf-function process-messages (c p)
  (map (message x) ((x) (select-comm c (process-alphabet p)))))

(disabled
 (function output (c v p) ()
   (prefix (make-comm c v) p)))

(grule output-is-process (c v p)
  (implies (and (is-process p)
                (in v (process-messages c p)))
           (is-process (output c v p))))
(WITH-ENABLED (PROCESS-MESSAGES.DEFINITION OUTPUT) (REDUCE))
(PRENEX)
(SIMPLIFY)

(rule process-alphabet-output (c v p)
  (implies (and (is-process p)
                (in v (process-messages c p)))
           (= (process-alphabet (output c v p))
              (process-alphabet p))))
(WITH-ENABLED (PROCESS-MESSAGES.DEFINITION OUTPUT) (REDUCE))
(PRENEX)
(REWRITE)

(rule process-traces-output (c v p)
  (implies (and (is-process p)
                (in v (process-messages c p)))
           (= (process-traces (output c v p))
              (union (unit (tr!empty))
                     (map-tack (make-comm c v) (process-traces p))))))
(WITH-ENABLED (PROCESS-MESSAGES.DEFINITION OUTPUT) (REDUCE))
(PRENEX)
(REWRITE)

(disabled
 (function input (c f) ()
   (process-choice (select-comm c (rel!dom f)) f)))

(grule input-is-process (c f)
  (implies (good-choice f (select-comm c (rel!dom f)))
           (is-process (input c f))))
(WITH-ENABLED (INPUT) (REDUCE))

(rule process-alphabet-input (c f)
  (implies (good-choice f (select-comm c (rel!dom f)))
           (= (process-alphabet (input c f))
              (process-alphabet
               (fn!apply f (choice (select-comm c (rel!dom f))))))))
(WITH-ENABLED (INPUT) (REDUCE))

(rule process-traces-input (c f)
  (implies (good-choice f (select-comm c (rel!dom f)))
           (= (process-traces (input c f))
              (union (unit (tr!empty))
                     (cup (map-prefix (select-comm c (rel!dom f)) f))))))
(WITH-ENABLED (INPUT) (REDUCE))


;;; ============ Sequencing ============

;;; a sequential process is one where when the specified termination
;;; event e occurs in a trace, it must be the last event

(disabled
 (function is-sequential-process (p e) ()
   (and (is-process p)
        (in e (process-alphabet p))
        (all (t) (implies (and (in t (process-traces p))
                               (tr!occurs e t))
                          (and (not (tr!occurs e (tr!but-last t)))
                               (= t (tr!append (tr!but-last t)
                                               (tr!tack e (tr!empty))))))))))

;;; skip takes an extra argument which specifies the termination event

(disabled
  (function skip (a e) ()
    (make-process a
                  (make-set (tr!empty) (tr!tack e (tr!empty))))))

(grule skip-is-sequential-process (a e)
  (implies (in e a)
           (is-sequential-process (skip a e) e)))
(WITH-ENABLED (IS-SEQUENTIAL-PROCESS SKIP) (REDUCE))
(INVOKE PREFIX-CLOSED)
(INVOKE TR!APPEND)
(REDUCE)

(rule process-alphabet-skip (a e)
  (implies (in e a)
           (= (process-alphabet (skip a e))
              a)))
(WITH-ENABLED (SKIP) (REDUCE))

(rule process-traces-skip (a e)
  (implies (in e a)
           (= (process-traces (skip a e))
              (make-set (tr!empty) (tr!tack e (tr!empty))))))
(WITH-ENABLED (SKIP) (REDUCE))

(frule is-sequential-process-frule (p e)
  (implies (is-sequential-process p e)
           (is-process p)))
(WITH-ENABLED (IS-SEQUENTIAL-PROCESS) (REDUCE))

;;; note that (is-process (skip a e)) is automatically simplified to
;;; (true) using the above two rules

;;; compose produces the sequential composition of processes

(zf-function select-terminated-traces (s e)
  (select (t s) (tr!occurs e t)))

(zf-function map-strip-trailing-event (s)
  (map (tr!but-last t) ((t) s)))

(zf-function map-append (s1 s2)
  (map (tr!append t1 t2) ((t1) s1) ((t2) s2)))

(disabled
  (function compose (p1 p2 e) ()
     (if (and (is-sequential-process p1 e)
              (is-sequential-process p2 e)
              (= (process-alphabet p1) (process-alphabet p2)))
         (make-process (process-alphabet p1)
                       (union (diff (process-traces p1)
                                    (select-terminated-traces
                                     (process-traces p1) e))
                              (map-append
                               (map-strip-trailing-event
                                (select-terminated-traces
                                 (process-traces p1) e))
                               (process-traces p2))))
         (false))))

(axiom terminating-trace-lemma (p s e)
  (implies (and (is-sequential-process p e)
                (in s (process-traces p))
                (tr!occurs e s))
           (and (not (tr!occurs e (tr!but-last s)))
                (= s (tr!append (tr!but-last s)
                                (tr!tack e (tr!empty)))))))
(INVOKE IS-SEQUENTIAL-PROCESS)
(SIMPLIFY)

(axiom append-in-process-traces-alphabet (s1 s2 p)
  (implies (and (is-process p)
                (tr!is-trace s1)
                (tr!is-trace s2)
                (in (tr!append s1 s2) (process-traces p)))
           (and (tr!is-trace-of s1 (process-alphabet p))
                (tr!is-trace-of s2 (process-alphabet p)))))
(INVOKE IS-PROCESS)
(REDUCE)
(INSTANTIATE (E (TR!APPEND S1 S2)))
(REARRANGE)
(REWRITE)

(axiom left-append-terminates (p e s t)
  (implies (and (is-sequential-process p e)
                (tr!is-trace s)
                (tr!is-trace t)
                (in (tr!append s t) (process-traces p))
                (tr!occurs e s))
           (= t (tr!empty))))
(USE APPEND-IN-PROCESS-TRACES (S1 S) (S2 T) (P P))
(SIMPLIFY)
(SPLIT (TR!OCCURS E (TR!APPEND S T)))
(CASES)
(USE TERMINATING-TRACE-LEMMA (P P) (S (TR!APPEND S T)) (E E))
(SIMPLIFY)
(SPLIT (TR!IS-EMPTY T))
(REWRITE)
(SPLIT (TR!IS-TRACE S))
(REWRITE)
(NEXT)
(APPLY TR!OCCURS-APPEND)
(SIMPLIFY)
(NEXT)

(axiom lemma-for-compose-1 (p1 p2 e s t t1 t2)
  (implies (and (is-sequential-process p1 e)
                (is-sequential-process p2 e)
                (= (process-alphabet p1 ) (process-alphabet p2))
                (tr!is-trace s)
                (tr!is-trace t)
                (in t1 (process-traces p1))
                (tr!occurs e t1)
                (in t2 (process-traces p2))
                (= (tr!append s t) (tr!append (tr!but-last t1) t2))
                (tr!occurs e s))
           (= t (tr!empty))))
(USE IN-PROCESS-TRACES (S T1) (P P1))
(USE IN-PROCESS-TRACES (S T2) (P P2))
(USE TERMINATING-TRACE-LEMMA (P P1) (S T1) (E E))
(USE TR!OCCURS-APPEND (E E) (S1 (TR!BUT-LAST T1)) (S2 T2))
(SIMPLIFY)
(SPLIT (TR!OCCURS E (TR!APPEND S T)))
(CASES)
(USE TR!OCCURS-APPEND (E E) (S1 (TR!BUT-LAST T1)) (S2 T2))
(USE TERMINATING-TRACE-LEMMA (P P2) (S T2) (E E))
(SIMPLIFY)
(SPLIT (TR!OCCURS E (TR!APPEND (TR!BUT-LAST T1) (TR!BUT-LAST T2))))
(CASES)
(USE TR!OCCURS-APPEND (E E) (S1 (TR!BUT-LAST T1)) (S2 (TR!BUT-LAST T2)))
(SIMPLIFY)
(NEXT)
(SPLIT (TR!OCCURS E (TR!APPEND S (TR!BUT-LAST T))))
(CASES)
(USE TR!OCCURS-APPEND (E E) (S1 S) (S2 (TR!BUT-LAST T)))
(USE TR!BUT-LAST-APPEND (S S) (T T))
(USE TR!BUT-LAST-APPEND (S (TR!BUT-LAST T1)) (T T2))
(SIMPLIFY)
(NEXT)
(SPLIT (AND (TR!IS-TRACE S)
            (TR!IS-TRACE T)
            (TR!OCCURS E S)))
(REWRITE)
(NEXT)
(SPLIT (AND (TR!IS-TRACE S)
            (TR!IS-TRACE T)
            (TR!OCCURS E S)))
(REWRITE)
(NEXT)

(grule compose-is-sequential-process (p1 p2 e)
  (implies (and (is-sequential-process p1 e)
                (is-sequential-process p2 e)
                (= (process-alphabet p1) (process-alphabet p2)))
           (is-sequential-process (compose p1 p2 e) e)))
(INVOKE (IS-SEQUENTIAL-PROCESS (COMPOSE P1 P2 E) E))
(CASES)
(WITH-ENABLED (COMPOSE)
 (REDUCE))
(CASES)
(PRENEX)
(USE IN-PROCESS-TRACES (S E$0) (P P1))
(SIMPLIFY)
(NEXT)
(PRENEX)
(WITH-ENABLED
   (MAP-APPEND.DEFINITION MAP-STRIP-TRAILING-EVENT.DEFINITION
    SELECT-TERMINATED-TRACES.DEFINITION)
 (REWRITE))
(PRENEX)
(USE TERMINATING-TRACE-LEMMA (P P1) (S T) (E E))
(SIMPLIFY)
(EQUALITY-SUBSTITUTE E$0)
(USE IN-PROCESS-TRACES (S T2) (P P2))
(REWRITE)
(USE APPEND-IN-PROCESS-TRACES-ALPHABET
     (S1 (TR!BUT-LAST T)) (S2 (TR!TACK E (TR!EMPTY))) (P P1))
(SIMPLIFY)
(NEXT)
(INVOKE PREFIX-CLOSED)
(WITH-ENABLED
   (MAP-APPEND.DEFINITION MAP-STRIP-TRAILING-EVENT.DEFINITION
    SELECT-TERMINATED-TRACES.DEFINITION)
 (REWRITE))
(PRENEX)
(CASES)
(CASES)
(CASES)
(USE LEFT-APPEND-TERMINATES (P P1) (E E) (S S) (T T))
(REWRITE)
(INSTANTIATE (T$1 T$0) (T2$0 T2))
(SIMPLIFY)
(NEXT)
(USE APPEND-IN-PROCESS-TRACES (S1 S) (S2 T) (P P1))
(SIMPLIFY)
(NEXT)
(CASES)
(USE LEMMA-FOR-COMPOSE-1 (P1 P1) (P2 P2) (E E) (S S) (T T) (T1 T$2) (T2 T2$1))
(SIMPLIFY)
(SPLIT (= T (TR!EMPTY)))
(REWRITE)
(NEXT)
(USE TR!APPEND-EQUALITY-LEMMA (S1 S) (S2 T) (T1 (TR!BUT-LAST T$2)) (T2 T2$1))
(USE IN-PROCESS-TRACES (S T2$1) (P P2))
(SIMPLIFY)
(CASES)
(INSTANTIATE (T$0 T$2) (T2 U1))
(REWRITE)
(SPLIT (= S (TR!APPEND (TR!BUT-LAST T$0) U1)))
(EQUALITY-SUBSTITUTE S)
(APPLY TR!APPEND-ASSOCIATIVE)
(SIMPLIFY)
(REWRITE)
(USE APPEND-IN-PROCESS-TRACES (S1 U1) (S2 T) (P P2))
(REWRITE)
(NEXT)
(PRENEX)
(USE APPEND-IN-PROCESS-TRACES
     (S1 (TR!BUT-LAST T$2)) (S2 (TR!TACK E (TR!EMPTY))) (P P1))
(REWRITE)
(USE TERMINATING-TRACE-LEMMA (P P1) (S T$2) (E E))
(SIMPLIFY)
(USE APPEND-IN-PROCESS-TRACES (S1 S) (S2 U2) (P P1))
(SIMPLIFY)
(NEXT)
(INVOKE (IS-SEQUENTIAL-PROCESS P1 E))
(INVOKE IS-PROCESS)
(SIMPLIFY)
(NEXT)
(INVOKE COMPOSE)
(REWRITE)
(INVOKE (IS-SEQUENTIAL-PROCESS P1 E))
(SIMPLIFY)
(NEXT)
(PRENEX)
(INVOKE COMPOSE)
(WITH-ENABLED
   (MAP-APPEND.DEFINITION MAP-STRIP-TRAILING-EVENT.DEFINITION
    SELECT-TERMINATED-TRACES.DEFINITION)
 (REWRITE))
(CASES)
(PRENEX)
(INVOKE (IS-SEQUENTIAL-PROCESS P1 E))
(SIMPLIFY)
(NEXT)
(PRENEX)
(EQUALITY-SUBSTITUTE T)
(APPLY TR!BUT-LAST-APPEND)
(USE IN-PROCESS-TRACES (S T2) (P P2))
(REWRITE)
(INVOKE IS-SEQUENTIAL-PROCESS)
(SIMPLIFY)
(NEXT)

(rule process-alphabet-compose (p1 p2 e)
  (implies (and (is-sequential-process p1 e)
                (is-sequential-process p2 e)
                (= (process-alphabet p1) (process-alphabet p2)))
           (= (process-alphabet (compose p1 p2 e))
              (process-alphabet p1))))
(WITH-ENABLED (COMPOSE) (REDUCE))

(rule process-traces-compose (p1 p2 e)
  (implies (and (is-sequential-process p1 e)
                (is-sequential-process p2 e)
                (= (process-alphabet p1) (process-alphabet p2)))
           (= (process-traces (compose p1 p2 e))
              (union (diff (process-traces p1)
                           (select-terminated-traces
                            (process-traces p1) e))
                     (map-append
                      (map-strip-trailing-event
                       (select-terminated-traces
                        (process-traces p1) e))
                      (process-traces p2))))))
(WITH-ENABLED (COMPOSE) (REDUCE))


;;; ============ RECURSION ==============

(disabled
  (function process-included (p1 p2) ()
    (and (= (process-alphabet p1) (process-alphabet p2))
         (subset (process-traces p1) (process-traces p2)))))

(axiom process-included-reflexive (p)
  (process-included p p))
(WITH-ENABLED (PROCESS-INCLUDED) (REDUCE))

(axiom process-included-transitive (p1 p2 p3)
  (implies (and (process-included p1 p2)
                (process-included p2 p3))
           (process-included p1 p3)))
(WITH-ENABLED (PROCESS-INCLUDED) (REDUCE))
(INSTANTIATE (E E$1))
(SIMPLIFY)

(axiom process-included-anti-symmetric (p1 p2)
  (implies (and (is-process p1)
                (is-process p2)
                (process-included p1 p2)
                (process-included p2 p1))
           (= p1 p2)))
(WITH-ENABLED (PROCESS-INCLUDED) (REDUCE))
(USE =.EXTENSIONAL.SUBSET (X (PROCESS-TRACES P1)) (Y (PROCESS-TRACES P2)))
(INVOKE SUBSET)
(REARRANGE)
(SIMPLIFY) 

(rule stop-is-least (a p)
  (implies (and (is-process p)
                (= (process-alphabet p) a))
           (= (process-included (stop a) p) (true))))
(WITH-ENABLED (PROCESS-INCLUDED) (REDUCE))
(INVOKE IS-PROCESS)
(SIMPLIFY)

(disabled
  (function is-process-chain (p) ()
    (and (fn!is-function p)
         (= (rel!dom p) (nat!nat))
         (all (n) (implies (in n (nat!nat))
                           (process-included
                              (fn!apply p n)
                              (fn!apply p (+ n 1))))))))

(zf-function collect-traces (p)
  (map (process-traces x) ((x) (rel!ran p))))

(disabled
  (function process-chain-limit (p) ()
    (make-process (process-alphabet (fn!apply p 0))
                  (cup (collect-traces p)))))

(rule alphabet-process-chain-element (pc i)
  (implies (and (> i 0)
                (is-process-chain pc))
           (= (process-alphabet (fn!apply pc i))
              (process-alphabet (fn!apply pc 0)))))
(INDUCT (NAT!WEAK-INDUCTION I))
(WITH-ENABLED (PROCESS-INCLUDED IS-PROCESS-CHAIN) (REDUCE))
(CASES)
(INSTANTIATE (N (- I 1)))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (N$0 0))
(SIMPLIFY)
(NEXT)

(axiom element-included-in-limit (pc i)
  (implies (and (in i (nat!nat))
                (is-process-chain pc))
           (process-included (fn!apply pc i)
                             (process-chain-limit pc))))
(WITH-ENABLED (PROCESS-INCLUDED PROCESS-CHAIN-LIMIT) (REDUCE))
(CASES)
(SPLIT (= I 0))
(REDUCE)
(NEXT)
(WITH-ENABLED (IS-PROCESS-CHAIN PROCESS-INCLUDED) (REDUCE))
(INSTANTIATE (N I) (E E$0))
(SIMPLIFY)
(WITH-ENABLED (COLLECT-TRACES.DEFINITION) (REWRITE))
(WITH-ENABLED (FN!IN-RAN-FUNCTION) (REWRITE))
(NEXT)

(axiom upper-bound-axiom (pc q)
  (implies (and (is-process-chain pc)
                (is-process q)
                (all (i) (implies (in i (nat!nat))
                                  (process-included (fn!apply pc i) q))))
           (process-included (process-chain-limit pc) q)))
(WITH-ENABLED (IS-PROCESS-CHAIN PROCESS-CHAIN-LIMIT PROCESS-INCLUDED) (REDUCE))
(APPLY COLLECT-TRACES.DEFINITION)
(PRENEX)
(APPLY FN!IN-RAN-FUNCTION)
(PRENEX)
(REWRITE)
(CASES)
(INSTANTIATE (I 0))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (I Y$0) (E$1 E))
(SIMPLIFY)
(NEXT)

(disabled
  (function is-continuous (a f) ()
    (all (p) (implies (and (is-process-chain p)
                           (= (process-alphabet (fn!apply p 0)) a))
                      (= (fn!apply f (process-chain-limit p))
                         (process-chain-limit
                            (rel!comp p f)))))))

(function iterate (n f x) ((measure n))
  (if (>= n 1)
      (fn!apply f (iterate (- n 1) f x))
      x))
(REDUCE)

(zf-function collect-process-iterations (a f)
  (map (pair!pair n (iterate n f (stop a))) ((n) (nat!nat))))

(rule in-collect-process-iterations (p a f)
  (= (in p (collect-process-iterations a f))
     (and (pair!is-pair p)
          (in (pair!fst p) (nat!nat))
          (= (pair!snd p) (iterate (pair!fst p) f (stop a))))))
(SPLIT (IN P (COLLECT-PROCESS-ITERATIONS A F)))
(WITH-ENABLED (COLLECT-PROCESS-ITERATIONS.DEFINITION) (REWRITE))
(CASES)
(PRENEX)
(EQUALITY-SUBSTITUTE)
(SIMPLIFY)
(NEXT)
(INSTANTIATE (N (PAIR!FST P)))
(SIMPLIFY)
(NEXT)

(rule dom-collect-process-iterations (a f)
  (= (rel!dom (collect-process-iterations a f))
     (nat!nat)))
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)
(APPLY REL!IN-DOM)
(REWRITE)

(rule collect-process-iterations-is-function (a f)
  (= (fn!is-function (collect-process-iterations a f)) (true)))
(WITH-ENABLED (FN!IS-FUNCTION REL!IS-RELATION) (REDUCE))

(rule apply-collect-process-iterations (x a f)
  (implies (in x (nat!nat))
           (= (fn!apply (collect-process-iterations a f) x)
              (iterate x f (stop a)))))
(USE FN!APPLY-DEFINITION (F (COLLECT-PROCESS-ITERATIONS A F)) (X X))
(REWRITE)

(disabled
  (function make-recursive-process (a f) ()
    (process-chain-limit (collect-process-iterations a f))))

(disabled
  (rule recursive-process-lemma (a f t)
    (= (in t (process-traces (make-recursive-process a f)))
       (some (n) (and (>= n 0)
                      (in t (process-traces (iterate n f (stop a)))))))))
(WITH-ENABLED (MAKE-RECURSIVE-PROCESS REL!IN-RAN
                                      PROCESS-CHAIN-LIMIT
                                      COLLECT-TRACES.DEFINITION)
              (REDUCE))
(SPLIT (SOME (N)
             (AND (>= N 0)
                  (IN T (PROCESS-TRACES (ITERATE N F (STOP A)))))))
(SIMPLIFY)
(CASES)
(INSTANTIATE (A$0 N))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (N A$1))
(SIMPLIFY)
(NEXT)


;;; process-of produces the set of all processes with alphabet a

(zf-function select-good-trace-sets (s)
  (select (t s) (and (in (tr!empty) t)
                     (prefix-closed t))))

(zf-function process-of (a)
  (map (make-process a t)
    ((t) (select-good-trace-sets (powerset (tr!trace-of a))))))

(rule in-process-of (a p)
  (= (in p (process-of a))
     (and (is-process p)
          (= (process-alphabet p) a))))
(SPLIT (AND (IS-PROCESS P) (= (PROCESS-ALPHABET P) A)))
(REDUCE)
(APPLY PROCESS-OF.DEFINITION)
(REDUCE)
(CASES)
(INSTANTIATE (T (PROCESS-TRACES P)))
(REDUCE)
(USE MAKE-PROCESS-IS-PROCESS (A (PROCESS-ALPHABET P)) (T (PROCESS-TRACES P)))
(SIMPLIFY)
(REDUCE)
(INSTANTIATE (T (PROCESS-TRACES P)))
(REWRITE)
(PRENEX)
(USE IN-PROCESS-TRACES (S E) (P P))
(SIMPLIFY)
(NEXT)
(PRENEX)
(REDUCE)
(SPLIT (IS-PROCESS (MAKE-PROCESS A T)))
(SIMPLIFY)
(REDUCE)
(NEXT)

(rule stop-in-process-of (a)
  (= (in (stop a) (process-of a)) (true)))
(WITH-ENABLED (PROCESS-OF.DEFINITION) (REDUCE))

(axiom is-process-chain-collect-process-iterations (f a)
  (implies (and (fn!is-function f)
                (= (rel!dom f) (process-of a))
                (subset (rel!ran f) (process-of a))
                (all (i) (implies (in i (nat!nat))
                                  (process-included
                                   (iterate i f (stop a))
                                   (iterate (+ i 1) f (stop a))))))
           (is-process-chain (collect-process-iterations a f))))
(INVOKE IS-PROCESS-CHAIN)
(REWRITE)

(axiom iterate-produces-process (n f a)
  (implies (and (fn!is-function f)
                (>= n 0)
                (= (rel!dom f) (process-of a))
                (subset (rel!ran f) (process-of a)))
           (in (iterate n f (stop a)) (process-of a))))
(INDUCT (NAT!WEAK-INDUCTION N))
(REDUCE)
(REDUCE)
(USE FN!APPLY-IN-RAN (F F) (X (ITERATE (- N 1) F (STOP A))))
(INSTANTIATE (E (FN!APPLY F (ITERATE (- N 1) F (STOP A)))))
(SIMPLIFY)
(REARRANGE)
(EQUALITY-SUBSTITUTE (REL!DOM F))
(REDUCE)

(axiom between-iterations (n f a)
  (implies (and (fn!is-function f)
                (>= n 0)
                (= (rel!dom f) (process-of a))
                (subset (rel!ran f) (process-of a)))
           (in (pair!pair (iterate n f (stop a))
                          (iterate (+ n 1) f (stop a)))
               f)))
(INVOKE (ITERATE (+ N 1) F (STOP A)))
(REDUCE)
(USE FN!APPLY-DEFINITION (F F) (X (ITERATE N F (STOP A))))
(USE ITERATE-PRODUCES-PROCESS (N N) (F F) (A A))
(REDUCE)
(EQUALITY-SUBSTITUTE (REL!DOM F))
(REDUCE)

(axiom process-traces-iterate-lemma (n e f a)
  (implies (and (>= n 0)
                (all (i) (implies (in i (nat!nat))
                                  (process-included
                                   (iterate i f (stop a))
                                   (iterate (+ i 1) f (stop a)))))
                (in e (process-traces (iterate n f (stop a)))))
           (in e (process-traces (iterate (+ n 1) f (stop a))))))
(INSTANTIATE (I N))
(REWRITE)
(INVOKE (PROCESS-INCLUDED (ITERATE N F (STOP A)) (ITERATE (+ 1 N) F (STOP A))))
(INVOKE SUBSET)
(REWRITE)

(axiom fixpoint-lemma-1 (f a)
  (implies (and (fn!is-function f)
                (= (rel!dom f) (process-of a))
                (subset (rel!ran f) (process-of a))
                (all (i) (implies (in i (nat!nat))
                                  (process-included
                                   (iterate i f (stop a))
                                   (iterate (+ i 1) f (stop a))))))
           (= (process-chain-limit (collect-process-iterations a f))
              (process-chain-limit
               (rel!comp (collect-process-iterations a f) f)))))
(INVOKE PROCESS-CHAIN-LIMIT)
(REDUCE)
(USE FN!APPLY-DEFINITION
     (F (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)) (X 0))
(REARRANGE)
(REDUCE)
(EQUALITY-SUBSTITUTE (REL!DOM F))
(REDUCE)
(USE FN!APPLY-DEFINITION (F F) (X (STOP A)))
(REARRANGE)
(EQUALITY-SUBSTITUTE (REL!DOM F))
(REDUCE)
(INSTANTIATE (E (FN!APPLY F (STOP A))))
(APPLY REL!IN-RAN (IN (FN!APPLY F (STOP A)) (REL!RAN F)))
(REDUCE)
(SPLIT
  (= (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))
     (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))))
(REDUCE)
(APPLY
  SETRULES!EXTENSIONALITY
  (= (CUP (COLLECT-TRACES (COLLECT-PROCESS-ITERATIONS A F)))
     (CUP (COLLECT-TRACES (REL!COMP (COLLECT-PROCESS-ITERATIONS A F) F)))))
(REARRANGE)
(PRENEX)
(REDUCE)
(CASES)
(APPLY COLLECT-TRACES.DEFINITION)
(APPLY REL!IN-RAN)
(PRENEX)
(APPLY REL!IN-COMP)
(REDUCE)
(USE PROCESS-TRACES-ITERATE-LEMMA (N A$0) (E E) (F F) (A A))
(USE BETWEEN-ITERATIONS (N A$0) (F F) (A A))
(REARRANGE)
(WITH-ENABLED (REL!IN-RAN)
 (REDUCE))
(CASES)
(INSTANTIATE (X$0 (FN!APPLY F (ITERATE A$0 F (STOP A)))) (A$2 A$0))
(SIMPLIFY)
(NEXT)
(INSTANTIATE (E$1 E$0) (A$4 A$1))
(SIMPLIFY)
(NEXT)
(APPLY COLLECT-TRACES.DEFINITION)
(APPLY REL!IN-RAN)
(PRENEX)
(APPLY REL!IN-COMP)
(REDUCE)
(USE BETWEEN-ITERATIONS (N A$0) (F F) (A A))
(REARRANGE)
(WITH-ENABLED (REL!IN-RAN)
 (REDUCE))
(USE FN!APPLY-UNIQUE (F F) (X (ITERATE A$0 F (STOP A))) (Y X))
(SIMPLIFY)
(CASES)
(INSTANTIATE (A$2 (+ A$0 1)))
(REDUCE)
(NEXT)
(INSTANTIATE (A$3 (+ A$0 1)))
(REDUCE)
(NEXT)


(disabled
 (function produces-chain (a f) ()
   (and (fn!is-function f)
        (= (rel!dom f) (process-of a))
        (subset (rel!ran f) (process-of a))
        (all (i) (implies (in i (nat!nat))
                          (process-included
                           (iterate i f (stop a))
                           (iterate (+ i 1) f (stop a))))))))

(rule fixed-point-theorem (a f)
  (implies (and (produces-chain a f)
                (is-continuous a f))
           (= (fn!apply f (make-recursive-process a f))
              (make-recursive-process a f))))
(INVOKE MAKE-RECURSIVE-PROCESS)
(INVOKE PRODUCES-CHAIN)
(INVOKE IS-CONTINUOUS)
(USE IS-PROCESS-CHAIN-COLLECT-PROCESS-ITERATIONS (F F) (A A))
(SIMPLIFY)
(INSTANTIATE (P (COLLECT-PROCESS-ITERATIONS A F)))
(REDUCE)
(USE FIXPOINT-LEMMA-1 (F F) (A A))
(REDUCE)

(rule process-alphabet-make-recursive (a f)
  (implies (produces-chain a f)
           (= (process-alphabet (make-recursive-process a f)) a)))
(INVOKE MAKE-RECURSIVE-PROCESS)
(INVOKE PROCESS-CHAIN-LIMIT)
(INVOKE PRODUCES-CHAIN)
(REDUCE)

(rule process-traces-make-recursive (a f)
  (implies (produces-chain a f)
           (= (process-traces (make-recursive-process a f))
              (cup (collect-traces (collect-process-iterations a f))))))
(INVOKE MAKE-RECURSIVE-PROCESS)
(INVOKE PROCESS-CHAIN-LIMIT)
(INVOKE PRODUCES-CHAIN)
(REDUCE)

(grule is-process-make-recursive (a f)
  (implies (produces-chain a f)
           (is-process (make-recursive-process a f))))
(INVOKE MAKE-RECURSIVE-PROCESS)
(INVOKE PROCESS-CHAIN-LIMIT)
(REDUCE)
(INVOKE PREFIX-CLOSED)
(CASES)
(PRENEX)
(WITH-ENABLED (COLLECT-TRACES.DEFINITION REL!IN-RAN)
 (REDUCE))
(PRENEX)
(REARRANGE)
(USE ITERATE-PRODUCES-PROCESS (N A$0) (F F) (A A))
(INVOKE PRODUCES-CHAIN)
(SIMPLIFY)
(APPLY PROCESS-OF.DEFINITION)
(APPLY SELECT-GOOD-TRACE-SETS.DEFINITION)
(PRENEX)
(REDUCE)
(NEXT)
(WITH-ENABLED (COLLECT-TRACES.DEFINITION REL!IN-RAN)
 (REDUCE))
(INSTANTIATE (A$0 0))
(REDUCE)
(NEXT)
(PRENEX)
(WITH-ENABLED (COLLECT-TRACES.DEFINITION REL!IN-RAN)
 (REDUCE))
(PRENEX)
(INSTANTIATE (A$1 (+ A$0 1)))
(INVOKE PRODUCES-CHAIN)
(USE PROCESS-TRACES-ITERATE-LEMMA (N A$0) (E S) (F F) (A A))
(REWRITE)
(USE APPEND-IN-PROCESS-TRACES (S1 S) (S2 T) (P (ITERATE A$0 F (STOP A))))
(USE ITERATE-PRODUCES-PROCESS (N A$0) (F F) (A A))
(REWRITE)
(NEXT)

