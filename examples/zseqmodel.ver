;;;
;;; Sequences
;;;
;;; Adapted from the Z toolkit
;;;

(load fn)
(load finite)
(load intfn)
(load elem)
(load nat)
(load setrules)

(function is-sequence (x) ()
  (and (fn!is-function x)
       (finite!is-finite x)
       (= (rel!dom x) (range 1 (finite!card x)))))

(axiom type-of-is-sequence (x)
  (= (type-of (is-sequence x))
     (bool)))
(REDUCE)

(axiom is-sequence-definition (x)
  (= (is-sequence x)
     (and (fn!is-function x)
	  (finite!is-finite x)
	  (= (rel!dom x) (range 1 (finite!card x))))))
(REDUCE)

(frule is-sequence-facts (x)
  (implies (is-sequence x)
	   (and (fn!is-function x)
		(finite!is-finite x)
		(= (rel!dom x) (range 1 (finite!card x))))))
(REDUCE)

;(frule is-sequence-implies-function-p (x)
;  (implies (is-sequence x)
;	   (fn!is-function x)))
;(REDUCE)

;(frule is-sequence-implies-finite (x)
;  (implies (is-sequence x)
;	   (finite!is-finite x)))
;(REDUCE)

(rule sequence-dom (x)
  (implies (is-sequence x)
	   (= (rel!dom x) (range 1 (finite!card x)))))
(SIMPLIFY)

(axiom is-sequence-subgoal (n x)
  (implies (and (in n (nat!nat))
		(fn!is-function x)
		(= (rel!dom x) (range 1 n)))
	   (and (is-sequence x)
		(= (finite!card x) n))))
(INVOKE IS-SEQUENCE)
(USE FINITE!FINITE-FUNCTION-DOM (F X))
(REARRANGE)
(EQUALITY-SUBSTITUTE (REL!DOM X))
(REWRITE)
(REDUCE)
 
(rule is-sequence-nullset ()
  (= (is-sequence (nullset)) (true)))
(REDUCE)

;;; sequence "types"

(zf-function sequence-of (x)
  (select (s (fn!pfun (int) x))
    (is-sequence s)))

(rule in-sequence-of (s x)
  (= (in s (sequence-of x))
     (and (is-sequence s)
	  (subset (rel!ran s) x))))
(USE IS-SEQUENCE-SUBGOAL (N (FINITE!CARD S)) (X S))
(WITH-ENABLED (FN!IN-PFUN)
 (REDUCE))

(function nonempty-sequence-of (x) ()
  (diff (sequence-of x) (unit (nullset))))

(rule in-nonempty-sequence-of (s x)
  (= (in s (nonempty-sequence-of x))
     (and (is-sequence s)
	  (not (= s (nullset)))
	  (subset (rel!ran s) x))))
(INVOKE NONEMPTY-SEQUENCE-OF)
(REWRITE)

;;; concatenation

(function append (x y) ()
  (union x (rel!comp (intfn!add (negate (finite!card x))) y)))

(axiom append-def (x y)
  (= (append x y)
     (union x (rel!comp (intfn!add (negate (finite!card x))) y))))
(REDUCE)

(axiom is-sequence-append-lemma (x y)
  (implies (and (is-sequence x) (is-sequence y))
	   (and (is-sequence (append x y))
		(= (finite!card (append x y))
		   (+ (finite!card x) (finite!card y))))))
(USE IS-SEQUENCE-SUBGOAL
     (X (APPEND X Y))
     (N (+ (FINITE!CARD X) (FINITE!CARD Y))))
(REARRANGE)
(INVOKE APPEND)
(WITH-ENABLED (FN!IS-FUNCTION-UNION) (REWRITE))
(REDUCE)

(rule is-sequence-append (x y)
  (implies (and (is-sequence x) (is-sequence y))
	   (= (is-sequence (append x y)) (true))))
(USE IS-SEQUENCE-APPEND-LEMMA (X X) (Y Y))
(SIMPLIFY)

(rule is-function-append (x y)
  (implies (and (is-sequence x)
		(is-sequence y))
	   (= (fn!is-function (append x y)) (true))))
(USE IS-SEQUENCE-APPEND (X X) (Y Y))
(INVOKE (IS-SEQUENCE (APPEND X Y)))
(SIMPLIFY)

(rule dom-append (x y)
  (implies (and (is-sequence x)
		(is-sequence y))
	   (= (rel!dom (append x y))
	      (range 1 (+ (finite!card x) (finite!card y))))))
(USE IS-SEQUENCE-APPEND-LEMMA (X X) (Y Y))
(INVOKE (IS-SEQUENCE (APPEND X Y)))
(SIMPLIFY)

(rule finite-append (x y)
  (implies (and (is-sequence x) (is-sequence y))
	   (= (finite!is-finite (append x y)) (true))))
(USE IS-SEQUENCE-APPEND-LEMMA (X X) (Y Y))
(INVOKE (IS-SEQUENCE (APPEND X Y)))
(SIMPLIFY)

(rule card-append (x y)
  (implies (and (is-sequence x)(is-sequence y))
	   (= (finite!card (append x y))
	      (+ (finite!card x) (finite!card y)))))
(USE IS-SEQUENCE-APPEND-LEMMA (X X)(Y Y))
(SIMPLIFY)

(rule append-nullset-left (x)
  (implies (is-sequence x)
	   (= (append (nullset) x)
	      x)))
(REDUCE)

(rule append-nullset-right (x)
    (implies (is-sequence x)
	   (= (append x (nullset))
	      x)))
(REDUCE)

(rule apply-append (x y n)
  (implies (and (is-sequence x)
		(is-sequence y)
		(in n (range 1 (finite!card (append x y)))))
	   (= (fn!apply (append x y) n)
	      (if (<= n (finite!card x))
		  (fn!apply x n)
		  (fn!apply y (- n (finite!card x)))))))
(USE FN!APPLY-UNION
     (F X)
     (G (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y))
     (X N))
(USE IS-SEQUENCE-APPEND-LEMMA (X X) (Y Y))
(INVOKE APPEND)
(WITH-DISABLED (FN!IS-FUNCTION-UNION) (REWRITE))

(rule append-associative (x y z)
  (implies (and (is-sequence x) (is-sequence y)(is-sequence z))
	   (= (append (append x y) z)
	      (append x (append y z)))))
(USE FN!FUNCTION-EXTENSIONALITY
     (F (APPEND (APPEND X Y) Z))
     (G (APPEND X (APPEND Y Z))))
(REARRANGE)
(REWRITE)


(rule ran-append (x y)
  (implies (and (is-sequence x) (is-sequence y))
	   (= (rel!ran (append x y))
	      (union (rel!ran x) (rel!ran y)))))
(REDUCE)

;;; unit sequences

(function unit-seq (x) ()			; Z's <x> notation
  (unit (pair!pair 1 x)))

(axiom unit-seq-def (x)
  (= (unit-seq x)
     (unit (pair!pair 1 x))))
(REDUCE)

(rule is-function-unit-seq (x)
  (= (fn!is-function (unit-seq x)) (true)))
(REDUCE)

(rule dom-unit-seq (x)
  (= (rel!dom (unit-seq x))
     (unit 1)))
(REDUCE)

(rule ran-unit-seq (x)
  (= (rel!ran (unit-seq x))
     (unit x)))
(REDUCE)

(rule finite-unit-seq (x)
  (= (finite!is-finite (unit-seq x)) (true)))
(REDUCE)

(rule card-unit-seq (x)
  (= (finite!card (unit-seq x))
     1))
(WITH-DISABLED (SETRULES) (REDUCE))

(rule is-sequence-unit-seq (x)
  (= (is-sequence (unit-seq x)) (true)))
(INVOKE IS-SEQUENCE)
(REWRITE)

(rule apply-unit-seq (x)
  (= (fn!apply (unit-seq x) 1)
     x))
(USE FN!APPLY-DEFINITION (F (UNIT-SEQ X)) (X 1))
(INVOKE UNIT-SEQ)
(REWRITE)

;;; head, last, tail, and front
;;; "last" is an elementary function defined in the EVES initial theory,
;;; so we use "zlast" here.


(function head (s) ()
  (fn!apply s 1))

(function zlast (s) ()
  (fn!apply s (finite!card s)))

(function tail (s) ()
  (rel!dom-restrict (range 1 (- (finite!card s) 1))
		    (rel!comp (intfn!add 1) s)))

(function front (s) ()
  (rel!dom-restrict (range 1 (- (finite!card s) 1)) s))

(rule head-append-unit (x s)
  (implies (is-sequence s)
	   (= (head (append (unit-seq x) s))
	      x)))
(INVOKE HEAD)
(REWRITE)

(rule tail-append-unit (x s)
  (implies (is-sequence s)
	   (= (tail (append (unit-seq x) s)) s)))
(USE FN!FUNCTION-EXTENSIONALITY (F (TAIL (APPEND (UNIT-SEQ X) S))) (G S))
(INVOKE TAIL)
(REARRANGE)
(REWRITE)

(rule zlast-append-unit (x s)
  (implies (is-sequence s)
	   (= (zlast (append s (unit-seq x)))
	      x)))
(INVOKE ZLAST)
(REWRITE)

(rule front-append-unit (x s)
  (implies (is-sequence s)
	   (= (front (append s (unit-seq x)))
	      s)))
(USE FN!FUNCTION-EXTENSIONALITY (F (FRONT (APPEND S (UNIT-SEQ X)))) (G S))
(INVOKE FRONT)
(REARRANGE)
(REWRITE)

(rule is-function-tail (s)
  (implies (is-sequence s)
	   (= (fn!is-function (tail s)) (true))))
(INVOKE TAIL)
(REWRITE)

(rule dom-tail (s)
  (implies (and (is-sequence s)
		(not (= s (nullset))))
	   (= (rel!dom (tail s))
	      (range 1 (- (finite!card s) 1)))))
(REDUCE)

(axiom ran-tail (s)
  (subset (rel!ran (tail s)) (rel!ran s)))
(INVOKE TAIL)
(REWRITE)
(USE REL!IMAGE-SUBSET-RAN
     (R S)
     (X (REL!IMAGE (INTFN!ADD 1) (RANGE 1 (- (FINITE!CARD S) 1)))))
(SIMPLIFY)
(REDUCE)

(rule card-tail (s)
  (implies (and (is-sequence s)
		(not (= s (nullset))))
	   (= (finite!card (tail s))
	      (- (finite!card s) 1))))
(USE IS-SEQUENCE-SUBGOAL (N (- (FINITE!CARD S) 1)) (X (TAIL S)))
(USE FINITE!CARD-0-IFF-NULLSET (X S))
(REARRANGE)
(REWRITE)

(rule is-sequence-tail (s)
  (implies (is-sequence s)
	   (= (is-sequence (tail s)) (true))))
(USE IS-SEQUENCE-SUBGOAL (N (- (FINITE!CARD S) 1)) (X (TAIL S)))
(USE FINITE!CARD-0-IFF-NULLSET (X S))
(REARRANGE)
(SPLIT (= S (NULLSET)))
(REWRITE)
(REDUCE)

(rule finite-tail (s)
  (implies (is-sequence s)
	   (= (finite!is-finite (tail s)) (true))))
(USE IS-SEQUENCE-TAIL (S S))
(WITH-DISABLED (IS-SEQUENCE-TAIL) (REWRITE))

(rule apply-tail (n s)
  (implies (and (is-sequence s)
		(not (= s (nullset)))
		(in n (rel!dom (tail s))))
	   (= (fn!apply (tail s) n)
	      (fn!apply s (+ n 1)))))
(INVOKE TAIL)
(REWRITE)

(axiom seq-head-tail (s)
  (implies (is-sequence s)
	   (or (= s (nullset))
	       (= s (append (unit-seq (head s)) (tail s))))))
(USE FN!FUNCTION-EXTENSIONALITY
     (F S)
     (G (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
(REARRANGE)
(INVOKE HEAD)
(REWRITE)

(rule is-function-front (s)
  (implies (is-sequence s)
	   (= (fn!is-function (front s)) (true))))
(INVOKE FRONT)
(REWRITE)

(rule dom-front (s)
  (implies (and (is-sequence s)
		(not (= s (nullset))))
	   (= (rel!dom (front s))
	      (range 1 (- (finite!card s) 1)))))
(REDUCE)

(axiom ran-front (s)
  (subset (rel!ran (front s)) (rel!ran s)))
(INVOKE FRONT)
(REWRITE)
(USE REL!IMAGE-SUBSET-RAN
     (R S)
     (X (RANGE 1 (- (FINITE!CARD S) 1))))
(SIMPLIFY)

(rule card-front (s)
  (implies (and (is-sequence s)
		(not (= s (nullset))))
	   (= (finite!card (front s))
	      (- (finite!card s) 1))))
(USE IS-SEQUENCE-SUBGOAL (N (- (FINITE!CARD S) 1)) (X (FRONT S)))
(USE FINITE!CARD-0-IFF-NULLSET (X S))
(REARRANGE)
(REWRITE)

(rule is-sequence-front (s)
  (implies (is-sequence s)
	   (= (is-sequence (front s)) (true))))
(USE IS-SEQUENCE-SUBGOAL (N (- (FINITE!CARD S) 1)) (X (FRONT S)))
(USE FINITE!CARD-0-IFF-NULLSET (X S))
(SPLIT (= S (NULLSET)))
(REARRANGE)
(REDUCE)

(rule finite-front (s)
  (implies (is-sequence s)
	   (= (finite!is-finite (front s)) (true))))
(USE IS-SEQUENCE-FRONT (S S))
(WITH-DISABLED (IS-SEQUENCE-FRONT) (REWRITE))

(rule apply-front (n s)
  (implies (and (is-sequence s)
		(not (= s (nullset)))
		(in n (rel!dom (front s))))
	   (= (fn!apply (front s) n)
	      (fn!apply s n))))
(INVOKE FRONT)
(REWRITE)

(axiom seq-front-last (s)
  (implies (is-sequence s)
	   (or (= s (nullset))
	       (= s (append (front s) (unit-seq (zlast s)))))))
(USE FN!FUNCTION-EXTENSIONALITY
     (F S)
     (G (APPEND (FRONT S) (UNIT-SEQ (ZLAST S)))))
(REARRANGE)
(INVOKE ZLAST)
(REWRITE)

(rule front-nullset ()
  (= (front (nullset))
     (nullset)))
(REDUCE)

(rule tail-nullset ()
  (= (tail (nullset))
     (nullset)))
(REDUCE)

;;; reversal

(function reverse (s) ()
  (rel!comp (intfn!multiply-by -1)
	   (rel!comp (intfn!add (+ (finite!card s) 1)) s)))

(rule is-function-reverse (s)
  (implies (is-sequence s)
	   (= (fn!is-function (reverse s)) (true))))
(INVOKE REVERSE)
(REWRITE)

(rule dom-reverse (s)
  (implies (is-sequence s)
	   (= (rel!dom (reverse s))
	      (rel!dom s))))
(INVOKE REVERSE)
(REWRITE)
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)

(rule ran-reverse (s)
  (implies (is-sequence s)
	   (= (rel!ran (reverse s))
	      (rel!ran s))))
(WITH-DISABLED (IS-SEQUENCE) (REDUCE))

(rule is-sequence-reverse (s)
  (implies (is-sequence s)
	   (= (is-sequence (reverse s)) (true))))
(USE IS-SEQUENCE-SUBGOAL (X (REVERSE s)) (N (FINITE!CARD s)))
(REARRANGE)
(REWRITE)

(rule finite-reverse (s)
  (implies (is-sequence s)
	   (= (finite!is-finite (reverse s)) (true))))
(USE IS-SEQUENCE-REVERSE (S S))
(WITH-DISABLED (IS-SEQUENCE-REVERSE) (REWRITE))

(rule card-reverse (s)
  (implies (is-sequence s)
	   (= (finite!card (reverse s))
	      (finite!card s))))
(USE IS-SEQUENCE-SUBGOAL (X (REVERSE s)) (N (FINITE!CARD S)))
(REARRANGE)
(REWRITE)

(rule reverse-nullset ()
  (= (reverse (nullset))
     (nullset)))
(REDUCE)

(rule apply-reverse (s n)
  (implies (and (is-sequence s)
		(in n (range 1 (finite!card s))))
	   (= (fn!apply (reverse s) n)
	      (fn!apply s (- (+ 1 (finite!card s)) n)))))
(INVOKE REVERSE)
(REWRITE)

(rule reverse-unit (x)
  (= (reverse (unit-seq x))
     (unit-seq x)))
(APPLY FN!FUNCTION-EXTENSIONALITY)
(REWRITE)

(rule reverse-append (x y)
  (implies (and (is-sequence x) (is-sequence y))
	   (= (reverse (append x y))
	      (append (reverse y) (reverse x)))))
(APPLY FN!FUNCTION-EXTENSIONALITY)
(REWRITE)

(rule head-reverse (s)
  (implies (and (is-sequence s)
		(not (= s (nullset))))
	   (= (head (reverse s)) (zlast s))))
(INVOKE HEAD)
(INVOKE ZLAST)
(USE FINITE!CARD-0-IFF-NULLSET (X S))
(REARRANGE)
(REWRITE)

(rule reverse-reverse (s)
  (implies (is-sequence s)
	   (= (reverse (reverse s)) s)))
(APPLY FN!FUNCTION-EXTENSIONALITY)
(REWRITE)

(rule last-reverse (s)
  (implies (and (is-sequence s)
		(not (= s (nullset))))
	   (= (zlast (reverse s)) (head s))))
(USE HEAD-REVERSE (S (REVERSE S)))
(REARRANGE)
(REWRITE)
;;; now show (rev s) = nullset implies s = nullset
(USE REVERSE-REVERSE (S S))
(USE REVERSE-NULLSET)
(SIMPLIFY)


(rule reverse-front (s)
  (implies (is-sequence s)
	   (= (reverse (front s)) (tail (reverse s)))))
(APPLY FN!FUNCTION-EXTENSIONALITY)
(SPLIT (OR (= S (NULLSET))
	   (= (REVERSE S) (NULLSET))))
(REWRITE)
;;; now show (rev s) = nullset implies s = nullset
(USE REVERSE-REVERSE (S S))
(USE REVERSE-NULLSET)
(SIMPLIFY)

(rule reverse-tail (s)
  (implies (is-sequence s)
	   (= (reverse (tail s)) (front (reverse s)))))
(USE REVERSE-REVERSE (S (FRONT (REVERSE S))))
(REARRANGE)
(REWRITE)

;;; filtering

(function filter (s x)
    ((measure (finite!card s)))
  (if (implies (is-sequence s) (= s (nullset)))
      (nullset)
      (if (in (head s) x)
	  (append (unit-seq (head s))
		  (filter (tail s) x))
	  (filter (tail s) x))))
(USE FINITE!CARD-0-IFF-NULLSET (X S))
(REWRITE)

(rule is-sequence-filter (s x)
  (implies (is-sequence s)
	   (= (is-sequence (filter s x)) (true))))
(INDUCT)
(REWRITE)
(INVOKE (FILTER S X))
(REWRITE)
(REDUCE)

(rule is-function-filter (s x)
  (implies (is-sequence s)
	   (= (fn!is-function (filter s x)) (true))))
(USE IS-SEQUENCE-FILTER (S S) (X X))
(WITH-DISABLED (IS-SEQUENCE-FILTER) (REWRITE))

(rule ran-filter (s x)
  (implies (is-sequence s)
	   (= (rel!ran (filter s x))
	      (inter (rel!ran s) x))))
(INDUCT)
(INVOKE (FILTER S X))
(REWRITE)
(USE SEQ-HEAD-TAIL (S S))
(SIMPLIFY)
(EQUALITY-SUBSTITUTE S)
(APPLY RAN-APPEND)
(REWRITE)

(rule finite-filter (s x)
  (implies (is-sequence s)
	   (= (finite!is-finite (filter s x)) (true))))
(USE IS-SEQUENCE-FILTER (S S) (X X))
(WITH-DISABLED (IS-SEQUENCE-FILTER) (REWRITE))

(rule filter-by-superset-ran (s x)
  (implies (and (is-sequence s)
		(subset (rel!ran s) x))
	   (= (filter s x) s)))
(INDUCT)
(INVOKE (FILTER S X))
(USE RAN-TAIL (S S))
(REWRITE)
(USE SUBSET.TRANSITIVE (X (REL!RAN (TAIL S))) (Y (REL!RAN S)) (Z X))
(USE SEQ-HEAD-TAIL (S S))
(SIMPLIFY)
(INVOKE HEAD)
(USE FN!APPLY-IN-RAN (F S) (X 1))
(INVOKE (SUBSET (REL!RAN S) X))
(USE FINITE!CARD-0-IFF-NULLSET (X S))
(REARRANGE)
(REWRITE)

(rule filter-nullset (x)
  (= (filter (nullset) x)
     (nullset)))
(REDUCE)

(rule filter-unit (x y)
  (= (filter (unit-seq x) y)
     (if (in x y)
	 (unit-seq x)
	 (nullset))))
(WITH-DISABLED (SETRULES) (REDUCE))

;;; two lemmas for filter-append

(rule head-append (x y)
  (implies (and (is-sequence x)
		(is-sequence y))
	   (= (head (append x y))
	      (if (= x (nullset))
		  (head y)
		  (head x)))))
(INVOKE HEAD)
(REWRITE)
(USE FINITE!CARD-0-IFF-NULLSET (X X))
(REARRANGE)
(REWRITE)

(rule tail-append (x y)
  (implies (and (is-sequence x)
		(is-sequence y))
	   (= (tail (append x y))
	      (if (= x (nullset))
		  (tail y)
		  (append (tail x) y)))))
(REWRITE)
(USE FINITE!CARD-0-IFF-NULLSET (X X))
(USE FN!FUNCTION-EXTENSIONALITY
     (F (TAIL (APPEND X Y)))
     (G (APPEND (TAIL X) Y)))
(REARRANGE)
(REWRITE)
(USE FINITE!CARD-0-IFF-NULLSET (X (APPEND X Y)))
(REARRANGE)
(REWRITE)

(rule filter-append (x y z)
  (implies (and (is-sequence x)
		(is-sequence y))
	   (= (filter (append x y) z)
	      (append (filter x z) (filter y z)))))
(INDUCT (FILTER X Z))
(INVOKE (FILTER X Z))
(REWRITE)
(INVOKE (FILTER (APPEND X Y) Z))
(REWRITE)
(USE FINITE!CARD-0-IFF-NULLSET (X X))
(USE FINITE!CARD-0-IFF-NULLSET (X (APPEND X Y)))
(REARRANGE)
(SPLIT (IS-SEQUENCE Y))
(REWRITE)

(rule reverse-filter (s x)
  (implies (is-sequence s)
	   (= (reverse (filter s x))
	      (filter (reverse s) x))))
(INDUCT)
(REWRITE)
(USE SEQ-HEAD-TAIL (S S))
(EQUALITY-SUBSTITUTE S)
(APPLY REVERSE-APPEND)
(APPLY FILTER-APPEND)
(REWRITE)

(rule filter-filter (s x y)
  (implies (is-sequence s)
	   (= (filter (filter s x) y)
	      (filter s (inter x y)))))
(INDUCT)
(INVOKE (FILTER S X))
(REWRITE)
(INVOKE (FILTER S (INTER X Y)))
(REWRITE)

(rule filter-by-nullset (s)
  (implies (is-sequence s)
	   (= (filter s (nullset))
	      (nullset))))
(INDUCT)
(INVOKE (FILTER S (NULLSET)))
(REWRITE)

(axiom card-filter (s x)
  (implies (is-sequence s)
	   (<= (finite!card (filter s x))
	       (finite!card s))))
(INDUCT)
(INVOKE (FILTER S X))
(REWRITE)
