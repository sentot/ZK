
Reading "/home/sentot/zk/version1/ZK/examples/zseqmodel.ver"
Warning RULE-LOOPS for FN!FUNCTION-EXTENSIONALITY:
 The rule FN!FUNCTION-EXTENSIONALITY loops upon itself.
Warning RULE-CONDITION-LOOPS for ELEM!>=-TRANSITIVE:
 The rule ELEM!>=-TRANSITIVE applies to its own condition.
Warning RULE-LOOPS for ELEM!>=-PRED-DEVELOPMENT:
 The rule ELEM!>=-PRED-DEVELOPMENT loops upon itself.
Warning RULE-CONDITION-LOOPS for ELEM!ASSYMETRY:
 The rule ELEM!ASSYMETRY applies to its own condition.
Warning RULE-LOOPS for ELEM!RANGE-BOTTOM-EXPANSION:
 The rule ELEM!RANGE-BOTTOM-EXPANSION loops upon itself.
Warning RULE-LOOPS for ELEM!RANGE-TOP-EXPANSION:
 The rule ELEM!RANGE-TOP-EXPANSION loops upon itself.
IS-SEQUENCE
TYPE-OF-IS-SEQUENCE
Beginning proof of TYPE-OF-IS-SEQUENCE ...
(= (TYPE-OF (IS-SEQUENCE X)) (BOOL))
Which simplifies
 with invocation of IS-SEQUENCE
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-SEQUENCE-DEFINITION
Beginning proof of IS-SEQUENCE-DEFINITION ...
(= (IS-SEQUENCE X)
 (AND (FN!IS-FUNCTION X) (FINITE!IS-FINITE X)
  (= (REL!DOM X) (RANGE 1 (FINITE!CARD X)))))
Which simplifies
 with invocation of IS-SEQUENCE
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-SEQUENCE-FACTS
Beginning proof of IS-SEQUENCE-FACTS ...
(IMPLIES (IS-SEQUENCE X)
 (AND (FN!IS-FUNCTION X) (FINITE!IS-FINITE X)
  (= (REL!DOM X) (RANGE 1 (FINITE!CARD X)))))
Which simplifies
 with invocation of IS-SEQUENCE
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
SEQUENCE-DOM
Beginning proof of SEQUENCE-DOM ...
(IMPLIES (IS-SEQUENCE X) (= (REL!DOM X) (RANGE 1 (FINITE!CARD X))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
IS-SEQUENCE-SUBGOAL
Beginning proof of IS-SEQUENCE-SUBGOAL ...
(IMPLIES (AND (IN N (NAT!NAT)) (FN!IS-FUNCTION X) (= (REL!DOM X) (RANGE 1 N)))
 (AND (IS-SEQUENCE X) (= (FINITE!CARD X) N)))
Invoking IS-SEQUENCE gives ...
(IMPLIES (AND (IN N (NAT!NAT)) (FN!IS-FUNCTION X) (= (REL!DOM X) (RANGE 1 N)))
 (AND (FN!IS-FUNCTION X) (FINITE!IS-FINITE X)
  (= (REL!DOM X) (RANGE 1 (FINITE!CARD X))) (= (FINITE!CARD X) N)))
Assuming FINITE!FINITE-FUNCTION-DOM with the instantiations: (= F X) generates
...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION X) (FINITE!IS-FINITE (REL!DOM X)))
   (AND (FINITE!IS-FINITE X) (= (FINITE!CARD X) (FINITE!CARD (REL!DOM X)))))
  (IN N (NAT!NAT)) (FN!IS-FUNCTION X) (= (REL!DOM X) (RANGE 1 N)))
 (AND (FN!IS-FUNCTION X) (FINITE!IS-FINITE X)
  (= (REL!DOM X) (RANGE 1 (FINITE!CARD X))) (= (FINITE!CARD X) N)))
Rearranging gives ...
(IMPLIES
 (AND (= (REL!DOM X) (RANGE 1 N)) (IN N (NAT!NAT)) (FN!IS-FUNCTION X)
  (IMPLIES (AND (FN!IS-FUNCTION X) (FINITE!IS-FINITE (REL!DOM X)))
   (AND (= (FINITE!CARD X) (FINITE!CARD (REL!DOM X))) (FINITE!IS-FINITE X))))
 (AND (= (REL!DOM X) (RANGE 1 (FINITE!CARD X))) (= (FINITE!CARD X) N)
  (FN!IS-FUNCTION X) (FINITE!IS-FINITE X)))
Substituting (= (REL!DOM X) (RANGE 1 N)) produces ...
(IMPLIES (AND (= (REL!DOM X) (RANGE 1 N)) (IN N (NAT!NAT)) (FN!IS-FUNCTION X))
 (IF (FINITE!IS-FINITE (RANGE 1 N))
  (IMPLIES
   (AND (= (FINITE!CARD X) (FINITE!CARD (RANGE 1 N))) (FINITE!IS-FINITE X))
   (AND (= (RANGE 1 N) (RANGE 1 (FINITE!CARD X))) (= (FINITE!CARD X) N)))
  (AND (= (RANGE 1 N) (RANGE 1 (FINITE!CARD X))) (= (FINITE!CARD X) N)
   (FINITE!IS-FINITE X))))
Which simplifies
 when rewriting with ELEM!NULL-RANGE, FINITE!CARD-SIMPLE-RANGE,
FINITE!IS-FINITE-SIMPLE-RANGE, NAT!IN-NAT
 forward chaining using FINITE!FINITE-CARD-NAT, FN!FUNCTION-IS-RELATION,
>=.SAME.TYPE
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(IMPLIES
 (AND (= (REL!DOM X) (RANGE 1 N)) (>= N 0) (FN!IS-FUNCTION X) (NAT!ZEROP N)
  (= (FINITE!CARD X) 0) (FINITE!IS-FINITE X))
 (AND (= (RANGE 1 N) (NULLSET)) (= 0 N)))
Which simplifies
 with invocation of NAT!ZEROP
 when rewriting with ELEM!NULL-RANGE
 forward chaining using FINITE!FINITE-CARD-NAT, FN!FUNCTION-IS-RELATION,
>=.SAME.TYPE
 with the assumptions FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
IS-SEQUENCE-NULLSET
Beginning proof of IS-SEQUENCE-NULLSET ...
(= (IS-SEQUENCE (NULLSET)) (TRUE))
Which simplifies
 with invocation of IS-SEQUENCE
 when rewriting with SEQUENCE-DOM, ELEM!NULL-RANGE, FINITE!CARD-NULLSET,
REL!DOM-NULLSET, FINITE!IS-FINITE-NULLSET, FN!IS-FUNCTION-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
SEQUENCE-OF
IN-SEQUENCE-OF
Beginning proof of IN-SEQUENCE-OF ...
(= (IN S (SEQUENCE-OF X)) (AND (IS-SEQUENCE S) (SUBSET (REL!RAN S) X)))
Assuming IS-SEQUENCE-SUBGOAL with the
instantiations: (= N (FINITE!CARD S)) (= X S) generates ...
(IMPLIES
 (IMPLIES
  (AND (IN (FINITE!CARD S) (NAT!NAT)) (FN!IS-FUNCTION S)
   (= (REL!DOM S) (RANGE 1 (FINITE!CARD S))))
  (AND (IS-SEQUENCE S) (= (FINITE!CARD S) (FINITE!CARD S))))
 (= (IN S (SEQUENCE-OF X)) (AND (IS-SEQUENCE S) (SUBSET (REL!RAN S) X))))
Which simplifies
 with invocation of SUBSET, IS-SEQUENCE
 when rewriting with RANGE.DEFINITION, FN!IN-PFUN, SEQUENCE-OF.DEFINITION,
SEQUENCE-DOM, NAT!IN-NAT
 forward chaining using FINITE!FINITE-CARD-NAT, IS-SEQUENCE-FACTS,
FN!FUNCTION-IS-RELATION, >=.SAME.TYPE
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
NONEMPTY-SEQUENCE-OF
IN-NONEMPTY-SEQUENCE-OF
Beginning proof of IN-NONEMPTY-SEQUENCE-OF ...
(= (IN S (NONEMPTY-SEQUENCE-OF X))
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))) (SUBSET (REL!RAN S) X)))
Invoking NONEMPTY-SEQUENCE-OF gives ...
(= (IN S (DIFF (SEQUENCE-OF X) (UNIT (NULLSET))))
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))) (SUBSET (REL!RAN S) X)))
Which simplifies
 when rewriting with NULLSET.DEFINITION, SETADD.DEFINITION, IN-SEQUENCE-OF,
DIFF.DEFINITION, SETRULES!UNIT-TO-SETADD
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-DIFF-RELATION to ...
(TRUE)
APPEND
APPEND-DEF
Beginning proof of APPEND-DEF ...
(= (APPEND X Y) (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))
Which simplifies
 with invocation of APPEND
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
IS-SEQUENCE-APPEND-LEMMA
Beginning proof of IS-SEQUENCE-APPEND-LEMMA ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (AND (IS-SEQUENCE (APPEND X Y))
  (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
Assuming IS-SEQUENCE-SUBGOAL with the
instantiations: (= X (APPEND X Y))
                (= N (+ (FINITE!CARD X) (FINITE!CARD Y))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (+ (FINITE!CARD X) (FINITE!CARD Y)) (NAT!NAT))
    (FN!IS-FUNCTION (APPEND X Y))
    (= (REL!DOM (APPEND X Y)) (RANGE 1 (+ (FINITE!CARD X) (FINITE!CARD Y)))))
   (AND (IS-SEQUENCE (APPEND X Y))
    (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (AND (IS-SEQUENCE (APPEND X Y))
  (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE X) (IS-SEQUENCE Y)
  (IMPLIES
   (AND
    (= (REL!DOM (APPEND X Y)) (RANGE 1 (+ (FINITE!CARD X) (FINITE!CARD Y))))
    (IN (+ (FINITE!CARD X) (FINITE!CARD Y)) (NAT!NAT))
    (FN!IS-FUNCTION (APPEND X Y)))
   (AND (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))
    (IS-SEQUENCE (APPEND X Y)))))
 (AND (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))
  (IS-SEQUENCE (APPEND X Y))))
Invoking APPEND gives ...
(IMPLIES
 (AND (IS-SEQUENCE X) (IS-SEQUENCE Y)
  (IMPLIES
   (AND
    (= (REL!DOM (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))
     (RANGE 1 (+ (FINITE!CARD X) (FINITE!CARD Y))))
    (IN (+ (FINITE!CARD X) (FINITE!CARD Y)) (NAT!NAT))
    (FN!IS-FUNCTION
     (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y))))
   (AND
    (=
     (FINITE!CARD (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))
     (+ (FINITE!CARD X) (FINITE!CARD Y)))
    (IS-SEQUENCE
     (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y))))))
 (AND
  (= (FINITE!CARD (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))
   (+ (FINITE!CARD X) (FINITE!CARD Y)))
  (IS-SEQUENCE (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))))
Which simplifies
 when rewriting with NULLSET.DEFINITION, ELEM!NULL-RANGE, ELEM!>=-MAX-RIGHT,
ELEM!>=-MIN-LEFT, ELEM!INTER-RANGE-RANGE, FN!IS-FUNCTION-COMP-FUNCTIONS,
INTFN!IS-FUNCTION-ADD, FN!IS-FUNCTION-UNION, NAT!IN-NAT,
INTFN!IMAGE-ADD-RANGE, INTFN!INVERSE-ADD, REL!DOM-COMP, SEQUENCE-DOM,
REL!DOM-UNION
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, FN!IS-FUNCTION-BOOL, REL!INVERSE-INVERSE,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2 to ...
(IMPLIES
 (AND (IS-SEQUENCE X) (IS-SEQUENCE Y)
  (NOT
   (=
    (UNION (RANGE 1 (FINITE!CARD X))
     (RANGE (+ 1 (FINITE!CARD X)) (+ (FINITE!CARD X) (FINITE!CARD Y))))
    (RANGE 1 (+ (FINITE!CARD X) (FINITE!CARD Y))))))
 (AND
  (= (FINITE!CARD (UNION X (REL!COMP (INTFN!ADD (* -1 (FINITE!CARD X))) Y)))
   (+ (FINITE!CARD X) (FINITE!CARD Y)))
  (IS-SEQUENCE (UNION X (REL!COMP (INTFN!ADD (* -1 (FINITE!CARD X))) Y)))))
Which simplifies
 with invocation of MAX, MIN, IS-SEQUENCE
 when rewriting with ELEM!UNION-RANGE-RANGE, SUCC.INT.RULE
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions ELEM!MAX-TYPE, SUCC.INT, ELEM!MIN-TYPE,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2,
FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-SEQUENCE-APPEND
Beginning proof of IS-SEQUENCE-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (IS-SEQUENCE (APPEND X Y)) (TRUE)))
Assuming IS-SEQUENCE-APPEND-LEMMA with the
instantiations: (= X X) (= Y Y) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (AND (IS-SEQUENCE (APPEND X Y))
    (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (IS-SEQUENCE (APPEND X Y)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
IS-FUNCTION-APPEND
Beginning proof of IS-FUNCTION-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (FN!IS-FUNCTION (APPEND X Y)) (TRUE)))
Assuming IS-SEQUENCE-APPEND with the instantiations: (= X X) (= Y Y) generates
...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (= (IS-SEQUENCE (APPEND X Y)) (TRUE)))
  (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (FN!IS-FUNCTION (APPEND X Y)))
Invoking (IS-SEQUENCE (APPEND X Y)) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (AND (FN!IS-FUNCTION (APPEND X Y)) (FINITE!IS-FINITE (APPEND X Y))
    (= (REL!DOM (APPEND X Y)) (RANGE 1 (FINITE!CARD (APPEND X Y))))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (FN!IS-FUNCTION (APPEND X Y)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
DOM-APPEND
Beginning proof of DOM-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (REL!DOM (APPEND X Y)) (RANGE 1 (+ (FINITE!CARD X) (FINITE!CARD Y)))))
Assuming IS-SEQUENCE-APPEND-LEMMA with the
instantiations: (= X X) (= Y Y) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (AND (IS-SEQUENCE (APPEND X Y))
    (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (REL!DOM (APPEND X Y)) (RANGE 1 (+ (FINITE!CARD X) (FINITE!CARD Y)))))
Invoking (IS-SEQUENCE (APPEND X Y)) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (AND (FN!IS-FUNCTION (APPEND X Y)) (FINITE!IS-FINITE (APPEND X Y))
    (= (REL!DOM (APPEND X Y)) (RANGE 1 (FINITE!CARD (APPEND X Y))))
    (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (REL!DOM (APPEND X Y)) (RANGE 1 (+ (FINITE!CARD X) (FINITE!CARD Y)))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
FINITE-APPEND
Beginning proof of FINITE-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (FINITE!IS-FINITE (APPEND X Y)) (TRUE)))
Assuming IS-SEQUENCE-APPEND-LEMMA with the
instantiations: (= X X) (= Y Y) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (AND (IS-SEQUENCE (APPEND X Y))
    (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (FINITE!IS-FINITE (APPEND X Y)))
Invoking (IS-SEQUENCE (APPEND X Y)) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (AND (FN!IS-FUNCTION (APPEND X Y)) (FINITE!IS-FINITE (APPEND X Y))
    (= (REL!DOM (APPEND X Y)) (RANGE 1 (FINITE!CARD (APPEND X Y))))
    (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (FINITE!IS-FINITE (APPEND X Y)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
CARD-APPEND
Beginning proof of CARD-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y))))
Assuming IS-SEQUENCE-APPEND-LEMMA with the
instantiations: (= X X) (= Y Y) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (AND (IS-SEQUENCE (APPEND X Y))
    (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
APPEND-NULLSET-LEFT
Beginning proof of APPEND-NULLSET-LEFT ...
(IMPLIES (IS-SEQUENCE X) (= (APPEND (NULLSET) X) X))
Which simplifies
 with invocation of SUBSET, APPEND, IS-SEQUENCE
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SUBSET.NULLSET.LEFT,
REL!DOM-RESTRICT-BY-SUPERSET-DOM, RANGE.DEFINITION, SEQUENCE-DOM,
REL!COMP-ID-LEFT, INTFN!ADD-0-IS-ID, FINITE!CARD-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FINITE!TYPE-OF-IS-FINITE,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
APPEND-NULLSET-RIGHT
Beginning proof of APPEND-NULLSET-RIGHT ...
(IMPLIES (IS-SEQUENCE X) (= (APPEND X (NULLSET)) X))
Which simplifies
 with invocation of APPEND, IS-SEQUENCE
 when rewriting with SETRULES!UNION-SUBSET-LEFT, SUBSET.NULLSET.LEFT,
REL!COMP-NULLSET-RIGHT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FINITE!TYPE-OF-IS-FINITE,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
APPLY-APPEND
Beginning proof of APPLY-APPEND ...
(IMPLIES
 (AND (IS-SEQUENCE X) (IS-SEQUENCE Y)
  (IN N (RANGE 1 (FINITE!CARD (APPEND X Y)))))
 (= (FN!APPLY (APPEND X Y) N)
  (IF (<= N (FINITE!CARD X)) (FN!APPLY X N)
   (FN!APPLY Y (- N (FINITE!CARD X))))))
Assuming FN!APPLY-UNION with the
instantiations: (= F X)
                (= G (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y))
                (= X N) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (FN!IS-FUNCTION
     (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))
    (IN N
     (REL!DOM (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))))
   (= (FN!APPLY (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)) N)
    (IF (IN N (REL!DOM X)) (FN!APPLY X N)
     (FN!APPLY (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y) N))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y) (IN N (RANGE 1 (FINITE!CARD (APPEND X Y)))))
 (= (FN!APPLY (APPEND X Y) N)
  (IF (>= (FINITE!CARD X) N) (FN!APPLY X N)
   (FN!APPLY Y (- N (FINITE!CARD X))))))
Assuming IS-SEQUENCE-APPEND-LEMMA with the
instantiations: (= X X) (= Y Y) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (AND (IS-SEQUENCE (APPEND X Y))
    (= (FINITE!CARD (APPEND X Y)) (+ (FINITE!CARD X) (FINITE!CARD Y)))))
  (IMPLIES
   (AND
    (FN!IS-FUNCTION
     (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))
    (IN N
     (REL!DOM (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))))
   (= (FN!APPLY (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)) N)
    (IF (IN N (REL!DOM X)) (FN!APPLY X N)
     (FN!APPLY (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y) N))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y) (IN N (RANGE 1 (FINITE!CARD (APPEND X Y)))))
 (= (FN!APPLY (APPEND X Y) N)
  (IF (>= (FINITE!CARD X) N) (FN!APPLY X N)
   (FN!APPLY Y (- N (FINITE!CARD X))))))
Invoking APPEND gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (AND
    (IS-SEQUENCE (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))
    (=
     (FINITE!CARD (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))
     (+ (FINITE!CARD X) (FINITE!CARD Y)))))
  (IMPLIES
   (AND
    (FN!IS-FUNCTION
     (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))
    (IN N
     (REL!DOM (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)))))
   (= (FN!APPLY (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)) N)
    (IF (IN N (REL!DOM X)) (FN!APPLY X N)
     (FN!APPLY (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y) N))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y)
  (IN N
   (RANGE 1
    (FINITE!CARD
     (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y))))))
 (= (FN!APPLY (UNION X (REL!COMP (INTFN!ADD (NEGATE (FINITE!CARD X))) Y)) N)
  (IF (>= (FINITE!CARD X) N) (FN!APPLY X N)
   (FN!APPLY Y (- N (FINITE!CARD X))))))
Which simplifies
 when rewriting with UNION.DEFINITION, INTFN!INVERSE-ADD, REL!DOM-COMP,
REL!DOM-UNION, FN!APPLY-COMP, INTFN!APPLY-ADD, INTFN!DOM-ADD,
INTFN!IS-FUNCTION-ADD, FN!APPLY-UNION, RANGE.DEFINITION, SEQUENCE-DOM
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions REL!INVERSE-INVERSE, FN!IS-FUNCTION-BOOL,
SETRULES!SUBSET-UNION-RELATION-1, SETRULES!SUBSET-UNION-RELATION-2 to ...
(TRUE)
APPEND-ASSOCIATIVE
Beginning proof of APPEND-ASSOCIATIVE ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y) (IS-SEQUENCE Z))
 (= (APPEND (APPEND X Y) Z) (APPEND X (APPEND Y Z))))
Assuming FN!FUNCTION-EXTENSIONALITY with the
instantiations: (= F (APPEND (APPEND X Y) Z))
                (= G (APPEND X (APPEND Y Z))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (APPEND (APPEND X Y) Z))
    (FN!IS-FUNCTION (APPEND X (APPEND Y Z))))
   (= (= (APPEND (APPEND X Y) Z) (APPEND X (APPEND Y Z)))
    (AND
     (= (REL!DOM (APPEND (APPEND X Y) Z)) (REL!DOM (APPEND X (APPEND Y Z))))
     (ALL (X$0)
      (IMPLIES (IN X$0 (REL!DOM (APPEND (APPEND X Y) Z)))
       (= (FN!APPLY (APPEND (APPEND X Y) Z) X$0)
        (FN!APPLY (APPEND X (APPEND Y Z)) X$0)))))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y) (IS-SEQUENCE Z))
 (= (APPEND (APPEND X Y) Z) (APPEND X (APPEND Y Z))))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE X) (IS-SEQUENCE Y) (IS-SEQUENCE Z)
  (IMPLIES
   (AND (FN!IS-FUNCTION (APPEND (APPEND X Y) Z))
    (FN!IS-FUNCTION (APPEND X (APPEND Y Z))))
   (= (= (APPEND (APPEND X Y) Z) (APPEND X (APPEND Y Z)))
    (AND
     (= (REL!DOM (APPEND (APPEND X Y) Z)) (REL!DOM (APPEND X (APPEND Y Z))))
     (ALL (X$0)
      (IMPLIES (IN X$0 (REL!DOM (APPEND (APPEND X Y) Z)))
       (= (FN!APPLY (APPEND (APPEND X Y) Z) X$0)
        (FN!APPLY (APPEND X (APPEND Y Z)) X$0))))))))
 (= (APPEND (APPEND X Y) Z) (APPEND X (APPEND Y Z))))
Which simplifies
 when rewriting with APPLY-APPEND, RANGE.DEFINITION, CARD-APPEND, DOM-APPEND,
IS-FUNCTION-APPEND, IS-SEQUENCE-APPEND
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
RAN-APPEND
Beginning proof of RAN-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (REL!RAN (APPEND X Y)) (UNION (REL!RAN X) (REL!RAN Y))))
Which simplifies
 with invocation of SUBSET, APPEND, IS-SEQUENCE
 when rewriting with REL!IMAGE-OF-SUPERSET-OF-DOM, RANGE.DEFINITION,
SEQUENCE-DOM, INTFN!RAN-ADD, REL!RAN-COMP, REL!RAN-UNION
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, FINITE!TYPE-OF-IS-FINITE,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
UNIT-SEQ
UNIT-SEQ-DEF
Beginning proof of UNIT-SEQ-DEF ...
(= (UNIT-SEQ X) (UNIT (PAIR!PAIR 1 X)))
Which simplifies
 with invocation of UNIT-SEQ
 when rewriting with SETRULES!UNIT-TO-SETADD
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
IS-FUNCTION-UNIT-SEQ
Beginning proof of IS-FUNCTION-UNIT-SEQ ...
(= (FN!IS-FUNCTION (UNIT-SEQ X)) (TRUE))
Which simplifies
 with invocation of UNIT-SEQ
 when rewriting with NULLSET.DEFINITION, ELEM!NULL-RANGE, FINITE!CARD-NULLSET,
SEQUENCE-DOM, IS-SEQUENCE-NULLSET, FN!IS-FUNCTION-NULLSET,
FN!IS-FUNCTION-SETADD, SETRULES!UNIT-TO-SETADD
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
IS-SEQUENCE-FACTS, FN!FUNCTION-IS-RELATION, PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, FN!IS-FUNCTION-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
DOM-UNIT-SEQ
Beginning proof of DOM-UNIT-SEQ ...
(= (REL!DOM (UNIT-SEQ X)) (UNIT 1))
Which simplifies
 with invocation of UNIT-SEQ
 when rewriting with REL!DOM-SETADD, SETRULES!UNIT-TO-SETADD
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
RAN-UNIT-SEQ
Beginning proof of RAN-UNIT-SEQ ...
(= (REL!RAN (UNIT-SEQ X)) (UNIT X))
Which simplifies
 with invocation of UNIT-SEQ
 when rewriting with REL!RAN-NULLSET, REL!RAN-SETADD, SETRULES!UNIT-TO-SETADD
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR to ...
(TRUE)
FINITE-UNIT-SEQ
Beginning proof of FINITE-UNIT-SEQ ...
(= (FINITE!IS-FINITE (UNIT-SEQ X)) (TRUE))
Which simplifies
 with invocation of UNIT-SEQ
 when rewriting with FINITE!IS-FINITE-NULLSET, FINITE!IS-FINITE-SETADD,
SETRULES!UNIT-TO-SETADD
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
PAIR!PAIR-COMPOSITION
 with the assumptions FINITE!TYPE-OF-IS-FINITE, PAIR!FST-PAIR, PAIR!SND-PAIR,
PAIR!PAIR-IS-PAIR to ...
(TRUE)
CARD-UNIT-SEQ
Beginning proof of CARD-UNIT-SEQ ...
(= (FINITE!CARD (UNIT-SEQ X)) 1)
Which simplifies
 with invocation of UNIT-SEQ
 when rewriting with FINITE!CARD-UNIT
 forward chaining using PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
IS-SEQUENCE-UNIT-SEQ
Beginning proof of IS-SEQUENCE-UNIT-SEQ ...
(= (IS-SEQUENCE (UNIT-SEQ X)) (TRUE))
Invoking IS-SEQUENCE gives ...
(AND (FN!IS-FUNCTION (UNIT-SEQ X)) (FINITE!IS-FINITE (UNIT-SEQ X))
 (= (REL!DOM (UNIT-SEQ X)) (RANGE 1 (FINITE!CARD (UNIT-SEQ X)))))
Which simplifies
 when rewriting with ELEM!SINGLETON-RANGE, CARD-UNIT-SEQ,
SETRULES!UNIT-TO-SETADD, DOM-UNIT-SEQ, FINITE-UNIT-SEQ, IS-FUNCTION-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
APPLY-UNIT-SEQ
Beginning proof of APPLY-UNIT-SEQ ...
(= (FN!APPLY (UNIT-SEQ X) 1) X)
Assuming FN!APPLY-DEFINITION with the
instantiations: (= F (UNIT-SEQ X)) (= X 1) generates ...
(IMPLIES
 (IMPLIES (AND (FN!IS-FUNCTION (UNIT-SEQ X)) (IN 1 (REL!DOM (UNIT-SEQ X))))
  (IN (PAIR!PAIR 1 (FN!APPLY (UNIT-SEQ X) 1)) (UNIT-SEQ X)))
 (= (FN!APPLY (UNIT-SEQ X) 1) X))
Invoking UNIT-SEQ gives ...
(IMPLIES
 (IMPLIES
  (AND (FN!IS-FUNCTION (UNIT (PAIR!PAIR 1 X)))
   (IN 1 (REL!DOM (UNIT (PAIR!PAIR 1 X)))))
  (IN (PAIR!PAIR 1 (FN!APPLY (UNIT (PAIR!PAIR 1 X)) 1))
   (UNIT (PAIR!PAIR 1 X))))
 (= (FN!APPLY (UNIT (PAIR!PAIR 1 X)) 1) X))
Which simplifies
 when rewriting with FN!APPLY-SETADD, SETADD.DEFINITION, REL!DOM-SETADD,
NULLSET.DEFINITION, ELEM!NULL-RANGE, FINITE!CARD-NULLSET, SEQUENCE-DOM,
IS-SEQUENCE-NULLSET, FN!IS-FUNCTION-NULLSET, FN!IS-FUNCTION-SETADD,
SETRULES!UNIT-TO-SETADD
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
IS-SEQUENCE-FACTS, FN!FUNCTION-IS-RELATION, PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!IS-PAIR-BOOL, FN!IS-FUNCTION-BOOL, PAIR!FST-PAIR,
PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
HEAD
ZLAST
TAIL
FRONT
HEAD-APPEND-UNIT
Beginning proof of HEAD-APPEND-UNIT ...
(IMPLIES (IS-SEQUENCE S) (= (HEAD (APPEND (UNIT-SEQ X) S)) X))
Invoking HEAD gives ...
(IMPLIES (IS-SEQUENCE S) (= (FN!APPLY (APPEND (UNIT-SEQ X) S) 1) X))
Which simplifies
 when rewriting with APPLY-UNIT-SEQ, APPLY-APPEND, RANGE.DEFINITION,
CARD-UNIT-SEQ, CARD-APPEND, IS-SEQUENCE-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
TAIL-APPEND-UNIT
Beginning proof of TAIL-APPEND-UNIT ...
(IMPLIES (IS-SEQUENCE S) (= (TAIL (APPEND (UNIT-SEQ X) S)) S))
Assuming FN!FUNCTION-EXTENSIONALITY with the
instantiations: (= F (TAIL (APPEND (UNIT-SEQ X) S))) (= G S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (TAIL (APPEND (UNIT-SEQ X) S))) (FN!IS-FUNCTION S))
   (= (= (TAIL (APPEND (UNIT-SEQ X) S)) S)
    (AND (= (REL!DOM (TAIL (APPEND (UNIT-SEQ X) S))) (REL!DOM S))
     (ALL (X$0)
      (IMPLIES (IN X$0 (REL!DOM (TAIL (APPEND (UNIT-SEQ X) S))))
       (= (FN!APPLY (TAIL (APPEND (UNIT-SEQ X) S)) X$0) (FN!APPLY S X$0)))))))
  (IS-SEQUENCE S))
 (= (TAIL (APPEND (UNIT-SEQ X) S)) S))
Invoking TAIL gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (FN!IS-FUNCTION
     (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
      (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S))))
    (FN!IS-FUNCTION S))
   (=
    (=
     (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
      (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S)))
     S)
    (AND
     (=
      (REL!DOM
       (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
        (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S))))
      (REL!DOM S))
     (ALL (X$0)
      (IMPLIES
       (IN X$0
        (REL!DOM
         (REL!DOM-RESTRICT
          (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
          (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S)))))
       (=
        (FN!APPLY
         (REL!DOM-RESTRICT
          (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
          (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S)))
         X$0)
        (FN!APPLY S X$0)))))))
  (IS-SEQUENCE S))
 (=
  (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
   (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S)))
  S))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S)
  (IMPLIES
   (AND
    (FN!IS-FUNCTION
     (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
      (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S))))
    (FN!IS-FUNCTION S))
   (=
    (=
     (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
      (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S)))
     S)
    (AND
     (=
      (REL!DOM
       (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
        (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S))))
      (REL!DOM S))
     (ALL (X$0)
      (IMPLIES
       (IN X$0
        (REL!DOM
         (REL!DOM-RESTRICT
          (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
          (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S)))))
       (=
        (FN!APPLY
         (REL!DOM-RESTRICT
          (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
          (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S)))
         X$0)
        (FN!APPLY S X$0))))))))
 (=
  (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND (UNIT-SEQ X) S)) 1))
   (REL!COMP (INTFN!ADD 1) (APPEND (UNIT-SEQ X) S)))
  S))
Which simplifies
 when rewriting with APPLY-APPEND, FN!APPLY-COMP, INTFN!APPLY-ADD,
INTFN!DOM-ADD, FN!APPLY-DOM-RESTRICT-FUNCTION, RANGE.DEFINITION, SEQUENCE-DOM,
SETRULES!INTER-SUBSET-RIGHT, ELEM!RANGE-SUBSET-RANGE, REL!DOM-DOM-RESTRICT,
FN!IS-FUNCTION-DOM-RESTRICT, FN!IS-FUNCTION-COMP-FUNCTIONS,
IS-FUNCTION-APPEND, INTFN!IS-FUNCTION-ADD, CARD-UNIT-SEQ, CARD-APPEND,
IS-SEQUENCE-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, FN!IS-FUNCTION-BOOL to ...
(TRUE)
ZLAST-APPEND-UNIT
Beginning proof of ZLAST-APPEND-UNIT ...
(IMPLIES (IS-SEQUENCE S) (= (ZLAST (APPEND S (UNIT-SEQ X))) X))
Invoking ZLAST gives ...
(IMPLIES (IS-SEQUENCE S)
 (= (FN!APPLY (APPEND S (UNIT-SEQ X)) (FINITE!CARD (APPEND S (UNIT-SEQ X))))
  X))
Which simplifies
 when rewriting with APPLY-UNIT-SEQ, APPLY-APPEND, RANGE.DEFINITION,
CARD-UNIT-SEQ, CARD-APPEND, IS-SEQUENCE-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
FRONT-APPEND-UNIT
Beginning proof of FRONT-APPEND-UNIT ...
(IMPLIES (IS-SEQUENCE S) (= (FRONT (APPEND S (UNIT-SEQ X))) S))
Assuming FN!FUNCTION-EXTENSIONALITY with the
instantiations: (= F (FRONT (APPEND S (UNIT-SEQ X)))) (= G S) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (FRONT (APPEND S (UNIT-SEQ X)))) (FN!IS-FUNCTION S))
   (= (= (FRONT (APPEND S (UNIT-SEQ X))) S)
    (AND (= (REL!DOM (FRONT (APPEND S (UNIT-SEQ X)))) (REL!DOM S))
     (ALL (X$0)
      (IMPLIES (IN X$0 (REL!DOM (FRONT (APPEND S (UNIT-SEQ X)))))
       (= (FN!APPLY (FRONT (APPEND S (UNIT-SEQ X))) X$0)
        (FN!APPLY S X$0)))))))
  (IS-SEQUENCE S))
 (= (FRONT (APPEND S (UNIT-SEQ X))) S))
Invoking FRONT gives ...
(IMPLIES
 (AND
  (IMPLIES
   (AND
    (FN!IS-FUNCTION
     (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
      (APPEND S (UNIT-SEQ X))))
    (FN!IS-FUNCTION S))
   (=
    (=
     (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
      (APPEND S (UNIT-SEQ X)))
     S)
    (AND
     (=
      (REL!DOM
       (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
        (APPEND S (UNIT-SEQ X))))
      (REL!DOM S))
     (ALL (X$0)
      (IMPLIES
       (IN X$0
        (REL!DOM
         (REL!DOM-RESTRICT
          (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
          (APPEND S (UNIT-SEQ X)))))
       (=
        (FN!APPLY
         (REL!DOM-RESTRICT
          (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
          (APPEND S (UNIT-SEQ X)))
         X$0)
        (FN!APPLY S X$0)))))))
  (IS-SEQUENCE S))
 (=
  (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
   (APPEND S (UNIT-SEQ X)))
  S))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S)
  (IMPLIES
   (AND
    (FN!IS-FUNCTION
     (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
      (APPEND S (UNIT-SEQ X))))
    (FN!IS-FUNCTION S))
   (=
    (=
     (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
      (APPEND S (UNIT-SEQ X)))
     S)
    (AND
     (=
      (REL!DOM
       (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
        (APPEND S (UNIT-SEQ X))))
      (REL!DOM S))
     (ALL (X$0)
      (IMPLIES
       (IN X$0
        (REL!DOM
         (REL!DOM-RESTRICT
          (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
          (APPEND S (UNIT-SEQ X)))))
       (=
        (FN!APPLY
         (REL!DOM-RESTRICT
          (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
          (APPEND S (UNIT-SEQ X)))
         X$0)
        (FN!APPLY S X$0))))))))
 (=
  (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD (APPEND S (UNIT-SEQ X))) 1))
   (APPEND S (UNIT-SEQ X)))
  S))
Which simplifies
 when rewriting with APPLY-APPEND, FN!APPLY-DOM-RESTRICT-FUNCTION,
RANGE.DEFINITION, SEQUENCE-DOM, SETRULES!INTER-SUBSET-RIGHT,
ELEM!RANGE-SUBSET-RANGE, DOM-APPEND, REL!DOM-DOM-RESTRICT,
FN!IS-FUNCTION-DOM-RESTRICT, IS-FUNCTION-APPEND, CARD-UNIT-SEQ, CARD-APPEND,
IS-SEQUENCE-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-FUNCTION-TAIL
Beginning proof of IS-FUNCTION-TAIL ...
(IMPLIES (IS-SEQUENCE S) (= (FN!IS-FUNCTION (TAIL S)) (TRUE)))
Invoking TAIL gives ...
(IMPLIES (IS-SEQUENCE S)
 (FN!IS-FUNCTION
  (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD S) 1))
   (REL!COMP (INTFN!ADD 1) S))))
Which simplifies
 when rewriting with FN!IS-FUNCTION-DOM-RESTRICT,
FN!IS-FUNCTION-COMP-FUNCTIONS, INTFN!IS-FUNCTION-ADD
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
DOM-TAIL
Beginning proof of DOM-TAIL ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (REL!DOM (TAIL S)) (RANGE 1 (- (FINITE!CARD S) 1))))
Which simplifies
 with invocation of TAIL, IS-SEQUENCE
 when rewriting with SETRULES!INTER-SUBSET-RIGHT, ELEM!RANGE-SUBSET-RANGE,
REL!DOM-DOM-RESTRICT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, FINITE!TYPE-OF-IS-FINITE,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
RAN-TAIL
Beginning proof of RAN-TAIL ...
(SUBSET (REL!RAN (TAIL S)) (REL!RAN S))
Invoking TAIL gives ...
(SUBSET
 (REL!RAN
  (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD S) 1))
   (REL!COMP (INTFN!ADD 1) S)))
 (REL!RAN S))
Which simplifies
 when rewriting with INTFN!IMAGE-ADD-RANGE, REL!IMAGE-COMP,
REL!RAN-DOM-RESTRICT to ...
(SUBSET (REL!IMAGE S (RANGE 2 (ORD (FINITE!CARD S)))) (REL!RAN S))
Assuming REL!IMAGE-SUBSET-RAN with the
instantiations: (= R S)
                (= X
                 (REL!IMAGE (INTFN!ADD 1)
                  (RANGE 1 (- (FINITE!CARD S) 1)))) generates
...
(IMPLIES
 (SUBSET
  (REL!IMAGE S (REL!IMAGE (INTFN!ADD 1) (RANGE 1 (- (FINITE!CARD S) 1))))
  (REL!RAN S))
 (SUBSET (REL!IMAGE S (RANGE 2 (ORD (FINITE!CARD S)))) (REL!RAN S)))
Which simplifies to ...
(IMPLIES
 (SUBSET
  (REL!IMAGE S (REL!IMAGE (INTFN!ADD 1) (RANGE 1 (+ -1 (FINITE!CARD S)))))
  (REL!RAN S))
 (SUBSET (REL!IMAGE S (RANGE 2 (ORD (FINITE!CARD S)))) (REL!RAN S)))
Which simplifies
 with invocation of SUBSET
 when rewriting with INTFN!IMAGE-ADD-RANGE to ...
(TRUE)
CARD-TAIL
Beginning proof of CARD-TAIL ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1)))
Assuming IS-SEQUENCE-SUBGOAL with the
instantiations: (= N (- (FINITE!CARD S) 1)) (= X (TAIL S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (TAIL S))
    (= (REL!DOM (TAIL S)) (RANGE 1 (- (FINITE!CARD S) 1))))
   (AND (IS-SEQUENCE (TAIL S))
    (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1)))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X S) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IMPLIES
   (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (TAIL S))
    (= (REL!DOM (TAIL S)) (RANGE 1 (- (FINITE!CARD S) 1))))
   (AND (IS-SEQUENCE (TAIL S))
    (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1)))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IMPLIES
   (AND (= (REL!DOM (TAIL S)) (RANGE 1 (- (FINITE!CARD S) 1)))
    (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (TAIL S)))
   (AND (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1))
    (IS-SEQUENCE (TAIL S)))))
 (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1)))
Which simplifies
 when rewriting with IS-FUNCTION-TAIL, NAT!IN-NAT, DOM-TAIL
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
IS-SEQUENCE-TAIL
Beginning proof of IS-SEQUENCE-TAIL ...
(IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (TAIL S)) (TRUE)))
Assuming IS-SEQUENCE-SUBGOAL with the
instantiations: (= N (- (FINITE!CARD S) 1)) (= X (TAIL S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (TAIL S))
    (= (REL!DOM (TAIL S)) (RANGE 1 (- (FINITE!CARD S) 1))))
   (AND (IS-SEQUENCE (TAIL S))
    (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1))))
  (IS-SEQUENCE S))
 (IS-SEQUENCE (TAIL S)))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X S) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IMPLIES
   (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (TAIL S))
    (= (REL!DOM (TAIL S)) (RANGE 1 (- (FINITE!CARD S) 1))))
   (AND (IS-SEQUENCE (TAIL S))
    (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1))))
  (IS-SEQUENCE S))
 (IS-SEQUENCE (TAIL S)))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S)
  (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IMPLIES
   (AND (= (REL!DOM (TAIL S)) (RANGE 1 (- (FINITE!CARD S) 1)))
    (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (TAIL S)))
   (AND (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1))
    (IS-SEQUENCE (TAIL S)))))
 (IS-SEQUENCE (TAIL S)))
Splitting on (= S (NULLSET)) generates ...
(IF (= S (NULLSET))
 (IMPLIES
  (AND (IS-SEQUENCE S)
   (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
   (IMPLIES
    (AND (= (REL!DOM (TAIL S)) (RANGE 1 (- (FINITE!CARD S) 1)))
     (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (TAIL S)))
    (AND (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1))
     (IS-SEQUENCE (TAIL S)))))
  (IS-SEQUENCE (TAIL S)))
 (IMPLIES
  (AND (IS-SEQUENCE S)
   (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
   (IMPLIES
    (AND (= (REL!DOM (TAIL S)) (RANGE 1 (- (FINITE!CARD S) 1)))
     (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (TAIL S)))
    (AND (= (FINITE!CARD (TAIL S)) (- (FINITE!CARD S) 1))
     (IS-SEQUENCE (TAIL S)))))
  (IS-SEQUENCE (TAIL S))))
Which simplifies
 when rewriting with CARD-TAIL, IS-FUNCTION-TAIL, DOM-TAIL, NAT!IN-NAT,
ELEM!NULL-RANGE, FINITE!CARD-NULLSET, FINITE!IS-FINITE-NULLSET,
IS-SEQUENCE-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, FINITE!TYPE-OF-IS-FINITE to ...
(IMPLIES (= S (NULLSET)) (IS-SEQUENCE (TAIL (NULLSET))))
Which simplifies
 with invocation of TAIL
 when rewriting with REL!DOM-RESTRICT-BY-SUPERSET-DOM, SUBSET.SELF,
SEQUENCE-DOM, IS-SEQUENCE-NULLSET, REL!IS-RELATION-NULLSET,
REL!COMP-NULLSET-RIGHT, ELEM!NULL-RANGE, FINITE!CARD-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions REL!IS-RELATION-BOOL to ...
(TRUE)
FINITE-TAIL
Beginning proof of FINITE-TAIL ...
(IMPLIES (IS-SEQUENCE S) (= (FINITE!IS-FINITE (TAIL S)) (TRUE)))
Assuming IS-SEQUENCE-TAIL with the instantiations: (= S S) generates ...
(IMPLIES
 (AND (IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (TAIL S)) (TRUE)))
  (IS-SEQUENCE S))
 (FINITE!IS-FINITE (TAIL S)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
APPLY-TAIL
Beginning proof of APPLY-TAIL ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))) (IN N (REL!DOM (TAIL S))))
 (= (FN!APPLY (TAIL S) N) (FN!APPLY S (+ N 1))))
Invoking TAIL gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IN N
   (REL!DOM
    (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD S) 1))
     (REL!COMP (INTFN!ADD 1) S)))))
 (=
  (FN!APPLY
   (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD S) 1))
    (REL!COMP (INTFN!ADD 1) S))
   N)
  (FN!APPLY S (+ N 1))))
Which simplifies
 when rewriting with FN!APPLY-COMP, INTFN!APPLY-ADD, INTFN!DOM-ADD,
FN!APPLY-DOM-RESTRICT-FUNCTION, FN!IS-FUNCTION-COMP-FUNCTIONS,
INTFN!IS-FUNCTION-ADD, RANGE.DEFINITION, SETRULES!INTER-SUBSET-RIGHT,
ELEM!RANGE-SUBSET-RANGE, REL!DOM-DOM-RESTRICT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2 to ...
(TRUE)
SEQ-HEAD-TAIL
Beginning proof of SEQ-HEAD-TAIL ...
(IMPLIES (IS-SEQUENCE S)
 (OR (= S (NULLSET)) (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))))
Assuming FN!FUNCTION-EXTENSIONALITY with the
instantiations: (= F S) (= G (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION S)
    (FN!IS-FUNCTION (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
   (= (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))
    (AND (= (REL!DOM S) (REL!DOM (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
     (ALL (X)
      (IMPLIES (IN X (REL!DOM S))
       (= (FN!APPLY S X)
        (FN!APPLY (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)) X)))))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IMPLIES
   (AND (FN!IS-FUNCTION S)
    (FN!IS-FUNCTION (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
   (= (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))
    (AND (= (REL!DOM S) (REL!DOM (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
     (ALL (X)
      (IMPLIES (IN X (REL!DOM S))
       (= (FN!APPLY S X)
        (FN!APPLY (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)) X))))))))
 (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
Invoking HEAD gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IMPLIES
   (AND (FN!IS-FUNCTION S)
    (FN!IS-FUNCTION (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S))))
   (= (= S (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S)))
    (AND (= (REL!DOM S) (REL!DOM (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S))))
     (ALL (X)
      (IMPLIES (IN X (REL!DOM S))
       (= (FN!APPLY S X)
        (FN!APPLY (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S)) X))))))))
 (= S (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S))))
Which simplifies
 when rewriting with APPLY-TAIL, DOM-TAIL, APPLY-UNIT-SEQ, APPLY-APPEND,
CARD-APPEND, RANGE.DEFINITION, CARD-TAIL, CARD-UNIT-SEQ, DOM-APPEND,
SEQUENCE-DOM, IS-FUNCTION-APPEND, IS-SEQUENCE-TAIL, IS-SEQUENCE-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-FUNCTION-FRONT
Beginning proof of IS-FUNCTION-FRONT ...
(IMPLIES (IS-SEQUENCE S) (= (FN!IS-FUNCTION (FRONT S)) (TRUE)))
Invoking FRONT gives ...
(IMPLIES (IS-SEQUENCE S)
 (FN!IS-FUNCTION (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD S) 1)) S)))
Which simplifies
 when rewriting with FN!IS-FUNCTION-DOM-RESTRICT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
DOM-FRONT
Beginning proof of DOM-FRONT ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1))))
Which simplifies
 with invocation of FRONT, IS-SEQUENCE
 when rewriting with SETRULES!INTER-SUBSET-RIGHT, ELEM!RANGE-SUBSET-RANGE,
REL!DOM-DOM-RESTRICT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, FINITE!TYPE-OF-IS-FINITE,
FN!IS-FUNCTION-BOOL to ...
(TRUE)
RAN-FRONT
Beginning proof of RAN-FRONT ...
(SUBSET (REL!RAN (FRONT S)) (REL!RAN S))
Invoking FRONT gives ...
(SUBSET (REL!RAN (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD S) 1)) S))
 (REL!RAN S))
Which simplifies
 when rewriting with REL!RAN-DOM-RESTRICT to ...
(SUBSET (REL!IMAGE S (RANGE 1 (+ -1 (FINITE!CARD S)))) (REL!RAN S))
Assuming REL!IMAGE-SUBSET-RAN with the
instantiations: (= R S) (= X (RANGE 1 (- (FINITE!CARD S) 1))) generates ...
(IMPLIES (SUBSET (REL!IMAGE S (RANGE 1 (- (FINITE!CARD S) 1))) (REL!RAN S))
 (SUBSET (REL!IMAGE S (RANGE 1 (+ -1 (FINITE!CARD S)))) (REL!RAN S)))
Which simplifies to ...
(TRUE)
CARD-FRONT
Beginning proof of CARD-FRONT ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1)))
Assuming IS-SEQUENCE-SUBGOAL with the
instantiations: (= N (- (FINITE!CARD S) 1)) (= X (FRONT S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (FRONT S))
    (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1))))
   (AND (IS-SEQUENCE (FRONT S))
    (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1)))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X S) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IMPLIES
   (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (FRONT S))
    (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1))))
   (AND (IS-SEQUENCE (FRONT S))
    (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1)))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IMPLIES
   (AND (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1)))
    (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (FRONT S)))
   (AND (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1))
    (IS-SEQUENCE (FRONT S)))))
 (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1)))
Which simplifies
 when rewriting with IS-FUNCTION-FRONT, NAT!IN-NAT, DOM-FRONT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
IS-SEQUENCE-FRONT
Beginning proof of IS-SEQUENCE-FRONT ...
(IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (FRONT S)) (TRUE)))
Assuming IS-SEQUENCE-SUBGOAL with the
instantiations: (= N (- (FINITE!CARD S) 1)) (= X (FRONT S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (FRONT S))
    (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1))))
   (AND (IS-SEQUENCE (FRONT S))
    (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1))))
  (IS-SEQUENCE S))
 (IS-SEQUENCE (FRONT S)))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X S) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IMPLIES
   (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (FRONT S))
    (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1))))
   (AND (IS-SEQUENCE (FRONT S))
    (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1))))
  (IS-SEQUENCE S))
 (IS-SEQUENCE (FRONT S)))
Splitting on (= S (NULLSET)) generates ...
(IF (= S (NULLSET))
 (IMPLIES
  (AND
   (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
   (IMPLIES
    (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (FRONT S))
     (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1))))
    (AND (IS-SEQUENCE (FRONT S))
     (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1))))
   (IS-SEQUENCE S))
  (IS-SEQUENCE (FRONT S)))
 (IMPLIES
  (AND
   (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
   (IMPLIES
    (AND (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (FRONT S))
     (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1))))
    (AND (IS-SEQUENCE (FRONT S))
     (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1))))
   (IS-SEQUENCE S))
  (IS-SEQUENCE (FRONT S))))
Rearranging gives ...
(IF (= S (NULLSET))
 (IMPLIES
  (AND (IS-SEQUENCE S)
   (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
   (IMPLIES
    (AND (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1)))
     (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (FRONT S)))
    (AND (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1))
     (IS-SEQUENCE (FRONT S)))))
  (IS-SEQUENCE (FRONT S)))
 (IMPLIES
  (AND (IS-SEQUENCE S)
   (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
   (IMPLIES
    (AND (= (REL!DOM (FRONT S)) (RANGE 1 (- (FINITE!CARD S) 1)))
     (IN (- (FINITE!CARD S) 1) (NAT!NAT)) (FN!IS-FUNCTION (FRONT S)))
    (AND (= (FINITE!CARD (FRONT S)) (- (FINITE!CARD S) 1))
     (IS-SEQUENCE (FRONT S)))))
  (IS-SEQUENCE (FRONT S))))
Which simplifies
 with invocation of IS-SEQUENCE, FRONT
 when rewriting with FN!IS-FUNCTION-DOM-RESTRICT, SETRULES!INTER-SUBSET-RIGHT,
ELEM!RANGE-SUBSET-RANGE, REL!DOM-DOM-RESTRICT, NAT!IN-NAT,
REL!DOM-RESTRICT-BY-SUPERSET-DOM, SUBSET.SELF, SEQUENCE-DOM,
REL!IS-RELATION-NULLSET, ELEM!NULL-RANGE, FINITE!CARD-NULLSET,
FINITE!IS-FINITE-NULLSET, IS-SEQUENCE-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, FN!IS-FUNCTION-BOOL, REL!IS-RELATION-BOOL,
FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
FINITE-FRONT
Beginning proof of FINITE-FRONT ...
(IMPLIES (IS-SEQUENCE S) (= (FINITE!IS-FINITE (FRONT S)) (TRUE)))
Assuming IS-SEQUENCE-FRONT with the instantiations: (= S S) generates ...
(IMPLIES
 (AND (IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (FRONT S)) (TRUE)))
  (IS-SEQUENCE S))
 (FINITE!IS-FINITE (FRONT S)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
APPLY-FRONT
Beginning proof of APPLY-FRONT ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))) (IN N (REL!DOM (FRONT S))))
 (= (FN!APPLY (FRONT S) N) (FN!APPLY S N)))
Invoking FRONT gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IN N (REL!DOM (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD S) 1)) S))))
 (= (FN!APPLY (REL!DOM-RESTRICT (RANGE 1 (- (FINITE!CARD S) 1)) S) N)
  (FN!APPLY S N)))
Which simplifies
 when rewriting with FN!APPLY-DOM-RESTRICT-FUNCTION, RANGE.DEFINITION,
SETRULES!INTER-SUBSET-RIGHT, ELEM!RANGE-SUBSET-RANGE, REL!DOM-DOM-RESTRICT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2 to ...
(TRUE)
SEQ-FRONT-LAST
Beginning proof of SEQ-FRONT-LAST ...
(IMPLIES (IS-SEQUENCE S)
 (OR (= S (NULLSET)) (= S (APPEND (FRONT S) (UNIT-SEQ (ZLAST S))))))
Assuming FN!FUNCTION-EXTENSIONALITY with the
instantiations: (= F S)
                (= G (APPEND (FRONT S) (UNIT-SEQ (ZLAST S)))) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION S)
    (FN!IS-FUNCTION (APPEND (FRONT S) (UNIT-SEQ (ZLAST S)))))
   (= (= S (APPEND (FRONT S) (UNIT-SEQ (ZLAST S))))
    (AND (= (REL!DOM S) (REL!DOM (APPEND (FRONT S) (UNIT-SEQ (ZLAST S)))))
     (ALL (X)
      (IMPLIES (IN X (REL!DOM S))
       (= (FN!APPLY S X)
        (FN!APPLY (APPEND (FRONT S) (UNIT-SEQ (ZLAST S))) X)))))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= S (APPEND (FRONT S) (UNIT-SEQ (ZLAST S)))))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IMPLIES
   (AND (FN!IS-FUNCTION S)
    (FN!IS-FUNCTION (APPEND (FRONT S) (UNIT-SEQ (ZLAST S)))))
   (= (= S (APPEND (FRONT S) (UNIT-SEQ (ZLAST S))))
    (AND (= (REL!DOM S) (REL!DOM (APPEND (FRONT S) (UNIT-SEQ (ZLAST S)))))
     (ALL (X)
      (IMPLIES (IN X (REL!DOM S))
       (= (FN!APPLY S X)
        (FN!APPLY (APPEND (FRONT S) (UNIT-SEQ (ZLAST S))) X))))))))
 (= S (APPEND (FRONT S) (UNIT-SEQ (ZLAST S)))))
Invoking ZLAST gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IMPLIES
   (AND (FN!IS-FUNCTION S)
    (FN!IS-FUNCTION
     (APPEND (FRONT S) (UNIT-SEQ (FN!APPLY S (FINITE!CARD S))))))
   (= (= S (APPEND (FRONT S) (UNIT-SEQ (FN!APPLY S (FINITE!CARD S)))))
    (AND
     (= (REL!DOM S)
      (REL!DOM (APPEND (FRONT S) (UNIT-SEQ (FN!APPLY S (FINITE!CARD S))))))
     (ALL (X)
      (IMPLIES (IN X (REL!DOM S))
       (= (FN!APPLY S X)
        (FN!APPLY (APPEND (FRONT S) (UNIT-SEQ (FN!APPLY S (FINITE!CARD S))))
         X))))))))
 (= S (APPEND (FRONT S) (UNIT-SEQ (FN!APPLY S (FINITE!CARD S))))))
Which simplifies
 when rewriting with APPLY-UNIT-SEQ, APPLY-FRONT, DOM-FRONT, APPLY-APPEND,
CARD-APPEND, RANGE.DEFINITION, CARD-UNIT-SEQ, CARD-FRONT, DOM-APPEND,
SEQUENCE-DOM, IS-FUNCTION-APPEND, IS-SEQUENCE-UNIT-SEQ, IS-SEQUENCE-FRONT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
FRONT-NULLSET
Beginning proof of FRONT-NULLSET ...
(= (FRONT (NULLSET)) (NULLSET))
Which simplifies
 with invocation of FRONT
 when rewriting with REL!DOM-RESTRICT-BY-SUPERSET-DOM, SUBSET.SELF,
SEQUENCE-DOM, IS-SEQUENCE-NULLSET, REL!IS-RELATION-NULLSET, ELEM!NULL-RANGE,
FINITE!CARD-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions REL!IS-RELATION-BOOL to ...
(TRUE)
TAIL-NULLSET
Beginning proof of TAIL-NULLSET ...
(= (TAIL (NULLSET)) (NULLSET))
Which simplifies
 with invocation of TAIL
 when rewriting with REL!DOM-RESTRICT-BY-SUPERSET-DOM, SUBSET.SELF,
SEQUENCE-DOM, IS-SEQUENCE-NULLSET, REL!IS-RELATION-NULLSET,
REL!COMP-NULLSET-RIGHT, ELEM!NULL-RANGE, FINITE!CARD-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions REL!IS-RELATION-BOOL to ...
(TRUE)
REVERSE
IS-FUNCTION-REVERSE
Beginning proof of IS-FUNCTION-REVERSE ...
(IMPLIES (IS-SEQUENCE S) (= (FN!IS-FUNCTION (REVERSE S)) (TRUE)))
Invoking REVERSE gives ...
(IMPLIES (IS-SEQUENCE S)
 (FN!IS-FUNCTION
  (REL!COMP (INTFN!MULTIPLY-BY -1)
   (REL!COMP (INTFN!ADD (+ (FINITE!CARD S) 1)) S))))
Which simplifies
 when rewriting with FN!IS-FUNCTION-COMP-FUNCTIONS, INTFN!IS-FUNCTION-ADD,
INTFN!IS-FUNCTION-MULTIPLY-BY
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
DOM-REVERSE
Beginning proof of DOM-REVERSE ...
(IMPLIES (IS-SEQUENCE S) (= (REL!DOM (REVERSE S)) (REL!DOM S)))
Invoking REVERSE gives ...
(IMPLIES (IS-SEQUENCE S)
 (=
  (REL!DOM
   (REL!COMP (INTFN!MULTIPLY-BY -1)
    (REL!COMP (INTFN!ADD (+ (FINITE!CARD S) 1)) S)))
  (REL!DOM S)))
Which simplifies
 when rewriting with INTFN!MULTIPLES-OF--1,
INTFN!IMAGE-MULTIPLY-NEGATIVE-RANGE, INTFN!IMAGE-ADD-RANGE, SEQUENCE-DOM,
INTFN!INVERSE-ADD, INTFN!INVERSE-MULTIPLY-BY--1, REL!DOM-COMP
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2, SUCC.INT, REL!INVERSE-INVERSE to ...
(IMPLIES (IS-SEQUENCE S)
 (= (INTER (INT) (RANGE 1 (FINITE!CARD S))) (RANGE 1 (FINITE!CARD S))))
Applying SETRULES!EXTENSIONALITY gives ...
(IMPLIES (IS-SEQUENCE S)
 (ALL (E)
  (IF (IN E (INTER (INT) (RANGE 1 (FINITE!CARD S))))
   (IN E (RANGE 1 (FINITE!CARD S))) (NOT (IN E (RANGE 1 (FINITE!CARD S)))))))
Which simplifies
 when rewriting with RANGE.DEFINITION, INTER.DEFINITION
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2 to ...
(TRUE)
RAN-REVERSE
Beginning proof of RAN-REVERSE ...
(IMPLIES (IS-SEQUENCE S) (= (REL!RAN (REVERSE S)) (REL!RAN S)))
Which simplifies
 with invocation of SUBSET, REVERSE
 when rewriting with RANGE.DEFINITION, SEQUENCE-DOM, INTFN!RAN-ADD,
REL!IMAGE-OF-SUPERSET-OF-DOM, SUBSET.SELF, INTFN!DOM-ADD, REL!IMAGE-COMP,
INTFN!MULTIPLES-OF--1, INTFN!RAN-MULTIPLY-BY, REL!RAN-COMP
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
IS-SEQUENCE-REVERSE
Beginning proof of IS-SEQUENCE-REVERSE ...
(IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (REVERSE S)) (TRUE)))
Assuming IS-SEQUENCE-SUBGOAL with the
instantiations: (= X (REVERSE S)) (= N (FINITE!CARD S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (FINITE!CARD S) (NAT!NAT)) (FN!IS-FUNCTION (REVERSE S))
    (= (REL!DOM (REVERSE S)) (RANGE 1 (FINITE!CARD S))))
   (AND (IS-SEQUENCE (REVERSE S))
    (= (FINITE!CARD (REVERSE S)) (FINITE!CARD S))))
  (IS-SEQUENCE S))
 (IS-SEQUENCE (REVERSE S)))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S)
  (IMPLIES
   (AND (= (REL!DOM (REVERSE S)) (RANGE 1 (FINITE!CARD S)))
    (IN (FINITE!CARD S) (NAT!NAT)) (FN!IS-FUNCTION (REVERSE S)))
   (AND (= (FINITE!CARD (REVERSE S)) (FINITE!CARD S))
    (IS-SEQUENCE (REVERSE S)))))
 (IS-SEQUENCE (REVERSE S)))
Which simplifies
 when rewriting with IS-FUNCTION-REVERSE, NAT!IN-NAT, SEQUENCE-DOM, DOM-REVERSE
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
FINITE-REVERSE
Beginning proof of FINITE-REVERSE ...
(IMPLIES (IS-SEQUENCE S) (= (FINITE!IS-FINITE (REVERSE S)) (TRUE)))
Assuming IS-SEQUENCE-REVERSE with the instantiations: (= S S) generates ...
(IMPLIES
 (AND (IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (REVERSE S)) (TRUE)))
  (IS-SEQUENCE S))
 (FINITE!IS-FINITE (REVERSE S)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
CARD-REVERSE
Beginning proof of CARD-REVERSE ...
(IMPLIES (IS-SEQUENCE S) (= (FINITE!CARD (REVERSE S)) (FINITE!CARD S)))
Assuming IS-SEQUENCE-SUBGOAL with the
instantiations: (= X (REVERSE S)) (= N (FINITE!CARD S)) generates ...
(IMPLIES
 (AND
  (IMPLIES
   (AND (IN (FINITE!CARD S) (NAT!NAT)) (FN!IS-FUNCTION (REVERSE S))
    (= (REL!DOM (REVERSE S)) (RANGE 1 (FINITE!CARD S))))
   (AND (IS-SEQUENCE (REVERSE S))
    (= (FINITE!CARD (REVERSE S)) (FINITE!CARD S))))
  (IS-SEQUENCE S))
 (= (FINITE!CARD (REVERSE S)) (FINITE!CARD S)))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S)
  (IMPLIES
   (AND (= (REL!DOM (REVERSE S)) (RANGE 1 (FINITE!CARD S)))
    (IN (FINITE!CARD S) (NAT!NAT)) (FN!IS-FUNCTION (REVERSE S)))
   (AND (= (FINITE!CARD (REVERSE S)) (FINITE!CARD S))
    (IS-SEQUENCE (REVERSE S)))))
 (= (FINITE!CARD (REVERSE S)) (FINITE!CARD S)))
Which simplifies
 when rewriting with IS-SEQUENCE-REVERSE, IS-FUNCTION-REVERSE, NAT!IN-NAT,
SEQUENCE-DOM, DOM-REVERSE
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
REVERSE-NULLSET
Beginning proof of REVERSE-NULLSET ...
(= (REVERSE (NULLSET)) (NULLSET))
Which simplifies
 with invocation of REVERSE
 when rewriting with REL!COMP-NULLSET-RIGHT, FINITE!CARD-NULLSET to ...
(TRUE)
APPLY-REVERSE
Beginning proof of APPLY-REVERSE ...
(IMPLIES (AND (IS-SEQUENCE S) (IN N (RANGE 1 (FINITE!CARD S))))
 (= (FN!APPLY (REVERSE S) N) (FN!APPLY S (- (+ 1 (FINITE!CARD S)) N))))
Invoking REVERSE gives ...
(IMPLIES (AND (IS-SEQUENCE S) (IN N (RANGE 1 (FINITE!CARD S))))
 (=
  (FN!APPLY
   (REL!COMP (INTFN!MULTIPLY-BY -1)
    (REL!COMP (INTFN!ADD (+ (FINITE!CARD S) 1)) S))
   N)
  (FN!APPLY S (- (+ 1 (FINITE!CARD S)) N))))
Which simplifies
 when rewriting with INTFN!APPLY-ADD, INTFN!DOM-ADD, FN!APPLY-COMP,
INTFN!IMAGE-ADD-RANGE, SEQUENCE-DOM, INTFN!INVERSE-ADD, REL!DOM-COMP,
INTFN!APPLY-MULTIPLY-BY, INTFN!DOM-MULTIPLY-BY, FN!IS-FUNCTION-COMP-FUNCTIONS,
INTFN!IS-FUNCTION-ADD, INTFN!IS-FUNCTION-MULTIPLY-BY, RANGE.DEFINITION
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions REL!INVERSE-INVERSE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
REVERSE-UNIT
Beginning proof of REVERSE-UNIT ...
(= (REVERSE (UNIT-SEQ X)) (UNIT-SEQ X))
Applying FN!FUNCTION-EXTENSIONALITY gives ...
(IF
 (AND (FN!IS-FUNCTION (REVERSE (UNIT-SEQ X))) (FN!IS-FUNCTION (UNIT-SEQ X)))
 (AND (= (REL!DOM (REVERSE (UNIT-SEQ X))) (REL!DOM (UNIT-SEQ X)))
  (ALL (X$0)
   (IMPLIES (IN X$0 (REL!DOM (REVERSE (UNIT-SEQ X))))
    (= (FN!APPLY (REVERSE (UNIT-SEQ X)) X$0) (FN!APPLY (UNIT-SEQ X) X$0)))))
 (= (REVERSE (UNIT-SEQ X)) (UNIT-SEQ X)))
Which simplifies
 when rewriting with APPLY-UNIT-SEQ, APPLY-REVERSE, ELEM!SINGLETON-RANGE,
CARD-UNIT-SEQ, NULLSET.DEFINITION, SETADD.DEFINITION, SETRULES!UNIT-TO-SETADD,
DOM-UNIT-SEQ, DOM-REVERSE, IS-FUNCTION-UNIT-SEQ, IS-FUNCTION-REVERSE,
IS-SEQUENCE-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
IS-SEQUENCE-FACTS, FN!FUNCTION-IS-RELATION
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
REVERSE-APPEND
Beginning proof of REVERSE-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (REVERSE (APPEND X Y)) (APPEND (REVERSE Y) (REVERSE X))))
Applying FN!FUNCTION-EXTENSIONALITY gives ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (IF
  (AND (FN!IS-FUNCTION (REVERSE (APPEND X Y)))
   (FN!IS-FUNCTION (APPEND (REVERSE Y) (REVERSE X))))
  (AND
   (= (REL!DOM (REVERSE (APPEND X Y)))
    (REL!DOM (APPEND (REVERSE Y) (REVERSE X))))
   (ALL (X$0)
    (IMPLIES (IN X$0 (REL!DOM (REVERSE (APPEND X Y))))
     (= (FN!APPLY (REVERSE (APPEND X Y)) X$0)
      (FN!APPLY (APPEND (REVERSE Y) (REVERSE X)) X$0)))))
  (= (REVERSE (APPEND X Y)) (APPEND (REVERSE Y) (REVERSE X)))))
Which simplifies
 when rewriting with APPLY-APPEND, APPLY-REVERSE, CARD-APPEND,
RANGE.DEFINITION, CARD-REVERSE, DOM-APPEND, DOM-REVERSE, IS-FUNCTION-APPEND,
IS-SEQUENCE-REVERSE, IS-FUNCTION-REVERSE, IS-SEQUENCE-APPEND
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
HEAD-REVERSE
Beginning proof of HEAD-REVERSE ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (HEAD (REVERSE S)) (ZLAST S)))
Invoking HEAD gives ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (FN!APPLY (REVERSE S) 1) (ZLAST S)))
Invoking ZLAST gives ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (FN!APPLY (REVERSE S) 1) (FN!APPLY S (FINITE!CARD S))))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X S) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (FN!APPLY (REVERSE S) 1) (FN!APPLY S (FINITE!CARD S))))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET)))))
 (= (FN!APPLY (REVERSE S) 1) (FN!APPLY S (FINITE!CARD S))))
Which simplifies
 when rewriting with APPLY-REVERSE, RANGE.DEFINITION
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
REVERSE-REVERSE
Beginning proof of REVERSE-REVERSE ...
(IMPLIES (IS-SEQUENCE S) (= (REVERSE (REVERSE S)) S))
Applying FN!FUNCTION-EXTENSIONALITY gives ...
(IMPLIES (IS-SEQUENCE S)
 (IF (AND (FN!IS-FUNCTION (REVERSE (REVERSE S))) (FN!IS-FUNCTION S))
  (AND (= (REL!DOM (REVERSE (REVERSE S))) (REL!DOM S))
   (ALL (X)
    (IMPLIES (IN X (REL!DOM (REVERSE (REVERSE S))))
     (= (FN!APPLY (REVERSE (REVERSE S)) X) (FN!APPLY S X)))))
  (= (REVERSE (REVERSE S)) S)))
Which simplifies
 when rewriting with APPLY-REVERSE, CARD-REVERSE, RANGE.DEFINITION,
SEQUENCE-DOM, DOM-REVERSE, IS-FUNCTION-REVERSE, IS-SEQUENCE-REVERSE
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
LAST-REVERSE
Beginning proof of LAST-REVERSE ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (ZLAST (REVERSE S)) (HEAD S)))
Assuming HEAD-REVERSE with the instantiations: (= S (REVERSE S)) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (IS-SEQUENCE (REVERSE S)) (NOT (= (REVERSE S) (NULLSET))))
   (= (HEAD (REVERSE (REVERSE S))) (ZLAST (REVERSE S))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (= (ZLAST (REVERSE S)) (HEAD S)))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (IMPLIES (AND (IS-SEQUENCE (REVERSE S)) (NOT (= (REVERSE S) (NULLSET))))
   (= (HEAD (REVERSE (REVERSE S))) (ZLAST (REVERSE S)))))
 (= (ZLAST (REVERSE S)) (HEAD S)))
Which simplifies
 when rewriting with REVERSE-REVERSE, IS-SEQUENCE-REVERSE
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))) (= (REVERSE S) (NULLSET)))
 (= (ZLAST (NULLSET)) (HEAD S)))
Assuming REVERSE-REVERSE with the instantiations: (= S S) generates ...
(IMPLIES
 (AND (IMPLIES (IS-SEQUENCE S) (= (REVERSE (REVERSE S)) S)) (IS-SEQUENCE S)
  (NOT (= S (NULLSET))) (= (REVERSE S) (NULLSET)))
 (= (ZLAST (NULLSET)) (HEAD S)))
Assuming REVERSE-NULLSET generates ...
(IMPLIES
 (AND (= (REVERSE (NULLSET)) (NULLSET))
  (IMPLIES (IS-SEQUENCE S) (= (REVERSE (REVERSE S)) S)) (IS-SEQUENCE S)
  (NOT (= S (NULLSET))) (= (REVERSE S) (NULLSET)))
 (= (ZLAST (NULLSET)) (HEAD S)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
REVERSE-FRONT
Beginning proof of REVERSE-FRONT ...
(IMPLIES (IS-SEQUENCE S) (= (REVERSE (FRONT S)) (TAIL (REVERSE S))))
Applying FN!FUNCTION-EXTENSIONALITY gives ...
(IMPLIES (IS-SEQUENCE S)
 (IF
  (AND (FN!IS-FUNCTION (REVERSE (FRONT S)))
   (FN!IS-FUNCTION (TAIL (REVERSE S))))
  (AND (= (REL!DOM (REVERSE (FRONT S))) (REL!DOM (TAIL (REVERSE S))))
   (ALL (X)
    (IMPLIES (IN X (REL!DOM (REVERSE (FRONT S))))
     (= (FN!APPLY (REVERSE (FRONT S)) X) (FN!APPLY (TAIL (REVERSE S)) X)))))
  (= (REVERSE (FRONT S)) (TAIL (REVERSE S)))))
Splitting on (OR (= S (NULLSET)) (= (REVERSE S) (NULLSET))) generates ...
(IF (OR (= S (NULLSET)) (= (REVERSE S) (NULLSET)))
 (IMPLIES (IS-SEQUENCE S)
  (IF
   (AND (FN!IS-FUNCTION (REVERSE (FRONT S)))
    (FN!IS-FUNCTION (TAIL (REVERSE S))))
   (AND (= (REL!DOM (REVERSE (FRONT S))) (REL!DOM (TAIL (REVERSE S))))
    (ALL (X)
     (IMPLIES (IN X (REL!DOM (REVERSE (FRONT S))))
      (= (FN!APPLY (REVERSE (FRONT S)) X) (FN!APPLY (TAIL (REVERSE S)) X)))))
   (= (REVERSE (FRONT S)) (TAIL (REVERSE S)))))
 (IMPLIES (IS-SEQUENCE S)
  (IF
   (AND (FN!IS-FUNCTION (REVERSE (FRONT S)))
    (FN!IS-FUNCTION (TAIL (REVERSE S))))
   (AND (= (REL!DOM (REVERSE (FRONT S))) (REL!DOM (TAIL (REVERSE S))))
    (ALL (X$0)
     (IMPLIES (IN X$0 (REL!DOM (REVERSE (FRONT S))))
      (= (FN!APPLY (REVERSE (FRONT S)) X$0)
       (FN!APPLY (TAIL (REVERSE S)) X$0)))))
   (= (REVERSE (FRONT S)) (TAIL (REVERSE S))))))
Which simplifies
 when rewriting with REVERSE-NULLSET, FRONT-NULLSET, APPLY-TAIL, APPLY-FRONT,
APPLY-REVERSE, CARD-FRONT, RANGE.DEFINITION, CARD-REVERSE, DOM-TAIL,
IS-FUNCTION-TAIL, IS-SEQUENCE-REVERSE, NULLSET.DEFINITION, ELEM!NULL-RANGE,
FINITE!CARD-NULLSET, SEQUENCE-DOM, IS-SEQUENCE-NULLSET, DOM-FRONT,
DOM-REVERSE, FN!IS-FUNCTION-NULLSET, TAIL-NULLSET, IS-FUNCTION-REVERSE,
IS-SEQUENCE-FRONT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(IMPLIES (AND (NOT (= S (NULLSET))) (= (REVERSE S) (NULLSET)) (IS-SEQUENCE S))
 (= (RANGE 1 (+ -1 (FINITE!CARD S))) (NULLSET)))
Assuming REVERSE-REVERSE with the instantiations: (= S S) generates ...
(IMPLIES
 (AND (IMPLIES (IS-SEQUENCE S) (= (REVERSE (REVERSE S)) S))
  (NOT (= S (NULLSET))) (= (REVERSE S) (NULLSET)) (IS-SEQUENCE S))
 (= (RANGE 1 (+ -1 (FINITE!CARD S))) (NULLSET)))
Assuming REVERSE-NULLSET generates ...
(IMPLIES
 (AND (= (REVERSE (NULLSET)) (NULLSET))
  (IMPLIES (IS-SEQUENCE S) (= (REVERSE (REVERSE S)) S)) (NOT (= S (NULLSET)))
  (= (REVERSE S) (NULLSET)) (IS-SEQUENCE S))
 (= (RANGE 1 (+ -1 (FINITE!CARD S))) (NULLSET)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
REVERSE-TAIL
Beginning proof of REVERSE-TAIL ...
(IMPLIES (IS-SEQUENCE S) (= (REVERSE (TAIL S)) (FRONT (REVERSE S))))
Assuming REVERSE-REVERSE with the
instantiations: (= S (FRONT (REVERSE S))) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-SEQUENCE (FRONT (REVERSE S)))
   (= (REVERSE (REVERSE (FRONT (REVERSE S)))) (FRONT (REVERSE S))))
  (IS-SEQUENCE S))
 (= (REVERSE (TAIL S)) (FRONT (REVERSE S))))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE S)
  (IMPLIES (IS-SEQUENCE (FRONT (REVERSE S)))
   (= (REVERSE (REVERSE (FRONT (REVERSE S)))) (FRONT (REVERSE S)))))
 (= (REVERSE (TAIL S)) (FRONT (REVERSE S))))
Which simplifies
 when rewriting with REVERSE-REVERSE, REVERSE-FRONT, IS-SEQUENCE-FRONT,
IS-SEQUENCE-REVERSE
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
FILTER
Beginning proof of FILTER ...
(IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (TRUE)
 (M< (FINITE!CARD (TAIL S)) (FINITE!CARD S)))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X S) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))))
 (M< (FINITE!CARD (TAIL S)) (FINITE!CARD S)))
Which simplifies
 when rewriting with M<.NAT, CARD-TAIL
 forward chaining using FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS,
>=.SAME.TYPE, FINITE!FINITE-CARD-NAT
 with the assumptions SUCC.INT, FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
IS-SEQUENCE-FILTER
Beginning proof of IS-SEQUENCE-FILTER ...
(IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (FILTER S X)) (TRUE)))
Inducting using the following scheme ...
 (AND (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
    (*P* (TAIL S) X))
   (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
    (*P* (TAIL S) X))
   (*P* S X)))
 produces ...
(AND
 (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))
  (IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (FILTER S X)) (TRUE))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (IS-SEQUENCE (FILTER (TAIL S) X)) (TRUE))))
  (IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (FILTER S X)) (TRUE))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (IS-SEQUENCE (FILTER (TAIL S) X)) (TRUE))))
  (IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (FILTER S X)) (TRUE)))))
Which simplifies
 when rewriting with IS-SEQUENCE-TAIL
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES (IS-SEQUENCE S)
 (IF (= S (NULLSET)) (IS-SEQUENCE (FILTER (NULLSET) X))
  (IMPLIES (IS-SEQUENCE (FILTER (TAIL S) X)) (IS-SEQUENCE (FILTER S X)))))
Invoking (FILTER S X) gives ...
(IMPLIES (IS-SEQUENCE S)
 (IF (= S (NULLSET)) (IS-SEQUENCE (FILTER (NULLSET) X))
  (IMPLIES (IS-SEQUENCE (FILTER (TAIL S) X))
   (IS-SEQUENCE
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X)))))))
Which simplifies
 when rewriting with IS-SEQUENCE-APPEND, IS-SEQUENCE-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES (AND (IS-SEQUENCE S) (= S (NULLSET)))
 (IS-SEQUENCE (FILTER (NULLSET) X)))
Which simplifies
 with invocation of FILTER, IS-SEQUENCE
 when rewriting with IS-SEQUENCE-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE, FN!IS-FUNCTION-BOOL to ...
(TRUE)
IS-FUNCTION-FILTER
Beginning proof of IS-FUNCTION-FILTER ...
(IMPLIES (IS-SEQUENCE S) (= (FN!IS-FUNCTION (FILTER S X)) (TRUE)))
Assuming IS-SEQUENCE-FILTER with the instantiations: (= S S) (= X X) generates
...
(IMPLIES
 (AND (IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (FILTER S X)) (TRUE)))
  (IS-SEQUENCE S))
 (FN!IS-FUNCTION (FILTER S X)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL to ...
(TRUE)
RAN-FILTER
Beginning proof of RAN-FILTER ...
(IMPLIES (IS-SEQUENCE S) (= (REL!RAN (FILTER S X)) (INTER (REL!RAN S) X)))
Inducting using the following scheme ...
 (AND (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
    (*P* (TAIL S) X))
   (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
    (*P* (TAIL S) X))
   (*P* S X)))
 produces ...
(AND
 (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))
  (IMPLIES (IS-SEQUENCE S) (= (REL!RAN (FILTER S X)) (INTER (REL!RAN S) X))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (REL!RAN (FILTER (TAIL S) X)) (INTER (REL!RAN (TAIL S)) X))))
  (IMPLIES (IS-SEQUENCE S) (= (REL!RAN (FILTER S X)) (INTER (REL!RAN S) X))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (REL!RAN (FILTER (TAIL S) X)) (INTER (REL!RAN (TAIL S)) X))))
  (IMPLIES (IS-SEQUENCE S) (= (REL!RAN (FILTER S X)) (INTER (REL!RAN S) X)))))
Invoking (FILTER S X) gives ...
(AND
 (IMPLIES (AND (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (IS-SEQUENCE S))
  (=
   (REL!RAN
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X))))
   (INTER (REL!RAN S) X)))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (REL!RAN (FILTER (TAIL S) X)) (INTER (REL!RAN (TAIL S)) X)))
   (IS-SEQUENCE S))
  (=
   (REL!RAN
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X))))
   (INTER (REL!RAN S) X)))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (REL!RAN (FILTER (TAIL S) X)) (INTER (REL!RAN (TAIL S)) X)))
   (IS-SEQUENCE S))
  (=
   (REL!RAN
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X))))
   (INTER (REL!RAN S) X))))
Which simplifies
 when rewriting with SETRULES!UNION-SUBSET-RIGHT, SETRULES!SETADD-UNION-LEFT,
SETRULES!UNIT-TO-SETADD, RAN-UNIT-SEQ, RAN-APPEND, IS-SEQUENCE-FILTER,
IS-SEQUENCE-UNIT-SEQ, INTER.COMMUTATIVE, IS-SEQUENCE-TAIL,
SETRULES!INTER-SUBSET-RIGHT, SUBSET.NULLSET.LEFT, REL!RAN-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2 to ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (IF (IN (HEAD S) X)
  (IMPLIES (= (REL!RAN (FILTER (TAIL S) X)) (INTER X (REL!RAN (TAIL S))))
   (= (SETADD (HEAD S) (REL!RAN (FILTER (TAIL S) X))) (INTER X (REL!RAN S))))
  (IMPLIES (= (REL!RAN (FILTER (TAIL S) X)) (INTER X (REL!RAN (TAIL S))))
   (= (REL!RAN (FILTER (TAIL S) X)) (INTER X (REL!RAN S))))))
Assuming SEQ-HEAD-TAIL with the instantiations: (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-SEQUENCE S)
   (OR (= S (NULLSET)) (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (IF (IN (HEAD S) X)
  (IMPLIES (= (REL!RAN (FILTER (TAIL S) X)) (INTER X (REL!RAN (TAIL S))))
   (= (SETADD (HEAD S) (REL!RAN (FILTER (TAIL S) X))) (INTER X (REL!RAN S))))
  (IMPLIES (= (REL!RAN (FILTER (TAIL S) X)) (INTER X (REL!RAN (TAIL S))))
   (= (REL!RAN (FILTER (TAIL S) X)) (INTER X (REL!RAN S))))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2 to ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
 (IF (IN (HEAD S) X)
  (IMPLIES (= (REL!RAN (FILTER (TAIL S) X)) (INTER X (REL!RAN (TAIL S))))
   (= (SETADD (HEAD S) (REL!RAN (FILTER (TAIL S) X))) (INTER X (REL!RAN S))))
  (IMPLIES (= (REL!RAN (FILTER (TAIL S) X)) (INTER X (REL!RAN (TAIL S))))
   (= (REL!RAN (FILTER (TAIL S) X)) (INTER X (REL!RAN S))))))
Substituting (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) produces ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
 (IF (IN (HEAD (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X)
  (IMPLIES
   (= (REL!RAN (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X))
    (INTER X (REL!RAN (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))))
   (=
    (SETADD (HEAD (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))
     (REL!RAN (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X)))
    (INTER X (REL!RAN (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))))
  (IMPLIES
   (= (REL!RAN (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X))
    (INTER X (REL!RAN (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))))
   (= (REL!RAN (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X))
    (INTER X (REL!RAN (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))))))
Applying RAN-APPEND gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
 (IF (IN (HEAD (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X)
  (IMPLIES
   (= (REL!RAN (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X))
    (INTER X (REL!RAN (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))))
   (=
    (SETADD (HEAD (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))
     (REL!RAN (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X)))
    (INTER X
     (IF (AND (IS-SEQUENCE (UNIT-SEQ (HEAD S))) (IS-SEQUENCE (TAIL S)))
      (UNION (REL!RAN (UNIT-SEQ (HEAD S))) (REL!RAN (TAIL S)))
      (REL!RAN (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))))))
  (IMPLIES
   (= (REL!RAN (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X))
    (INTER X (REL!RAN (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))))
   (= (REL!RAN (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X))
    (INTER X
     (IF (AND (IS-SEQUENCE (UNIT-SEQ (HEAD S))) (IS-SEQUENCE (TAIL S)))
      (UNION (REL!RAN (UNIT-SEQ (HEAD S))) (REL!RAN (TAIL S)))
      (REL!RAN (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))))))))
Which simplifies
 when rewriting with SETRULES!SETADD-INTER-RIGHT-NONMEMBER,
SETRULES!SETADD-INTER-RIGHT-MEMBER, SETRULES!UNION-SUBSET-RIGHT,
SUBSET.NULLSET.LEFT, SETRULES!SETADD-UNION-LEFT, SETRULES!UNIT-TO-SETADD,
RAN-UNIT-SEQ, IS-SEQUENCE-TAIL, IS-SEQUENCE-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-UNION-RELATION-1,
SETRULES!SUBSET-UNION-RELATION-2, SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2 to ...
(TRUE)
FINITE-FILTER
Beginning proof of FINITE-FILTER ...
(IMPLIES (IS-SEQUENCE S) (= (FINITE!IS-FINITE (FILTER S X)) (TRUE)))
Assuming IS-SEQUENCE-FILTER with the instantiations: (= S S) (= X X) generates
...
(IMPLIES
 (AND (IMPLIES (IS-SEQUENCE S) (= (IS-SEQUENCE (FILTER S X)) (TRUE)))
  (IS-SEQUENCE S))
 (FINITE!IS-FINITE (FILTER S X)))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
FILTER-BY-SUPERSET-RAN
Beginning proof of FILTER-BY-SUPERSET-RAN ...
(IMPLIES (AND (IS-SEQUENCE S) (SUBSET (REL!RAN S) X)) (= (FILTER S X) S))
Inducting using the following scheme ...
 (AND (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
    (*P* (TAIL S) X))
   (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
    (*P* (TAIL S) X))
   (*P* S X)))
 produces ...
(AND
 (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))
  (IMPLIES (AND (IS-SEQUENCE S) (SUBSET (REL!RAN S) X)) (= (FILTER S X) S)))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (AND (IS-SEQUENCE (TAIL S)) (SUBSET (REL!RAN (TAIL S)) X))
    (= (FILTER (TAIL S) X) (TAIL S))))
  (IMPLIES (AND (IS-SEQUENCE S) (SUBSET (REL!RAN S) X)) (= (FILTER S X) S)))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (AND (IS-SEQUENCE (TAIL S)) (SUBSET (REL!RAN (TAIL S)) X))
    (= (FILTER (TAIL S) X) (TAIL S))))
  (IMPLIES (AND (IS-SEQUENCE S) (SUBSET (REL!RAN S) X)) (= (FILTER S X) S))))
Invoking (FILTER S X) gives ...
(AND
 (IMPLIES
  (AND (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (IS-SEQUENCE S)
   (SUBSET (REL!RAN S) X))
  (=
   (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
    (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
     (FILTER (TAIL S) X)))
   S))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (AND (IS-SEQUENCE (TAIL S)) (SUBSET (REL!RAN (TAIL S)) X))
    (= (FILTER (TAIL S) X) (TAIL S)))
   (IS-SEQUENCE S) (SUBSET (REL!RAN S) X))
  (=
   (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
    (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
     (FILTER (TAIL S) X)))
   S))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (AND (IS-SEQUENCE (TAIL S)) (SUBSET (REL!RAN (TAIL S)) X))
    (= (FILTER (TAIL S) X) (TAIL S)))
   (IS-SEQUENCE S) (SUBSET (REL!RAN S) X))
  (=
   (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
    (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
     (FILTER (TAIL S) X)))
   S)))
Assuming RAN-TAIL with the instantiations: (= S S) generates ...
(IMPLIES (SUBSET (REL!RAN (TAIL S)) (REL!RAN S))
 (AND
  (IMPLIES
   (AND (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (IS-SEQUENCE S)
    (SUBSET (REL!RAN S) X))
   (=
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X)))
    S))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
    (IMPLIES (AND (IS-SEQUENCE (TAIL S)) (SUBSET (REL!RAN (TAIL S)) X))
     (= (FILTER (TAIL S) X) (TAIL S)))
    (IS-SEQUENCE S) (SUBSET (REL!RAN S) X))
   (=
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X)))
    S))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
    (IMPLIES (AND (IS-SEQUENCE (TAIL S)) (SUBSET (REL!RAN (TAIL S)) X))
     (= (FILTER (TAIL S) X) (TAIL S)))
    (IS-SEQUENCE S) (SUBSET (REL!RAN S) X))
   (=
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X)))
    S))))
Which simplifies
 when rewriting with IS-SEQUENCE-TAIL, SUBSET.NULLSET.LEFT, REL!RAN-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES
 (AND (SUBSET (REL!RAN (TAIL S)) (REL!RAN S)) (IS-SEQUENCE S)
  (NOT (= S (NULLSET))))
 (IF (IN (HEAD S) X)
  (IF (SUBSET (REL!RAN (TAIL S)) X)
   (IMPLIES (AND (= (FILTER (TAIL S) X) (TAIL S)) (SUBSET (REL!RAN S) X))
    (= (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)) S))
   (IMPLIES (SUBSET (REL!RAN S) X)
    (= (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X)) S)))
  (IF (SUBSET (REL!RAN (TAIL S)) X)
   (IMPLIES (AND (= (FILTER (TAIL S) X) (TAIL S)) (SUBSET (REL!RAN S) X))
    (= (TAIL S) S))
   (IMPLIES (SUBSET (REL!RAN S) X) (= (FILTER (TAIL S) X) S)))))
Assuming SUBSET.TRANSITIVE with the
instantiations: (= X (REL!RAN (TAIL S))) (= Y (REL!RAN S)) (= Z X) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (SUBSET (REL!RAN (TAIL S)) (REL!RAN S)) (SUBSET (REL!RAN S) X))
   (= (SUBSET (REL!RAN (TAIL S)) X) (TRUE)))
  (SUBSET (REL!RAN (TAIL S)) (REL!RAN S)) (IS-SEQUENCE S)
  (NOT (= S (NULLSET))))
 (IF (IN (HEAD S) X)
  (IF (SUBSET (REL!RAN (TAIL S)) X)
   (IMPLIES (AND (= (FILTER (TAIL S) X) (TAIL S)) (SUBSET (REL!RAN S) X))
    (= (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)) S))
   (IMPLIES (SUBSET (REL!RAN S) X)
    (= (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X)) S)))
  (IF (SUBSET (REL!RAN (TAIL S)) X)
   (IMPLIES (AND (= (FILTER (TAIL S) X) (TAIL S)) (SUBSET (REL!RAN S) X))
    (= (TAIL S) S))
   (IMPLIES (SUBSET (REL!RAN S) X) (= (FILTER (TAIL S) X) S)))))
Assuming SEQ-HEAD-TAIL with the instantiations: (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-SEQUENCE S)
   (OR (= S (NULLSET)) (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))))
  (IMPLIES
   (AND (SUBSET (REL!RAN (TAIL S)) (REL!RAN S)) (SUBSET (REL!RAN S) X))
   (SUBSET (REL!RAN (TAIL S)) X))
  (SUBSET (REL!RAN (TAIL S)) (REL!RAN S)) (IS-SEQUENCE S)
  (NOT (= S (NULLSET))))
 (IF (IN (HEAD S) X)
  (IF (SUBSET (REL!RAN (TAIL S)) X)
   (IMPLIES (AND (= (FILTER (TAIL S) X) (TAIL S)) (SUBSET (REL!RAN S) X))
    (= (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)) S))
   (IMPLIES (SUBSET (REL!RAN S) X)
    (= (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X)) S)))
  (IF (SUBSET (REL!RAN (TAIL S)) X)
   (IMPLIES (AND (= (FILTER (TAIL S) X) (TAIL S)) (SUBSET (REL!RAN S) X))
    (= (TAIL S) S))
   (IMPLIES (SUBSET (REL!RAN S) X) (= (FILTER (TAIL S) X) S)))))
Which simplifies
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))
  (SUBSET (REL!RAN (TAIL S)) (REL!RAN S)) (SUBSET (REL!RAN S) X)
  (SUBSET (REL!RAN (TAIL S)) X) (NOT (IN (HEAD S) X))
  (= (FILTER (TAIL S) X) (TAIL S)))
 (= (TAIL S) S))
Invoking HEAD gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S)))
  (SUBSET (REL!RAN (TAIL S)) (REL!RAN S)) (SUBSET (REL!RAN S) X)
  (SUBSET (REL!RAN (TAIL S)) X) (NOT (IN (FN!APPLY S 1) X))
  (= (FILTER (TAIL S) X) (TAIL S)))
 (= (TAIL S) S))
Assuming FN!APPLY-IN-RAN with the instantiations: (= F S) (= X 1) generates ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION S) (IN 1 (REL!DOM S)))
   (IN (FN!APPLY S 1) (REL!RAN S)))
  (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S)))
  (SUBSET (REL!RAN (TAIL S)) (REL!RAN S)) (SUBSET (REL!RAN S) X)
  (SUBSET (REL!RAN (TAIL S)) X) (NOT (IN (FN!APPLY S 1) X))
  (= (FILTER (TAIL S) X) (TAIL S)))
 (= (TAIL S) S))
Invoking (SUBSET (REL!RAN S) X) gives ...
(IMPLIES
 (AND
  (IMPLIES (AND (FN!IS-FUNCTION S) (IN 1 (REL!DOM S)))
   (IN (FN!APPLY S 1) (REL!RAN S)))
  (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S)))
  (SUBSET (REL!RAN (TAIL S)) (REL!RAN S))
  (ALL (E) (IMPLIES (IN E (REL!RAN S)) (IN E X)))
  (SUBSET (REL!RAN (TAIL S)) X) (NOT (IN (FN!APPLY S 1) X))
  (= (FILTER (TAIL S) X) (TAIL S)))
 (= (TAIL S) S))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X S) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IMPLIES (AND (FN!IS-FUNCTION S) (IN 1 (REL!DOM S)))
   (IN (FN!APPLY S 1) (REL!RAN S)))
  (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S)))
  (SUBSET (REL!RAN (TAIL S)) (REL!RAN S))
  (ALL (E) (IMPLIES (IN E (REL!RAN S)) (IN E X)))
  (SUBSET (REL!RAN (TAIL S)) X) (NOT (IN (FN!APPLY S 1) X))
  (= (FILTER (TAIL S) X) (TAIL S)))
 (= (TAIL S) S))
Rearranging gives ...
(IMPLIES
 (AND (= S (APPEND (UNIT-SEQ (FN!APPLY S 1)) (TAIL S)))
  (= (FILTER (TAIL S) X) (TAIL S)) (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (SUBSET (REL!RAN (TAIL S)) (REL!RAN S)) (SUBSET (REL!RAN (TAIL S)) X)
  (NOT (IN (FN!APPLY S 1) X))
  (IMPLIES (FINITE!IS-FINITE S) (= (= (FINITE!CARD S) 0) (= S (NULLSET))))
  (IMPLIES (AND (FN!IS-FUNCTION S) (IN 1 (REL!DOM S)))
   (IN (FN!APPLY S 1) (REL!RAN S)))
  (ALL (E) (IMPLIES (IN E (REL!RAN S)) (IN E X))))
 (= (TAIL S) S))
Which simplifies
 when rewriting with RANGE.DEFINITION, SEQUENCE-DOM
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, FINITE!TYPE-OF-IS-FINITE
 with the instantiation (= E (FN!APPLY S 1)) to ...
(TRUE)
FILTER-NULLSET
Beginning proof of FILTER-NULLSET ...
(= (FILTER (NULLSET) X) (NULLSET))
Which simplifies
 when rewriting with FILTER-BY-SUPERSET-RAN, SUBSET.NULLSET.LEFT,
REL!RAN-NULLSET, IS-SEQUENCE-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
FILTER-UNIT
Beginning proof of FILTER-UNIT ...
(= (FILTER (UNIT-SEQ X) Y) (IF (IN X Y) (UNIT-SEQ X) (NULLSET)))
Which simplifies
 with invocation of FILTER, TAIL, HEAD, IS-SEQUENCE, UNIT-SEQ
 when rewriting with APPEND-NULLSET-RIGHT, FILTER-NULLSET,
REL!DOM-RESTRICT-BY-NULLSET, ELEM!NULL-RANGE, FN!APPLY-UNIT-PAIR,
FINITE!IS-FINITE-UNIT, FN!IS-FUNCTION-UNIT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS, PAIR!PAIR-COMPOSITION
 with the assumptions PAIR!FST-PAIR, PAIR!SND-PAIR, PAIR!PAIR-IS-PAIR to ...
(TRUE)
HEAD-APPEND
Beginning proof of HEAD-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (HEAD (APPEND X Y)) (IF (= X (NULLSET)) (HEAD Y) (HEAD X))))
Invoking HEAD gives ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (FN!APPLY (APPEND X Y) 1)
  (IF (= X (NULLSET)) (FN!APPLY Y 1) (FN!APPLY X 1))))
Which simplifies
 when rewriting with APPEND-NULLSET-LEFT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET))))
 (= (FN!APPLY (APPEND X Y) 1) (FN!APPLY X 1)))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X X) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET))))
 (= (FN!APPLY (APPEND X Y) 1) (FN!APPLY X 1)))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET)))
  (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET)))))
 (= (FN!APPLY (APPEND X Y) 1) (FN!APPLY X 1)))
Which simplifies
 when rewriting with APPLY-APPEND, RANGE.DEFINITION, CARD-APPEND
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
TAIL-APPEND
Beginning proof of TAIL-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (TAIL (APPEND X Y)) (IF (= X (NULLSET)) (TAIL Y) (APPEND (TAIL X) Y))))
Which simplifies
 when rewriting with APPEND-NULLSET-LEFT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET))))
 (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y)))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X X) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET))))
 (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y)))
Assuming FN!FUNCTION-EXTENSIONALITY with the
instantiations: (= F (TAIL (APPEND X Y))) (= G (APPEND (TAIL X) Y)) generates
...
(IMPLIES
 (AND
  (IMPLIES
   (AND (FN!IS-FUNCTION (TAIL (APPEND X Y)))
    (FN!IS-FUNCTION (APPEND (TAIL X) Y)))
   (= (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y))
    (AND (= (REL!DOM (TAIL (APPEND X Y))) (REL!DOM (APPEND (TAIL X) Y)))
     (ALL (X$0)
      (IMPLIES (IN X$0 (REL!DOM (TAIL (APPEND X Y))))
       (= (FN!APPLY (TAIL (APPEND X Y)) X$0)
        (FN!APPLY (APPEND (TAIL X) Y) X$0)))))))
  (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET))))
 (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y)))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET)))
  (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET))))
  (IMPLIES
   (AND (FN!IS-FUNCTION (TAIL (APPEND X Y)))
    (FN!IS-FUNCTION (APPEND (TAIL X) Y)))
   (= (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y))
    (AND (= (REL!DOM (TAIL (APPEND X Y))) (REL!DOM (APPEND (TAIL X) Y)))
     (ALL (X$0)
      (IMPLIES (IN X$0 (REL!DOM (TAIL (APPEND X Y))))
       (= (FN!APPLY (TAIL (APPEND X Y)) X$0)
        (FN!APPLY (APPEND (TAIL X) Y) X$0))))))))
 (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y)))
Which simplifies
 when rewriting with RANGE.DEFINITION, CARD-TAIL, DOM-APPEND, SEQUENCE-DOM,
IS-FUNCTION-APPEND, IS-SEQUENCE-TAIL, IS-FUNCTION-TAIL, IS-SEQUENCE-APPEND
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FN!IS-FUNCTION-BOOL, FINITE!TYPE-OF-IS-FINITE to ...
(IMPLIES
 (AND (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET)))
  (= (= (FINITE!CARD X) 0) (FALSE)))
 (IF
  (= (RANGE 1 (FINITE!CARD (TAIL (APPEND X Y))))
   (RANGE 1 (+ -1 (FINITE!CARD X) (FINITE!CARD Y))))
  (OR
   (ALL (X$0)
    (IMPLIES (AND (>= X$0 1) (>= (FINITE!CARD (TAIL (APPEND X Y))) X$0))
     (= (FN!APPLY (TAIL (APPEND X Y)) X$0)
      (FN!APPLY (APPEND (TAIL X) Y) X$0))))
   (NOT (= (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y)) (FALSE))))
  (NOT (= (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y)) (FALSE)))))
Assuming FINITE!CARD-0-IFF-NULLSET with the
instantiations: (= X (APPEND X Y)) generates ...
(IMPLIES
 (AND
  (IMPLIES (FINITE!IS-FINITE (APPEND X Y))
   (= (= (FINITE!CARD (APPEND X Y)) 0) (= (APPEND X Y) (NULLSET))))
  (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET)))
  (NOT (= (FINITE!CARD X) 0)))
 (IF
  (= (RANGE 1 (FINITE!CARD (TAIL (APPEND X Y))))
   (RANGE 1 (+ -1 (FINITE!CARD X) (FINITE!CARD Y))))
  (OR
   (ALL (X$0)
    (IMPLIES (AND (>= X$0 1) (>= (FINITE!CARD (TAIL (APPEND X Y))) X$0))
     (= (FN!APPLY (TAIL (APPEND X Y)) X$0)
      (FN!APPLY (APPEND (TAIL X) Y) X$0))))
   (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y)))
  (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y))))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE X) (IS-SEQUENCE Y) (NOT (= X (NULLSET)))
  (NOT (= (FINITE!CARD X) 0))
  (IMPLIES (FINITE!IS-FINITE (APPEND X Y))
   (= (= (FINITE!CARD (APPEND X Y)) 0) (= (APPEND X Y) (NULLSET)))))
 (IF
  (= (RANGE 1 (FINITE!CARD (TAIL (APPEND X Y))))
   (RANGE 1 (+ -1 (FINITE!CARD X) (FINITE!CARD Y))))
  (OR (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y))
   (ALL (X$0)
    (IMPLIES (AND (>= X$0 1) (>= (FINITE!CARD (TAIL (APPEND X Y))) X$0))
     (= (FN!APPLY (TAIL (APPEND X Y)) X$0)
      (FN!APPLY (APPEND (TAIL X) Y) X$0)))))
  (= (TAIL (APPEND X Y)) (APPEND (TAIL X) Y))))
Which simplifies
 when rewriting with IS-SEQUENCE-TAIL, APPLY-APPEND, APPLY-TAIL,
RANGE.DEFINITION, DOM-TAIL, CARD-TAIL, IS-SEQUENCE-APPEND, CARD-APPEND,
FINITE-APPEND
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
FILTER-APPEND
Beginning proof of FILTER-APPEND ...
(IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
 (= (FILTER (APPEND X Y) Z) (APPEND (FILTER X Z) (FILTER Y Z))))
Inducting using the following scheme ...
 (AND (IMPLIES (IMPLIES (IS-SEQUENCE X) (= X (NULLSET))) (*P* X Y Z))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE X) (= X (NULLSET)))) (IN (HEAD X) Z)
    (*P* (TAIL X) Y Z))
   (*P* X Y Z))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE X) (= X (NULLSET)))) (NOT (IN (HEAD X) Z))
    (*P* (TAIL X) Y Z))
   (*P* X Y Z)))
 produces ...
(AND
 (IMPLIES (IMPLIES (IS-SEQUENCE X) (= X (NULLSET)))
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (= (FILTER (APPEND X Y) Z) (APPEND (FILTER X Z) (FILTER Y Z)))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE X) (= X (NULLSET)))) (IN (HEAD X) Z)
   (IMPLIES (AND (IS-SEQUENCE (TAIL X)) (IS-SEQUENCE Y))
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (= (FILTER (APPEND X Y) Z) (APPEND (FILTER X Z) (FILTER Y Z)))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE X) (= X (NULLSET)))) (NOT (IN (HEAD X) Z))
   (IMPLIES (AND (IS-SEQUENCE (TAIL X)) (IS-SEQUENCE Y))
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
  (IMPLIES (AND (IS-SEQUENCE X) (IS-SEQUENCE Y))
   (= (FILTER (APPEND X Y) Z) (APPEND (FILTER X Z) (FILTER Y Z))))))
Invoking (FILTER X Z) gives ...
(AND
 (IMPLIES
  (AND (IMPLIES (IS-SEQUENCE X) (= X (NULLSET))) (IS-SEQUENCE X)
   (IS-SEQUENCE Y))
  (= (FILTER (APPEND X Y) Z)
   (APPEND
    (IF (IMPLIES (IS-SEQUENCE X) (= X (NULLSET))) (NULLSET)
     (IF (IN (HEAD X) Z) (APPEND (UNIT-SEQ (HEAD X)) (FILTER (TAIL X) Z))
      (FILTER (TAIL X) Z)))
    (FILTER Y Z))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE X) (= X (NULLSET)))) (IN (HEAD X) Z)
   (IMPLIES (AND (IS-SEQUENCE (TAIL X)) (IS-SEQUENCE Y))
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))
   (IS-SEQUENCE X) (IS-SEQUENCE Y))
  (= (FILTER (APPEND X Y) Z)
   (APPEND
    (IF (IMPLIES (IS-SEQUENCE X) (= X (NULLSET))) (NULLSET)
     (IF (IN (HEAD X) Z) (APPEND (UNIT-SEQ (HEAD X)) (FILTER (TAIL X) Z))
      (FILTER (TAIL X) Z)))
    (FILTER Y Z))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE X) (= X (NULLSET)))) (NOT (IN (HEAD X) Z))
   (IMPLIES (AND (IS-SEQUENCE (TAIL X)) (IS-SEQUENCE Y))
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))
   (IS-SEQUENCE X) (IS-SEQUENCE Y))
  (= (FILTER (APPEND X Y) Z)
   (APPEND
    (IF (IMPLIES (IS-SEQUENCE X) (= X (NULLSET))) (NULLSET)
     (IF (IN (HEAD X) Z) (APPEND (UNIT-SEQ (HEAD X)) (FILTER (TAIL X) Z))
      (FILTER (TAIL X) Z)))
    (FILTER Y Z)))))
Which simplifies
 when rewriting with APPEND-ASSOCIATIVE, IS-SEQUENCE-UNIT-SEQ,
IS-SEQUENCE-TAIL, IS-SEQUENCE-FILTER, APPEND-NULLSET-LEFT
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES (AND (IS-SEQUENCE X) (NOT (= X (NULLSET))))
 (IF (IN (HEAD X) Z)
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))
   (= (FILTER (APPEND X Y) Z)
    (APPEND (UNIT-SEQ (HEAD X)) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))
   (= (FILTER (APPEND X Y) Z) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))))
Invoking (FILTER (APPEND X Y) Z) gives ...
(IMPLIES (AND (IS-SEQUENCE X) (NOT (= X (NULLSET))))
 (IF (IN (HEAD X) Z)
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))
   (=
    (IF (IMPLIES (IS-SEQUENCE (APPEND X Y)) (= (APPEND X Y) (NULLSET)))
     (NULLSET)
     (IF (IN (HEAD (APPEND X Y)) Z)
      (APPEND (UNIT-SEQ (HEAD (APPEND X Y))) (FILTER (TAIL (APPEND X Y)) Z))
      (FILTER (TAIL (APPEND X Y)) Z)))
    (APPEND (UNIT-SEQ (HEAD X)) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))
   (=
    (IF (IMPLIES (IS-SEQUENCE (APPEND X Y)) (= (APPEND X Y) (NULLSET)))
     (NULLSET)
     (IF (IN (HEAD (APPEND X Y)) Z)
      (APPEND (UNIT-SEQ (HEAD (APPEND X Y))) (FILTER (TAIL (APPEND X Y)) Z))
      (FILTER (TAIL (APPEND X Y)) Z)))
    (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))))
Which simplifies
 when rewriting with TAIL-APPEND, HEAD-APPEND, IS-SEQUENCE-APPEND
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES (AND (IS-SEQUENCE X) (NOT (= X (NULLSET))))
 (IF (IN (HEAD X) Z)
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
    (= (APPEND X Y) (NULLSET)))
   (= (NULLSET)
    (APPEND (UNIT-SEQ (HEAD X)) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
    (= (APPEND X Y) (NULLSET)))
   (= (NULLSET) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))))
Assuming FINITE!CARD-0-IFF-NULLSET with the instantiations: (= X X) generates
...
(IMPLIES
 (AND (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET))))
  (IS-SEQUENCE X) (NOT (= X (NULLSET))))
 (IF (IN (HEAD X) Z)
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
    (= (APPEND X Y) (NULLSET)))
   (= (NULLSET)
    (APPEND (UNIT-SEQ (HEAD X)) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
    (= (APPEND X Y) (NULLSET)))
   (= (NULLSET) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))))
Assuming FINITE!CARD-0-IFF-NULLSET with the
instantiations: (= X (APPEND X Y)) generates ...
(IMPLIES
 (AND
  (IMPLIES (FINITE!IS-FINITE (APPEND X Y))
   (= (= (FINITE!CARD (APPEND X Y)) 0) (= (APPEND X Y) (NULLSET))))
  (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET))))
  (IS-SEQUENCE X) (NOT (= X (NULLSET))))
 (IF (IN (HEAD X) Z)
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
    (= (APPEND X Y) (NULLSET)))
   (= (NULLSET)
    (APPEND (UNIT-SEQ (HEAD X)) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
  (IMPLIES
   (AND (IS-SEQUENCE Y)
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
    (= (APPEND X Y) (NULLSET)))
   (= (NULLSET) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))))
Rearranging gives ...
(IMPLIES
 (AND (IS-SEQUENCE X) (NOT (= X (NULLSET)))
  (IMPLIES (FINITE!IS-FINITE (APPEND X Y))
   (= (= (FINITE!CARD (APPEND X Y)) 0) (= (APPEND X Y) (NULLSET))))
  (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET)))))
 (IF (IN (HEAD X) Z)
  (IMPLIES
   (AND
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
    (= (APPEND X Y) (NULLSET)) (IS-SEQUENCE Y))
   (= (NULLSET)
    (APPEND (UNIT-SEQ (HEAD X)) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
  (IMPLIES
   (AND
    (= (FILTER (APPEND (TAIL X) Y) Z)
     (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
    (= (APPEND X Y) (NULLSET)) (IS-SEQUENCE Y))
   (= (NULLSET) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))))
Splitting on (IS-SEQUENCE Y) generates ...
(IF (IS-SEQUENCE Y)
 (IMPLIES
  (AND (IS-SEQUENCE X) (NOT (= X (NULLSET)))
   (IMPLIES (FINITE!IS-FINITE (APPEND X Y))
    (= (= (FINITE!CARD (APPEND X Y)) 0) (= (APPEND X Y) (NULLSET))))
   (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET)))))
  (IF (IN (HEAD X) Z)
   (IMPLIES
    (AND
     (= (FILTER (APPEND (TAIL X) Y) Z)
      (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
     (= (APPEND X Y) (NULLSET)) (IS-SEQUENCE Y))
    (= (NULLSET)
     (APPEND (UNIT-SEQ (HEAD X)) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
   (IMPLIES
    (AND
     (= (FILTER (APPEND (TAIL X) Y) Z)
      (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
     (= (APPEND X Y) (NULLSET)) (IS-SEQUENCE Y))
    (= (NULLSET) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z))))))
 (IMPLIES
  (AND (IS-SEQUENCE X) (NOT (= X (NULLSET)))
   (IMPLIES (FINITE!IS-FINITE (APPEND X Y))
    (= (= (FINITE!CARD (APPEND X Y)) 0) (= (APPEND X Y) (NULLSET))))
   (IMPLIES (FINITE!IS-FINITE X) (= (= (FINITE!CARD X) 0) (= X (NULLSET)))))
  (IF (IN (HEAD X) Z)
   (IMPLIES
    (AND
     (= (FILTER (APPEND (TAIL X) Y) Z)
      (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
     (= (APPEND X Y) (NULLSET)) (IS-SEQUENCE Y))
    (= (NULLSET)
     (APPEND (UNIT-SEQ (HEAD X)) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))
   (IMPLIES
    (AND
     (= (FILTER (APPEND (TAIL X) Y) Z)
      (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))
     (= (APPEND X Y) (NULLSET)) (IS-SEQUENCE Y))
    (= (NULLSET) (APPEND (FILTER (TAIL X) Z) (FILTER Y Z)))))))
Which simplifies
 when rewriting with CARD-APPEND, FINITE-APPEND
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions FINITE!TYPE-OF-IS-FINITE to ...
(TRUE)
REVERSE-FILTER
Beginning proof of REVERSE-FILTER ...
(IMPLIES (IS-SEQUENCE S) (= (REVERSE (FILTER S X)) (FILTER (REVERSE S) X)))
Inducting using the following scheme ...
 (AND (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
    (*P* (TAIL S) X))
   (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
    (*P* (TAIL S) X))
   (*P* S X)))
 produces ...
(AND
 (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))
  (IMPLIES (IS-SEQUENCE S) (= (REVERSE (FILTER S X)) (FILTER (REVERSE S) X))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (REVERSE (FILTER (TAIL S) X)) (FILTER (REVERSE (TAIL S)) X))))
  (IMPLIES (IS-SEQUENCE S) (= (REVERSE (FILTER S X)) (FILTER (REVERSE S) X))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (REVERSE (FILTER (TAIL S) X)) (FILTER (REVERSE (TAIL S)) X))))
  (IMPLIES (IS-SEQUENCE S) (= (REVERSE (FILTER S X)) (FILTER (REVERSE S) X)))))
Which simplifies
 when rewriting with REVERSE-TAIL, IS-SEQUENCE-TAIL, REVERSE-NULLSET,
FILTER-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= (REVERSE (FILTER (TAIL S) X)) (FILTER (FRONT (REVERSE S)) X)))
 (= (REVERSE (FILTER S X)) (FILTER (REVERSE S) X)))
Assuming SEQ-HEAD-TAIL with the instantiations: (= S S) generates ...
(IMPLIES
 (AND
  (IMPLIES (IS-SEQUENCE S)
   (OR (= S (NULLSET)) (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))))
  (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= (REVERSE (FILTER (TAIL S) X)) (FILTER (FRONT (REVERSE S)) X)))
 (= (REVERSE (FILTER S X)) (FILTER (REVERSE S) X)))
Substituting (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) produces ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))
  (= (REVERSE (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X))
   (FILTER (FRONT (REVERSE (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))) X)))
 (= (REVERSE (FILTER (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)) X))
  (FILTER (REVERSE (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X)))
Applying REVERSE-APPEND gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))
  (= (REVERSE (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X))
   (FILTER
    (FRONT
     (IF (AND (IS-SEQUENCE (UNIT-SEQ (HEAD S))) (IS-SEQUENCE (TAIL S)))
      (APPEND (REVERSE (TAIL S)) (REVERSE (UNIT-SEQ (HEAD S))))
      (REVERSE (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))))
    X)))
 (= (REVERSE (FILTER (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)) X))
  (FILTER
   (IF (AND (IS-SEQUENCE (UNIT-SEQ (HEAD S))) (IS-SEQUENCE (TAIL S)))
    (APPEND (REVERSE (TAIL S)) (REVERSE (UNIT-SEQ (HEAD S))))
    (REVERSE (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
   X)))
Applying FILTER-APPEND gives ...
(IMPLIES
 (AND (IS-SEQUENCE S) (NOT (= S (NULLSET)))
  (= S (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))
  (= (REVERSE (FILTER (TAIL (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))) X))
   (FILTER
    (FRONT
     (IF (AND (IS-SEQUENCE (UNIT-SEQ (HEAD S))) (IS-SEQUENCE (TAIL S)))
      (APPEND (REVERSE (TAIL S)) (REVERSE (UNIT-SEQ (HEAD S))))
      (REVERSE (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)))))
    X)))
 (=
  (REVERSE
   (IF (AND (IS-SEQUENCE (UNIT-SEQ (HEAD S))) (IS-SEQUENCE (TAIL S)))
    (APPEND (FILTER (UNIT-SEQ (HEAD S)) X) (FILTER (TAIL S) X))
    (FILTER (APPEND (UNIT-SEQ (HEAD S)) (TAIL S)) X)))
  (FILTER
   (IF (AND (IS-SEQUENCE (UNIT-SEQ (HEAD S))) (IS-SEQUENCE (TAIL S)))
    (APPEND (REVERSE (TAIL S)) (REVERSE (UNIT-SEQ (HEAD S))))
    (REVERSE (APPEND (UNIT-SEQ (HEAD S)) (TAIL S))))
   X)))
Which simplifies
 when rewriting with APPEND-NULLSET-RIGHT, FILTER-APPEND, REVERSE-APPEND,
APPEND-NULLSET-LEFT, IS-SEQUENCE-FILTER, FILTER-UNIT, FRONT-APPEND-UNIT,
IS-SEQUENCE-FRONT, IS-SEQUENCE-REVERSE, REVERSE-UNIT, REVERSE-TAIL,
IS-SEQUENCE-TAIL, IS-SEQUENCE-UNIT-SEQ
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
FILTER-FILTER
Beginning proof of FILTER-FILTER ...
(IMPLIES (IS-SEQUENCE S) (= (FILTER (FILTER S X) Y) (FILTER S (INTER X Y))))
Inducting using the following scheme ...
 (AND (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (*P* S X Y))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
    (*P* (TAIL S) X Y))
   (*P* S X Y))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
    (*P* (TAIL S) X Y))
   (*P* S X Y)))
 produces ...
(AND
 (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))
  (IMPLIES (IS-SEQUENCE S)
   (= (FILTER (FILTER S X) Y) (FILTER S (INTER X Y)))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (FILTER (FILTER (TAIL S) X) Y) (FILTER (TAIL S) (INTER X Y)))))
  (IMPLIES (IS-SEQUENCE S)
   (= (FILTER (FILTER S X) Y) (FILTER S (INTER X Y)))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (FILTER (FILTER (TAIL S) X) Y) (FILTER (TAIL S) (INTER X Y)))))
  (IMPLIES (IS-SEQUENCE S)
   (= (FILTER (FILTER S X) Y) (FILTER S (INTER X Y))))))
Invoking (FILTER S X) gives ...
(AND
 (IMPLIES (AND (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (IS-SEQUENCE S))
  (=
   (FILTER
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X)))
    Y)
   (FILTER S (INTER X Y))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (FILTER (FILTER (TAIL S) X) Y) (FILTER (TAIL S) (INTER X Y))))
   (IS-SEQUENCE S))
  (=
   (FILTER
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X)))
    Y)
   (FILTER S (INTER X Y))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (= (FILTER (FILTER (TAIL S) X) Y) (FILTER (TAIL S) (INTER X Y))))
   (IS-SEQUENCE S))
  (=
   (FILTER
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X)))
    Y)
   (FILTER S (INTER X Y)))))
Which simplifies
 when rewriting with APPEND-NULLSET-LEFT, IS-SEQUENCE-FILTER, FILTER-UNIT,
FILTER-APPEND, IS-SEQUENCE-UNIT-SEQ, IS-SEQUENCE-TAIL, FILTER-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2 to ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (IF (IN (HEAD S) X)
  (IMPLIES (= (FILTER (FILTER (TAIL S) X) Y) (FILTER (TAIL S) (INTER X Y)))
   (IF (IN (HEAD S) Y)
    (= (APPEND (UNIT-SEQ (HEAD S)) (FILTER (FILTER (TAIL S) X) Y))
     (FILTER S (INTER X Y)))
    (= (FILTER (FILTER (TAIL S) X) Y) (FILTER S (INTER X Y)))))
  (IMPLIES (= (FILTER (FILTER (TAIL S) X) Y) (FILTER (TAIL S) (INTER X Y)))
   (= (FILTER (FILTER (TAIL S) X) Y) (FILTER S (INTER X Y))))))
Invoking (FILTER S (INTER X Y)) gives ...
(IMPLIES (AND (IS-SEQUENCE S) (NOT (= S (NULLSET))))
 (IF (IN (HEAD S) X)
  (IMPLIES (= (FILTER (FILTER (TAIL S) X) Y) (FILTER (TAIL S) (INTER X Y)))
   (IF (IN (HEAD S) Y)
    (= (APPEND (UNIT-SEQ (HEAD S)) (FILTER (FILTER (TAIL S) X) Y))
     (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
      (IF (IN (HEAD S) (INTER X Y))
       (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) (INTER X Y)))
       (FILTER (TAIL S) (INTER X Y)))))
    (= (FILTER (FILTER (TAIL S) X) Y)
     (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
      (IF (IN (HEAD S) (INTER X Y))
       (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) (INTER X Y)))
       (FILTER (TAIL S) (INTER X Y)))))))
  (IMPLIES (= (FILTER (FILTER (TAIL S) X) Y) (FILTER (TAIL S) (INTER X Y)))
   (= (FILTER (FILTER (TAIL S) X) Y)
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) (INTER X Y))
      (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) (INTER X Y)))
      (FILTER (TAIL S) (INTER X Y))))))))
Which simplifies
 when rewriting with INTER.DEFINITION
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS
 with the assumptions SETRULES!SUBSET-INTER-RELATION-1,
SETRULES!SUBSET-INTER-RELATION-2 to ...
(TRUE)
FILTER-BY-NULLSET
Beginning proof of FILTER-BY-NULLSET ...
(IMPLIES (IS-SEQUENCE S) (= (FILTER S (NULLSET)) (NULLSET)))
Inducting using the following scheme ...
 (AND (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (*P* S))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))))
    (IN (HEAD S) (NULLSET)) (*P* (TAIL S)))
   (*P* S))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))))
    (NOT (IN (HEAD S) (NULLSET))) (*P* (TAIL S)))
   (*P* S)))
 produces ...
(AND
 (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))
  (IMPLIES (IS-SEQUENCE S) (= (FILTER S (NULLSET)) (NULLSET))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) (NULLSET))
   (IMPLIES (IS-SEQUENCE (TAIL S)) (= (FILTER (TAIL S) (NULLSET)) (NULLSET))))
  (IMPLIES (IS-SEQUENCE S) (= (FILTER S (NULLSET)) (NULLSET))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))))
   (NOT (IN (HEAD S) (NULLSET)))
   (IMPLIES (IS-SEQUENCE (TAIL S)) (= (FILTER (TAIL S) (NULLSET)) (NULLSET))))
  (IMPLIES (IS-SEQUENCE S) (= (FILTER S (NULLSET)) (NULLSET)))))
Invoking (FILTER S (NULLSET)) gives ...
(AND
 (IMPLIES (AND (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (IS-SEQUENCE S))
  (=
   (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
    (IF (IN (HEAD S) (NULLSET))
     (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) (NULLSET)))
     (FILTER (TAIL S) (NULLSET))))
   (NULLSET)))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) (NULLSET))
   (IMPLIES (IS-SEQUENCE (TAIL S)) (= (FILTER (TAIL S) (NULLSET)) (NULLSET)))
   (IS-SEQUENCE S))
  (=
   (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
    (IF (IN (HEAD S) (NULLSET))
     (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) (NULLSET)))
     (FILTER (TAIL S) (NULLSET))))
   (NULLSET)))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))))
   (NOT (IN (HEAD S) (NULLSET)))
   (IMPLIES (IS-SEQUENCE (TAIL S)) (= (FILTER (TAIL S) (NULLSET)) (NULLSET)))
   (IS-SEQUENCE S))
  (=
   (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
    (IF (IN (HEAD S) (NULLSET))
     (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) (NULLSET)))
     (FILTER (TAIL S) (NULLSET))))
   (NULLSET))))
Which simplifies
 when rewriting with IS-SEQUENCE-TAIL, NULLSET.DEFINITION
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
CARD-FILTER
Beginning proof of CARD-FILTER ...
(IMPLIES (IS-SEQUENCE S) (<= (FINITE!CARD (FILTER S X)) (FINITE!CARD S)))
Inducting using the following scheme ...
 (AND (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
    (*P* (TAIL S) X))
   (*P* S X))
  (IMPLIES
   (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
    (*P* (TAIL S) X))
   (*P* S X)))
 produces ...
(AND
 (IMPLIES (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))
  (IMPLIES (IS-SEQUENCE S) (<= (FINITE!CARD (FILTER S X)) (FINITE!CARD S))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (<= (FINITE!CARD (FILTER (TAIL S) X)) (FINITE!CARD (TAIL S)))))
  (IMPLIES (IS-SEQUENCE S) (<= (FINITE!CARD (FILTER S X)) (FINITE!CARD S))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (<= (FINITE!CARD (FILTER (TAIL S) X)) (FINITE!CARD (TAIL S)))))
  (IMPLIES (IS-SEQUENCE S) (<= (FINITE!CARD (FILTER S X)) (FINITE!CARD S)))))
Invoking (FILTER S X) gives ...
(AND
 (IMPLIES (AND (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (IS-SEQUENCE S))
  (>= (FINITE!CARD S)
   (FINITE!CARD
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X))))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (IN (HEAD S) X)
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (>= (FINITE!CARD (TAIL S)) (FINITE!CARD (FILTER (TAIL S) X))))
   (IS-SEQUENCE S))
  (>= (FINITE!CARD S)
   (FINITE!CARD
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X))))))
 (IMPLIES
  (AND (NOT (IMPLIES (IS-SEQUENCE S) (= S (NULLSET)))) (NOT (IN (HEAD S) X))
   (IMPLIES (IS-SEQUENCE (TAIL S))
    (>= (FINITE!CARD (TAIL S)) (FINITE!CARD (FILTER (TAIL S) X))))
   (IS-SEQUENCE S))
  (>= (FINITE!CARD S)
   (FINITE!CARD
    (IF (IMPLIES (IS-SEQUENCE S) (= S (NULLSET))) (NULLSET)
     (IF (IN (HEAD S) X) (APPEND (UNIT-SEQ (HEAD S)) (FILTER (TAIL S) X))
      (FILTER (TAIL S) X)))))))
Which simplifies
 when rewriting with CARD-UNIT-SEQ, CARD-APPEND, IS-SEQUENCE-FILTER,
IS-SEQUENCE-UNIT-SEQ, CARD-TAIL, IS-SEQUENCE-TAIL, FINITE!CARD-NULLSET
 forward chaining using >=.SAME.TYPE, FINITE!FINITE-CARD-NAT,
FN!FUNCTION-IS-RELATION, IS-SEQUENCE-FACTS to ...
(TRUE)
Done.