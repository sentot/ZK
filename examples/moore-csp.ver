;;; partial order

(load rel)
(load fn)
(load nat)
(load setrules)

;;; A rephrasing of some function-space axioms
;;; I think these are heuristically better than the rules in fn

(disabled
 (function is-fun (f D R) ()
   (and (fn!is-function f)
	(= (rel!dom f) D)
	(subset (rel!ran f) R))))

(frule is-fun-facts (f D R)
  (implies (is-fun f D R)
	   (and (fn!is-function f)
		(= (rel!dom f) D)
		(subset (rel!ran f) R))))
(WITH-ENABLED (IS-FUN) (REDUCE))

(rule in-fun (f D R)
  (= (in f (fn!fun D R))
     (is-fun f D R)))
(INVOKE IS-FUN)
(WITH-ENABLED (FN!IN-FUN) (REWRITE))

(grule apply-in-nominal-range (f D R x)
  (implies (and (is-fun f D R)
		(in x D))
	   (in (fn!apply f x) R)))
(USE FN!APPLY-IN-RAN (F F) (X X))
(WITH-ENABLED (IS-FUN) (REDUCE))

;; when D is a type with a membership rule, the above grule does not
;; trigger.  We have D = (nat!nat) in the sequel; here is a specialized
;; instance to deal with it:

(grule apply-in-nominal-range-nat (f R x)
  (implies (and (is-fun f (nat!nat) R)
		(>= x 0))
	   (in (fn!apply f x) R)))
(use apply-in-nominal-range (f f)(d (nat!nat)) (r r)(x x))
(rewrite)

;; When R is a type with a membership rule, there are similar
;; problems.  The grule adds (in ... R), but not the normalized
;; version of it.  Here is a specialized instance when R is (fn!fun D2 R),
;; with rule IN-FUN applied to the comclusion

(grule apply-in-nominal-range-fun (f D1 D2 R x)
  (implies (and (is-fun f D1 (fn!fun D2 R))
		(in x D1))
	   (is-fun (fn!apply f x) D2 R)))
(USE APPLY-IN-NOMINAL-RANGE (F F) (D D1) (R (FN!FUN D2 R)) (X X))
(APPLY IN-FUN)
(SIMPLIFY)

;; finally, when D is (nat!nat) and R is (fn!fun ...), we need
;; a further special rule.  Yes, this DOES come up below!

(grule apply-in-nominal-range-fun-nat (f D R x)
  (implies (and (is-fun f (nat!nat) (fn!fun D R))
		(>= x 0))
	   (is-fun (fn!apply f x) D R)))
(use apply-in-nominal-range-fun (f f) (D1 (nat!nat)) (D2 D) (R R))
(rewrite)

(grule is-fun-composition (f g X Y Z)
  (implies (and (is-fun f X Y)
		(is-fun g Y Z))
	   (is-fun (rel!comp f g) X Z)))
(INVOKE IS-FUN)
(REWRITE)
(USE REL!IMAGE-SUBSET-RAN (R G) (X (REL!RAN F)))
(REWRITE)

(disabled
 (rule is-fun-subgoal (f x y)
  (implies (and (fn!is-function f)
		(= (rel!dom f) x)
		(all (z) (implies (in z x) (in (fn!apply f z) y))))
	   (= (is-fun f x y) (true)))))
(INVOKE IS-FUN)
(WITH-ENABLED (FN!IN-RAN-FUNCTION) (REDUCE))

;;; nicer notation for relatedness:

(disabled
 (function related (x R y) ()
   (in (pair!pair x y) R)))

(rule related-nullset (x y)
  (= (related x (nullset) y)
     (false)))
(with-enabled (related) (reduce))

(rule related-id (x S y)
  (= (related x (rel!id S) y)
     (and (in x S)
	  (= x y))))
(WITH-ENABLED (RELATED) (REDUCE))

(rule related-inverse (x R y)
  (= (related x (rel!inverse R) y)
     (related y R x)))
(with-enabled (related) (reduce))

(rule related-comp (x R S z)
  (= (related x (rel!comp R S) z)
     (some (y) (and (related x R y) (related y S z)))))
(split (related x (rel!comp R S) z))
(simplify)
(with-enabled (related rel!in-comp) (reduce))

(frule related-dom-ran (x R y)
  (implies (related x R y)
	   (and (in x (rel!dom R))
		(in y (rel!ran R)))))
(with-enabled (related) (reduce))

;;; Transitivity

(disabled
 (function is-transitive (R) ()
   (all (x y z)
     (implies (and (related x R y)
		   (related y R z))
	      (related x R z)))))

(axiom transitive (R x y z)
  (implies (and (is-transitive R)
		(related x R y)
		(related y R z))
	   (related x R z)))
(with-enabled (is-transitive) (REDUCE))

(rule is-transitive-inverse (r)
  (= (is-transitive (rel!inverse r))
     (is-transitive r)))
(SPLIT (IS-TRANSITIVE R))
(SIMPLIFY)
(WITH-ENABLED (IS-TRANSITIVE) (REDUCE))
(INSTANTIATE (X$0 Z) (Y$0 Y) (Z$0 X))
(SIMPLIFY)

;;; Partial orders

(disabled
 (function is-po (r) ()
   (and (rel!is-relation r)
        (is-transitive r)
        (= (rel!dom r) (rel!ran r))
        (= (inter r (rel!inverse r)) (rel!id (rel!dom r))))))

(frule is-po-basic (r)
  (implies (is-po r)
	   (and (rel!is-relation r)
		(is-transitive r)
		(= (rel!ran r) (rel!dom r)))))
(INVOKE IS-PO)
(SIMPLIFY)

(rule is-po-inverse (r)
  (= (is-po (rel!inverse r))
     (is-po r)))
(WITH-ENABLED (IS-PO) (REDUCE))

(rule related-po-self (R x)
  (implies (is-po R)
	   (= (related x R x)
	      (in x (rel!dom R)))))
(with-enabled (is-po related) (REDUCE))
(SPLIT (SUBSET (REL!ID (REL!DOM R)) R))
(REWRITE)
(INVOKE SUBSET)
(INSTANTIATE (E (PAIR!PAIR X X)))
(WITH-ENABLED (REL!IN-DOM) (REWRITE))

(axiom po-transitive (R x y z)
  (implies (and (is-po R)
		(related x R y)
		(related y R z))
	   (related x R z)))
(INVOKE IS-PO)
(USE TRANSITIVE (R R) (X X) (Y Y) (Z Z))
(SIMPLIFY)

(axiom po-asymmetry (R x y)
  (implies (and (is-po R)
		(related x R y)
		(related y R x))
	   (= x y)))
(WITH-ENABLED (IS-PO RELATED) (REDUCE))
(APPLY SETRULES!EXTENSIONALITY
       (= (INTER R (REL!INVERSE R)) (REL!ID (REL!DOM R))))
(INSTANTIATE (E (PAIR!PAIR X Y)))
(REWRITE)

;;; Bottom element

(function is-bottom (b R) ()
  (and (in b (rel!dom R))
       (all (x) (implies (in x (rel!dom R))
			 (related b R x)))))

(frule is-bottom-implies-in-dom (b R)
  (implies (is-bottom b R)
	   (in b (rel!dom R))))
(invoke is-bottom)
(simplify)

(function has-bottom (R) ()
  (some (b) (is-bottom b R)))

(axiom bottom-unique (R b1 b2)
  (implies (and (is-po R)
		(is-bottom b1 R)
		(is-bottom b2 R))
	   (= b1 b2)))
(INVOKE IS-BOTTOM)
(USE PO-ASYMMETRY (R R) (X B1) (Y B2))
(SIMPLIFY)
(INSTANTIATE (X B2))
(SIMPLIFY)

(zf-function bottom (R)
  (that x (if (and (is-po R) (has-bottom R))
	      (is-bottom x r)
	      (= x 0))))
(INSTANTIATE (X 0))
(SIMPLIFY)
(INVOKE HAS-BOTTOM)
(INSTANTIATE (X B))
(PRENEX)
(USE BOTTOM-UNIQUE (R R) (B1 B) (B2 X-0$0))
(SIMPLIFY)

(rule bottom-is-bottom (R)
  (implies (and (is-po R)
		(has-bottom R))
	   (= (is-bottom (bottom R) R)
	      (true))))
(USE BOTTOM.DEFINITION (R R))
(SIMPLIFY)

(rule bottom-in-dom (R)
  (implies (and (is-po R)
		(has-bottom R))
	   (= (in (bottom R) (rel!dom R))
	      (true))))
(USE BOTTOM.DEFINITION (R R))
(INVOKE IS-BOTTOM)
(SIMPLIFY)

(rule bottom-less (R x)
  (implies (and (is-po R)
		(has-bottom R)
		(in x (rel!dom R)))
	   (= (related (bottom R) R x)
	      (true))))
(USE BOTTOM.DEFINITION (R R))
(INVOKE IS-BOTTOM)
(SIMPLIFY)

;;; Monotonic functions

(disabled
 (function is-monotonic (f R1 R2) ()
   (and (is-fun f (rel!dom R1) (rel!dom R2))
        (all (x y) (implies (related x R1 y)
			    (related (fn!apply f x) R2 (fn!apply f y)))))))

(frule is-monotonic-facts (f R1 R2)
  (implies (is-monotonic f R1 R2)
	   (is-fun f (rel!dom R1) (rel!dom R2))))
(INVOKE IS-MONOTONIC)
(SIMPLIFY)

(rule is-monotonic-fact (f R1 R2 x y)
  (implies (and (is-monotonic f R1 R2)
		(related x R1 y))
	   (= (related (fn!apply f x) R2 (fn!apply f y))
	      (true))))
(WITH-ENABLED (IS-MONOTONIC) (REDUCE))

;;; Chains

(disabled
 (function is-chain (f R) ()
   (and (is-fun f (nat!nat) (rel!dom R))
        (all (n)
	  (implies (in n (nat!nat))
		   (related (fn!apply f n) R (fn!apply f (+ 1 n))))))))

(frule chain-is-fun (f R)
  (implies (is-chain f R)
	   (is-fun f (nat!nat) (rel!dom R))))
(INVOKE IS-CHAIN)
(SIMPLIFY)

(rule dom-chain (f R)
  (implies (is-chain f R)
	   (= (rel!dom f) (nat!nat))))
(SIMPLIFY)

;(grule apply-chain (f R n)
;  (implies (and (is-chain f R)
;		(>= n 0))
;	   (in (fn!apply f n) (rel!dom R))))
;(USE FN!APPLY-IN-RAN (F F) (X N))
;(REARRANGE)
;(REWRITE)
;(INVOKE IS-CHAIN)
;(WITH-ENABLED (IS-FUN) (REDUCE))

(axiom chain-applications-related-lemma (f R n1 n2)
  (implies (and (is-chain f R)
		(is-po R)
		(<= 0 n1)
		(<= 0 n2))
	   (related (fn!apply f n1) R (fn!apply f (+ n1 n2)))))
(INDUCT (NAT!WEAK-INDUCTION N2))
(REDUCE)
(INVOKE IS-CHAIN)
(INSTANTIATE (N (+ -1 (+ N1 N2))))
(USE PO-TRANSITIVE
     (R R)
     (X (FN!APPLY F N1))
     (Y (FN!APPLY F (+ -1 (+ N1 N2))))
     (Z (FN!APPLY F (+ N1 N2))))
(REWRITE)

(rule chain-applications-related (f R n1 n2)
  (implies (and (is-chain f R)
		(is-po R)
		(<= 0 n1)
		(<= n1 n2))
	   (= (related (fn!apply f n1) R (fn!apply f n2))
	      (true))))
(USE CHAIN-APPLICATIONS-RELATED-LEMMA (F F) (R R) (N1 N1) (N2 (- N2 N1)))
(SIMPLIFY)

(rule is-chain-comp (f g R1 R2)
  (implies (and (is-monotonic g R1 R2)
		(is-chain f R1)
		(is-po R1))
	   (= (is-chain (rel!comp f g) R2)
	      (true))))
(INVOKE (IS-CHAIN (REL!COMP F G) R2))
(REWRITE)

(function is-chain-bound (f b R) ()
  (and (is-chain f R)
       (in b (rel!dom R))
       (all (n) (implies (in n (nat!nat))
			 (related (fn!apply f n) R b)))))

(function is-chain-limit (f x R) ()
  (and (is-chain-bound f x R)
       (all (b) (implies (is-chain-bound f b R)
			 (related x R b)))))

(axiom chain-limit-unique (f x y R)
  (implies (and (is-po R)
		(is-chain-limit f x R)
		(is-chain-limit f y R))
	   (= x y)))
(INVOKE IS-CHAIN-LIMIT)
(USE PO-ASYMMETRY (R R) (X X) (Y Y))
(REARRANGE)
(SIMPLIFY)

;;; Complete POs

(function is-complete-po (R) ()
  (and (is-po R)
       (all (f) (implies (is-chain f R)
			 (some (b) (is-chain-limit f b R))))))

(frule complete-po-is-po (R)
  (implies (is-complete-po R)
	   (is-po R)))
(invoke is-complete-po)
(simplify)

(zf-function limit (f R)
  (that x
    (if (and (is-po R)
	     (some (b) (is-chain-limit f b R)))
	(is-chain-limit f x R)
	(= x 0))))
(INSTANTIATE (X 0))
(SIMPLIFY)
(INSTANTIATE (X B))
(PRENEX)
(USE CHAIN-LIMIT-UNIQUE (R R) (F F) (X B) (Y X-0$0))
(SIMPLIFY)

(axiom limit-is-chain-limit (f R)
  (implies (and (is-complete-po R)
		(is-chain f R))
	   (is-chain-limit f (limit f R) R)))
(USE LIMIT.DEFINITION (F F) (R R))
(INVOKE IS-COMPLETE-PO)
(INSTANTIATE (F$0 F))
(SIMPLIFY)

(grule limit-in-dom (f R)
  (implies (and (is-complete-po R)
		(is-chain f R))
	   (in (limit f R) (rel!dom R))))
(USE LIMIT-IS-CHAIN-LIMIT (F F) (R R))
(INVOKE (IS-CHAIN-LIMIT F (LIMIT F R) R))
(INVOKE (IS-CHAIN-BOUND F (LIMIT F R) R))
(SIMPLIFY)

(rule limit-is-upper-bound (n f R)
  (implies (and (is-complete-po R)
		(is-chain f R)
		(>= n 0))
	   (= (related (fn!apply f n) R (limit f R))
	      (true))))
(USE LIMIT-IS-CHAIN-LIMIT (F F) (R R))
(INVOKE (IS-CHAIN-LIMIT F (LIMIT F R) R))
(INVOKE (IS-CHAIN-BOUND F (LIMIT F R) R))
(INSTANTIATE (N$0 N))
(REWRITE)

(rule limit-below (f R x)
  (implies (and (is-chain f R)
		(is-complete-po R)
		(in x (rel!dom R)))
	   (= (related (limit f R) R x)
	      (all (n) (implies (in n (nat!nat))
				(related (fn!apply f n) R x))))))
(SPLIT (RELATED (LIMIT F R) R X))
(SIMPLIFY)
(CASES)
(PRENEX)
(USE PO-TRANSITIVE (R R) (X (FN!APPLY F N)) (Y (LIMIT F R)) (Z X))
(REARRANGE)
(REWRITE)
(NEXT)
(USE LIMIT-IS-CHAIN-LIMIT (F F) (R R))
(INVOKE IS-CHAIN-LIMIT)
(INSTANTIATE (B X))
(INVOKE (IS-CHAIN-BOUND F X R))
(SIMPLIFY)
(NEXT)


;;; Continuity

(function is-continuous (f R) ()
  (and (is-monotonic f R R)
       (all (g) (implies (is-chain g R)
			 (= (limit (rel!comp g f) R)
			    (fn!apply f (limit g R)))))))

(frule continuous-implies-monotonic (f R)
  (implies (is-continuous f R)
	   (is-monotonic f R R)))
(INVOKE IS-CONTINUOUS)
(SIMPLIFY)

(disabled
 (rule continuity-fact (f g R)
   (implies (and (is-continuous f R)
		 (is-chain g R))
	    (= (fn!apply f (limit g R))
	       (limit (rel!comp g f) R)))))
(INVOKE IS-CONTINUOUS)
(INSTANTIATE (G$0 G))
(SIMPLIFY)

(axiom continuity-subgoal (f R)
  (implies
   (and (is-complete-po R)
	(is-monotonic f R R)
	(all (g) (implies (is-chain g R)
			  (related (fn!apply f (limit g R))
				   R
				   (limit (rel!comp g f) R)))))
   (is-continuous f R)))
(INVOKE IS-CONTINUOUS)
(INSTANTIATE (G G$0))
(USE PO-ASYMMETRY (R R) (X (FN!APPLY F (LIMIT G R))) (Y (LIMIT (REL!COMP G F) R)))
(SPLIT (AND (IS-COMPLETE-PO R)
            (IS-MONOTONIC F R R)
            (IS-CHAIN G R)))
(REWRITE)


;;; Fixed points

(function iterate (f n x)
    ((measure n))
  (if (>= n 1)
      (fn!apply f (iterate f (+ -1 n) x))
      x))
(REDUCE)

(rule iterate-in-dom (f n x)
  (implies (and (fn!is-function f)
		(subset (rel!ran f) (rel!dom f))
		(in x (rel!dom f)))
	   (= (in (iterate f n x) (rel!dom f))
	      (true))))
(INDUCT)
(REDUCE)
(USE FN!APPLY-IN-RAN (F F) (X (ITERATE F (+ -1 N) X)))
(SIMPLIFY)

(rule iterates-of-bottom-related (f b r n)
  (implies (and (is-po r)
		(is-bottom b r)
		(is-monotonic f r r)
		(>= n 0))
	   (= (related (iterate f n b) R (iterate f (+ 1 n) b))
	      (true))))
(INDUCT)
(CASES)
(INVOKE (ITERATE F N B))
(INVOKE (ITERATE F (+ 1 N)B))
(REWRITE)
(NEXT)
(INVOKE (ITERATE F N B))
(INVOKE IS-BOTTOM)
(INSTANTIATE (X (ITERATE F 1 B)))
(USE ITERATE-IN-DOM (F F) (N 1) (X B))
(SIMPLIFY)
(NEXT)

(zf-function iteration-chain (f x)
  (select (p (pair!cross (nat!nat) (rel!dom f)))
    (= (pair!snd p) (iterate f (pair!fst p) x))))

(rule dom-iteration-chain (f x)
  (implies (and (fn!is-function f)
		(subset (rel!ran f) (rel!dom f))
		(in x (rel!dom f)))
	   (= (rel!dom (iteration-chain f x))
	      (nat!nat))))
(APPLY SETRULES!EXTENSIONALITY)
(APPLY REL!IN-DOM (IN E (REL!DOM (ITERATION-CHAIN F X))))
(REWRITE)

(rule ran-iteration-chain (f x)
  (implies (and (fn!is-function f)
		(subset (rel!ran f) (rel!dom f))
		(in x (rel!dom f)))
	   (= (subset (rel!ran (iteration-chain f x))
		      (rel!dom f))
	      (true))))
(REDUCE)
(WITH-ENABLED (REL!IN-RAN) (REWRITE))

(rule is-function-iteration-chain (f x)
  (= (fn!is-function (iteration-chain f x))
     (true)))
(WITH-ENABLED (FN!IS-FUNCTION REL!IS-RELATION) (REDUCE))

(rule apply-iteration-chain (f x n)
  (implies (and (fn!is-function f)
		(subset (rel!ran f) (rel!dom f))
		(in x (rel!dom f))
		(>= n 0))
	   (= (fn!apply (iteration-chain f x) n)
	      (iterate f n x))))
(USE FN!APPLY-DEFINITION (F (ITERATION-CHAIN F X)) (X N))
(REARRANGE)
(REWRITE)

(axiom iteration-chain-is-chain (R b f)
  (implies (and (is-po R)
		(is-monotonic f R R)
		(is-bottom b R))
	   (is-chain (iteration-chain f b) R)))
(INVOKE IS-CHAIN)
(INVOKE IS-FUN)
(REWRITE)
(USE RAN-ITERATION-CHAIN (F F) (X B))
(SIMPLIFY)

(axiom fixedpoint-lemma (f g R)
  (implies
   (and (is-complete-po R)
	(is-chain f R)
	(is-chain g R)
	(all (n) (implies (>= n 0)
			  (= (fn!apply f n) (fn!apply g (+ 1 n))))))
   (= (limit f R) (limit g R))))
(USE PO-ASYMMETRY (R R) (X (LIMIT F R)) (Y (LIMIT G R)))
(REARRANGE)
(SIMPLIFY)
(CASES)
(REWRITE)
(PRENEX)
(USE PO-TRANSITIVE
     (R R)
     (X (FN!APPLY G N))
     (Y (FN!APPLY G (+ 1 N)))
     (Z (LIMIT F R)))
(USE LIMIT-IS-UPPER-BOUND (R R) (F F) (N N)) ;;; <= don't bother...
(REARRANGE)
(INSTANTIATE (N$1 N))
(REWRITE)
(USE LIMIT-IS-UPPER-BOUND (R R) (F F) (N N))
(SIMPLIFY)
(NEXT)
(REWRITE)
(PRENEX)
(INSTANTIATE (N$0 N))
(USE LIMIT-IS-UPPER-BOUND (N (+ 1 N)) (F G) (R R))
(SIMPLIFY)
(NEXT)

(function fixpt (f R) ()
  (limit (iteration-chain f (bottom R)) R))

(axiom fixpt-is-fixedpoint (f R)
  (implies (and (is-complete-po R)
		(has-bottom R)
		(is-continuous f R))
	   (and (in (fixpt f R) (rel!dom f))
		(= (fn!apply f (fixpt f R))
		   (fixpt f R)))))
(INVOKE FIXPT)
(CASES)
(USE ITERATION-CHAIN-IS-CHAIN (F F) (B (BOTTOM R)) (R R))
(REARRANGE)
(REWRITE)
(NEXT)
(APPLY CONTINUITY-FACT)
(USE ITERATION-CHAIN-IS-CHAIN (F F) (B (BOTTOM R)) (R R))
(REARRANGE)
(REWRITE)
(USE FIXEDPOINT-LEMMA
     (R R)
     (F (REL!COMP (ITERATION-CHAIN F (BOTTOM R)) F))
     (G (ITERATION-CHAIN F (BOTTOM R))))
(REARRANGE)
(REWRITE)
(PRENEX)
(APPLY APPLY-ITERATION-CHAIN)
(REWRITE)
(INVOKE (ITERATE F (+ 1 N) (BOTTOM R)))
(SIMPLIFY)
(USE BOTTOM-IN-DOM (R R))
(SIMPLIFY)
(NEXT)


;;; function orderings ("pointwise")
;;;
;;; (fn-order D R) is the pointwise ordering on functions from D to (dom R)

(disabled
 (function pointwise-related (f R g) ()
   (all (x) (implies (in x (rel!dom f))
		     (related (fn!apply f x) R (fn!apply g x))))))

(rule pointwise-related-self (f R)
  (implies (and (fn!is-function f)
		(is-po R)
		(subset (rel!ran f) (rel!dom R)))
	   (= (pointwise-related f R f)
	      (true))))
(INVOKE POINTWISE-RELATED)
(PRENEX)
(USE FN!APPLY-IN-RAN (F F) (X X))
(REDUCE)

(zf-function fn-order (D R)
  (select (p (pair!cross (fn!fun D (rel!dom R))
			 (fn!fun D (rel!dom R))))
    (pointwise-related (pair!fst p) R (pair!snd p))))

(rule is-relation-fn-order (D R)
  (= (rel!is-relation (fn-order D R)) (true)))
(WITH-ENABLED (REL!IS-RELATION) (REDUCE))

(rule related-by-fn-order (f D R g)
  (= (related f (fn-order D R) g)
     (and (in f (fn!fun D (rel!dom R)))
	  (in g (fn!fun D (rel!dom R)))
	  (pointwise-related f R g))))
(WITH-ENABLED (RELATED) (REDUCE))

(rule fn-order-1 (D R f)
  (implies (and (in f (fn!fun D (rel!dom R)))
		(is-po R))
	   (= (in (pair!pair f f) (fn-order D R)) (true))))
(WITH-ENABLED (FN!IN-FUN) (REWRITE))

(rule dom-fn-order (D R)
  (implies (is-po R)
	   (= (rel!dom (fn-order D R))
	      (fn!fun D (rel!dom R)))))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL!IN-DOM) (REWRITE))
(INSTANTIATE (B E))
(REWRITE)

(rule ran-fn-order (D R)
  (implies (is-po R)
	   (= (rel!ran (fn-order D R))
	      (fn!fun D (rel!dom R)))))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL!IN-RAN) (REWRITE))
(INSTANTIATE (A E))
(REWRITE)

(rule is-transitive-fn-order (D R)
  (implies (is-transitive R)
	   (= (is-transitive (fn-order D R)) (true))))
(INVOKE (IS-TRANSITIVE (FN-ORDER D R)))
(WITH-ENABLED (POINTWISE-RELATED) (REDUCE))
(PRENEX)
(INSTANTIATE (X$1 X$0))
(INSTANTIATE (X$2 X$0))
(USE TRANSITIVE
     (R R)
     (X (FN!APPLY X X$0))
     (Y (FN!APPLY Y X$0))
     (Z (FN!APPLY Z X$0)))
(SIMPLIFY)

(rule is-po-fn-order (D R)
  (implies (is-po R)
	   (= (is-po (fn-order D R))
	      (true))))
(INVOKE (IS-PO (FN-ORDER D R)))
(REWRITE)
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)
(PRENEX)
(USE POINTWISE-RELATED-SELF (F (PAIR!FST E)) (R R))
(SIMPLIFY)
(APPLY FN!FUNCTION-EXTENSIONALITY)
(INVOKE POINTWISE-RELATED)
(REWRITE)
(INSTANTIATE (X$0 X$2))
(INSTANTIATE (X$2 X))
(SIMPLIFY)
(PRENEX)
(USE PO-ASYMMETRY
     (R R)
     (X (FN!APPLY (PAIR!FST E) X))
     (Y (FN!APPLY (PAIR!SND E) X)))
(SIMPLIFY)


(function const-fn (d v) () ;; domain d, constant value v
  (pair!cross d (unit v)))

(grule cont-fn-is-fun (d v)
  (is-fun (const-fn d v) d (unit v)))
(WITH-ENABLED (IS-FUN FN!IS-FUNCTION) (REDUCE))

(rule ran-const-fun (d v)
  (= (rel!ran (const-fn d v))
     (if (= d (nullset))
	 (nullset)
	 (unit v))))
(reduce)

(rule apply-const-fn (d v x)
  (implies (in x d)
	   (= (fn!apply (const-fn d v) x)
	      v)))
(USE FN!APPLY-DEFINITION (F (CONST-FN D V)) (X X))
(REWRITE)
(REDUCE)

(axiom fn-order-bottom (D R)
  (implies (and (is-po R)
		(has-bottom R))
	   (is-bottom (const-fn D (bottom R))
		      (fn-order D R))))
(INVOKE IS-BOTTOM)
(REWRITE)
(INVOKE POINTWISE-RELATED)
(REWRITE)
(INVOKE IS-FUN)
(REWRITE)

(rule has-bottom-fn-order (D R)
  (implies (and (is-po R)
		(has-bottom R))
	   (= (has-bottom (fn-order D R))
	      (true))))
(INVOKE (HAS-BOTTOM (FN-ORDER D R)))
(INSTANTIATE (B (CONST-FN D (BOTTOM R))))
(USE FN-ORDER-BOTTOM (D D) (R R))
(SIMPLIFY)

;;; (section f x) takes the chain in D->R to the R-chain lambda n . f(n)(x)

(zf-function section (f x)
  (map (pair!pair n (fn!apply (fn!apply f n) x))
    ((n) (rel!dom f))))

(rule in-section (p f x)
  (= (in p (section f x))
     (and (pair!is-pair p)
	  (in (pair!fst p) (rel!dom f))
	  (= (pair!snd p) (fn!apply (fn!apply f (pair!fst p)) x)))))
(SPLIT (AND (PAIR!IS-PAIR P)
            (IN (PAIR!FST P) (REL!DOM F))
            (= (PAIR!SND P) (FN!APPLY (FN!APPLY F (PAIR!FST P)) X))))
(WITH-ENABLED (SECTION.DEFINITION) (REWRITE))
(INSTANTIATE (N (PAIR!FST P)))
(SIMPLIFY)

(rule is-function-section (f x)
  (= (fn!is-function (section f x)) (true)))
(with-enabled (fn!is-function rel!is-relation) (reduce))

(rule dom-section (f x)
  (= (rel!dom (section f x))
     (rel!dom f)))
(apply setrules!extensionality)
(with-enabled (rel!in-dom) (rewrite))

(rule apply-section (n f x)
  (implies (in n (rel!dom f))
	   (= (fn!apply (section f x) n)
	      (fn!apply (fn!apply f n) x))))
(use fn!apply-definition (f (section f x)) (x n))
(rewrite)

(grule is-fun-section (f D1 D2 R x)
  (implies (and (is-fun f D1 (fn!fun D2 R))
		(in x D2))
	   (is-fun (section f x) D1 R)))
(INVOKE (IS-FUN (SECTION F X) D1 R))
(WITH-ENABLED (REL!IN-RAN) (REDUCE))

(grule section-is-chain (f x D R)
  (implies (and (is-chain f (fn-order D R))
		(in x D))
	   (is-chain (section f x) R)))
(INVOKE IS-CHAIN)
(CASES)
(INVOKE (IS-FUN (SECTION F X) (NAT!NAT) (REL!DOM R)))
(WITH-ENABLED (FN!IN-RAN-FUNCTION) (REDUCE))
(INSTANTIATE (N Y))
(SIMPLIFY)
(NEXT)
(REWRITE)
(INVOKE POINTWISE-RELATED)
(INSTANTIATE (N N$0))
(REWRITE)
(NEXT)

;; As with the apply-in-nominal-range grules, we need special cases

(grule section-is-chain-nat (f x R)
  (implies (and (is-chain f (fn-order (nat!nat) R))
		(>= x 0))
	   (is-chain (section f x) R)))
(use section-is-chain (f f)(x x)(D (nat!nat))(R R))
(rewrite)

;(rule section-is-chain-2 (f x D R)
;  (implies (and (is-chain f (fn-order D R))
;		(in x D))
;	   (= (is-chain (section f x) R)
;	      (true))))
;(SIMPLIFY)

(zf-function pointwise-limit (f D R)
  (map (pair!pair x (limit (section f x) R))
    ((x) D)))

(rule in-pointwise-limit (p f D R)
  (= (in p (pointwise-limit f D R))
     (and (pair!is-pair p)
	  (in (pair!fst p) D)
	  (= (pair!snd p) (limit (section f (pair!fst p)) R)))))
(SPLIT (AND (PAIR!IS-PAIR P)
            (IN (PAIR!FST P) D)
            (= (PAIR!SND P) (LIMIT (SECTION F (PAIR!FST P)) R))))
(SIMPLIFY)
(WITH-ENABLED (POINTWISE-LIMIT.DEFINITION) (REWRITE))
(INSTANTIATE (X (PAIR!FST P)))
(SIMPLIFY)

(grule is-function-pointwise-limit (f D R)
  (fn!is-function (pointwise-limit f D R)))
(WITH-ENABLED (FN!IS-FUNCTION REL!IS-RELATION) (REDUCE))

(rule dom-pointwise-limit (f D R)
  (= (rel!dom (pointwise-limit f D R))
     D))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL!IN-DOM) (REWRITE))

(rule apply-pointwise-limit (f D R x)
  (implies (in x D)
	   (= (fn!apply (pointwise-limit f D R) x)
	      (limit (section f x) R))))
(USE FN!APPLY-DEFINITION (F (POINTWISE-LIMIT F D R)) (X X))
(REWRITE)

(axiom pointwise-limit-is-limit (f D R)
  (implies (and (is-complete-po R)
		(is-chain f (fn-order D R)))
	   (is-chain-limit f (pointwise-limit f D R) (fn-order D R))))
(INVOKE IS-CHAIN-LIMIT)
(CASES)
(INVOKE IS-CHAIN-BOUND)
(with-enabled (is-fun-subgoal) (REWRITE))
(INVOKE POINTWISE-RELATED)
(REWRITE)
(PRENEX)
(USE LIMIT-IS-UPPER-BOUND (F (SECTION F X)) (R R) (N N))
(REARRANGE)
(SPLIT (IN X D))
(REWRITE)
(INVOKE IS-CHAIN)
(REWRITE)
(NEXT)
(INVOKE IS-CHAIN-BOUND)
(with-enabled (is-fun-subgoal) (REWRITE))
(INVOKE POINTWISE-RELATED)
(PRENEX)
(REWRITE)
(INSTANTIATE (N N$0) (X$0 X))
(REWRITE)
(NEXT)

(grule is-fun-pointwise-limit (f D R)
  (implies (and (is-complete-po R)
		(is-chain f (fn-order D R)))
	   (is-fun (pointwise-limit f D R) D (rel!dom R))))
(USE POINTWISE-LIMIT-IS-LIMIT (F F) (D D) (R R))
(INVOKE IS-CHAIN-LIMIT)
(INVOKE IS-CHAIN-BOUND)
(REWRITE)

(rule is-fun-pointwise-limit-2 (f D R1 R2)
  (implies (and (is-complete-po R1)
		(is-chain f (fn-order D R1))
		(= R2 (rel!dom R1)))
	   (= (is-fun (pointwise-limit f D R1) D R2) ;
	      (true))))
(simplify)

(grule function-order-complete (D R)
  (implies (is-complete-po R)
	   (is-complete-po (fn-order D R))))
(INVOKE (IS-COMPLETE-PO (FN-ORDER D R)))
(REWRITE)
(PRENEX)
(USE POINTWISE-LIMIT-IS-LIMIT (F F) (D D) (R R))
(SIMPLIFY)

(rule fn-order-limit (f D R)
  (implies (and (is-complete-po R)
		(is-chain f (fn-order D R)))
	   (= (limit f (fn-order D R))
	      (pointwise-limit f D R))))
(USE CHAIN-LIMIT-UNIQUE
     (F F)
     (X (LIMIT F (FN-ORDER D R)))
     (Y (POINTWISE-LIMIT F D R))
     (R (FN-ORDER D R)))
(USE LIMIT-IS-CHAIN-LIMIT (F F) (R (FN-ORDER D R)))
(USE POINTWISE-LIMIT-IS-LIMIT (F F) (D D) (R R))
(SIMPLIFY)


;;; The CSP order

(load pr)

(zf-function process-trace-sets (alphabet)
  (select (t (powerset (tr!trace-of alphabet)))
    (pr!is-process (pr!make-process alphabet t))))

(zf-function processes (alphabet)
  (map (pr!make-process alphabet t)
    ((t) (process-trace-sets alphabet))))

(rule in-processes (x a)
  (= (in x (processes a))
     (and (pr!is-process x)
	  (= (pr!process-alphabet x) a))))
(SPLIT (IN X (PROCESSES A)))
(SIMPLIFY)
(WITH-ENABLED (PROCESSES.DEFINITION) (REWRITE))
(CASES)
(PRENEX)
(EQUALITY-SUBSTITUTE X)
(REWRITE)
(NEXT)
(INSTANTIATE (T (PR!PROCESS-TRACES X)))
(REWRITE)
(USE PR!MAKE-PROCESS-IS-PROCESS
     (A (PR!PROCESS-ALPHABET X))
     (T (PR!PROCESS-TRACES X)))
(SIMPLIFY)
(NEXT)

(grule apply-is-process (f x D a)
  (implies (and (is-fun f D (processes a))
		(in x D))
	   (pr!is-process (fn!apply f x))))
(USE APPLY-IN-NOMINAL-RANGE (F F) (X X) (D D) (R (PROCESSES A)))
(APPLY IN-PROCESSES)
(SIMPLIFY)

(grule process-alphabet-apply (f x D a)
  (implies (and (is-fun f D (processes a))
		(in x D))
	   (= (pr!process-alphabet (fn!apply f x))
	      a)))
(USE APPLY-IN-NOMINAL-RANGE (F F) (X X) (D D) (R (PROCESSES A)))
(APPLY IN-PROCESSES)
(SIMPLIFY)

;; also need special cases for D = (nat!nat)

(grule apply-is-process-nat (f x a)
  (implies (and (is-fun f (nat!nat) (processes a))
		(>= x 0))
	   (pr!is-process (fn!apply f x))))
(USE APPLY-IS-PROCESS (F F)(X X)(D (NAT!NAT))(A A))
(REWRITE)

(grule process-alphabet-apply-nat (f x a)
  (implies (and (is-fun f (nat!nat) (processes a))
		(>= x 0))
	   (= (pr!process-alphabet (fn!apply f x))
	      a)))
(USE PROCESS-ALPHABET-APPLY (F F)(X X)(D (NAT!NAT))(A A))
(REWRITE)

(zf-function process-po (alphabet)
  (select (p (pair!cross (processes alphabet) (processes alphabet)))
    (pr!process-included (pair!fst p) (pair!snd p))))

(rule related-by-process-po (p1 p2 alphabet)
  (= (related p1 (process-po alphabet) p2)
     (and (pr!is-process p1)
	  (= (pr!process-alphabet p1) alphabet)
	  (pr!is-process p2)
	  (= (pr!process-alphabet p2) alphabet)
	  (pr!process-included p1 p2))))
(INVOKE RELATED)
(REWRITE)

(rule dom-process-po (a)
  (= (rel!dom (process-po a))
     (processes a)))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL!IN-DOM) (REWRITE))
(INSTANTIATE (B E))
(USE PR!PROCESS-INCLUDED-REFLEXIVE (P E))
(SIMPLIFY)

(rule ran-process-po (a)
  (= (rel!ran (process-po a))
     (processes a)))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL!IN-RAN) (REWRITE))
(INSTANTIATE (A$0 E))
(USE PR!PROCESS-INCLUDED-REFLEXIVE (P E))
(SIMPLIFY)

(grule process-po-is-po (a)
  (is-po (process-po a)))
(INVOKE IS-PO)
(WITH-ENABLED (REL!IS-RELATION) (REDUCE))
(CASES)
(WITH-ENABLED (IS-TRANSITIVE) (REDUCE))
(USE PR!PROCESS-INCLUDED-TRANSITIVE (P1 X) (P2 Y) (P3 Z))
(SIMPLIFY)
(NEXT)
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)
(USE PR!PROCESS-INCLUDED-REFLEXIVE (P (PAIR!FST E)))
(USE PR!PROCESS-INCLUDED-ANTI-SYMMETRIC (P1 (PAIR!FST E)) (P2 (PAIR!SND E)))
(SIMPLIFY)
(NEXT)

(axiom process-po-bottom (a)
  (is-bottom (pr!stop a) (process-po a)))
(INVOKE IS-BOTTOM)
(REWRITE)

(grule has-bottom-process-po (a)
  (has-bottom (process-po a)))
(USE PROCESS-PO-BOTTOM (A A))
(INVOKE HAS-BOTTOM)
(SIMPLIFY)

(rule bottom-process-po (a)
  (= (bottom (process-po a))
     (pr!stop a)))
(USE PROCESS-PO-BOTTOM (A A))
(USE BOTTOM-UNIQUE
     (R (PROCESS-PO A))
     (B1 (PR!STOP A))
     (B2 (BOTTOM (PROCESS-PO A))))
(REWRITE)

(rule process-chain-bridge (f a)
  (implies (is-chain f (process-po a))
	   (= (pr!is-process-chain f) (true))))
(INVOKE PR!IS-PROCESS-CHAIN)
(REWRITE)
(INVOKE IS-CHAIN)
(REWRITE)

(rule is-process-apply-process-chain (f a n)
  (implies (and (>= n 0)
		(is-chain f (process-po a)))
	   (= (pr!is-process (fn!apply f n)) (true))))
(INVOKE IS-CHAIN)
(USE APPLY-IN-NOMINAL-RANGE
     (F F)
     (D (NAT!NAT))
     (R (REL!DOM (PROCESS-PO A)))
     (X N))
(REWRITE)

(rule alphabet-apply-process-chain (f a n)
  (implies (and (>= n 0)
		(is-chain f (process-po a)))
	   (= (pr!process-alphabet (fn!apply f n)) a)))
(INVOKE IS-CHAIN)
(USE APPLY-IN-NOMINAL-RANGE
     (F F)
     (D (NAT!NAT))
     (R (REL!DOM (PROCESS-PO A)))
     (X N))
(REWRITE)

(axiom is-process-facts (p)
  (implies (pr!is-process p)
	   (and (subset (pr!process-traces p)
			(tr!trace-of (pr!process-alphabet p)))
		(in (tr!empty) (pr!process-traces p))
		(pr!prefix-closed (pr!process-traces p)))))
(USE PR!PROCESS-COMPOSITION (P P))
(USE PR!MAKE-PROCESS-IS-PROCESS
     (A (PR!PROCESS-ALPHABET P))
     (T (PR!PROCESS-TRACES P)))
(SIMPLIFY)

(rule prefix-closed-cup (x)
  (implies (all (y) (implies (in y x)
			     (pr!prefix-closed y)))
	   (= (pr!prefix-closed (cup x))
	      (true))))
(INVOKE PR!PREFIX-CLOSED)
(REWRITE)
(PRENEX)
(INSTANTIATE (Y$0 Y) (S$0 S) (T$0 T))
(SIMPLIFY)

(axiom process-limit-lemma (f a)
  (implies (is-chain f (process-po a))
	   (in (pr!process-chain-limit f) (processes a))))
(INVOKE PR!PROCESS-CHAIN-LIMIT)
(REWRITE)
(APPLY PREFIX-CLOSED-CUP)
(WITH-ENABLED (SETRULES!CUP-SUBSET PR!COLLECT-TRACES FN!IN-RAN-FUNCTION)
 (REWRITE))
(CASES)
(PRENEX)
(USE IS-PROCESS-FACTS (P (FN!APPLY F Y)))
(REARRANGE)
(REWRITE)
(NEXT)
(INSTANTIATE (Y$0 0))
(REWRITE)
(USE IS-PROCESS-FACTS (P (FN!APPLY F 0)))
(REARRANGE)
(REWRITE)
(NEXT)
(PRENEX)
(USE IS-PROCESS-FACTS (P (FN!APPLY F Y)))
(REARRANGE)
(REWRITE)
(NEXT)

(rule limit-is-process (f a)
  (implies (is-chain f (process-po a))
	   (= (pr!is-process (pr!process-chain-limit f))
	      (true))))
(use process-limit-lemma (f f)(a a))
(rewrite)

(rule process-alphabet-limit (f a)
  (implies (is-chain f (process-po a))
	   (= (pr!process-alphabet (pr!process-chain-limit f)) a)))
(use process-limit-lemma (f f)(a a))
(rewrite)

(axiom process-chains-have-limits (f a)
  (implies (is-chain f (process-po a))
	   (is-chain-limit f (pr!process-chain-limit f) (process-po a))))
(INVOKE IS-CHAIN-LIMIT)
(INVOKE IS-CHAIN-BOUND)
(REWRITE)
(PRENEX)
(USE PR!ELEMENT-INCLUDED-IN-LIMIT (PC F) (I N))
(USE PR!UPPER-BOUND-AXIOM (PC F) (Q B))
(REARRANGE)
(REWRITE)


(grule process-po-is-complete (a)
  (is-complete-po (process-po a)))
(INVOKE IS-COMPLETE-PO)
(PRENEX)
(USE PROCESS-CHAINS-HAVE-LIMITS (F F) (A A))
(SIMPLIFY)

(rule process-po-limit (f a)
  (implies (is-chain f (process-po a))
	   (= (limit f (process-po a))
	      (pr!process-chain-limit f))))
(USE CHAIN-LIMIT-UNIQUE
     (F F)
     (R (PROCESS-PO A))
     (X (LIMIT F (PROCESS-PO A)))
     (Y (PR!PROCESS-CHAIN-LIMIT F)))
(USE LIMIT-IS-CHAIN-LIMIT (F F) (R (PROCESS-PO A)))
(USE PROCESS-CHAINS-HAVE-LIMITS (F F) (A A))
(SIMPLIFY)


;;; In preparation for the example, some development of
;;; the CSP theory

(rule empty-in-traces (p)
  (implies (pr!is-process p)
	   (= (in (tr!empty) (pr!process-traces p))
	      (true))))
(USE PR!MAKE-PROCESS-IS-PROCESS
     (A (PR!PROCESS-ALPHABET P))
     (T (PR!PROCESS-TRACES P)))
(WITH-DISABLED (PR!MAKE-PROCESS-IS-PROCESS) (REWRITE))


(rule in-map-tack (t x p)
  (implies (pr!is-process p)
	   (= (in t (pr!map-tack x (pr!process-traces p)))
	      (and (not (tr!is-empty t))
		   (= (tr!head t) x)
		   (in (tr!tail t) (pr!process-traces p))))))
(WITH-ENABLED (PR!MAP-TACK.DEFINITION) (REWRITE))
(INSTANTIATE (S (TR!TAIL T)))
(REWRITE)
(PRENEX)
(USE PR!IN-PROCESS-TRACES (S S) (P P))
(SIMPLIFY)

(rule subset-setadd (e x y)		; missing from setrules?
  (implies (subset x y)
	   (= (subset x (setadd e y))
	      (true))))
(REDUCE)

(rule subset-map-tack (a x y)
  (implies (subset x y)
	   (= (subset (pr!map-tack a x) (pr!map-tack a y))
	      (true))))
(WITH-ENABLED (PR!MAP-TACK.DEFINITION) (REDUCE))
(INSTANTIATE (S$0 S))
(SIMPLIFY)

(rule prefix-included (a b P Q)
  (implies (and (pr!is-process P)
		(pr!is-process Q)
		(in a (pr!process-alphabet P))
		(in b (pr!process-alphabet Q)))
	   (= (pr!process-included (pr!prefix a P) (pr!prefix b Q))
	      (and (= a b)
		   (pr!process-included P Q)))))
(SPLIT (PR!PROCESS-INCLUDED P Q))
(SIMPLIFY)
(WITH-ENABLED (PR!PROCESS-INCLUDED) (REDUCE))
(CASES)
(SPLIT (= A B))
(SIMPLIFY)
(INSTANTIATE (E$0 (TR!TACK A (TR!EMPTY))))
(REWRITE)
(NEXT)
(INSTANTIATE (E$1 (TR!TACK A E)))
(REWRITE)
(PRENEX)
(USE PR!IN-PROCESS-TRACES (S E) (P P))
(SIMPLIFY)
(NEXT)

;; we need this rule as well as grule "pr!prefix-is-process", because
;; the condition of the grule will not always succeed.
;; (for example, try (pr!is-process (pr!prefix 0 (pr!stop (int))))
;;
(rule is-process-prefix (a P)
  (implies (and (pr!is-process P)
		(in a (pr!process-alphabet P)))
	   (= (pr!is-process (pr!prefix a P))
	      (true))))
(simplify)

;;; choice, as defined in the main theory, is rather awkward to use.
;;; For simple finite choices, the function input-choice defined here
;;; is easier to use.

;; (first-actions P) is the set of actions that P may engage in
;; as its first action.

(zf-function first-actions (P)
  (select (a (pr!process-alphabet p))
    (in (tr!tack a (tr!empty)) (pr!process-traces P))))

(rule first-actions-stop (a)
  (= (first-actions (pr!stop a))
     (nullset)))
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)

(rule first-actions-run (a)
  (= (first-actions (pr!run a))
     a))
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)

(rule first-actions-prefix (a P)
  (implies (and (pr!is-process P)
		(in a (pr!process-alphabet P)))
	   (= (first-actions (pr!prefix a P))
	      (make-set a))))
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)

;; the condition is not absolutely necessary in the definition
;; of input-choice, but it keeps us in the domain of deterministic
;; processes.

(disabled
 (function input-choice (P Q) ()
  (if (= (inter (first-actions P) (first-actions Q))
	 (nullset))
      (pr!make-process (union (pr!process-alphabet P)
			      (pr!process-alphabet Q))
		       (union (pr!process-traces P)
			      (pr!process-traces Q)))
      0)))

(axiom trace-of-subset (x y)
  (implies (subset x y)
	   (= (subset (tr!trace-of x) (tr!trace-of y))
	      (true))))
(INVOKE (SUBSET (TR!TRACE-OF X) (TR!TRACE-OF Y)))
(PRENEX)
(REWRITE)
(INDUCT)
(REDUCE)

(rule prefix-closed-union (x y)
  (implies (and (pr!prefix-closed x)
		(pr!prefix-closed y))
	   (= (pr!prefix-closed (union x y))
	      (true))))
(WITH-ENABLED (PR!PREFIX-CLOSED) (REDUCE))

(rule is-process-input-choice (P Q)
  (implies (and (pr!is-process P)
		(pr!is-process Q)
		(= (inter (first-actions P) (first-actions Q))
		   (nullset)))
	   (= (pr!is-process (input-choice P Q)) (true))))
(INVOKE INPUT-CHOICE)
(REWRITE)
(USE IS-PROCESS-FACTS (P P))
(USE IS-PROCESS-FACTS (P Q))
(USE TRACE-OF-SUBSET
     (X (PR!PROCESS-ALPHABET P))
     (Y (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
(USE TRACE-OF-SUBSET
     (X (PR!PROCESS-ALPHABET Q))
     (Y (UNION (PR!PROCESS-ALPHABET P) (PR!PROCESS-ALPHABET Q))))
(REARRANGE)
(REWRITE)

(rule alphabet-input-choice (P Q)
  (implies (and (pr!is-process P)
		(pr!is-process Q)
		(= (inter (first-actions P) (first-actions Q))
		   (nullset)))
	   (= (pr!process-alphabet (input-choice P Q))
	      (union (pr!process-alphabet P)
		     (pr!process-alphabet Q)))))
(INVOKE INPUT-CHOICE)
(REWRITE)

(rule traces-input-choice (P Q)
  (implies (and (pr!is-process P)
		(pr!is-process Q)
		(= (inter (first-actions P) (first-actions Q))
		   (nullset)))
	   (= (pr!process-traces (input-choice P Q))
	      (union (pr!process-traces P)
		     (pr!process-traces Q)))))
(INVOKE INPUT-CHOICE)
(REWRITE)

(rule first-actions-input-choice (P Q)
  (implies (and (pr!is-process P)
		(pr!is-process Q)
		(= (inter (first-actions P) (first-actions Q))
		   (nullset)))
	   (= (first-actions (input-choice P Q))
	      (union (first-actions P)
		     (first-actions Q)))))
(REWRITE)
(APPLY SETRULES!EXTENSIONALITY)
(REWRITE)
(INSTANTIATE (E E$0))
(USE PR!IN-PROCESS-TRACES (S (TR!TACK E (TR!EMPTY))) (P Q))
(USE PR!IN-PROCESS-TRACES (S (TR!TACK E (TR!EMPTY))) (P P))
(REDUCE)


;;; A specific example
;;; P(n) = if n = 0 then up -> P(1) else (up -> P(n+1) | down -> P(n-1))
;;; for n in Nat

(function up () () 0)

(function down () () 1)

(function p-step (p n) ()
  (if (= n 0)
      (pr!prefix (up) (fn!apply p (+ 1 n)))
      (input-choice (pr!prefix (up) (fn!apply p (+ 1 n)))
		    (pr!prefix (down) (fn!apply p (+ -1 n))))))

(disabled
 (function two-set (x y) ()
   (make-set x y)))

(rule in-two-set (a x y)
  (= (in a (two-set x y))
     (or (= a x)
	 (= a y))))
(with-enabled (two-set) (reduce))

(grule in-two-set-1 (x y)
  (in x (two-set x y)))
(rewrite)

(grule in-two-set-2 (x y)
  (in y (two-set x y)))
(rewrite)

(axiom p-step-result (p n)
  (implies (and (is-fun p (nat!nat) (processes (two-set (up) (down))))
		(>= n 0))
	   (in (p-step p n) (processes (two-set (up) (down))))))
(INVOKE P-STEP)
(USE IS-PROCESS-APPLY-PROCESS-CHAIN (F P) (A (TWO-SET (up) (down))) (N (+ 1 N)))
(WITH-DISABLED (IS-PROCESS-APPLY-PROCESS-CHAIN) (REWRITE))
(USE UNION.SELF (X (TWO-SET (up) (down))))
(SIMPLIFY)

(rule p-step-alphabet (p n)
  (implies (and (is-fun p (nat!nat) (processes (two-set (up) (down))))
		(>= n 0))
	   (= (pr!process-alphabet (p-step p n))
	      (two-set (up) (down)))))
(use p-step-result (p p)(n n))
(rewrite)

(rule is-process-p-step (p n)
  (implies (and (is-fun p (nat!nat) (processes (two-set (up) (down))))
		(>= n 0))
	   (= (pr!is-process (p-step p n))
	      (true))))
(use p-step-result (p p)(n n))
(rewrite)

;;; (p-step-aux p) = lambda n: nat . (p-step p n)

(zf-function p-step-aux (p)
  (select (x (pair!cross (nat!nat) (processes (two-set (up) (down)))))
    (= (pair!snd x) (p-step p (pair!fst x)))))

(rule p-step-aux-is-function (p)
  (= (fn!is-function (p-step-aux p))
     (true)))
(with-enabled (fn!is-function rel!is-relation) (reduce))

(rule dom-p-step-aux (p)
  (implies (in p (fn!fun (nat!nat) (processes (two-set (up) (down)))))
	   (= (rel!dom (p-step-aux p))
	      (nat!nat))))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL!IN-DOM) (REWRITE))

(rule apply-p-step-aux (p n)
  (implies (and (is-fun p (nat!nat) (processes (two-set (up) (down))))
		(>= n 0))
	   (= (fn!apply (p-step-aux p) n)
	      (p-step p n))))
(USE FN!APPLY-DEFINITION (F (P-STEP-AUX P)) (X N))
(REARRANGE)
(REWRITE)

(grule is-fun-p-step-aux (p)
  (implies (is-fun p (nat!nat) (processes (two-set (up) (down))))
	   (is-fun (p-step-aux p)
		   (nat!nat)
		   (processes (two-set (up) (down))))))
(INVOKE (IS-FUN (P-STEP-AUX P)
                (NAT!NAT)
                (PROCESSES (two-set (up) (down)))))
(WITH-ENABLED (REL!IN-RAN) (REDUCE))
(SIMPLIFY)

;;; (p-step-fn) = lambda p: nat -> processes {'u', 'd'} . lambda n: nat .
;;;                  (p-step p n)

(zf-function p-step-fn ()
  (select (x (pair!cross (fn!fun (nat!nat) (processes (two-set (up) (down))))
			 (fn!fun (nat!nat) (processes (two-set (up) (down))))))
    (= (pair!snd x) (p-step-aux (pair!fst x)))))

(rule p-step-fn-is-function ()
  (= (fn!is-function (p-step-fn))
     (true)))
(WITH-ENABLED (FN!IS-FUNCTION REL!IS-RELATION) (REDUCE))

(rule dom-p-step-fn ()
  (= (rel!dom (p-step-fn))
     (fn!fun (nat!nat) (processes (two-set (up) (down))))))
(APPLY SETRULES!EXTENSIONALITY)
(WITH-ENABLED (REL!IN-DOM) (REWRITE))

(rule apply-p-step-fn (p)
  (implies (is-fun p (nat!nat) (processes (two-set (up) (down))))
	   (= (fn!apply (p-step-fn) p)
	      (p-step-aux p))))
(USE FN!APPLY-DEFINITION (F (P-STEP-FN)) (X P))
(REARRANGE)
(REWRITE)

(grule is-fun-p-step-fn ()
  (is-fun (p-step-fn)
	  (fn!fun (nat!nat) (processes (two-set (up) (down))))
	  (fn!fun (nat!nat) (processes (two-set (up) (down))))))
(INVOKE IS-FUN)
(WITH-ENABLED (REL!IN-RAN) (REDUCE))


;;; Now, show p-step-fn is monotonic and continuous...


(axiom p-step-fn-is-monotonic ()
  (is-monotonic (p-step-fn)
		(fn-order (nat!nat) (process-po (two-set (up) (down))))
		(fn-order (nat!nat) (process-po (two-set (up) (down))))))
(INVOKE IS-MONOTONIC)
(REWRITE)
(INVOKE POINTWISE-RELATED)
(REWRITE)
(INSTANTIATE (X$0 (+ 1 X$1)))
(INVOKE P-STEP)
(INVOKE PR!PROCESS-INCLUDED)
(REWRITE)


(rule CSP-rec-lemma (f g D A)
  (= (related f (fn-order D (process-po A)) g)
     (and (is-fun f D (processes A))
	  (is-fun g D (processes A))
	  (all (x) (implies (in x D)
			    (subset (pr!process-traces (fn!apply f x))
				    (pr!process-traces (fn!apply g x))))))))
(SPLIT (RELATED F (FN-ORDER D (PROCESS-PO A)) G))
(REWRITE)
(INVOKE POINTWISE-RELATED)
(REWRITE)
(INVOKE PR!PROCESS-INCLUDED)
(SIMPLIFY)
(INSTANTIATE (X$0 X))
(SIMPLIFY)

(rule in-traces-process-chain-limit (t f A)
  (implies (is-chain f (process-po A))
	   (= (in t (pr!process-traces (pr!process-chain-limit f)))
	      (some (n) (and (>= n 0)
			     (in t (pr!process-traces (fn!apply f n))))))))
(SPLIT
 (AND (IS-CHAIN F (PROCESS-PO A))
  (IN T (PR!PROCESS-TRACES (PR!PROCESS-CHAIN-LIMIT F)))))
(SIMPLIFY)
(INVOKE PR!PROCESS-CHAIN-LIMIT)
(WITH-ENABLED (PR!COLLECT-TRACES.DEFINITION FN!IN-RAN-FUNCTION)
 (REWRITE))
(CASES)
(PRENEX)
(INSTANTIATE (N Y))
(SIMPLIFY)
(NEXT)
(PRENEX)
(SIMPLIFY)
(INSTANTIATE (Y N))
(SIMPLIFY)
(NEXT)


;(axiom parameterized-CSP-recursion-continuity-lemma (f D A)
;  (implies
;   (and (is-monotonic f (fn-order D (process-po A))
;		        (fn-order D (process-po A)))
;	(all (g x t)
;	  (implies
;	   (and (is-chain g (fn-order D (process-po A)))
;		(in x D)
;		(in t (pr!process-traces
;		       (fn!apply (fn!apply
;				  f
;				  (limit g (fn-order D (process-po A))))
;				 x))))
;	   (in t (pr!process-traces
;		  (fn!apply (pointwise-limit (rel!comp g f) D (process-po A))
;			    x))))))
;   (is-continuous f (fn-order D (process-po A)))))


(axiom parameterized-CSP-recursion-continuity-lemma (f D A)
  (implies
   (and (is-monotonic f (fn-order D (process-po A))
		        (fn-order D (process-po A)))
	(all (g x t)
	  (implies
	   (and (is-chain g (fn-order D (process-po A)))
		(in x D)
		(in t (pr!process-traces
		       (fn!apply (fn!apply
				  f
				  (limit g (fn-order D (process-po A))))
				 x))))
	   (some (n)
	     (and (>= n 0)
		  (in t (pr!process-traces
			 (fn!apply (fn!apply f (fn!apply g n)) x))))))))
   (is-continuous f (fn-order D (process-po A)))))
(USE CONTINUITY-SUBGOAL (F F) (R (FN-ORDER D (PROCESS-PO A))))
(REWRITE)
(INVOKE SUBSET)
(PRENEX)
(SIMPLIFY)
(CASES)
(APPLY PROCESS-PO-LIMIT)
(USE SECTION-IS-CHAIN (F (REL!COMP G F)) (X X) (D D) (R (PROCESS-PO A)))
(REARRANGE)
(INSTANTIATE (G$0 G) (X$0 X) (T E))
(REWRITE)
(NEXT)
(USE APPLY-IN-NOMINAL-RANGE
     (F F)
     (X (POINTWISE-LIMIT G D (PROCESS-PO A)))
     (D (FN!FUN D (PROCESSES A)))
     (R (FN!FUN D (PROCESSES A))))
(REARRANGE)
(INVOKE IS-MONOTONIC)
(REWRITE)
(NEXT)

(axiom p-step-fn-is-continuous ()
  (is-continuous (p-step-fn)
		 (fn-order (nat!nat) (process-po (two-set (up) (down))))))
(USE PARAMETERIZED-CSP-RECURSION-CONTINUITY-LEMMA
     (F (P-STEP-FN)) (D (NAT!NAT)) (A (TWO-SET (up) (down))))
(USE P-STEP-FN-IS-MONOTONIC)
(REWRITE)
(PRENEX)
(APPLY APPLY-P-STEP-FN)
(REWRITE)
(INVOKE P-STEP)
(USE SECTION-IS-CHAIN
     (F G) (X (+ 1 X)) (D (NAT!NAT)) (R (PROCESS-PO (TWO-SET (UP) (DOWN)))))
(WITH-DISABLED (SECTION-IS-CHAIN)
 (REWRITE))
(INVOKE IS-CHAIN)
(REWRITE)

;; So we have a fixed-point.  Here is is:

(function example-process () ()
  (fixpt (p-step-fn) (fn-order (nat!nat) (process-po (two-set (up) (down))))))

(grule example-process-1 ()
  (is-fun (example-process) (nat!nat) (processes (two-set (up) (down)))))
(USE FIXPT-IS-FIXEDPOINT
     (F (p-step-fn))
     (R (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET (UP) (DOWN))))))
(USE P-STEP-FN-IS-CONTINUOUS)
(REWRITE)

(axiom example-process-2 (n)
  (implies
   (>= n 0)
   (= (fn!apply (example-process) n)
      (if (= n 0)
	  (pr!prefix (up) (fn!apply (example-process) 1))
	  (input-choice (pr!prefix (up) (fn!apply (example-process) (+ 1 n)))
			(pr!prefix (down)
				   (fn!apply (example-process) (+ -1 n))))))))
(USE FIXPT-IS-FIXEDPOINT
     (F (P-STEP-FN))
     (R (FN-ORDER (NAT!NAT) (PROCESS-PO (TWO-SET (UP) (DOWN))))))
(USE P-STEP-FN-IS-CONTINUOUS)
(REWRITE)
(USE APPLY-P-STEP-AUX (P (EXAMPLE-PROCESS)) (N N))
(INVOKE P-STEP)
(SIMPLIFY)
